## Thread Interruption and Cooperative Cancellation

Java threads cannot be stopped forcibly from the outside. Instead, Java provides a cooperative mechanism called **thread interruption**, which allows one thread to request that another thread stop what it is doing. The target thread decides how and when to respond.

### What Interrupting a Thread Means

Interrupting a thread does **not** terminate it. Calling `interrupt()` sets an internal **interruption flag** on the target thread. It is the responsibility of the running thread to observe this flag and react appropriately.

- Interrupt Request: A signal sent to a thread indicating that it should stop or change its current activity.
- Interruption Flag: A boolean status associated with each thread, set when `interrupt()` is invoked.
- Cooperative Cancellation: A design pattern where threads periodically check for interruption and terminate themselves cleanly.

### Interrupting Blocking Operations

Some blocking methods in Java respond immediately to interruption by throwing `InterruptedException` and clearing the interruption flag. These methods include `sleep()`, `wait()`, and `join()`.

When a thread is blocked in one of these methods and another thread interrupts it, the blocked thread is awakened and an exception is thrown. This provides a safe escape point from blocking operations.

### Checking the Interruption Status

Threads that are not blocked must explicitly check whether they have been interrupted. Java provides two ways to do this.

- `Thread.currentThread().isInterrupted()`: Returns the interruption status without clearing it.
- `Thread.interrupted()`: Returns the interruption status and clears it.

Failing to check the interruption status may cause threads to ignore cancellation requests and run indefinitely.

### Example: Interrupting a Sleeping Thread

The following example demonstrates cooperative cancellation using interruption. A worker thread repeatedly sleeps while performing work. The main thread interrupts it, causing a clean shutdown.

```java
class InterruptExample {

static class Worker implements Runnable {
public void run() {
try {
while (true) {
System.out.println("Working...");
Thread.sleep(1000);
}
} catch (InterruptedException e) {
System.out.println("Worker interrupted, shutting down");
}
}
}

public static void main(String[] args) throws InterruptedException {
Thread worker = new Thread(new Worker());
worker.start();

Thread.sleep(3000);
worker.interrupt();
}
}
```

### Key Observations

- Calling `interrupt()` does not stop the thread directly.
- The interruption is detected because `sleep()` throws `InterruptedException`.
- The worker thread terminates itself in a controlled manner.
- Proper interruption handling allows threads to release resources and maintain program correctness.

> **Note:** 
Swallowing `InterruptedException` without terminating or restoring the interruption status is considered bad practice and may lead to unresponsive threads.
