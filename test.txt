## Conceptual Model: Filesystem, Files, Directories, Links, and I/O Targets

Before understanding Java I/O APIs, it is essential to understand what they interact with. Java I/O does not operate in a vacuum: it interacts with filesystem abstractions provided by the operating system. This section defines those concepts independently of Java, then explains how Java I/O maps onto them and what problems are being solved.

### 1. Filesystem – The Global Abstraction

A filesystem is a structured mechanism provided by an operating system to organize, store, retrieve, and manage data on persistent storage devices.

At a conceptual level, a filesystem solves several fundamental problems:

- Persistent storage beyond program execution
- Hierarchical organization of data
- Naming and locating data
- Access control and permissions
- Concurrency and consistency guarantees

In Java NIO, a filesystem is represented by the `FileSystem` abstraction.

| Aspect | Meaning |
| --- | --- |
| Persistence | Data survives JVM termination |
| Scope | OS-managed, not JVM-managed |
| Multiplicity | Multiple filesystems may exist |
| Examples | Disk FS, ZIP FS, in-memory FS |

> [!NOTE]
> Java does not implement filesystems; it adapts to filesystem implementations provided by the OS or custom providers.

### 2. Path – Locating an Entry in a Filesystem

A path is a logical locator, not a resource. It describes where something would be in a filesystem, not what it is or whether it exists.

A path solves the problem of addressing.

- Identifies a location
- Is interpreted within a specific filesystem
- May or may not correspond to an existing entry

| Property | Path |
| --- | --- |
| Existence-aware | No |
| Type-aware | No |
| Immutable | Yes |
| OS resource | No |

> [!NOTE]
> In Java, `Path` represents potential filesystem entries, not actual ones.

### 3. Files – Persistent Data Containers

A file is a filesystem entry whose primary role is to store data. The filesystem treats files as opaque byte sequences.

Problems solved by files:

- Durable storage of information
- Sequential and random access to data
- Sharing data between processes

From the filesystem perspective, a file has:

- Content (bytes)
- Metadata (size, timestamps, permissions)
- A location (path)

| Aspect | Description |
| --- | --- |
| Content | Byte-oriented |
| Interpretation | Application-defined |
| Lifetime | Independent of processes |
| Java access | Streams, channels, Files methods |

> [!NOTE]
> Text vs binary is not a filesystem concept; it is an application-level interpretation.

### 4. Directories – Structural Containers

A directory (or folder) is a filesystem entry whose purpose is to organize other entries.

Directories solve the problem of scalability and organization.

- Group related entries
- Enable hierarchical naming
- Support efficient lookup

| Aspect | Directory |
| --- | --- |
| Stores data | No (stores references) |
| Contains | Files, directories, links |
| Read/write | Structural, not content-based |
| Java access | Files.list, Files.walk |

> [!NOTE]
> A directory is not a file with content, even if both share common metadata.

### 5. Links – Indirection Mechanisms

A link is a filesystem entry that refers to another entry. Links solve the problem of indirection and reuse.

5.1 Hard Links

A hard link is an additional name for the same underlying data.

- Multiple paths point to the same file data
- Deletion occurs only when all links are removed

5.2 Symbolic (Soft) Links

A symbolic link is a special file containing a path to another entry.

- May point to non-existing targets
- Resolved at access time

| Link Type | Refers To | Can Dangle | Java Handling |
| --- | --- | --- | --- |
| Hard | Data | No | Transparent |
| Symbolic | Path | Yes | Explicit control |

> [!NOTE]
> Java NIO exposes link behavior explicitly via `LinkOption`.

### 6. Other Filesystem Entry Types

Some filesystem entries are not data containers but interaction endpoints.

| Type | Purpose |
| --- | --- |
| Device file | Interface to hardware |
| FIFO / Pipe | Inter-process communication |
| Socket file | Network communication |

> [!NOTE]
> Java I/O may interact with these entries, but behavior is platform-dependent.

### 7. How Java I/O Interacts with These Concepts

Java I/O APIs operate at different abstraction layers:

- Path → describes a filesystem entry
- Files → queries or modifies filesystem state
- Streams / Channels → move bytes or characters

| Java API | Role |
| --- | --- |
| Path | Addressing |
| Files | Filesystem operations |
| InputStream / Reader | Reading data |
| OutputStream / Writer | Writing data |
| Channels | Advanced data access |

> [!NOTE]
> No Java API “is” a file; APIs mediate access to filesystem-managed resources.

### 8. Core Conceptual Pitfalls (Exam-Relevant)

- Confusing paths with files
- Assuming paths imply existence
- Assuming directories store file data
- Assuming links are always resolved automatically

> [!NOTE]
> Always separate location, structure, and data flow when reasoning about I/O.
