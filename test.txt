### 4.8 Custom Serialization Hooks: writeObject and readObject
Custom serialization hooks exist to handle cases where default Java serialization is not enough (transient state, derived fields, encryption, validation, compatibility).
They are advanced but extremely important for correct deserialization behavior.

### 4.8.1 Why Custom Serialization Exists
By default, Java serialization automatically writes and reads all non-static, non-transient instance fields of a Serializable object.
This is convenient, but it cannot express certain common needs.
Typical reasons to customize serialization:
- A field should not be stored directly (sensitive data)
- A field is derived/cached and should be recomputed after restore
- You need validation when reading (reject invalid state)
- You need backward/forward compatibility logic (support older streams)
- A referenced object is not Serializable and must be handled specially

### 4.8.2 What writeObject and readObject Really Are
writeObject and readObject are private methods with special meaning.
They are NOT overrides and you never call them directly in normal code.
Instead, ObjectOutputStream and ObjectInputStream look for these methods (by reflection).
If they exist with the exact required signature, the stream calls them automatically.

> [!NOTE]
> If the signature is wrong (wrong visibility, parameter type, return type), the method is ignored and default serialization happens.
> This can be very confusing during debugging.

### 4.8.3 Exact Required Signatures

```java
private void writeObject(ObjectOutputStream out) throws IOException

private void readObject(ObjectInputStream in)
throws IOException, ClassNotFoundException
```

Key constraints:
- must be private
- must return void
- parameter types must match exactly
- exceptions must be compatible with the required throws list

### 4.8.4 What Happens During Serialization: Step by Step
When you serialize an object, you typically call:
```java
out.writeObject(obj);
```

Then the serialization mechanism does roughly this:
- Checks if the object’s class implements Serializable
- Checks whether the class declares a private writeObject(ObjectOutputStream)
- If not present: default serialization runs automatically
- If present: your writeObject is called instead

A crucial point: inside writeObject, Java does not automatically write the normal fields unless you ask for it.
This is why this call exists:
```java
out.defaultWriteObject();
```

defaultWriteObject() means: “serialize the object’s normal serializable fields using the default mechanism.”
After that, you may write extra data in any format you want.

### 4.8.5 Typical Pattern and the Write/Read Order Rule
The typical pattern is to keep default serialization and then extend it.
The order of reads MUST match the order of writes.

```java
private void writeObject(ObjectOutputStream out) throws IOException {
out.defaultWriteObject(); // writes normal fields
out.writeInt(42); // writes extra custom data
}

private void readObject(ObjectInputStream in)
throws IOException, ClassNotFoundException {

in.defaultReadObject();         // reads normal fields
int x = in.readInt();           // reads extra custom data in same order


}
```

> [!NOTE]
> If you write extra values (ints/strings/etc.), you must read them back in the same sequence.
> Otherwise deserialization will fail or restore corrupted state.

### 4.8.6 Example Use Case: Restoring a transient Derived Field
A classic use case is recomputing a transient cached value after deserialization.

```java
class User implements Serializable {
private static final long serialVersionUID = 1L;

private String firstName;
private String lastName;

private transient String fullName;

User(String firstName, String lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
    this.fullName = firstName + " " + lastName;
}

private void readObject(ObjectInputStream in)
        throws IOException, ClassNotFoundException {

    in.defaultReadObject(); // restore firstName and lastName
    fullName = firstName + " " + lastName; // recompute transient field
}


}
```

### 4.9 Constructors and Serialization (Including Inheritance)
Constructor behavior during serialization and deserialization is a frequent source of confusion.
Java serialization restores object state primarily from the byte stream, not by running constructors.

### 4.9.1 Rule: Constructors of Serializable Classes Are Not Called
During deserialization of a Serializable class, the constructors of that class are NOT executed.
The instance is created without calling those constructors, and field values are injected from the stream.

> [!NOTE]
> This is why constructors of Serializable classes must not contain essential initialization logic.
> That initialization would not run during deserialization.

### 4.9.2 Inheritance Rule: The First Non-Serializable Superclass Constructor Is Called
When a Serializable class has a non-Serializable superclass, deserialization must still initialize that superclass part.
Therefore, Java calls the no-argument constructor of the first non-Serializable superclass.

Important implications:
- the non-Serializable superclass must have an accessible no-arg constructor
- serializable subclasses skip constructors, but non-serializable superclasses do not

### 4.9.3 Summary Table: Which Constructors Run

| Class type Constructor called during deserialization |
| --- |
| Serializable class No |
| Serializable subclass No |
| First non-Serializable superclass Yes (no-arg constructor) |
| Externalizable class Yes (public no-arg constructor required) |

### 4.10 Worked Example: Which Constructors Are Called
This example prints which constructors run during normal construction and during deserialization.

```java
import java.io.*;

class A {
A() {
System.out.println("A constructor");
}
}

class B extends A implements Serializable {
private static final long serialVersionUID = 1L;

B() {
    System.out.println("B constructor");
}


}

class C extends B {
private static final long serialVersionUID = 1L;

C() {
    System.out.println("C constructor");
}


}

public class Demo {
public static void main(String[] args) throws Exception {
C obj = new C();

    try (ObjectOutputStream out =
             new ObjectOutputStream(new FileOutputStream("c.bin"))) {
        out.writeObject(obj);
    }

    try (ObjectInputStream in =
             new ObjectInputStream(new FileInputStream("c.bin"))) {
        Object restored = in.readObject();
    }
}


}
```

### 4.10.1 Expected Output and Explanation
During normal construction (new C()):
```text
A constructor
B constructor
C constructor
```

During deserialization (readObject):
```text
A constructor
```

Explanation:
- C is Serializable, so C() is not called during deserialization
- B is Serializable, so B() is not called during deserialization
- A is not Serializable, so A() is called (no-arg constructor)
- Fields of B and C are restored from the stream instead of constructors running

> [!NOTE]
> If the first non-Serializable superclass has no accessible no-arg constructor, deserialization fails.
> This is a classic certification trap.
