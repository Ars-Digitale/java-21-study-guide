## Primitive Streams (IntStream, LongStream, DoubleStream)

Java provides three specialized stream types to avoid boxing overhead and to enable numeric-focused operations:
- `IntStream` for `int`
- `LongStream` for `long`
- `DoubleStream` for `double`

Primitive streams are still streams (lazy pipelines, intermediate + terminal operations, single-use), but they are **not generic** and they use primitive-specialized functional interfaces (e.g., `IntPredicate`, `LongUnaryOperator`, `DoubleConsumer`).

> **Note:** Use primitive streams when the data is naturally numeric or when performance matters: they avoid boxing/unboxing overhead and provide additional numeric terminal operations.

### Why primitive streams matter
- Performance: avoid allocating wrapper objects and repeated boxing/unboxing in large pipelines
- Convenience: built-in numeric reductions such as `sum()`, `average()`, `summaryStatistics()`
- Exam traps: understanding when results are primitives vs `OptionalInt`/`OptionalLong`/`OptionalDouble`

### Common creation methods
The following are the most frequently used ways to create primitive streams. Many certification questions start by identifying the stream type created by a factory method.

```text
IntStream sources

IntStream.of(int...)

IntStream.range(int startInclusive, int endExclusive)

IntStream.rangeClosed(int startInclusive, int endInclusive)

IntStream.iterate(int seed, IntUnaryOperator f) // infinite unless limited

IntStream.iterate(int seed, IntPredicate hasNext, IntUnaryOperator f) // Java 9+

IntStream.generate(IntSupplier s) // infinite unless limited

LongStream sources

LongStream.of(long...)

LongStream.range(long startInclusive, long endExclusive)

LongStream.rangeClosed(long startInclusive, long endInclusive)

LongStream.iterate(long seed, LongUnaryOperator f)

LongStream.iterate(long seed, LongPredicate hasNext, LongUnaryOperator f)

LongStream.generate(LongSupplier s)

DoubleStream sources

DoubleStream.of(double...)

DoubleStream.iterate(double seed, DoubleUnaryOperator f)

DoubleStream.iterate(double seed, DoublePredicate hasNext, DoubleUnaryOperator f)

DoubleStream.generate(DoubleSupplier s)
```

> **Note:** Only `IntStream` and `LongStream` provide `range()` and `rangeClosed()`. There is no `DoubleStream.range` because counting with doubles has rounding issues.

### Primitive-specialized mapping methods (within the same primitive family)
Primitive streams provide **primitive-only** mapping operations that avoid boxing:
- `IntStream.map(IntUnaryOperator)` → `IntStream`
- `IntStream.mapToLong(IntToLongFunction)` → `LongStream`
- `IntStream.mapToDouble(IntToDoubleFunction)` → `DoubleStream`
- `LongStream.map(LongUnaryOperator)` → `LongStream`
- `LongStream.mapToInt(LongToIntFunction)` → `IntStream`
- `LongStream.mapToDouble(LongToDoubleFunction)` → `DoubleStream`
- `DoubleStream.map(DoubleUnaryOperator)` → `DoubleStream`
- `DoubleStream.mapToInt(DoubleToIntFunction)` → `IntStream`
- `DoubleStream.mapToLong(DoubleToLongFunction)` → `LongStream`

> **Note:** The presence of `mapToInt` / `mapToLong` / `mapToDouble` often indicates a deliberate “boxing vs primitive” exam focus. Identify the stream type after each mapping step.

### Mapping table among Stream<T> and primitive streams
This table summarizes the main conversions among object streams and primitive streams. The “From” column tells you which methods are available and the resulting target stream type.

```text

From (source)	To (target)	Primary method(s)
Stream<T>	Stream<R>	map(Function<? super T, ? extends R>)
Stream<T>	Stream<R> (flatten)	flatMap(Function<? super T, ? extends Stream<? extends R>>)
Stream<T>	IntStream	mapToInt(ToIntFunction<? super T>)
Stream<T>	LongStream	mapToLong(ToLongFunction<? super T>)
Stream<T>	DoubleStream	mapToDouble(ToDoubleFunction<? super T>)
Stream<T>	IntStream (flatten)	flatMapToInt(Function<? super T, ? extends IntStream>)
Stream<T>	LongStream (flatten)	flatMapToLong(Function<? super T, ? extends LongStream>)
Stream<T>	DoubleStream (flatten)	flatMapToDouble(Function<? super T, ? extends DoubleStream>)
IntStream	Stream<Integer>	boxed()
LongStream	Stream<Long>	boxed()
DoubleStream	Stream<Double>	boxed()
IntStream	Stream<U>	mapToObj(IntFunction<? extends U>)
LongStream	Stream<U>	mapToObj(LongFunction<? extends U>)
DoubleStream	Stream<U>	mapToObj(DoubleFunction<? extends U>)
IntStream	LongStream	asLongStream()
IntStream	DoubleStream	asDoubleStream()
LongStream	DoubleStream	asDoubleStream()
```		

> **Note:** There is no `unboxed()` operation. To go from wrappers to primitives you must start from `Stream<T>` and use `mapToInt` / `mapToLong` / `mapToDouble`.

### Terminal operations and their result types
Primitive streams have several terminal operations that are either unique or have primitive-specific return types. Many exam questions test the return type precisely.

```text

Terminal operation	IntStream returns	LongStream returns	DoubleStream returns
count()	long	long	long
sum()	int	long	double
min() / max()	OptionalInt	OptionalLong	OptionalDouble
average()	OptionalDouble	OptionalDouble	OptionalDouble
findFirst() / findAny()	OptionalInt	OptionalLong	OptionalDouble
reduce(op)	OptionalInt	OptionalLong	OptionalDouble
reduce(identity, op)	int	long	double
summaryStatistics()	IntSummaryStatistics	LongSummaryStatistics	DoubleSummaryStatistics
```			

> **Note:** Even for `IntStream` and `LongStream`, `average()` returns `OptionalDouble` (not `OptionalInt` or `OptionalLong`). This is a classic certification trap.

### Examples (end-to-end conversions)

Example 1: `Stream<String>` → `IntStream` → primitive terminal operations.
```java
List<String> words = List.of("a", "bb", "ccc");

int totalLength =
words.stream()
.mapToInt(String::length) // IntStream
.sum(); // int

// totalLength = 1 + 2 + 3 = 6
```

Example 2: `IntStream` → boxed `Stream<Integer>` (boxing introduced).
```java
Stream<Integer> boxed =
IntStream.rangeClosed(1, 3) // 1,2,3
.boxed(); // Stream<Integer>
```

Example 3: primitive stream → object stream via `mapToObj`.
```java
Stream<String> labels =
IntStream.range(1, 4) // 1,2,3
.mapToObj(i -> "N=" + i); // Stream<String>
```

### Certification pitfalls and gotchas
- Do not confuse `Stream<Integer>` with `IntStream`: their mapping methods and functional interfaces differ
- `IntStream.sum()` returns `int` but `IntStream.count()` returns `long` — result types are frequently tested
- `average()` always returns `OptionalDouble` for all primitive stream types
- Using `boxed()` reintroduces boxing; only do it if the downstream API requires objects (e.g., collecting to `List<Integer>`)
- Be careful with narrowing conversions: `LongStream.mapToInt` and `DoubleStream.mapToInt` may truncate values

### Mini-exercises (exam style)

1) State the compile-time type of each expression.
- `Stream.of("a","bb").mapToInt(String::length)`
- `IntStream.of(1,2,3).mapToObj(String::valueOf)`
- `IntStream.range(0, 5).boxed()`
- `LongStream.of(1L, 2L).asDoubleStream()`

2) What does each line return (type + “empty or not” possibility)?
- `IntStream.empty().min()`
- `IntStream.empty().sum()`
- `IntStream.empty().average()`

3) Spot the first failing line (compile-time vs runtime).
```java
Stream<Integer> s = Stream.of(1, 2, 3);
IntStream p = s.mapToInt(x -> x);
Stream<Integer> b = p.boxed();
s.count(); // which kind of failure (if any)?
System.out.println(p.sum()); // which kind of failure (if any)?
b.forEach(System.out::println);
```