## Collectors (collect(), Collector, and the Collectors Factory Methods)
A `Collector` describes how to accumulate stream elements into a final result. The `collect(...)` terminal operation executes this recipe. The `Collectors` utility class provides ready-made collectors for common aggregation tasks.
> **Note:** On certifications, **collectors** are heavily tested because they involve generics, nested collectors, maps, grouping, partitioning, and parallel semantics (supplier/accumulator/combiner).

### collect() vs Collector
There are two main ways to collect:
- `collect(Collector)` → the common form using `Collectors.*`
- `collect(supplier, accumulator, combiner)` → explicit mutable reduction (lower-level)

```java
List<String> list =
Stream.of("a", "b")
.collect(Collectors.toList());

StringBuilder sb =
Stream.of("a", "b")
.collect(StringBuilder::new, StringBuilder::append, StringBuilder::append);
```

> **Note:** Use `collect(supplier, accumulator, combiner)` when you need a custom mutable container and do not want to implement a full `Collector`.

### Core collectors (quick reference)
These are the most frequently used collectors and the ones most likely to appear in exam questions.
- `toList()` → `List<T>` (no guarantees about mutability/implementation)
- `toSet()` → `Set<T>`
- `toCollection(supplier)` → specific collection type (e.g., `TreeSet`)
- `joining(delim, prefix, suffix)` → `String` from `CharSequence` elements
- `counting()` → `Long` count
- `summingInt` / `summingLong` / `summingDouble` → numeric sums
- `averagingInt` / `averagingLong` / `averagingDouble` → numeric averages
- `minBy(comparator)` / `maxBy(comparator)` → `Optional<T>`
- `mapping(mapper, downstream)` → transform then collect with downstream
- `filtering(predicate, downstream)` → filter inside collector (Java 9+)

### Grouping collectors
`groupingBy` classifies elements into buckets keyed by a classifier function. It produces a `Map<K, V>` where `V` depends on the downstream collector.

```java
Map<Integer, List<String>> byLen =
Stream.of("a", "bb", "ccc", "dd")
.collect(Collectors.groupingBy(String::length));
```

With a downstream collector you control what each bucket contains:

```java
Map<Integer, Long> countByLen =
Stream.of("a", "bb", "ccc", "dd")
.collect(Collectors.groupingBy(String::length, Collectors.counting()));

Map<Integer, Set<String>> setByLen =
Stream.of("a", "bb", "ccc", "dd")
.collect(Collectors.groupingBy(String::length, Collectors.toSet()));
```

> **Note:** Common exam requirement: know the resulting map value type. Example: `groupingBy(..., counting())` yields `Map<K, Long>` (not `int`).

### partitioningBy
`partitioningBy` splits the stream into exactly two groups using a boolean predicate. It always returns a map with keys `true` and `false`.

```java
Map<Boolean, List<String>> parts =
Stream.of("a", "bb", "ccc")
.collect(Collectors.partitioningBy(s -> s.length() > 1));
```

> **Note:** `partitioningBy` always creates two buckets, while `groupingBy` can create many. Both support downstream collectors.

### toMap and merge rules
`toMap` is a frequent exam topic because it throws an exception on duplicate keys unless you provide a merge function.

```java
Map<Integer, String> m1 =
Stream.of("aa", "bb")
.collect(Collectors.toMap(String::length, s -> s)); // OK: keys are unique (2)

Map<Integer, String> m2 =
Stream.of("aa", "bb", "cc")
.collect(Collectors.toMap(
String::length,
s -> s,
(oldV, newV) -> oldV + "," + newV
)); // key=2 merges values
```

> **Note:** Without a merge function, duplicate keys cause `IllegalStateException` at runtime. This is a common certification trap.

### collectingAndThen
`collectingAndThen(downstream, finisher)` lets you apply a final transformation after collecting (e.g., make the list unmodifiable).

```java
List<String> unmodifiable =
Stream.of("a", "b", "c")
.collect(Collectors.collectingAndThen(
Collectors.toList(),
List::copyOf
));
```

### How collectors relate to parallel streams
Collectors are designed to work with parallel streams by using supplier/accumulator/combiner internally. In parallel, each worker builds a partial result container and then merges containers.
- The accumulator mutates a per-thread container (no shared mutable state)
- The combiner merges containers (required for parallel execution)
- Some collectors are “concurrent” or have characteristics that affect performance and ordering

> **Note:** Certification emphasis: prefer `collect(Collectors.toList())` over using `reduce` to build collections. `reduce` is for immutable-style reductions; `collect` is for mutable containers.

### Mini-exercises
- What is the result type? `stream.collect(Collectors.groupingBy(String::length, Collectors.counting()))`
- What happens at runtime? `Collectors.toMap(kFn, vFn)` with duplicate keys
- Difference: `groupingBy` vs `partitioningBy` (number of buckets and key types)