## 4.4 Buffered Streams and Performance

Buffered streams wrap another stream and add an in-memory buffer.
Instead of interacting with the operating system on every read or write, data is accumulated in memory and transferred in larger chunks.

- BufferedInputStream / BufferedOutputStream for byte streams
- BufferedReader / BufferedWriter for character streams

> [!NOTE]
> Buffered streams are decorators: they do not replace the underlying stream,
> they enhance it by adding buffering behavior.

### 4.4.1 Why Buffering Matters

| Aspect Unbuffered Buffered |
| --- |
| System calls Frequent Reduced |
| Performance Poor High |
| Memory usage Minimal Slightly higher |

System calls are expensive operations.
Buffering minimizes them by grouping multiple logical reads or writes into fewer physical I/O operations.

### 4.4.2 How Unbuffered Reading Works

In an unbuffered stream, each call to read() may result in a native system call.
This is especially inefficient when reading small amounts of data.

```java
try (InputStream in = new FileInputStream("data.bin")) {
int b;
while ((b = in.read()) != -1) {
// each read() may trigger a system call
}
}
```

> [!NOTE]
> Reading byte-by-byte without buffering is almost always a performance anti-pattern.

### 4.4.3 How BufferedInputStream Works

BufferedInputStream internally reads a large block of bytes into a buffer.
Subsequent read() calls are served directly from memory until the buffer is empty.

```java
try (InputStream in =
new BufferedInputStream(new FileInputStream("data.bin"))) {

int b;
while ((b = in.read()) != -1) {
    // most reads are served from memory, not the OS
}


}
```

The program still calls read() repeatedly,
but the operating system is accessed only when the internal buffer needs refilling.

### 4.4.4 Buffered Output Example

Buffered output accumulates data in memory and writes it in larger chunks.
The flush() operation forces the buffer to be written immediately.

```java
try (OutputStream out =
new BufferedOutputStream(new FileOutputStream("out.bin"))) {

for (int i = 0; i < 1_000; i++) {
    out.write(i);
}
out.flush(); // forces buffered data to disk


}
```

> [!NOTE]
> close() automatically calls flush().
> Calling flush() explicitly is useful when data must be visible immediately.

### 4.4.5 BufferedReader vs Reader

BufferedReader adds efficient line-based reading on top of a Reader.
Without buffering, each character read may involve a system call.

```java
try (BufferedReader reader =
new BufferedReader(new FileReader("file.txt"))) {

String line;
while ((line = reader.readLine()) != null) {
    System.out.println(line);
}


}
```

The readLine() method is only available on BufferedReader,
because it relies on buffering to efficiently detect line boundaries.

### 4.4.6 BufferedWriter Example

```java
try (BufferedWriter writer =
new BufferedWriter(new FileWriter("file.txt"))) {

writer.write("Hello");
writer.newLine();
writer.write("World");


}
```

BufferedWriter minimizes disk access and provides convenience methods such as newLine().

> [!NOTE]
> For exams and real applications:
> 
> Always wrap file streams with buffering unless there is a strong reason not to
> 
> Prefer BufferedReader / BufferedWriter for text
> 
> Prefer BufferedInputStream / BufferedOutputStream for binary data
