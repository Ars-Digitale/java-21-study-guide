# Nested Classes in Java

Java supports several kinds of **nested classes** — classes declared inside another class.  
They are a fundamental tool for encapsulation, code organization, event-handling patterns, and representing logical hierarchies.  
A nested class always belongs to an **enclosing class** and has special accessibility and instantiation rules depending on its category.

Java defines four kinds of nested classes:

- **Static Nested Classes** – declared with `static` inside another class.
- **Inner Classes** (non-static nested classes).
- **Local Classes** – declared inside a block (method, constructor, or initializer).
- **Anonymous Classes** – unnamed classes created inline, usually to override a method or implement an interface.

---

## 1. Static Nested Classes

A **static nested class** behaves like a top-level class that is namespaced inside its enclosing class.  
It **cannot** access instance members of the outer class but **can** access static members.  
It does **not** hold a reference to an instance of the enclosing class.

### 1.1 Syntax and Access Rules

- Declared using `static class` inside another class.
- Can access only **static** members of the outer class.
- Does not have an implicit reference to the enclosing instance.
- Can be instantiated without an outer instance.

```java
class Outer {
    static int version = 1;

    static class Nested {
        void print() {
            System.out.println("Version: " + version); // OK: accessing static member
        }
    }
}

class Test {
    public static void main(String[] args) {
        Outer.Nested n = new Outer.Nested(); // No Outer instance required
        n.print();
    }
}
```

### 1.2 Certification Pitfalls

- Static nested classes **cannot access instance variables**:

```java
class Outer {
    int x = 10;
    static class Nested {
        void test() {
            // System.out.println(x); // ❌ Compile error
        }
    }
}
```

---

## 2. Inner Classes (Non-Static Nested Classes)

An **inner class** is associated with an instance of the outer class and can access **all members** of the outer class, including **private** ones.

### 2.1 Syntax and Access Rules

- Declared without `static`.
- Has an implicit reference to the enclosing instance.
- Can access both static and instance members of the outer class.
- Requires an enclosing instance for instantiation.

```java
class Outer {
    private int value = 100;

    class Inner {
        void print() {
            System.out.println("Value = " + value); // OK: accessing private
        }
    }

    void make() {
        Inner i = new Inner(); // OK inside the outer class
        i.print();
    }
}

class Test {
    public static void main(String[] args) {
        Outer o = new Outer();
        Outer.Inner i = o.new Inner(); // MUST be created from an instance
        i.print();
    }
}
```

### 2.2 Certification Pitfalls

- Inner classes **cannot declare static members** except **static final constants**.

```java
class Outer {
    class Inner {
        // static int x = 10;     // ❌ Compile error
        static final int OK = 10; // ✔ Allowed (constant)
    }
}
```

- Instantiating an inner class WITHOUT an outer instance is illegal.

---

## 3. Local Classes

A **local class** is a nested class defined inside a block — most commonly a method.  
It has no access modifier and is visible only within the block where it is declared.

### 3.1 Characteristics

- Declared inside a method, constructor, or initializer.
- Can access members of the outer class.
- Can access local variables if they are **effectively final**.
- Cannot declare static members (except static final constants).

```java
class Outer {
    void compute() {
        int base = 5; // must be effectively final

        class Local {
            void show() {
                System.out.println(base); // OK
            }
        }

        new Local().show();
    }
}
```

### 3.2 Certification Pitfalls

- `base` must be effectively final; changing it breaks compilation.

```java
void compute() {
    int base = 5;
    base++; // ❌ Now base is NOT effectively final
    class Local {}
}
```

---

## 4. Anonymous Classes

An **anonymous class** is a one-off class created inline, usually to implement an interface or override a method without naming a new class.

### 4.1 Syntax and Usage

- Created using `new` + type + body.
- Cannot have constructors (no name).
- Often used for event handling, callbacks, comparators.

```java
Runnable r = new Runnable() {
    @Override
    public void run() {
        System.out.println("Anonymous running");
    }
};
```

### 4.2 Anonymous Class Extending a Class

```java
Button b = new Button("Click");
b.onClick(new ClickHandler() {
    @Override
    public void handle() {
        System.out.println("Handled!");
    }
});
```

---

## 5. Comparison of Nested Class Types

A quick table summarizing all kinds of nested classes.

```text
Type                | Has Outer Instance? | Can Access Outer Instance Members? | Can Have Static Members? | Typical Use
------------------- | ------------------- | ---------------------------------- | ------------------------- | ---------------------------
Static Nested       | No                  | No                                 | Yes                      | Namespacing, helpers
Inner Class         | Yes                 | Yes                                | No (except constants)     | Object-bound behavior
Local Class         | Yes                 | Yes                                | No                        | Temporary scoped classes
Anonymous Class     | Yes                 | Yes                                | No                        | Inline customization
```

---

## 6. Certification Pitfalls Summary

- Inner classes cannot have static members (except constants).
- Static nested classes cannot access instance members of the outer class.
- Local and anonymous classes require effectively final variables.
- Anonymous classes cannot define constructors.
- To instantiate an inner class, you MUST have an instance of the outer class.
- Accessing shadowed members requires `Outer.this.member` inside inner classes.

---

If you want, I can now generate:  
- A full chapter comparing nested classes with records, interfaces, and sealed hierarchies  
- Exam-style questions specifically about nested classes  
- A flow diagram showing how each nested class captures context  
Just let me know!
