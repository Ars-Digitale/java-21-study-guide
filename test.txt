### 13.2.4 Struttura del pattern DecimalFormat

Un pattern può contenere una sottostruttura positiva e una negativa opzionale, separate da `;`.

```text
#,##0.00;(#,##0.00)
```

> [!NOTE]
> - La prima parte → numeri positivi.
> - La seconda parte → numeri negativi.
> - Se la parte negativa è omessa, i numeri negativi usano automaticamente un `-` iniziale.

### 13.2.5 Il simbolo `0` (cifra obbligatoria)

Il simbolo `0` forza la visualizzazione di una cifra, riempiendo con zeri se necessario.

```java
DecimalFormat df = new DecimalFormat("0000.00");
System.out.println(df.format(12.3));
```

```bash
0012.30
```

- Controlla il numero minimo di cifre.
- Riempie con zeri se il numero ha meno cifre.
- Utile per output a larghezza fissa o allineato.

### 13.2.6 Il simbolo `#` (cifra opzionale)

Il simbolo `#` visualizza una cifra solo se esiste.

```java
DecimalFormat df = new DecimalFormat("####.##");
System.out.println(df.format(12.3));
```

```bash
12.3
```

- Sopprime gli zeri iniziali.
- Sopprime gli zeri finali non necessari.
- Adatto a una formattazione “user-friendly”.

### 13.2.7 Combinare `0` e `#`

I pattern combinano spesso entrambi i simboli per maggiore flessibilità.

```java
DecimalFormat df = new DecimalFormat("#,##0.##");
System.out.println(df.format(12));
System.out.println(df.format(12.5));
System.out.println(df.format(12345.678));
```

```bash
12
12.5
12,345.68
```

Spiegazione del pattern:

```text
#,##0 . ##
 ^  ^    ^
 |  |    |
 |  |    └─ cifre frazionarie opzionali (#)
 |  └───── cifra intera obbligatoria (0)
 └──────── pattern di raggruppamento (,)
```

- È garantita almeno una cifra intera (lo `0`).
- Le cifre sono raggruppate per migliaia usando il separatore di raggruppamento.
- Le cifre frazionarie sono opzionali (fino a due).

### 13.2.8 Separatori decimali e di raggruppamento

Nei pattern:

- `.` → separatore decimale.
- `,` → separatore di raggruppamento.

I simboli effettivamente utilizzati a runtime dipendono dal `Locale` (ad esempio, virgola vs punto).

### 13.2.9 DecimalFormatSymbols: simboli di formattazione specifici del Locale

```java
DecimalFormatSymbols symbols =
        DecimalFormatSymbols.getInstance(Locale.FRANCE);

DecimalFormat df =
        new DecimalFormat("#,##0.00", symbols);

System.out.println(df.format(1234.5));
```

```bash
1 234,50
```

- Controlla i separatori decimali e di raggruppamento.
- Controlla il segno meno e il simbolo di valuta.
- Controlla le stringhe NaN e Infinity.

### 13.2.10 Pattern speciali di DecimalFormat

```text
0.###E0   notazione scientifica
###%      percentuale
¤#,##0.00 valuta (¤ è il simbolo di valuta)
```

### 13.2.11 Regole ed errori comuni

- `DecimalFormat` è una sottoclasse di `NumberFormat`.
- `0` forza le cifre, `#` no.
- I pattern controllano la formattazione, non la modalità di arrotondamento (usare `setRoundingMode()`).
- Il raggruppamento funziona solo se il separatore (di solito `,`) è presente nel pattern.
- Il parsing può riuscire parzialmente senza errore se sono presenti caratteri finali dopo un numero valido.
- `DecimalFormat` è mutabile e non thread-safe.

## 13.3 Parsing dei Numeri

Il parsing converte testo localizzato in valori numerici. Per impostazione predefinita, il parsing è permissivo.

```java
NumberFormat nf = NumberFormat.getInstance(Locale.FRANCE);
Number n = nf.parse("12 345,67abc"); // estrae 12345.67
```

- Il parsing si ferma al primo carattere non valido.
- Il testo finale viene ignorato se non controllato esplicitamente.

### 13.3.1 Parsing con DecimalFormat

`DecimalFormat` può anche effettuare il parsing dei numeri. Il parsing è permissivo per impostazione predefinita.

```java
DecimalFormat df = new DecimalFormat("#,##0.##");
Number n = df.parse("1,234.56abc");
```

- Il parsing si ferma al primo carattere non valido.
- Il testo finale viene ignorato se presente.

Per forzare un parsing rigoroso:

```java
df.setParseStrict(true);
```

### 13.3.2 CompactNumberFormat

La formattazione compatta abbrevia i numeri grandi per la leggibilità umana.

- Supporta stili SHORT e LONG.
- Usa abbreviazioni dipendenti dal locale (ad esempio K, M, “million”).

```java
NumberFormat cnf =
        NumberFormat.getCompactNumberInstance(
                Locale.US, NumberFormat.Style.SHORT);

System.out.println(cnf.format(1_200));        // 1.2K
System.out.println(cnf.format(5_000_000));    // 5M

NumberFormat cnf1 =
        NumberFormat.getCompactNumberInstance(
                Locale.US, NumberFormat.Style.SHORT);

NumberFormat cnf2 =
        NumberFormat.getCompactNumberInstance(
                Locale.US, NumberFormat.Style.LONG);

System.out.println(cnf1.format(315_000_000));   // 315M
System.out.println(cnf2.format(315_000_000));   // 315 million
```

## 13.4 Formattazione di Data e Ora

### 13.4.1 DateTimeFormatter

Java 21 si basa su `java.time` e `DateTimeFormatter` per la formattazione moderna di data e ora.

```java
DateTimeFormatter f =
        DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
System.out.println(LocalDateTime.now().format(f));
```

**Proprietà principali:**

- Immutabile.
- Thread-safe.
- Sensibile al locale.

### 13.4.2 Simboli standard di data e ora

```text
y   anno
M   numero del mese (o nome con più lettere)
d   giorno del mese
E   nome del giorno
H   ora (0–23)
h   ora (1–12)
m   minuto
s   secondo
a   indicatore AM/PM
z   fuso orario
```

### 13.4.3 datetime.format vs formatter.format

Entrambi i metodi sono funzionalmente identici:

```java
date.format(formatter);
formatter.format(date);
```

- `date.format(formatter)` → preferito per leggibilità (prima il dato, poi la formattazione).
- `formatter.format(date)` → utile in codice funzionale o con formatter riutilizzabili.

### 13.4.4 Localizzazione delle date

Gli stili localizzati adattano l’output delle date alle norme culturali.

```java
DateTimeFormatter fullIt =
        DateTimeFormatter
                .ofLocalizedDate(FormatStyle.FULL)
                .withLocale(Locale.ITALY);

DateTimeFormatter shortIt =
        DateTimeFormatter
                .ofLocalizedDate(FormatStyle.SHORT)
                .withLocale(Locale.ITALY);

LocalDate today = LocalDate.of(2025, 12, 17);

System.out.println(today.format(fullIt));
System.out.println(today.format(shortIt));
```

Output possibile:

```bash
mercoledì 17 dicembre 2025
17/12/25
```

## 13.5 Internazionalizzazione (i18n) e Localizzazione (l10n)

### 13.5.1 Locales

Un `Locale` definisce lingua, paese e una variante opzionale.

```java
Locale l1 = Locale.US;
Locale l2 = Locale.of("fr", "FR");
Locale l3 = new Locale.Builder()
        .setLanguage("en")
        .setRegion("US")
        .build();
```

Formati di Locale:

- `en` (it, fr, ecc.): codice lingua minuscolo.
- `en_US` (fr_CA, it_IT, ecc.): codice lingua minuscolo + underscore + codice paese maiuscolo.

### 13.5.2 Categorie di Locale

Le categorie di Locale separano la formattazione dalla lingua dell’interfaccia utente.

`Locale.Category` consente a Java di usare Locale predefiniti diversi per scopi diversi.

Esistono due categorie:

| Category | Usata per |
| --- | --- |
| FORMAT | Numeri, date, valuta, altra formattazione |
| DISPLAY | Testo leggibile (UI, nomi, messaggi) |

### 13.5.3 Esempio reale

Un utente francese che vive in Germania potrebbe desiderare:

- Numeri e date → formato tedesco.
- Lingua dell’interfaccia → francese.

Prima di Java 7, questo non era possibile.

```java
Locale.setDefault(Locale.Category.FORMAT, Locale.GERMANY);
Locale.setDefault(Locale.Category.DISPLAY, Locale.FRANCE);
```

Effetti di esempio:

| Aspetto | Risultato (esempio) |
| --- | --- |
| Numeri | 1.234,56 |
| Date | 31.12.2025 |
| Valuta | € |
| Testo UI | Francese |
| Nomi dei mesi | décembre |
| Nomi dei paesi | Allemagne |

## 13.6 Properties e Resource Bundles

I resource bundle esternalizzano il testo e consentono la localizzazione senza modifiche al codice.

```java
ResourceBundle rb =
        ResourceBundle.getBundle("messages", Locale.GERMAN);

String msg = rb.getString("welcome");
```

### 13.6.1 Regole di risoluzione dei Resource Bundle

Java cerca i bundle seguendo un ordine di fallback rigoroso. Ad esempio, con nome base `messages` e locale `de_DE`:

- messages_de_DE.properties
- messages_de.properties
- messages.properties

Se nessuno viene trovato → `MissingResourceException`.

> [!NOTE]
> I file `.properties` tradizionali sono specificati come ISO-8859-1;
> i caratteri non ASCII devono essere codificati come escape Unicode (ad esempio `\u00E9` per é), a meno di usare meccanismi di caricamento alternativi.

## 13.7 Regole ed errori comuni

- `DateTimeFormatter` è immutabile e thread-safe.
- `NumberFormat` / `DecimalFormat` sono mutabili e non thread-safe.
- Cambiare il `Locale` influisce su come i valori sono formattati e interpretati, non sui valori numerici o temporali sottostanti.
- Il parsing con `NumberFormat` o `DecimalFormat` può riuscire parzialmente senza eccezioni se dopo un numero valido è presente testo aggiuntivo.
- `java.time` sostituisce la maggior parte degli usi delle vecchie API `java.util.Date` / `Calendar` nel codice moderno e nell’esame.
