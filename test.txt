## 3. Method References

Method references provide a shorthand syntax for using an existing method as a functional interface implementation.  
They are equivalent to lambda expressions, but more concise, readable, and often preferred when the target method already exists.

There are four categories of method references in Java:

- 1. Reference to a static method (`ClassName::staticMethod`)
- 2. Reference to an instance method of a particular object (`instance::method`)
- 3. Reference to an instance method of an arbitrary object of a given type (`ClassName::instanceMethod`)
- 4. Reference to a constructor (`ClassName::new`)

---

### 3.1 Reference to a Static Method

A static method reference replaces a lambda that calls a static method.

```java
class Utils {
    static int square(int x) { return x * x; }
}

Function<Integer, Integer> f1 = x -> Utils.square(x);
Function<Integer, Integer> f2 = Utils::square;  // method reference
```

Both `f1` and `f2` behave identically.

---

### 3.2 Reference to an Instance Method of a Particular Object

Used when you already have an object instance, and want to refer to one of its methods.

```java
String prefix = "Hello, ";

UnaryOperator<String> op1 = s -> prefix.concat(s);
UnaryOperator<String> op2 = prefix::concat;   // method reference

System.out.println(op2.apply("World"));
```

The reference `prefix::concat` binds `concat` to **that specific object**.

---

### 3.3 Reference to an Instance Method of an Arbitrary Object of a Given Type

This is the trickiest form.  
The functional interface’s first parameter becomes the method’s receiver (`this`).

```java
BiPredicate<String, String> p1 = (s1, s2) -> s1.equals(s2);
BiPredicate<String, String> p2 = String::equals;   // method reference

System.out.println(p2.test("abc", "abc"));  // true
```

> **Note:** This form applies the method to the *first argument* of the lambda.

---

### 3.4 Reference to a Constructor

Constructor references replace lambdas that call `new`.

```java
Supplier<ArrayList<String>> sup1 = () -> new ArrayList<>();
Supplier<ArrayList<String>> sup2 = ArrayList::new; // method reference

Function<Integer, ArrayList<String>> sup3 = ArrayList::new;
// calls the constructor ArrayList(int capacity)
```

---

### 3.5 Summary Table of Method Reference Types

The table below summarizes all method reference categories.

```text
Type                                | Syntax Example          | Equivalent Lambda
----------------------------------- | ------------------------ | ----------------------------------------
Static method                       | Class::staticMethod     | x -> Class.staticMethod(x)
Instance method of specific object  | instance::method        | x -> instance.method(x)
Instance method of arbitrary object | Class::method           | (obj, x) -> obj.method(x)
Constructor                         | Class::new              | () -> new Class()
```

---

### 3.6 Common Pitfalls (Certification Traps)

- A method reference must match *exactly* the functional interface signature.
- Method overloads can make method references ambiguous.
- Instance-method reference (`Class::method`) shifts the receiver to parameter 1.
- Constructor reference fails if there is no matching constructor.

```java
// ❌ Ambiguous: which println()? (println(int), println(String)...)
Consumer<String> c = System.out::println; // OK only because FI parameter is String

// ❌ No matching constructor
Function<String, Integer> f = Integer::new; 
// ERROR: Integer(String) exists, but return type Integer must match
```

When in doubt, rewrite the method reference as a lambda — if the lambda works but the method reference does not, the problem is usually signature matching.
