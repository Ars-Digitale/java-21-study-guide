### 4.7.1 Primitive Casting

Primitive casting changes the type of a numeric value.

There are two categories of casting:

| Type | Description | Example | Explicit? | Risk |
| --- | --- | --- | --- | --- |
| Widening | smaller type → larger type | int → double | No | no loss |
| Narrowing | larger type → smaller type | double → int | Yes | possible loss |

### 4.7.1.1 Widening Implicit Casting

Automatic conversion from a “smaller” type to a compatible “larger” type.  
Handled by the compiler, **does not require explicit syntax**.

```java
int i = 100;
double d = i;  // implicit cast: int → double
System.out.println(d); // 100.0
```

✅ **Safe** – no overflow (though still be aware of floating-point precision).

### 4.7.1.2 Narrowing Explicit Casting

Manual conversion from a “larger” type to a “smaller” one.  
Requires a **cast expression** because it may cause data loss.

```java
double d = 9.78;
int i = (int) d;  // explicit cast: double → int
System.out.println(i); // 9 (fraction discarded)
```

⚠ Use only when you are sure the value fits in the target type.

### 4.7.2 Data Loss, Overflow and Underflow

When a value exceeds a type’s capacity, you may get:

- **Overflow**: result greater than the maximum representable value
- **Underflow**: result lower than the minimum representable value
- **Truncation**: data that does not fit is lost (e.g., decimals)

**Example – overflow/underflow with int:**

```java
int max = Integer.MAX_VALUE;
int overflow = max + 1;     // "wrap-around" to negative

int min = Integer.MIN_VALUE;
int underflow = min - 1;    // "wrap-around" to positive
```

Example: truncation

```java
double d = 9.99;
int i = (int) d; // 9 (fraction discarded)
```

> [!NOTE]
> Floating-point types (`float`, `double`) **do not wrap**:
> overflow → `Infinity` / `-Infinity`
> underflow (very small values) → 0.0 or denormalized values.

### 4.7.3 Casting Values versus Variables

Java treats:

- Integer **literals** as `int` by default
- Floating-point **literals** as `double` by default

The compiler **does not require a cast** when a literal fits within the target type range:

```java
byte first = 10;        // OK: 10 fits in byte
short second = 9 * 10;  // OK: constant expression evaluated at compile time
```

But:

```java
long a = 5729685479;    // ❌ error: int literal out of range
long b = 5729685479L;   // ✅ long literal (L suffix)

float c = 3.14;         // ❌ double → float: requires F or cast
float d = 3.14F;        // ✅ float literal

int e = 0x7FFF_FFFF;    // ✅ max int in hex
int f = 0x8000_0000;    // ❌ out of int range (needs L)
```

However, when numeric promotion rules apply:

> With variables of type `byte`, `short`, and `char` in an arithmetic expression,  
> operands are promoted to `int` and the result is `int`.

```java
byte first = 10;
short second = 9 + first;       // ❌ 9 (int literal) + first (byte → int) = int
// second = (short) (9 + first);  // ✅ cast entire expression
```

```java
short b = 10;
short a = 5 + b;               // ❌ 5 (int) + b (short → int) = int
short a2 = (short) (5 + b);    // ✅ cast entire expression
```

> [!WARNING]
> Cast is a **unary operator**:
> `short a = (short) 5 + b;`
> The cast applies only to `5` → the expression result remains int → assignment still fails.

### 4.7.4 Reference Casting Objects

Casting also applies to **object references** in a class hierarchy.  
It does not change the object in memory — only **the reference type** used to access it.

Key rules:

- The **real object type** determines which fields/methods actually exist.
- The **reference type** determines what you may access at that point in code.

### 4.7.4.1 Upcasting (Widening Reference Cast)

Conversion from **subclass** to **superclass**.

- **Implicit** and **always safe**: every `Dog` is also an `Animal`.

```java
class Animal { }
class Dog extends Animal { }

Dog dog = new Dog();
Animal a = dog;    // implicit upcast: Dog → Animal
```

### 4.7.4.2 Downcasting (Narrowing Reference Cast)

Conversion from **superclass** to **subclass**.

- **Explicit**
- Can fail at runtime with `ClassCastException` if not truly that type

```java
Animal a = new Dog();
Dog d = (Dog) a;   // OK: a really points to a Dog

Animal x = new Animal();
Dog d2 = (Dog) x;  // ⚠ Runtime error: ClassCastException
```

For safety, use `instanceof`:

```java
if (x instanceof Dog) {
    Dog safeDog = (Dog) x;   // safe cast
}
```

### 4.7.5 Key Points Summary

| Casting Type | Applies To | Direction | Syntax | Safe? | Performed By |
| --- | --- | --- | --- | --- | --- |
| Widening Primitive | Primitives | small → large | Implicit | Yes | Compiler |
| Narrowing Primitive | Primitives | large → small | Explicit | No | Programmer |
| Upcasting | Objects | subclass → superclass | Implicit | Yes | Compiler |
| Downcasting | Objects | superclass → subclass | Explicit | Runtime check | Programmer |

### 4.7.6 Examples

```java
// Primitive casting
short s = 50;
int i = s;           // widening
byte b = (byte) i;   // narrowing (possible loss)

// Object casting
Object obj = "Hello";
String str = (String) obj; // OK: obj points to a String

Object n = Integer.valueOf(10);
// String fail = (String) n;  // ClassCastException at runtime
```

In summary:

- **Primitive casting** changes the numeric type.
- **Reference casting** changes the “view” of an object in the hierarchy.
- **Upcasting** → safe and implicit.
- **Downcasting** → explicit, to be used carefully (often after `instanceof`).
