## 9.2 java.nio — Buffers, Channels, and Non-Blocking I/O

The java.nio API (New I/O) was introduced to address limitations of legacy java.io.
It provides a lower-level, more explicit model of I/O that maps closely to modern operating systems.

At its core, java.nio is built around three concepts:
- Buffers — explicit memory containers
- Channels — bidirectional data connections
- Selectors — multiplexing non-blocking I/O

### 9.2.1 From Streams to Buffers: A Conceptual Shift

Legacy streams hide memory management from the programmer.
In contrast, NIO makes memory explicit through buffers.

| Aspect | java.io | java.nio |
| --- | --- | --- |
| Data | flow | Push-based Pull-based |
| Memory | Hidden | Explicit |
| Control | Simple | More granular |

With NIO, the application controls when data is read into memory and how it is consumed.

### 9.2.2 Buffers: Purpose and Structure

A buffer is a fixed-size, typed container for data.
All NIO I/O operations read from or write to buffers.

The most common buffer is ByteBuffer.

```java
ByteBuffer buffer = ByteBuffer.allocate(1024);
```

| Property | Meaning |
| --- | --- |
| capacity | Total size of the buffer |
| position | Current read/write index |
| limit | Boundary of readable or writable data |

### 9.2.3 Buffer Lifecycle: Write → Flip → Read

Buffers have a strict usage lifecycle.
Misunderstanding it is a common source of bugs.

Typical sequence:
- Write data into the buffer
- flip() to switch to read mode
- Read data from the buffer
- clear() or compact() to reuse

```java
ByteBuffer buffer = ByteBuffer.allocate(16);

buffer.put((byte) 1);
buffer.put((byte) 2);

buffer.flip(); // switch to read mode

while (buffer.hasRemaining()) {
byte b = buffer.get();
}

buffer.clear(); // ready for writing again
```

> [!NOTE]
> flip() does not erase data.
> It adjusts position and limit.

### 9.2.4 clear() vs compact()

After reading, a buffer can be reused in two ways.

| Method | Behavior |
| --- | --- |
| clear() | Discards unread data |
| compact() | Preserves unread data |

compact() is useful in streaming protocols where partial messages may remain in the buffer.

### 9.2.5 Heap Buffers vs Direct Buffers

Buffers can be allocated in two different memory regions.

```java
ByteBuffer heap = ByteBuffer.allocate(1024);
ByteBuffer direct = ByteBuffer.allocateDirect(1024);
```

| Type | Memory | location | Characteristics |
| --- | --- | --- | --- |
| Heap | buffer | JVM | heap Garbage collected |
| Direct | buffer | Native | memory Faster I/O, costly allocation |

> [!NOTE]
> Direct buffers reduce copying between JVM and OS
> but must be used carefully to avoid memory pressure.

### 9.2.6 Channels: What They Are

A channel represents a connection to an I/O entity
such as a file, socket, or device.

Unlike streams, channels are bidirectional.

| Channel | type | Purpose |
| --- | --- | --- |
| FileChannel | File | I/O |
| SocketChannel | TCP | sockets |
| DatagramChannel | UDP |

```java
try (FileChannel channel =
FileChannel.open(Path.of("file.txt"))) {

ByteBuffer buffer = ByteBuffer.allocate(128);
channel.read(buffer);


}
```

### 9.2.7 Blocking vs Non-Blocking Channels

Channels can operate in blocking or non-blocking mode.

```java
SocketChannel channel = SocketChannel.open();
channel.configureBlocking(false);
```

In non-blocking mode:
- read() may return immediately with 0 bytes
- write() may write only part of the data

> [!NOTE]
> Non-blocking I/O shifts complexity from the OS to the application.

### 9.2.8 Scatter/Gather I/O

NIO supports reading into or writing from multiple buffers in a single operation.

```java
ByteBuffer header = ByteBuffer.allocate(128);
ByteBuffer body = ByteBuffer.allocate(1024);

ByteBuffer[] buffers = { header, body };
channel.read(buffers);
```

This is useful for structured protocols (headers + payload).

### 9.2.9 Selectors: Multiplexing Non-Blocking I/O

Selectors allow a single thread to monitor multiple channels.

They are the foundation of scalable servers.

| Component | Role |
| --- | --- |
| Selector | Monitors channels |
| SelectionKey | Represents channel state |
| Interest | set Operations of interest |

> [!NOTE]
> Selectors are advanced and rarely required in exams,
> but understanding their purpose is important.

### 9.2.10 When to Use java.nio

NIO is appropriate when:
- High concurrency is required
- You need fine-grained memory control
- You are implementing protocols or servers

For simple file operations, java.nio.file.Files is usually sufficient.
