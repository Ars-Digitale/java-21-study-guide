## Using `Path.relativize`: Concepts, Rules, and Examples

The `relativize` method is often misunderstood but is very important both in real code and in certification exams. This section explains what it does, the strict rules it follows, and provides concrete examples.

### 1. What `relativize` Does

`Path.relativize` computes a **relative path** from one path to another. The resulting path, when `resolve`d against the source path, yields the target path.

In other words:

- It answers the question: “How do I go from path A to path B?”
- The result is always a **relative** path
- No filesystem access occurs

> [!NOTE]
> `relativize` is purely syntactic. It does not check whether paths exist.

### 2. Fundamental Rules (EXAM-CRITICAL)

`relativize` has strict preconditions. Violating them throws an exception.

| Rule | Explanation |
|------|-------------|
| Both paths must be absolute | or both relative |
| Both paths must belong to the same filesystem | same provider |
| Root components must match | same root (on Windows, same drive) |
| Result is never absolute | always relative |

> [!NOTE]
> If one path is absolute and the other relative, `IllegalArgumentException` is thrown.

### 3. Simple Relative Example

Both paths are relative, so relativization is allowed.

```java
Path p1 = Path.of("docs/manual");
Path p2 = Path.of("docs/images/logo.png");

Path relative = p1.relativize(p2);
System.out.println(relative);
```

```bash
../images/logo.png
```

Interpretation: from `docs/manual`, go up one level, then into `images/logo.png`.

### 4. Absolute Paths Example

Absolute paths work exactly the same way.

```java
Path base = Path.of("/home/user/projects");
Path target = Path.of("/home/user/docs/readme.txt");

Path relative = base.relativize(target);
System.out.println(relative);
```

```bash
../../docs/readme.txt
```

> [!NOTE]
> The common prefix (here `/home/user`) is removed before computing the `..` segments.

### 5. Using `resolve` to Verify the Result

A key property of `relativize` is this identity:

```text
base.resolve(base.relativize(target)).equals(target)
```

```java
Path base = Path.of("/a/b/c");
Path target = Path.of("/a/d/e");

Path r = base.relativize(target);
System.out.println(r); // ../../d/e
System.out.println(base.resolve(r)); // /a/d/e
```

> [!NOTE]
> This identity is frequently tested in certification questions.

### 6. Mixing Absolute and Relative Paths (ERROR CASE)

This is one of the most common mistakes.

```java
Path abs = Path.of("/a/b");
Path rel = Path.of("c/d");

abs.relativize(rel); // throws exception
```

```bash
Exception in thread "main" java.lang.IllegalArgumentException
```

> [!NOTE]
> `relativize` does NOT attempt to convert paths to absolute automatically.

### 7. Different Roots (Windows-Specific Trap)

On Windows, paths with different drive letters cannot be relativized.

```java
Path p1 = Path.of("C:\data\a");
Path p2 = Path.of("D:\data\b");

p1.relativize(p2); // IllegalArgumentException
```

> [!NOTE]
> On Unix-like systems, the root is always `/`, so this issue does not occur.

### 8. Relativize vs Normalize

These two methods are often confused but serve different purposes.

Method	Purpose
`relativize`	Compute a path between two paths
`normalize`	Remove `.` and `..` segments

```java
Path p = Path.of("a/b/../c");
System.out.println(p.normalize()); // a/c
```

> [!NOTE]
> `normalize` works on a single path; `relativize` always involves two paths.

### 9. Exam-Oriented Summary

- `relativize` returns a relative path from one path to another
- Both paths must be either absolute or relative
- Paths must share the same root/filesystem
- No filesystem access occurs
- Result can be safely `resolve`d back

> [!NOTE]
> If you see `IllegalArgumentException` in a question, check for mixed absolute/relative paths or different roots.
