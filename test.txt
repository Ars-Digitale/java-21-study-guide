## 14.5 Varargs (Listes d’arguments à longueur variable)

Les varargs permettent à une méthode d’accepter **zéro ou plusieurs** paramètres du même type.

Syntaxe :

```java
void printNames(String... names)
```

Règles :

- Une méthode peut avoir **un seul** paramètre varargs.
- Il doit être le **dernier** paramètre dans la liste.
- Les varargs sont traités comme un **tableau** à l’intérieur de la méthode.

- Exemple :

```java
void show(int x, String... values) {
    System.out.println(values.length);
}

show(10);                     // length = 0
show(10, "A");                // length = 1
show(10, "A", "B", "C");      // length = 3
```

> [!IMPORTANT]
> Les varargs et les tableaux participent à la surcharge des méthodes.
> La résolution de la surcharge peut devenir ambiguë.


## 14.6 Méthodes statiques, variables statiques et initialiseurs statiques

En Java, le mot-clé **`static`** marque des éléments qui **appartiennent à la classe elle-même**, et non aux instances individuelles.
Cela signifie :

- Ils sont **chargés une seule fois** en mémoire lorsque la classe est chargée pour la première fois par la JVM.
- Ils sont partagés entre **toutes les instances**.
- Ils peuvent être accessibles **sans créer d’objet** de la classe.

Les membres statiques sont stockés dans la **method area** de la JVM (mémoire au niveau de la classe), tandis que les membres d’instance vivent dans le **heap**.


### 14.6.1 Variables statiques (Variables de classe)

Une **variable statique** est une variable définie au niveau de la classe et partagée par toutes les instances.

Caractéristiques :

- Créées lorsque la classe est chargée.
- Existent **même si aucune instance** de la classe n’est créée.
- Tous les objets voient la **même valeur**.
- Peuvent être marquées `final`, `volatile` ou `transient`.

- Exemple :

```java
public class Counter {
    static int count = 0;    // partagée par toutes les instances
    int id;                  // variable d’instance

    public Counter() {
        count++;
        id = count;          // chaque instance obtient un id unique
    }
}
```


### 14.6.2 Méthodes statiques

Une **méthode statique** appartient à la classe, et non à une instance d’objet.

Règles :

- Elles peuvent être appelées en utilisant le nom de la classe : `ClassName.method()`.
- Elles **ne peuvent pas** accéder directement aux variables ou méthodes d’instance, mais uniquement via une instance de la classe.
- Elles **ne peuvent pas** utiliser `this` ou `super`.
- Elles sont couramment utilisées pour :
-   - des méthodes utilitaires (ex. `Math.sqrt()`)
-   - des méthodes de fabrique
-   - des comportements globaux qui ne dépendent pas de l’état d’instance

- Exemple :

```java
public class MathUtil {

    static int square(int x) {        // méthode statique
        return x * x;
    }

    void instanceMethod() {
        // System.out.println(count);   // OK : accès à une variable statique
        // square(5);                   // OK : méthode statique accessible
    }
}
```

Erreurs courantes :

```java
// ❌ Erreur de compilation : une méthode d’instance ne peut pas être appelée directement dans un contexte statique
static void go() {
    run();        // run() est une méthode d’instance !
}

void run() { }
```


### 14.6.3 Blocs d’initialisation statique

Les blocs d’initialisation statique permettent d’exécuter du code **une seule fois**, lorsque la classe est chargée.

Syntaxe :

```java
static {
    // logique d’initialisation
}
```

Utilisation :

- initialisation de variables statiques complexes
- exécution d’un setup au niveau de la classe
- exécution de code qui doit être exécuté exactement une fois

- Exemple :

```java
public class Config {

    static final Map<String, String> settings = new HashMap<>();

    static {
        settings.put("mode", "production");
        settings.put("version", "1.0");
        System.out.println("Static initializer executed");
    }
}
```

> [!IMPORTANT]
> Les blocs d’initialisation statique s’exécutent **une seule fois**, dans l’ordre où ils apparaissent, avant `main()` et avant qu’une méthode statique ne soit appelée.


### 14.6.4 Ordre d’initialisation (Statique vs. Instance)

( Se référer au chapitre : [15. Class Loading, Initialization, and Object Construction](class-loading.md) )


### 14.6.5 Accéder aux membres statiques

### 14.6.5.1 Recommandé : utiliser le nom de la classe

```java
Math.sqrt(16);
MyClass.staticMethod();
```


### 14.6.5.2 Aussi légal : via une référence d’instance

```java
MyClass obj = new MyClass();
obj.staticMethod();
```


### 14.6.6 Statique et héritage

Les méthodes statiques :

- peuvent être **masquées**, pas redéfinies
- le binding est **à la compilation**, pas à l’exécution
- sont accessibles selon le **type de la référence**, et non le type de l’objet

- Exemple :

```java
class A {
    static void test() { System.out.println("A"); }
}

class B extends A {
    static void test() { System.out.println("B"); }
}

A ref = new B();
ref.test();   // affiche "A" — binding statique !
```

> [!NOTE]
> Règle clé : les méthodes statiques utilisent le **type de la référence**, et non le type de l’objet.


### 14.6.7 Pièges courants

- Tenter de référencer une variable ou une méthode d’instance depuis un contexte statique.
- Supposer que les méthodes statiques sont redéfinies → elles sont **masquées**.
- Appeler une méthode statique via une référence d’instance (légal mais déroutant).
- Confondre l’ordre d’initialisation des éléments statiques et des éléments d’instance.
- Oublier que les variables statiques sont partagées entre tous les objets.
- Ignorer que les initialiseurs statiques s’exécutent *une seule fois*, dans l’ordre de déclaration.
