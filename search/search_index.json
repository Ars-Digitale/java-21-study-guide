{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Ars Digitale Technical Guides","text":""},{"location":"#volume-i-java-21","title":"Volume I \u2014 Java 21","text":"<p>Version 1.0 \u2014 February 2026</p> <p>Publisher: Ars Digitale</p> <p>This guide is part of the Ars Digitale Technical Guides series \u2014 a structured collection of engineering-focused references.</p> <p>The Java 21 volume provides a modular, concept-driven overview of the language and core APIs, designed for engineers who prefer clarity, structure, and long-term understanding.</p> <p></p>"},{"location":"#choose-your-language","title":"\ud83c\udf0d Choose your language","text":"<ul> <li>\ud83c\uddec\ud83c\udde7 English \u2192 English Edition</li> <li>\ud83c\uddee\ud83c\uddf9 Italiano \u2192 Edizione Italiana</li> <li>\ud83c\uddeb\ud83c\uddf7 Fran\u00e7ais \u2192 \u00c9dition Fran\u00e7aise</li> </ul> <p>\u00a9 2026 Ars Digitale</p>"},{"location":"en/","title":"Index","text":"<p>\ud83c\udf0d Language: English | Italiano | Fran\u00e7ais</p>"},{"location":"en/#course-index-java-21","title":"Course Index (Java 21)","text":"<p>This index provides the complete English (EN) curriculum for the Java 21 Study Guide.</p> <p>Modules are designed to be read sequentially, but each topic can also be used as a standalone reference.</p> <p></p>"},{"location":"en/#module-00-prerequisites-setup","title":"Module 00 \u2014 Prerequisites &amp; Setup","text":"<ul> <li>Prerequisite material</li> <li>Eclipse shortcuts</li> </ul>"},{"location":"en/#module-01-java-language-basics","title":"Module 01 \u2014 Java Language Basics","text":"<ul> <li>Syntax building blocks</li> <li>Basic language building blocks</li> <li>Java naming rules</li> <li>Java data types and casting</li> <li>Java operators</li> <li>Instantiating types</li> </ul>"},{"location":"en/#module-02-control-flow","title":"Module 02 \u2014 Control Flow","text":"<ul> <li>Control flow statements</li> <li>Loops</li> </ul>"},{"location":"en/#module-03-core-standard-apis","title":"Module 03 \u2014 Core Standard APIs","text":"<ul> <li>Strings in Java</li> <li>Arrays in Java</li> <li>Math utilities</li> <li>Dates and time</li> <li>Formatting and localization</li> </ul>"},{"location":"en/#module-04-object-oriented-fundamentals","title":"Module 04 \u2014 Object-Oriented Fundamentals","text":"<ul> <li>Methods, attributes, and variables</li> <li>Class loading, initialization, and object construction</li> <li>Inheritance</li> <li>Beyond classes</li> <li>Generics in Java</li> <li>Exceptions and error handling</li> </ul>"},{"location":"en/#module-05-functional-programming","title":"Module 05 \u2014 Functional Programming","text":"<ul> <li>Functional programming in Java</li> <li>Java streams</li> </ul>"},{"location":"en/#module-06-collections-framework","title":"Module 06 \u2014 Collections Framework","text":"<ul> <li>Introduction to the collections framework</li> <li>Shared collection operations and equality</li> <li>Sorting and comparing</li> <li>List APIs</li> <li>Set APIs</li> <li>Queue and deque APIs</li> <li>Map APIs</li> <li>Sequenced collections</li> </ul>"},{"location":"en/#module-07-concurrency-and-threads","title":"Module 07 \u2014 Concurrency and Threads","text":"<ul> <li>Thread fundamentals</li> <li>Concurrency APIs</li> </ul>"},{"location":"en/#module-08-java-io-and-nio","title":"Module 08 \u2014 Java I/O and NIO","text":"<ul> <li>Files and paths fundamentals</li> <li>Files and paths APIs</li> <li>Java I/O streams</li> <li>I/O streams APIs</li> <li>Interacting with the user</li> </ul>"},{"location":"en/#module-09-java-platform-module-system-jpms","title":"Module 09 \u2014 Java Platform Module System (JPMS)","text":"<ul> <li>JPMS fundamentals</li> <li>Compiling, packaging, and running modules</li> <li>Services in JPMS</li> </ul>"},{"location":"en/module-00/eclipse-shortcuts/","title":"Eclipse main shortcuts","text":"WIN APPLE DESCRIPTION <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + 3</code> <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + 3</code> Go to quick access search for available views, actions, wizards, menus and more <code>&lt;kbd&gt;Alt&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + Q Q</code> <code>&lt;kbd&gt;\u2325&lt;/kbd&gt; + &lt;kbd&gt;\u2318&lt;/kbd&gt; + Q Q</code> Show all available views and select one or more to open <code>F2</code> <code>F2</code> Show Javadoc for the selected element <code>F3 or &lt;kbd&gt;Ctrl&lt;/kbd&gt; + Left click</code> <code>F3 or &lt;kbd&gt;\u2318&lt;/kbd&gt; + Left click</code> In a code editor, go to the declaration of the selected symbol <code>F4</code> <code>F4</code> Show selected symbol in the \u201cType Hierarchy\u201d view <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + T</code> <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + T</code> Open dialog to search for a type (class, interface, enum) <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + Alt + H</code> <code>^ + &lt;kbd&gt;\u2325&lt;/kbd&gt; + H</code> Open selected callable symbol in the \u201cCall Hierarchy\u201d view <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + G</code> <code>&lt;kbd&gt;\u21e7&lt;/kbd&gt; + &lt;kbd&gt;\u2318&lt;/kbd&gt; + G</code> Search workspace for all references to the symbol <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + R</code> <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + R</code> Open dialog to search resources (e.g. text files) by filename <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + F</code> <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + F</code> Find/replace in the current file <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + H</code> <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + H</code> Find/replace in current file, project, or workspace <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + L</code> <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + L</code> Go to a line number <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + .</code> <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + .</code> Jump to next occurrence, warning or error <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + ,</code> <code>&lt;kbd&gt;\u21e7&lt;/kbd&gt; + &lt;kbd&gt;\u2318&lt;/kbd&gt; + .</code> Jump to previous occurrence, warning or error <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + D</code> <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + D</code> Delete line at cursor position <code>&lt;kbd&gt;Alt&lt;/kbd&gt; + \u2191</code> or <code>&lt;kbd&gt;Alt&lt;/kbd&gt; + \u2193</code> <code>&lt;kbd&gt;\u2325&lt;/kbd&gt; + \u2191</code> or <code>&lt;kbd&gt;\u2325&lt;/kbd&gt; + \u2193</code> Move current line one line above or one line below <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + Space</code> <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + Space</code> Open content assist dialog (based on current context) <code>Type \"main\", \"if\", \"for\", \"while\", \"do\", \"syso\" + &lt;kbd&gt;Ctrl&lt;/kbd&gt; + Space</code> (same as before) +  <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + Space</code> Autocomplete element <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + F</code> Format code <code>&lt;kbd&gt;Alt&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + Z</code> <code>&lt;kbd&gt;\u2325&lt;/kbd&gt; + &lt;kbd&gt;\u2318&lt;/kbd&gt; + Z</code> Toggle Try Catch and other predefined blocks of code <code>&lt;kbd&gt;Alt&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + A</code> <code>&lt;kbd&gt;\u2325&lt;/kbd&gt; + &lt;kbd&gt;\u2318&lt;/kbd&gt; + A</code> Toggle block / column selection in the current text editor <code>&lt;kbd&gt;Alt&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + R</code> <code>&lt;kbd&gt;\u2325&lt;/kbd&gt; + &lt;kbd&gt;\u2318&lt;/kbd&gt; + R</code> Rename (variable, field, method, class...) <code>&lt;kbd&gt;Alt&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + S</code> <code>&lt;kbd&gt;\u2325&lt;/kbd&gt; + &lt;kbd&gt;\u2318&lt;/kbd&gt; + S</code> Show advanced editing operations for current selection <code>&lt;kbd&gt;Alt&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + T</code> <code>&lt;kbd&gt;\u2325&lt;/kbd&gt; + &lt;kbd&gt;\u2318&lt;/kbd&gt; + T</code> Show available refactoring operations for current selection <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + 1</code> <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + 1</code> Show all possible fixes for a problem (on a text element with a problem marker, or in the problem view) <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + C</code> <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + /</code> Add/Remove line comment <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + /</code> <code>^ + &lt;kbd&gt;\u2318&lt;/kbd&gt; + /</code> Add/Remove block line comment"},{"location":"en/module-00/prerequisites/","title":"Prerequisite material for the course","text":"<p>This is all the prerequisite material you will need for the course</p> <p></p>"},{"location":"en/module-00/prerequisites/#documentation","title":"DOCUMENTATION","text":"<ul> <li>Java 21 APIs -  Java 21 API Specification</li> <li>Eclipse shortcuts - Eclipse IDE shortcuts</li> </ul>"},{"location":"en/module-00/prerequisites/#editor","title":"EDITOR","text":"<ul> <li>Eclipse IDE - Download Eclipse here</li> </ul>"},{"location":"en/module-00/prerequisites/#pandoc","title":"PANDOC","text":"<ul> <li>Pandoc - Download Pandoc here</li> </ul>"},{"location":"en/module-01/basic-building-blocks/","title":"2. Basic Language Java Building Blocks","text":""},{"location":"en/module-01/basic-building-blocks/#table-of-contents","title":"Table of Contents","text":"<ul> <li>2.1 Class Definition</li> <li>2.2 Comments</li> <li>2.3 Access Modifiers</li> <li>2.4 Packages<ul> <li>2.4.1 Organization and Purpose</li> <li>2.4.2 Mapping with the File System and Declaration of a Package</li> <li>2.4.3 Belonging to the Same Package</li> <li>2.4.4 Importing from a Package</li> <li>2.4.5 Static Imports<ul> <li>2.4.5.1 Precedence Rules</li> </ul> </li> <li>2.4.6 Standard vs. User-Defined Packages</li> </ul> </li> <li>2.5 The main Method<ul> <li>2.5.1 main Method Signature</li> </ul> </li> <li>2.6 Compiling and Running Your Code<ul> <li>2.6.1 Compiling One File, Default Package (Single Directory)</li> <li>2.6.2 Multiple Files, Default Package (Single Directory)</li> <li>2.6.3 Code Inside Packages (standard src \u2192 out layout)</li> <li>2.6.4 Compiling to Another Directory (-d)</li> <li>2.6.5 Multiple Files Across Packages (Compile Whole Source Tree)</li> <li>2.6.6 Single-File Source Execution (Quick Runs Without javac)</li> <li>2.6.7 Passing Parameters to a Java Program</li> </ul> </li> </ul> <p>This chapter introduces the essential structural elements of a Java program: <code>classes</code>, <code>methods</code>, <code>comments</code>, <code>access modifiers</code>, <code>packages</code>, the <code>main</code> method, and the basic command-line tools (<code>javac</code> and <code>java</code>).</p> <p>These are the minimum essential components required to write, compile, organize, and execute Java code using the JDK (Java Development Kit) \u2014 without the use of any IDE (Integrated Development Environment).</p> <p></p>"},{"location":"en/module-01/basic-building-blocks/#21-class-definition","title":"2.1 Class definition","text":"<p>A Java <code>class</code> is the fundamental building block of a Java program.</p> <p>A <code>class</code> represents a user-defined data type, composed of a set of internal data (<code>fields</code>) and the operations that can act upon them (<code>methods</code>).</p> <p>A <code>class</code> is a blueprint, while <code>objects</code> are concrete instances created at runtime.</p> <p>A Java class is composed of two main elements, known as its members:</p> <ul> <li>Fields (or variables): they represent the data that define the state of this newly created type.</li> <li>Methods (or functions): they represent the operations that can be performed on this data.</li> </ul> <p>Some members can be declared with the keyword static.</p> <p>A static member belongs to the class itself, not to the objects created from it.</p> <p>This means that:</p> <ul> <li>there is only one shared copy across all instances</li> <li>it can be used without creating an object of the class</li> <li>it is loaded into memory when the class is loaded by the JVM</li> </ul> <p>Non-static members (called instance members) instead belong to individual objects, and each instance has its own copy.</p> <p>Normally, each class is defined in its own \".java\" file; for example, a class named Person will be defined in the corresponding file Person.java.</p> <p>Any class that is independently defined in its own source file is called a top-level class.</p> <p>Such a class can only be declared as <code>public</code> or <code>package-private</code> (i.e., with no access modifier).</p> <p>A single file, however, may contain more than one class definition. In this case, only one class can be declared public, and the file name must match that class. </p> <p>Nested class, which are classes declared inside another class, can declare any access modifier: <code>public</code>, <code>protected</code>, <code>private</code>, <code>default</code> (package-private).</p> <ul> <li>Example:</li> </ul> <pre><code>public class Person {\n\n    // This is a comment: explains the code but is ignored by the compiler. See section below.\n\n    // Field \u2192 defines data/state\n    String personName;\n\n    // Method \u2192 defines behavior (this one take a parameter, newName, in input but does not return a value)\n    void setPersonName(String newName) {\n        personName = newName;\n    }\n\n    // Method \u2192 defines behavior  (this one does not take parameters in input but does return a String)\n    String getPersonName(){\n        return personName;\n    }\n}\n</code></pre> <p>Note</p> <p>In its simplest form, we could theoretically have a class with no methods and no fields. Although such a class would compile, it would hardly make much sense.</p> Token / Identifier Category Meaning Optional? public Keyword / access modifier determines which other classes can use or see that element Mandatory (when absent is, by default, package-private) class Keyword Declares a class type. Mandatory Person Class name (identifier) The name of the class. Mandatory personName Field name (identifier) Stores the name of the person. Optional String Type / Keyword Type of the field <code>personName</code> and of the parameter <code>newName</code>. Mandatory setPersonName, getPersonName Method names (identifier) name a behavior of the class. Optional newName Parameter name (identifier) input passed to the method <code>setPersonName</code>. Mandatory (if the method needs a parameter) return Keyword Exits a method and gives back a value. Mandatory (in methods with a non-void return type) void Return Type / Keyword Indicates the method does not return a value. Mandatory (if the method does not return a value) <p>Note</p> <p>Mandatory = required by Java syntax, Optional = not required by syntax; depends on design. </p> <p></p>"},{"location":"en/module-01/basic-building-blocks/#22-comments","title":"2.2 Comments","text":"<p>Comments are not executable code: they explain the code but are ignored by the compiler.</p> <p>In Java there are 3 types of comments: - Single-line (<code>//</code>) - Multi-line (<code>/* ... */</code>) - Javadoc (<code>/** ... */</code>)</p> <p>A single-line comment starts with 2 slashes: all the text after that, on the same line, is ignored by the compiler.</p> <ul> <li>Example:</li> </ul> <pre><code>// This is a single-line comment. It starts with 2 slashes and ends at the end of the line. \n</code></pre> <p>A multiline comment includes anything between the symbols / and /.</p> <ul> <li>Example:</li> </ul> <pre><code>/*  \n* This is a multi-line comment.\n* It can span multiple lines.\n* All the text between its opening and closing symbols is ignored by the compiler.\n*\n*/\n</code></pre> <p>A Javadoc comment is similar to a multiline comment, except it starts with /**: all the text between its opening and closing symbols is processed by the Javadoc tool to generate API documentation.</p> <pre><code>/**\n * This is a Javadoc comment\n *\n * This class represents a Person.\n * It stores a name and provides methods\n * to set and retrieve it.\n *\n * &lt;p&gt;Javadoc comments can include HTML tags,\n * and special annotations like @param and @return.&lt;/p&gt;\n */\n</code></pre> <p>Warning</p> <p>In Java, every block comment must be properly closed with */.</p> <ul> <li>Example:</li> </ul> <pre><code>/* valid block comment */\n</code></pre> <p>is fine, but</p> <pre><code>/* */ */\n</code></pre> <p>will cause a compilation error because, while the first two symbols are part of the comment, the last symbol don't. The extra symbol <code>*/</code> is not valid syntax then and the compiler will complain. </p> <p></p>"},{"location":"en/module-01/basic-building-blocks/#23-access-modifiers","title":"2.3 Access modifiers","text":"<p>In Java, an access modifier is a keyword that specifies the visibility (or accessibility) of a class, method, or field. It determines which other classes can use or see that element.</p> <p>Note</p> <p>Table of the access modifiers available in Java</p> Token / Identifier Category Meaning Optional? public Keyword / access modifier Visible from any class in any package Yes no modifier (default) Keyword / access modifier Visible only within the same package Yes protected Keyword / access modifier Visible within the same package and by subclasses (even in other packages) Yes private Keyword / access modifier Visible only within the same class Yes <p>Tip</p> <p>private &gt; default &gt; protected &gt; public Think \u201cvisibility grows outward\u201d.</p> <p></p>"},{"location":"en/module-01/basic-building-blocks/#24-packages","title":"2.4 Packages","text":"<p>Java packages are logical groupings of classes, interfaces, and sub-packages. They help organize large codebases, avoid name conflicts, and provide controlled access between different parts of an application.</p> <p></p>"},{"location":"en/module-01/basic-building-blocks/#241-organization-and-purpose","title":"2.4.1 Organization and Purpose","text":"<ul> <li>Naming of packages follow the same rules of variable names. see: Java Naming Rules</li> <li>Packages are like folders for your Java source code.  </li> <li>They let you group related classes together (e.g., all utility classes in <code>java.util</code>, all networking classes in <code>java.net</code>).  </li> <li>By using packages, you can prevent naming conflicts: for example, you may have two classes named <code>Date</code>, but one is <code>java.util.Date</code> and another is <code>java.sql.Date</code>.</li> </ul>"},{"location":"en/module-01/basic-building-blocks/#242-mapping-with-the-file-system-and-declaration-of-a-package","title":"2.4.2 Mapping with the File System and declaration of a package","text":"<ul> <li>Packages map directly to the directory hierarchy on your file system.</li> <li>You declare the package at the top of the source file (before any imports).</li> <li> <p>If you do not declare a package, the class belongs to the default package.</p> <ul> <li>This is not recommended for real projects, since it complicates organization and imports.</li> </ul> </li> <li> <p>Example:</p> </li> </ul> <pre><code>package com.example.myapp.utils;\n\npublic class MyApp{\n\n}\n</code></pre> <p>Important</p> <p>This declaration means the class must be located in the directory: com/example/myapp/utils/MyApp.java</p> <p></p>"},{"location":"en/module-01/basic-building-blocks/#243-belonging-to-the-same-package","title":"2.4.3 Belonging to the Same Package","text":"<p>Two classes belong to the same package if and only if:</p> <ul> <li>They are declared with the same package statement at the top of their source file.</li> <li> <p>They are placed in the same directory of the source hierarchy.</p> </li> <li> <p>Example:</p> </li> </ul> <p>A class in package A.B.C; belongs to A.B.C only, not to A.B. Classes in A.B cannot directly access package-private members of classes in A.B.C, because they are different packages.</p> <p>Classes in the same package:</p> <ul> <li>Can access each other\u2019s package-private members (i.e., members without an access modifier).</li> <li>Share the same namespace, so you don\u2019t need to import them to use them.  </li> </ul> <p>Example: Two files in the same package</p> <pre><code>// File: src/com/example/tools/Tool.java\npackage com.example.tools;\n\npublic class Tool {\n    static void hello() { System.out.println(\"Hi!\"); }\n}\n</code></pre> <pre><code>// File: src/com/example/tools/Runner.java\npackage com.example.tools;\n\npublic class Runner {\n    public static void main(String[] args) {\n        Tool.hello();    // OK: same package, no import needed\n    }\n}\n</code></pre> <p></p>"},{"location":"en/module-01/basic-building-blocks/#244-importing-from-a-package","title":"2.4.4 Importing from a Package","text":"<p>To use classes from another package, you need to import them:</p> <ul> <li>Example:</li> </ul> <pre><code>import java.util.List;       // imports a specific class\nimport java.util.*;          // imports all classes in java.util\n\nimport java.nio.file.*.*     // ERROR! only one wildcard is allowed and it must be at the end!\n</code></pre> <p>Note</p> <p>The wildcard character  *  imports all types in the package but not its subpackages.</p> <p>You can always use the fully qualified name instead of importing all the classes in that package:</p> <pre><code>java.util.List myList = new java.util.ArrayList&lt;&gt;();\n</code></pre> <p>Note</p> <p>If you explicitely import a class name, it takes precedence over any wildcard import; if you want two use two class with the same name (ex. <code>Date</code> from java.util and from java.sql), it is better to use a fully qualified name import.</p> <p></p>"},{"location":"en/module-01/basic-building-blocks/#245-static-imports","title":"2.4.5 Static imports","text":"<p>In addition to importing classes from a package, Java allows another kind of import: the static import.</p> <p>A static import lets you import static members of a class \u2014 such as static methods and static variables \u2014 so you can use them without referencing the class name.</p> <p>You may import either specific static members or use a wildcard to import all static members of a class.</p> <p>Example \u2014 Specific Static Import</p> <pre><code>import static java.util.Arrays.asList;   // Imports Arrays.asList()\n\npublic class Example {\n\n    List&lt;String&gt; arr = asList(\"first\", \"second\");\n    // We can call asList() directly, without using Arrays.asList()\n}\n</code></pre> <p>Example \u2014 Static Import of a Constant</p> <pre><code>import static java.lang.Math.PI;\nimport static java.lang.Math.sqrt;\n\npublic class Circle {\n    double radius = 3;\n\n    double area = PI * radius * radius;\n    double diagonal = sqrt(2); \n}\n</code></pre> <p>Example \u2014 Wildcard Static Import</p> <pre><code>import static java.lang.Math.*;\n\npublic class Calculator {\n    double x = sqrt(49);   // 7.0\n    double y = max(10, 20); \n    double z = random();   // calls Math.random()\n}\n</code></pre> <p>Wildcard static imports behave exactly like normal wildcard imports: they bring all static members of the class into scope.</p> <p>Warning</p> <p>You can always call a static member with the class name: <code>Math.sqrt(16)</code> always works \u2014 even if imported statically.</p> <p></p>"},{"location":"en/module-01/basic-building-blocks/#2451-precedence-rules","title":"2.4.5.1 Precedence Rules","text":"<p>If the current class already declares a method or variable with the same name as the statically imported one:</p> <ul> <li>The local member takes precedence.</li> <li>The imported static member is shadowed.</li> </ul> <p>Example:</p> <pre><code>import static java.lang.Math.max;\n\npublic class Test {\n\n    static int max(int a, int b) {   // local version\n        return a &gt; b ? a : b;\n    }\n\n    void run() {\n        System.out.println(max(2, 5));  \n        // Calls the LOCAL max(), not Math.max()\n    }\n}\n</code></pre> <p>Warning</p> <ul> <li>A static import must follow the exact syntax: <code>import static</code>.</li> <li>The compiler forbids importing two static members with the same simple name if it creates ambiguity \u2014 even if they come from different classes or packages.</li> </ul> <p>Example \u2014 Not allowed:</p> <pre><code>import static java.util.Collections.emptyList;\nimport static java.util.List.of;\n\n// \u274c ERROR: both methods have the same name `of()`\nimport static java.util.Set.of;\n</code></pre> <p>The compiler does not know which <code>of()</code> you intend to call \u2192 compilation fails.</p> <p>Tip</p> <ul> <li>If two static imports introduce the same name, any attempt to use that name causes a compile error.</li> <li>Static imports do not import classes, only static members.</li> <li>You can still call the static member using the class name even if statically imported.</li> </ul> <p>Example:</p> <pre><code>import static java.lang.Math.sqrt;\n\ndouble a = sqrt(16);        // imported\ndouble b = Math.sqrt(25);   // fully qualified \u2014 always allowed\n</code></pre> <p></p>"},{"location":"en/module-01/basic-building-blocks/#246-standard-vs-user-defined-packages","title":"2.4.6 Standard vs. User-Defined Packages","text":"<p>Standard packages: shipped with the JDK (e.g., java.lang, java.util, java.io).</p> <p>User-defined packages: created by developers to organize application code.</p> <p></p>"},{"location":"en/module-01/basic-building-blocks/#25-the-main-method","title":"2.5 The <code>main</code> Method","text":"<p>In Java, the <code>main</code> method serves as the entry point of a standalone application. Its correct declaration is critical for the JVM to recognize it:</p> <p></p>"},{"location":"en/module-01/basic-building-blocks/#251-main-method-signature","title":"2.5.1 <code>main</code> method signature","text":"<p>Let's review the <code>main</code> method signature inside two of the simplest possible classes:</p> <ul> <li>Example: without optional modifiers</li> </ul> <pre><code>public class MainFirstExample {\n\n    public static void main(String[] args){\n\n        System.out.print(\"Hello World!!\");\n\n    }\n\n}\n</code></pre> <ul> <li>Example: with both, optional, <code>final</code> modifiers</li> </ul> <pre><code>public class MainSecondExample {\n\n    public final static void main(final String options[]){\n\n        System.out.print(\"Hello World!!\");\n\n    }\n\n}\n</code></pre> <p>Note</p> <p>Table of the access modifiers for the main method</p> Token / Identifier Category Meaning Optional? public Keyword / Access Modifier Makes the method accessible from anywhere. Required so the JVM can call it from outside the class. Mandatory static Keyword Means the method belongs to the class itself and can be called without creating an object. Required because the JVM has no object instance when starting the program. Mandatory final (before return type) Modifier Prevents the method from being overridden. It can legally appear before the return type, but it has no effect on <code>main</code> and is not required. Optional main Method name (predefined) The exact name that the JVM looks for as the entry point of the program. Must be spelled exactly as <code>main</code> (lowercase). Mandatory void Return Type / Keyword Declares that the method does not return any value to the JVM. Mandatory String[] args Parameter list An array of <code>String</code> values that holds the command-line arguments passed to the program. May also be written as <code>String args[]</code> or <code>String... args</code>. The parameter name (<code>args</code>) is arbitrary. Mandatory (the parameter type is required, but the name can vary) final (in parameter) Modifier Marks the parameter as unchangeable inside the method body (you cannot reassign <code>args</code> to another array). Optional <p>Important</p> <p>Modifiers <code>public</code>, <code>static</code> (mandatory) and <code>final</code> (if present) can be swapped in order;  <code>public</code> and <code>static</code> can't be omitted.</p> <p>Java treats <code>String[] args</code> and <code>String... args</code> the same. Both compile and run correctly as entry points.</p> <p></p>"},{"location":"en/module-01/basic-building-blocks/#26-compiling-and-running-your-code","title":"2.6 Compiling and running your code","text":"<p>This chapter shows correct, working <code>javac</code> and <code>java</code> command lines for common situations in Java 21: single files, multiple files, packages, separate output directories, and classpath/module-path usage. </p> <p>Follow the directory layouts exactly.</p> <p>check your tools</p> <pre><code>javac -version   # should print: javac 21.x\njava  -version   # should print: java version \"21.0.7\" ... (the output could be different depending on the implementation of the jvm you installed)\n</code></pre> <p>Warning</p> <p>When running a class inside a package, java requires the fully qualified name, NEVER the path:</p> <p><code>java com.example.app.Main</code> \u2714</p> <p><code>java src/com/example/app/Main</code> \u274c</p> <p></p>"},{"location":"en/module-01/basic-building-blocks/#261-compiling-one-file-default-package-single-directory","title":"2.6.1 Compiling one file, default package (single directory)","text":"<p>Files <pre><code>.\n\u2514\u2500\u2500 Hello.java\n</code></pre></p> <p>Hello.java <pre><code>public class Hello {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, Java 21!\");\n    }\n}\n</code></pre></p> <p>Compile (in the same directory) <pre><code>javac Hello.java\n</code></pre></p> <p>This command will create, in the same directory, a file with the same name of your \".java\" file but with \".class\" filename extension ; this is the bytecode file which will be interpreted and compiled by the jvm.</p> <p>Once you have the .class file, in this case Hello.class, you can run the program with:</p> <p>Run <pre><code>java Hello\n</code></pre></p> <p>Important</p> <p>You don't have to specify the \".class\" extension when executing the program</p> <p></p>"},{"location":"en/module-01/basic-building-blocks/#262-multiple-files-default-package-single-directory","title":"2.6.2 Multiple files, default package (single directory)","text":"<p>Files <pre><code>.\n\u251c\u2500\u2500 A.java\n\u2514\u2500\u2500 B.java\n</code></pre></p> <p>Compile everything <pre><code>javac *.java\n</code></pre></p> <p>Or, if the classes belong to a specific package:</p> <pre><code>javac packagex/*.java\n</code></pre> <p>Or, specifying each of them</p> <p><pre><code>javac A.java B.java\n</code></pre> and</p> <pre><code>javac packagex/A.java packagey/B.java\n</code></pre> <p>Run the entry point: The class which has a <code>main</code> method <pre><code>java A    # if A has main(...)\n# or\njava B\n</code></pre></p> <p>Important</p> <p>The path to your classes is, in Java, the classpath. You can specify the classpath with one of the following options:</p> <ul> <li>-cp <code>&lt;classpath&gt;</code></li> <li>-classpath <code>&lt;classpath&gt;</code></li> <li>--class-path <code>&lt;classpath&gt;</code></li> </ul> <p></p>"},{"location":"en/module-01/basic-building-blocks/#263-code-inside-packages-standard-src-out-layout","title":"2.6.3 Code inside packages (standard src \u2192 out layout)","text":"<p>Files <pre><code>.\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 com/\n\u2502       \u2514\u2500\u2500 example/\n\u2502           \u2514\u2500\u2500 app/\n\u2502               \u2514\u2500\u2500 Main.java\n\u2514\u2500\u2500 out/\n</code></pre></p> <p>Note</p> <p>The <code>src</code> and <code>out</code> folders are not part of our packages, being only the directory containing all our source files and the compiled .class files;</p> <p>Main.java <pre><code>package com.example.app;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Packages done right.\");\n    }\n}\n</code></pre></p> <p>Compile to the same directory <pre><code># Creates .class file just beside the source file\njavac src/com/example/app/Main.java\n</code></pre></p> <p></p>"},{"location":"en/module-01/basic-building-blocks/#264-compiling-to-another-directory-d","title":"2.6.4 Compiling to another directory (<code>-d</code>)","text":"<p><code>-d out</code> places compiled <code>.class</code> files into the <code>out/</code> directory, creating package subfolders that mirror your <code>package</code> names:</p> <pre><code>javac -d out -sourcepath src src/com/example/app/Main.java\n</code></pre> <p>Run (use the classpath to point at out/) <pre><code># Unix/macOS\njava -cp out com.example.app.Main\n\n# Windows\njava -cp out com.example.app.Main\n</code></pre></p> <p></p>"},{"location":"en/module-01/basic-building-blocks/#265-multiple-files-across-packages-compile-whole-source-tree","title":"2.6.5 Multiple files across packages (compile whole source tree)","text":"<p>Files <pre><code>.\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 com/\n\u2502       \u2514\u2500\u2500 example/\n\u2502           \u251c\u2500\u2500 util/\n\u2502           \u2502   \u2514\u2500\u2500 Utils.java\n\u2502           \u2514\u2500\u2500 app/\n\u2502               \u2514\u2500\u2500 Main.java\n\u2514\u2500\u2500 out/\n</code></pre></p> <p>Compile entire source tree to <code>out/</code> <pre><code># Option A: point javac at the top package(s)\njavac -d out   src/com/example/util/Utils.java   src/com/example/app/Main.java\n\n# Option B: use -sourcepath to let javac find dependencies\njavac -d out -sourcepath src   src/com/example/app/Main.java\n</code></pre></p> <p>Important</p> <p>-sourcepath <code>&lt;sourcepath&gt;</code> tells <code>javac</code> where to look for other <code>.java</code> files that a given source depends on.</p> <p></p>"},{"location":"en/module-01/basic-building-blocks/#266-single-file-source-execution-quick-runs-without-javac","title":"2.6.6 Single-file source execution (quick runs without <code>javac</code>)","text":"<p>Java 21 (since Java 11) lets you run small programs directly from source:</p> <pre><code># Default package only\njava Hello.java\n</code></pre> <p>Multiple source files are allowed if they\u2019re in the default package and in the same directory:</p> <pre><code>java Main.java Helper.java\n</code></pre> <p>If you use packages, prefer compiling to <code>out/</code> and running with <code>-cp</code>.</p> <p></p>"},{"location":"en/module-01/basic-building-blocks/#267-passing-parameters-to-a-java-program","title":"2.6.7 Passing Parameters to a Java program","text":"<p>You can send data to your Java program through the parameters of the <code>main</code> entry point.</p> <p>As we learned before, the <code>main</code> method can receive an array of strings in the form: String[] args. See the section on main.</p> <p>Main.java printing out two parameters received in input by the \"main\" method:  <pre><code>package com.example.app;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(args[0]);\n        System.out.println(args[1]);\n    }\n}\n</code></pre></p> <p>To pass parameters, just type (for example):</p> <pre><code>java Main.java Hello World  #spaces are used to separate the two arguments\n</code></pre> <p>If you want to pass an argument containing spaces, just use quotes:</p> <pre><code>java Main.java Hello \"World Mario\" #space are used to separate the two arguments\n</code></pre> <p>If you declare to use (in this case print) the first two element of the parameter's array (as in our previous example) but, in fact, you pass less arguments, the jvm will notify you of a problem through a <code>java.lang.ArrayIndexOutOfBoundsException</code>.</p> <p>If, on the other hand, you pass more arguments than the method expects, it will print out just the two (in this case) expected. </p> <p><code>args.length</code> tells you how many arguments were provided.</p>"},{"location":"en/module-01/data-types/","title":"4. Java Data Types and Casting","text":""},{"location":"en/module-01/data-types/#table-of-contents","title":"Table of Contents","text":"<ul> <li>4.1 Primitive Types</li> <li>4.2 Reference Types</li> <li>4.3 Primitive Types Table</li> <li>4.4 Notes</li> <li>4.5 Recap</li> <li>4.6 Arithmetic and Primitive Numeric Promotion<ul> <li>4.6.1 Numeric Promotion Rules in Java<ul> <li>4.6.1.1 Rule 1 \u2013 Mixed Data Types \u2192 Smaller type promoted to larger type</li> <li>4.6.1.2 Rule 2 \u2013 Integral + Floating-point \u2192 Integral promoted to floating-point</li> <li>4.6.1.3 Rule 3 \u2013 byte short and char are promoted to int during arithmetic</li> <li>4.6.1.4 Rule 4 \u2013 Result type matches the promoted operand type</li> </ul> </li> <li>4.6.2 Summary of Numeric Promotion Behavior<ul> <li>4.6.2.1 Key Takeaways</li> </ul> </li> </ul> </li> <li>4.7 Casting in Java<ul> <li>4.7.1 Primitive Casting<ul> <li>4.7.1.1 Widening Implicit Casting</li> <li>4.7.1.2 Narrowing Explicit Casting</li> <li>4.7.1.3 Compile-Time Implicit Narrowing</li> </ul> </li> <li>4.7.2 Data Loss Overflow and Underflow</li> <li>4.7.3 Casting Values versus Variables</li> <li>4.7.4 Reference Casting Objects<ul> <li>4.7.4.1 Upcasting Widening Reference Cast</li> <li>4.7.4.2 Downcasting Narrowing Reference Cast</li> </ul> </li> <li>4.7.5 Key Points Summary</li> <li>4.7.6 Examples</li> </ul> </li> <li>4.8 Summary</li> </ul> <p>As we saw before in the Syntax Building Blocks, Java has two categories of data types:</p> <ul> <li>Primitive types </li> <li>Reference types</li> </ul> <p>\ud83d\udc49 For a complete overview of primitive types with their sizes, ranges, defaults, and examples, see the Primitive Types Table.</p> <p></p>"},{"location":"en/module-01/data-types/#41-primitive-types","title":"4.1 Primitive Types","text":"<p><code>Primitives</code> represent single raw values stored directly in memory. Each primitive type has a fixed size that determines how many bytes it occupies.</p> <p>Conceptually, a primitive is just a cell in memory holding a value:</p> <pre><code>+-------+\n|  42   |   \u2190 value of type short (2 bytes in memory)\n+-------+\n</code></pre> <p></p>"},{"location":"en/module-01/data-types/#42-reference-types","title":"4.2 Reference Types","text":"<p>A <code>reference</code> type does not hold the <code>object</code> itself, but a reference (pointer) to it. The reference has a fixed size (JVM-dependent, often 4 or 8 bytes), which points to a memory location where the actual object is stored.</p> <ul> <li>Example: a <code>String</code> reference variable points to a string object in the heap, which internally is composed of an array of <code>char</code> primitives.</li> </ul> <p>Diagram:</p> <pre><code>Reference (4 or 8 bytes)\n+---------+\n| address | \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba  Object in Heap\n+---------+                  +-------------------+\n                             |   \"Hello\"         |\n                             | ['H','e','l','l','o']  \u2190 array of char\n                             +-------------------+\n</code></pre> <p></p>"},{"location":"en/module-01/data-types/#43-primitive-types-table","title":"4.3 Primitive Types Table","text":"Keyword Type Size Min Value Max Value Default Value Example <code>byte</code> 8-bit int 1 byte \u2013128 127 0 <code>byte b = 100;</code> <code>short</code> 16-bit int 2 bytes \u201332,768 32,767 0 <code>short s = 2000;</code> <code>int</code> 32-bit int 4 bytes \u20132,147,483,648 (<code>\u20132^31</code>) 2,147,483,647 (<code>2^31\u20131</code>) 0 <code>int i = 123456;</code> <code>long</code> 64-bit int 8 bytes \u20132^63 2^63\u20131 0L <code>long l = 123456789L;</code> <code>float</code> 32-bit FP 4 bytes see note see note 0.0f <code>float f = 3.14f;</code> <code>double</code> 64-bit FP 8 bytes see note see note 0.0 <code>double d = 2.718;</code> <code>char</code> UTF-16 2 bytes <code>'\\u0000'</code> (0) <code>'\\uffff'</code> (65,535) <code>'\\u0000'</code> <code>char c = 'A';</code> <code>boolean</code> true/false JVM-dep. (often 1 byte) <code>false</code> <code>true</code> <code>false</code> <code>boolean b = true;</code>"},{"location":"en/module-01/data-types/#44-notes","title":"4.4 Notes","text":"<p><code>float</code> and <code>double</code> do not have fixed integer bounds like integral types. Instead, they follow the IEEE 754 standard:</p> <ul> <li>Smallest positive nonzero values:  </li> <li><code>Float.MIN_VALUE \u2248 1.4E\u201345</code> </li> <li> <p><code>Double.MIN_VALUE \u2248 4.9E\u2013324</code> </p> </li> <li> <p>Largest finite values:  </p> </li> <li><code>Float.MAX_VALUE \u2248 3.4028235E+38</code> </li> <li><code>Double.MAX_VALUE \u2248 1.7976931348623157E+308</code> </li> </ul> <p>They also support special values: <code>+Infinity</code>, <code>-Infinity</code>, and <code>NaN</code> (Not a Number).</p> <ul> <li>FP = floating point.  </li> <li><code>boolean</code> size is JVM-dependent but behaves logically as <code>true</code>/<code>false</code>.  </li> <li>Default values apply to fields (class variables). Local variables must be explicitly initialized before use.</li> </ul> <p></p>"},{"location":"en/module-01/data-types/#45-recap","title":"4.5 Recap","text":"<ul> <li>Primitive = actual value, stored directly in memory.  </li> <li>Reference = pointer to an object; the object itself may contain primitives and other references.  </li> <li>For details of primitives, see the Primitive Types Table.</li> </ul>"},{"location":"en/module-01/data-types/#46-arithmetic-and-primitive-numeric-promotion","title":"4.6 Arithmetic and Primitive Numeric Promotion","text":"<p>When applying arithmetic or comparison operators to primitive data types, Java automatically converts (or promotes) values to compatible types according to well-defined numeric promotion rules.</p> <p>These rules ensure consistent calculations and prevent data loss when mixing different numeric types.</p> <p></p>"},{"location":"en/module-01/data-types/#461-numeric-promotion-rules-in-java","title":"4.6.1 \ud83d\udd39 Numeric Promotion Rules in Java","text":""},{"location":"en/module-01/data-types/#4611-rule-1-mixed-data-types-smaller-type-promoted-to-larger-type","title":"4.6.1.1 Rule 1 \u2013 Mixed Data Types \u2192 Smaller type promoted to larger type","text":"<p>If two operands belong to different numeric data types, Java automatically promotes the smaller type to the larger type before performing the operation.</p> Example Explanation <code>int x = 10; double y = 5.5;</code><code>double result = x + y;</code> The <code>int</code> value <code>x</code> is promoted to <code>double</code>, so the result is a <code>double</code> (<code>15.5</code>). <p>Valid type promotion order (smallest \u2192 largest): <code>byte \u2192 short \u2192 int \u2192 long \u2192 float \u2192 double</code></p> <p></p>"},{"location":"en/module-01/data-types/#4612-rule-2-integral-floating-point-integral-promoted-to-floating-point","title":"4.6.1.2 Rule 2 \u2013 Integral + Floating-point \u2192 Integral promoted to floating-point","text":"<p>If one operand is an integral type (<code>byte</code>, <code>short</code>, <code>char</code>, <code>int</code>, <code>long</code>) and the other is a floating-point type (<code>float</code>, <code>double</code>), the integral value is promoted to the floating-point type before the operation.</p> Example Explanation <code>float f = 2.5F; int n = 3;</code><code>float result = f * n;</code> <code>n</code> (int) is promoted to <code>float</code>. The result is a <code>float</code> (<code>7.5</code>). <code>double d = 10.0; long l = 3;</code><code>double result = d / l;</code> <code>l</code> (long) is promoted to <code>double</code>. The result is a <code>double</code> (<code>3.333...</code>). <p></p>"},{"location":"en/module-01/data-types/#4613-rule-3-byte-short-and-char-are-promoted-to-int-during-arithmetic","title":"4.6.1.3 Rule 3 \u2013 <code>byte</code>, <code>short</code>, and <code>char</code> are promoted to <code>int</code> during arithmetic","text":"<p>When performing arithmetic with variables (not literal constants) of type <code>byte</code>, <code>short</code>, or <code>char</code>, Java automatically promotes them to <code>int</code>, even if both operands are smaller than <code>int</code>.</p> Example Explanation <code>byte a = 10, b = 20;</code><code>byte c = a + b;</code> \u274c Compile-time error: result of <code>a + b</code> is <code>int</code>, not <code>byte</code>. Must cast \u2192 <code>byte c = (byte)(a + b);</code> <code>short s1 = 1000, s2 = 2000;</code><code>short sum = (short)(s1 + s2);</code> The operands are promoted to <code>int</code>, so explicit casting is required to assign to <code>short</code>. <code>char c1 = 'A', c2 = 2;</code><code>int result = c1 + c2;</code> <code>'A'</code> (65) and <code>2</code> are promoted to <code>int</code>, result = <code>67</code>. <p>Note</p> <p>This rule applies only when using variables. When using constant literals, the compiler can sometimes evaluate the expression at compile time and assign it safely.</p> <pre><code>byte a = 10 + 20;   // \u2705 OK: constant expression fits in byte\nbyte b = 10;\nbyte c = 20;\nbyte d = b + c;     // \u274c Error: b + c is evaluated at runtime \u2192 int\n</code></pre> <p></p>"},{"location":"en/module-01/data-types/#4614-rule-4-result-type-matches-the-promoted-operand-type","title":"4.6.1.4 Rule 4 \u2013 Result type matches the promoted operand type","text":"<p>After promotions are applied, and both operands are of the same type, the result of the expression has that same promoted type.</p> Example Explanation <code>int i = 5; double d = 6.0;</code><code>var result = i * d;</code> <code>i</code> is promoted to <code>double</code>, result is <code>double</code>. <code>float f = 3.5F; long l = 4L;</code><code>var result = f + l;</code> <code>l</code> is promoted to <code>float</code>, result is <code>float</code>. <code>int x = 10, y = 4;</code><code>var div = x / y;</code> Both are <code>int</code>, result = <code>int</code> (<code>2</code>), fractional part truncated. <p>Warning</p> <p>Integer division always produces an integer result. To obtain a decimal result, at least one operand must be floating-point:</p> <pre><code>double result = 10.0 / 4; // \u2705 2.5\nint result = 10 / 4;      // \u274c 2 (fraction discarded)\n</code></pre> <p></p>"},{"location":"en/module-01/data-types/#462-summary-of-numeric-promotion-behavior","title":"4.6.2 \u2705 Summary of Numeric Promotion Behavior","text":"Situation Promotion Result Example Mixing smaller and larger numeric types Smaller type promoted to larger <code>int + double \u2192 double</code> Integral + Floating-point Integral promoted to floating-point <code>long + float \u2192 float</code> <code>byte</code>, <code>short</code>, <code>char</code> arithmetic Promoted to <code>int</code> <code>byte + byte \u2192 int</code> Result after promotion Result matches promoted type <code>float + long \u2192 float</code>"},{"location":"en/module-01/data-types/#4621-key-takeaways","title":"4.6.2.1 \ud83e\udde0 Key Takeaways","text":"<ul> <li>Always consider type promotion when mixing data types in arithmetic.  </li> <li>For smaller types (<code>byte</code>, <code>short</code>, <code>char</code>), promotion to <code>int</code> is automatic when operands of an arithmetic operation containing variables.  </li> <li>Use explicit casting only when you are sure the result fits the target type.  </li> <li>Remember: integer division truncates, floating-point division keeps decimals.  </li> <li>Understanding promotion rules is crucial for avoiding unexpected precision loss or compile-time errors.</li> </ul>"},{"location":"en/module-01/data-types/#47-casting-in-java","title":"4.7 Casting in Java","text":"<p><code>Casting</code> in Java is the process of explicitly converting a value from one type to another. It applies both to <code>primitive types</code> (numbers) and to <code>reference types</code> (objects in a class hierarchy).</p> <p></p>"},{"location":"en/module-01/data-types/#471-primitive-casting","title":"4.7.1 Primitive Casting","text":"<p>Primitive casting changes the type of a numeric value.</p> <p>There are two categories of casting:</p> Type Description Example Explicit? Risk Widening smaller type \u2192 larger type int \u2192 double No no loss Narrowing larger type \u2192 smaller type double \u2192 int Yes possible loss <p></p>"},{"location":"en/module-01/data-types/#4711-widening-implicit-casting","title":"4.7.1.1 Widening Implicit Casting","text":"<p>Automatic conversion from a \u201csmaller\u201d type to a compatible \u201clarger\u201d type. Handled by the compiler, does not require explicit syntax.</p> <pre><code>int i = 100;\ndouble d = i;  // implicit cast: int \u2192 double\nSystem.out.println(d); // 100.0\n</code></pre> <p>\u2705 Safe \u2013 no overflow (though still be aware of floating-point precision).</p> <p></p>"},{"location":"en/module-01/data-types/#4712-narrowing-explicit-casting","title":"4.7.1.2 Narrowing Explicit Casting","text":"<p>Manual conversion from a \u201clarger\u201d type to a \u201csmaller\u201d one. Requires a cast expression because it may cause data loss.</p> <pre><code>double d = 9.78;\nint i = (int) d;  // explicit cast: double \u2192 int\nSystem.out.println(i); // 9 (fraction discarded)\n</code></pre> <p>Warning</p> <p>\u26a0 Use only when you are sure the value fits in the target type.</p> <p></p>"},{"location":"en/module-01/data-types/#4713-compile-time-implicit-narrowing","title":"4.7.1.3 Compile-Time Implicit Narrowing","text":"<p>In some specific cases, the compiler allows a narrowing conversion without an explicit cast.</p> <p>If a variable is declared <code>final</code> and initialized with a constant expression whose value fits into the target type, the compiler can safely perform the conversion at compile time.</p> <pre><code>final int k = 11;\nbyte b = k;  // allowed: value 11 fits into byte range\n\nfinal int x = 200;\nbyte c = x;  // does NOT compile: 200 is outside byte range\n</code></pre> <p>This works because the compiler knows the exact value of a <code>final</code> variable and can verify that it is within the range of the smaller type.</p> <p>This kind of narrowing is allowed between: - <code>byte</code> - <code>short</code> - <code>char</code> - <code>int</code></p> <p>However, it does not apply to: - <code>long</code> - <code>float</code> - <code>double</code></p> <p>For example:</p> <pre><code>final float f = 10.0f;\nint n = f;   // does not compile\n</code></pre> <p>Even though the value seems compatible, floating-point types are not eligible for this form of implicit narrowing.</p> <p></p>"},{"location":"en/module-01/data-types/#472-data-loss-overflow-and-underflow","title":"4.7.2 Data Loss, Overflow and Underflow","text":"<p>When a value exceeds a type\u2019s capacity, you may get:</p> <ul> <li>Overflow: result greater than the maximum representable value</li> <li>Underflow: result lower than the minimum representable value</li> <li> <p>Truncation: data that does not fit is lost (e.g., decimals)</p> </li> <li> <p>Example \u2013 overflow/underflow with int</p> </li> </ul> <pre><code>int max = Integer.MAX_VALUE;\nint overflow = max + 1;     // \"wrap-around\" to negative\n\nint min = Integer.MIN_VALUE;\nint underflow = min - 1;    // \"wrap-around\" to positive\n</code></pre> <ul> <li>Example: truncation</li> </ul> <pre><code>double d = 9.99;\nint i = (int) d; // 9 (fraction discarded)\n</code></pre> <p>Note</p> <p>Floating-point types (<code>float</code>, <code>double</code>) do not wrap: - overflow \u2192 <code>Infinity</code> / <code>-Infinity</code> - underflow (very small values) \u2192 0.0 or denormalized values.</p> <p></p>"},{"location":"en/module-01/data-types/#473-casting-values-versus-variables","title":"4.7.3 Casting Values versus Variables","text":"<p>Java treats:</p> <ul> <li>Integer literals as <code>int</code> by default</li> <li>Floating-point literals as <code>double</code> by default</li> </ul> <p>The compiler does not require a cast when a literal fits within the target type range:</p> <pre><code>byte first = 10;        // OK: 10 fits in byte\nshort second = 9 * 10;  // OK: constant expression evaluated at compile time\n</code></pre> <p>But:</p> <pre><code>long a = 5729685479;    // \u274c error: int literal out of range\nlong b = 5729685479L;   // \u2705 long literal (L suffix)\n\nfloat c = 3.14;         // \u274c double \u2192 float: requires F or cast\nfloat d = 3.14F;        // \u2705 float literal\n\nint e = 0x7FFF_FFFF;    // \u2705 max int in hex\nint f = 0x8000_0000;    // \u274c out of int range (needs L)\n</code></pre> <p>However, when numeric promotion rules apply:</p> <p>With variables of type <code>byte</code>, <code>short</code>, and <code>char</code> in an arithmetic expression, operands are promoted to <code>int</code> and the result is <code>int</code>.</p> <pre><code>byte first = 10;\nshort second = 9 + first;       // \u274c 9 (int literal) + first (byte \u2192 int) = int\n// second = (short) (9 + first);  // \u2705 cast entire expression\n</code></pre> <pre><code>short b = 10;\nshort a = 5 + b;               // \u274c 5 (int) + b (short \u2192 int) = int\nshort a2 = (short) (5 + b);    // \u2705 cast entire expression\n</code></pre> <p>Warning</p> <p>Cast is a unary operator:</p> <p><code>short a = (short) 5 + b;</code> The cast applies only to <code>5</code> \u2192 the expression result remains int \u2192 assignment still fails.</p> <p></p>"},{"location":"en/module-01/data-types/#474-reference-casting-objects","title":"4.7.4 Reference Casting Objects","text":"<p>Casting also applies to object references in a class hierarchy. It does not change the object in memory \u2014 only the reference type used to access it.</p> <p>Key rules:</p> <ul> <li>The real object type determines which fields/methods actually exist.</li> <li>The reference type determines what you may access at that point in code.</li> </ul> <p></p>"},{"location":"en/module-01/data-types/#4741-upcasting-widening-reference-cast","title":"4.7.4.1 Upcasting (Widening Reference Cast)","text":"<p>Conversion from subclass to superclass.</p> <p>Implicit and always safe: every <code>Dog</code> is also an <code>Animal</code>.</p> <pre><code>class Animal { }\nclass Dog extends Animal { }\n\nDog dog = new Dog();\nAnimal a = dog;    // implicit upcast: Dog \u2192 Animal\n</code></pre> <p></p>"},{"location":"en/module-01/data-types/#4742-downcasting-narrowing-reference-cast","title":"4.7.4.2 Downcasting (Narrowing Reference Cast)","text":"<p>Conversion from superclass to subclass.</p> <ul> <li>Explicit</li> <li>Can fail at runtime with <code>ClassCastException</code> if not truly that type</li> </ul> <pre><code>Animal a = new Dog();\nDog d = (Dog) a;   // OK: a really points to a Dog\n\nAnimal x = new Animal();\nDog d2 = (Dog) x;  // \u26a0 Runtime error: ClassCastException\n</code></pre> <p>For safety, use <code>instanceof</code>:</p> <pre><code>if (x instanceof Dog) {\n    Dog safeDog = (Dog) x;   // safe cast\n}\n</code></pre> <p></p>"},{"location":"en/module-01/data-types/#475-key-points-summary","title":"4.7.5 Key Points Summary","text":"Casting Type Applies To Direction Syntax Safe? Performed By Widening Primitive Primitives small \u2192 large Implicit Yes Compiler Narrowing Primitive Primitives large \u2192 small Explicit No Programmer Upcasting Objects subclass \u2192 superclass Implicit Yes Compiler Downcasting Objects superclass \u2192 subclass Explicit Runtime check Programmer"},{"location":"en/module-01/data-types/#476-examples","title":"4.7.6 Examples","text":""},{"location":"en/module-01/data-types/#primitive-casting-short-s-50-int-i-s-widening-byte-b-byte-i-narrowing-possible-loss-object-casting-object-obj-hello-string-str-string-obj-ok-obj-points-to-a-string-object-n-integervalueof10-string-fail-string-n-classcastexception-at-runtime","title":"<pre><code>// Primitive casting\nshort s = 50;\nint i = s;           // widening\nbyte b = (byte) i;   // narrowing (possible loss)\n\n// Object casting\nObject obj = \"Hello\";\nString str = (String) obj; // OK: obj points to a String\n\nObject n = Integer.valueOf(10);\n// String fail = (String) n;  // ClassCastException at runtime\n</code></pre>","text":""},{"location":"en/module-01/data-types/#48-summary","title":"4.8 Summary:","text":"<ul> <li>Primitive casting changes the numeric type.</li> <li>Reference casting changes the \u201cview\u201d of an object in the hierarchy.</li> <li>Upcasting \u2192 safe and implicit.</li> <li>Downcasting \u2192 explicit, to be used carefully (often after <code>instanceof</code>).</li> </ul>"},{"location":"en/module-01/instantiating-types/","title":"6. Instantiating Types","text":""},{"location":"en/module-01/instantiating-types/#table-of-contents","title":"Table of Contents","text":"<ul> <li>6.1 Introduction<ul> <li>6.1.1 Handling Primitive Types<ul> <li>6.1.1.1 Declaring a Primitive</li> <li>6.1.1.2 Assigning a Primitive</li> </ul> </li> <li>6.1.2 Handling Reference Types</li> <li>6.1.2.1 Creating and Assigning a Reference</li> <li>6.1.2.2 Constructors</li> <li>6.1.2.3 Instance Initializer Blocks</li> </ul> </li> <li>6.2 Default Variable Initialization<ul> <li>6.2.1 Instance and Class Variables</li> <li>6.2.2 Final Instance Variables</li> <li>6.2.3 Local Variables<ul> <li>6.2.3.1 Inferring Types with var</li> </ul> </li> </ul> </li> <li>6.3 Wrapper Types<ul> <li>6.3.1 Purpose of Wrapper Types</li> <li>6.3.2 Autoboxing and Unboxing</li> <li>6.3.3 Parsing and Conversion</li> <li>6.3.4 Helper Methods</li> <li>6.3.5 Null Values</li> </ul> </li> <li>6.4 Equality in Java<ul> <li>6.4.1 Equality with Primitive Types<ul> <li>6.4.1.1 Key Points</li> </ul> </li> <li>6.4.2 Equality with Reference Types<ul> <li>6.4.2.1 Identity Comparison</li> <li>6.4.2.2 equals Logical Comparison</li> <li>6.4.2.3 Key Points</li> </ul> </li> <li>6.4.3 String Pool and Equality<ul> <li>6.4.3.1 The intern Method</li> </ul> </li> <li>6.4.4 Equality with Wrapper Types</li> <li>6.4.5 Equality and null</li> <li>6.4.6 Summary Table</li> </ul> </li> </ul>"},{"location":"en/module-01/instantiating-types/#61-introduction","title":"6.1 Introduction","text":"<p>In Java, a type can be either a primitive type (such as <code>int</code>, <code>double</code>, <code>boolean</code>, etc.) or a reference type (classes, interfaces, arrays, enums, records, etc.). See: Java Data Types and Casting</p> <p>The way instances are created depends on the category of the type:</p> <ul> <li>Primitive types   Instances of primitive types are created simply by declaring a variable.   The JVM automatically allocates memory to hold the value, and no explicit keyword is needed. </li> </ul> <pre><code>int age = 30;         // creates a primitive int with value 30\nboolean flag = true;  // creates a primitive boolean with value true\ndouble pi = 3.14159;  // creates a primitive double with value 3.14159\n</code></pre> <ul> <li>Reference types (objects)     Instances of class types are created using the new keyword (except for a few special cases such as string literals, records with canonical constructors, or factory methods).     The new keyword allocates memory on the heap and invokes a constructor of the class.</li> </ul> <pre><code>String name = new String(\"Alice\"); // creates a new String object explicitly\nPerson p = new Person();           // creates a new Person object using its constructor\n</code></pre> <p>It is also common to rely on literals or factory methods for object creation.</p> <pre><code>String text = \"Hello World\";\n\nList&lt;String&gt; list = List.of(\"A\", \"B\", \"C\");              // factory method immutabile\nMap&lt;String, Integer&gt; map = Map.of(\"one\", 1, \"two\", 2);   // factory method immutabile\nOptional&lt;String&gt; opt = Optional.of(\"value\");             // factory method\n\nLocalDate date = LocalDate.of(2025, 3, 15);\nInteger boxed = Integer.valueOf(10);\n</code></pre> <p>Important</p> <p>String literals do not require <code>new</code> and are stored in the String pool. Using <code>new String(\"x\")</code> always creates a new object on the heap.</p> <p></p>"},{"location":"en/module-01/instantiating-types/#611-handling-primitive-types","title":"6.1.1 Handling Primitive Types","text":""},{"location":"en/module-01/instantiating-types/#6111-declaring-a-primitive","title":"6.1.1.1 Declaring a Primitive","text":"<p>Declaring a primitive type (as with reference types) means reserving space in memory for a variable of a given type, without necessarily giving it a value.  </p> <p>Warning</p> <p>Unlike primitives, whose size depends on their specific type (e.g., <code>int</code> vs <code>long</code>), reference types always occupy the same fixed size in memory \u2014 what varies is the size of the object they point to.</p> <ul> <li>Syntax examples for declaration only:</li> </ul> <pre><code>int number;\n\nboolean active;\n\nchar letter;\n\nint x, y, z;          // Multiple declarations in one statement: Java allows declaring multiple variables of the same type\n</code></pre> <p>Important</p> <p>The <code>modifiers</code> and the <code>type</code> declared at the beginning of a variable declaration apply to all variables declared in the same statement.</p> <p>Exception: when declaring arrays using brackets after the variable name, the brackets are part of the individual variable declarator, not the base type.</p> <ul> <li>Examples</li> </ul> <pre><code>static int a, b, c;\n\n// is equivalent to :\n\nstatic int a;\nstatic int b;\nstatic int c;\n\n\nint[] a, b;   // both are arrays of int\nint c[], d;   // only c is an array, d is a regular int\n</code></pre> <p></p>"},{"location":"en/module-01/instantiating-types/#6112-assigning-a-primitive","title":"6.1.1.2 Assigning a Primitive","text":"<p>Assigning a primitive type (as with reference types) means storing a value into a declared variable of that given type. For primitives, the variable holds the value itself, while for reference types the variable holds the memory address (a reference) of the object being pointed to.</p> <ul> <li>Syntax examples:</li> </ul> <pre><code>int number;                     // Declaring an int type: a variable called \"number\"\n\nnumber = 10;                // Assigning the value 10 to this variable\n\nchar letter = 'A';          // Declaring and Assigning in a single statement: declaration and assignment can be combined \n\nint a1, a2;                   // Multiple declarations  \n\nint a = 1, b = 2, c = 3;    // Multiple declarations &amp; assignements\n\nchar b1, b2, b3 = 'C';      // Mixed declarations (2 declarations + 1 assignment)\n\ndouble d1, double d2;         // ERROR - NOT LEGAL\n\nint v1; v2;                     // ERROR - NOT LEGAL\n</code></pre> <p>Important</p> <p>When you write a number directly in the code (a numeric literal), Java assumes by default that it is of type int. If the value does not fit into an <code>int</code>, the code will not compile unless you explicitly mark it with the correct suffix.</p> <ul> <li>Syntax example for a numeric literal:</li> </ul> <pre><code>long exNumLit = 5729685479; // \u274c Does not compile.\n                          // Even though the value would fit in a long,\n                          // a plain numeric literal is assumed to be an int,\n                          // and this number is too large for int.\n\nChanging the declaration adding the correct suffix (L or l) will solve:\n\nlong exNumLit = 5729685479L;\n\nor\n\nlong exNumLit = 5729685479l;\n</code></pre> <p>Declaring a <code>reference</code> type means reserving space in memory for a variable that will contain a reference (pointer) to an object of the specified type.</p> <p>At this stage, no object is created yet \u2014 the variable only has the potential to point to one.</p> <p>Warning</p> <p>Unlike primitives, whose size depends on their specific type (e.g., <code>int</code> vs <code>long</code>), reference variables always occupy the same fixed size in memory (enough to store a reference). What varies is the size of the object they point to, which is allocated separately on the heap.</p> <ul> <li>Syntax examples for declaration only:</li> </ul> <pre><code>String name;\nPerson person;\nList&lt;Integer&gt; numbers;\n\nPerson p1, p2, p3;   // Multiple declarations in one statement\n\nString a = \"abc\", b = \"def\", c = \"ghi\";     // Multiple declarations &amp; assignements\n\nString b1, b2, b3 = \"abc\"                   // Mixed declarations (b1, b2) with one assignement (b3)\n\nString d1, String d2;                   // ERROR - NOT LEGAL\n\nString v1; v2;                          // ERROR - NOT LEGAL\n</code></pre> <p></p>"},{"location":"en/module-01/instantiating-types/#612-handling-reference-types","title":"6.1.2 Handling Reference Types","text":""},{"location":"en/module-01/instantiating-types/#6121-creating-and-assigning-a-reference","title":"6.1.2.1 Creating and Assigning a Reference","text":"<p>Assigning a <code>reference</code> type means storing into the variable the memory address of an object.</p> <p>This is normally done after the creation of the object with the new keyword and a Constructor, or by using a literal or a factory method.</p> <p>A reference can also be assigned to another object of the same or compatible type.</p> <p>Reference types can also be assigned null, which means that they do not refer to an object.</p> <ul> <li>Syntax examples:</li> </ul> <pre><code>Person person = new Person(); // Example with 'new' and a constructor 'Person()':\n                            // 'new Person()' creates a new Person object on the heap\n                            // and returns its reference, which is stored in the variable 'person'.\n\nString greeting = \"Hello\";   // Example with literal (for String).\n\nList&lt;Integer&gt; numbers = List.of(1, 2, 3);   // Example with a factory method.\n</code></pre> <p></p>"},{"location":"en/module-01/instantiating-types/#6122-constructors","title":"6.1.2.2 Constructors","text":"<p>In the example, <code>Person()</code> is a constructor \u2014 a special kind of method used to initialize new objects.</p> <p>Whenever you call <code>new Person()</code>, the constructor runs and sets up the newly created instance.</p> <p>Constructors have three main characteristics:</p> <ul> <li>The constructor name must match the class name exactly (case-sensitive).  </li> <li>Constructors do not declare a return type (not even <code>void</code>).  </li> <li>If you do not define any constructor in your class, the compiler will automatically provide a default no-argument constructor that does nothing.</li> </ul> <p>Warning</p> <p>If you see a method that has the same name as the class but also declares a return type, it is not a constructor. It is simply a regular method (though starting method names with a capital letter is against Java naming conventions).</p> <p>The purpose of a constructor is to initialize the state of a newly created object \u2014 typically by assigning values to its fields, either with default values or using parameters passed to the constructor.</p> <ul> <li>Example 1: Default constructor (no parameters)</li> </ul> <pre><code>public class Person {\n    String name;\n    int age;\n\n    // Default constructor\n    public Person() {\n        name = \"Unknown\";\n        age = 0;\n    }\n}\n\nPerson p1 = new Person(); // name = \"Unknown\", age = 0\n</code></pre> <ul> <li>Example 2: Constructor with parameters</li> </ul> <pre><code>public class Person {\n    String name;\n    int age;\n\n    // Constructor with parameters\n    public Person(String newName, int newAge) {\n        name = newName;\n        age = newAge;\n    }\n}\n\nPerson p2 = new Person(\"Alice\", 30); // name = \"Alice\", age = 30\n</code></pre> <ul> <li>Example 3: Multiple constructors (constructor overloading)</li> </ul> <pre><code>public class Person {\n    String name;\n    int age;\n\n    // Default constructor\n    public Person() {\n        this(\"Unknown\", 0); // calls the other constructor\n    }\n\n    // Constructor with parameters\n    public Person(String newName, int newAge) {\n        name = newName;\n        age = newAge;\n    }\n}\n\nPerson p1 = new Person();            // name = \"Unknown\", age = 0\nPerson p2 = new Person(\"Bob\", 25);   // name = \"Bob\", age = 25\n</code></pre> <p>Important</p> <ul> <li>Constructors are not inherited: if a superclass defines constructors, they are not automatically available in the subclass \u2014 you must declare them explicitly.</li> <li>If you declare any constructor in a class, the compiler does not generate the default no-argument constructor: if you still need a no-argument constructor, you must declare it manually.</li> </ul> <p></p>"},{"location":"en/module-01/instantiating-types/#6123-instance-initializer-blocks","title":"6.1.2.3 Instance Initializer Blocks","text":"<p>In addition to constructors, Java provides a mechanism called initializer blocks to help initialize objects. These are blocks of code inside a class, enclosed in <code>{ }</code>, that run every time an instance is created, just before the constructor body is executed.</p> <p>Characteristics</p> <ul> <li>Also called instance initializer blocks.  </li> <li>Executed, along with fields initializers, in the order in which they appear in the class definition but always before Constructors.    </li> <li>Useful when multiple constructors need to share common initialization code.</li> </ul> <p>Example: Using an Instance Initializer Block</p> <pre><code>public class Person {\n    String name;\n    int age;\n\n    // Instance initializer block\n    {\n        System.out.println(\"Instance initializer block executed\");\n        age = 18; // default age for every Person\n    }\n\n    // Default constructor\n    public Person() {\n        name = \"Unknown\";\n    }\n\n    // Constructor with parameters\n    public Person(String newName) {\n        name = newName;\n    }\n}\n\nPerson p1 = new Person();          // prints \"Instance initializer block executed\"\nPerson p2 = new Person(\"Alice\");   // prints \"Instance initializer block executed\"\n</code></pre> <p>Note</p> <p>In this example, the initializer block runs before either constructor body. Both p1 and p2 will start with age = 18, regardless of which constructor is used.</p> <p>Multiple Initializer Blocks: if a class contains multiple initializer blocks, they are executed in the order they appear in the source file:</p> <ul> <li>Example: </li> </ul> <pre><code>public class Example {\n    {\n        System.out.println(\"First block\");\n    }\n\n    {\n        System.out.println(\"Second block\");\n    }\n}\n\nExample ex = new Example();\n// Output:\n// First block\n// Second block\n</code></pre> <p>Note</p> <p>Instance initializer blocks are less common in practice, because similar logic can often be placed directly in constructors. It is important to know that: - They always run before the constructor body. - They are executed in the order of declaration in the class. - They can be combined with constructors to avoid code duplication.</p> <p>Warning</p> <p>Order of initialization when creating an object 1. Static fields 2. Static initializer blocks 3. Instance fields 4. Instance initializer blocks 5. Constructor body</p> <p></p>"},{"location":"en/module-01/instantiating-types/#62-default-variable-initialization","title":"6.2 Default Variable Initialization","text":""},{"location":"en/module-01/instantiating-types/#621-instance-and-class-variables","title":"6.2.1 Instance and Class variables","text":"<ul> <li>An instance variable (a field) is a value defined within an instance of an object;</li> <li>A class variable (defined with the keyword static) is defined at class level and it is shared among all the objects (instances of the class)</li> </ul> <p>Instance and class variables are given a default value, by the compiler, if not initialized.</p> <ul> <li>Table of default values for instance &amp; class variables;</li> </ul> Type Default Value Object null Numeric 0 boolean false char '\\u0000' (NUL) <p></p>"},{"location":"en/module-01/instantiating-types/#622-final-instance-variables","title":"6.2.2 Final Instance Variables","text":"<p>Unlike regular instance and class variables, <code>final</code> variables are not default-initialized by the compiler. A <code>final</code> variable must be explicitly assigned exactly once, otherwise the code does not compile.</p> <p>This applies to both:</p> <ul> <li>final instance variables</li> <li>static final class variables</li> </ul> <p>Note</p> <p>We can assign a <code>null</code> value to a <code>final</code> instance or class instance variables as long they are explicitely set.</p> <p>Java enforces this rule because a <code>final</code> variable represents a value that must be known and fixed before use.</p> <p><code>Final Instance Variables</code></p> <p>A final instance variable must be assigned exactly once, and the assignment must occur in one of the following:</p> <ol> <li>At the point of declaration</li> <li>In an instance initializer block</li> <li>Inside every constructor</li> </ol> <p>If the class has multiple constructors, the variable must be assigned in all of them.</p> <ul> <li>Example: <pre><code>public class Person {\n    final int id;   // must be assigned before constructor ends\n    String name;\n\n    // Constructor 1\n    public Person(int id, String name) {\n        this.id = id;        // ok\n        this.name = name;\n    }\n\n    // Constructor 2\n    public Person() {\n        this.id = 0;         // also required here\n        this.name = \"Unknown\";\n    }\n}\n</code></pre></li> </ul> <p>Warning</p> <p>Trying to compile without assigning <code>id</code> inside every constructor produces a compile-time error: variable id might not have been initialized</p> <p><code>static final</code> Class Variables (Constants)</p> <p>A static final variable belongs to the class rather than to any instance. It must also be assigned exactly once, but assignment can occur in one of the following places:</p> <ol> <li>At the point of declaration</li> <li> <p>Inside a static initializer block</p> </li> <li> <p>Example: <pre><code>public class AppConfig {\n\n    static final int TIMEOUT = 5000;    // assigned at declaration\n\n    static final String VERSION;        // assigned in static initializer\n\n    static {\n        VERSION = \"1.0.0\";              // ok\n    }\n}\n</code></pre></p> </li> </ol> <p>Attempting to assign a <code>static final</code> in a constructor is illegal.</p> <p>Key Rules for <code>final</code> Fields</p> Scenario Allowed? Notes Assign at declaration \u2714 Most common pattern Assign in constructor \u2714 All constructors must assign it Assign in instance initializer \u2714 Before constructor body runs Assign in static initializer (<code>static final</code> only) \u2714 For class-level constants Assign multiple times \u274c Compilation error Default initialization \u274c Must be explicitly assigned <p>Example of an illegal situation: <pre><code>public class Example {\n    final int x;        // not initialized\n}\n\nExample e = new Example(); // \u274c compile-time error\n</code></pre></p> <p>Why <code>final</code> Variables Are Not Default-Initialized?</p> <p>Because:</p> <ul> <li>Their value must be known and immutable, and</li> <li>Java must guarantee that the value is set before use,</li> <li>Default initialization would create a situation where <code>0</code>, <code>null</code>, or <code>false</code> might unintentionally become the permanent value.</li> </ul> <p>Thus, Java forces developers to explicitly initialize <code>final</code> fields.</p> <p>Tip</p> <p><code>final</code> means assigned once, not immutable object.</p> <p>A final reference can still point to a mutable object.</p> <pre><code>final List&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"ok\");      // allowed\nlist = new ArrayList&lt;&gt;(); // \u274c cannot reassign reference\n</code></pre> <p></p>"},{"location":"en/module-01/instantiating-types/#623-local-variables","title":"6.2.3 Local variables","text":"<p>Local variables are variables defined within a constructor, method or inizializer block;</p> <p>Local variables do not have default values and they must be initialized before they can be used. If you try to use a not initialized local variable the compiler will report an ERROR.</p> <ul> <li>Example </li> </ul> <pre><code>public int localMethod {\n\n    int firstVar = 25;\n    int secondVar;\n    secondVar = 35;\n    int firstSum = firstVar + secondVar;    // OK variables are both initialized before use\n\n    int thirdVar;\n    int secondSum = firstSum + thirdVar;    // ERROR: variable thirdVar has not been initialized before use; if you do not try to use thirdVar the compiler will not complain\n}\n</code></pre> <p></p>"},{"location":"en/module-01/instantiating-types/#6231-inferring-types-with-var","title":"6.2.3.1 Inferring Types with var","text":"<p>Under certain conditions you can use the keyword var in place of the appropriate type when declaring local variables;</p> <p>Warning</p> <ul> <li>var IS NOT a reserved word in java;</li> <li>var can be used only for local variables: it CAN'T be used for constructor parameters, instance variables or method parameters;</li> <li>The compiler infere the type by looking ONLY at the code on the line of the declaration; once the right type has been inferred you can't reassign to another type.</li> </ul> <ul> <li>example</li> </ul> <pre><code>public int localMethod {\n\n    var inferredInt = 10;   // The compiler infer int by the context;\n    inferredInt = 25;       // OK\n\n    inferredInt = \"abcd\";   // ERROR: the compiler has already inferred the type of the variable as int\n\n    var notInferred;\n    notInferred = 30;       // ERROR: in order to infer the type, the compiler looks ONLY at the line with declaration\n\n    var first, second = 15; // ERROR: var cannot be used to define two variables on the same statement;\n\n    var x = null;           // ERROR: var cannot be initialized with null but it can be reassigned to null provided that the underlying type is a reference type.\n}\n</code></pre> <p>Warning</p> <p>Local variables never get default values. Instance &amp; static fields always do.</p> <p></p>"},{"location":"en/module-01/instantiating-types/#63-wrapper-types","title":"6.3 Wrapper Types","text":"<p>In Java, wrapper types are object representations of the eight primitive types. Each primitive has a corresponding wrapper class in the <code>java.lang</code> package:</p> Primitive Wrapper Class <code>byte</code> <code>Byte</code> <code>short</code> <code>Short</code> <code>int</code> <code>Integer</code> <code>long</code> <code>Long</code> <code>float</code> <code>Float</code> <code>double</code> <code>Double</code> <code>char</code> <code>Character</code> <code>boolean</code> <code>Boolean</code> <p>Wrapper objects are immutable \u2014 once created, their value cannot change.</p> <p></p>"},{"location":"en/module-01/instantiating-types/#631-purpose-of-wrapper-types","title":"6.3.1 Purpose of Wrapper Types","text":"<ul> <li>Allow primitives to be used in contexts that require objects (e.g., collections, generics).  </li> <li>Provide utility methods for parsing, converting, and working with values.  </li> <li>Support constants such as <code>Integer.MAX_VALUE</code> or <code>Double.MIN_VALUE</code>.  </li> </ul>"},{"location":"en/module-01/instantiating-types/#632-autoboxing-and-unboxing","title":"6.3.2 Autoboxing and Unboxing","text":"<p>Since Java 5, the compiler automatically converts between primitives and their wrappers:</p> <ul> <li>Autoboxing: primitive \u2192 wrapper  </li> <li>Unboxing: wrapper \u2192 primitive  </li> </ul> <pre><code>Integer i = 10;       // autoboxing: int \u2192 Integer\nint n = i;            // unboxing: Integer \u2192 int\n\nInteger int1 = Integer.valueOf(11);\nlong long1 = int1;  // Unboxing --&gt; implicit cast OK\n\nLong long2 = 11;   // \u274c Does not compile. \n                   // 11 is an int literal \u2192 requires autoboxing + widening \u2192 illegal\n\nCharacter char1 = null;\nchar char2 = char1;  // WARNING: NullPointerException\n\nInteger  arr1 = {11.5, 13.6}  // WARNING: Does not compile!!\nDouble[] arr2 = {11, 22};     // WARNING: Does not compile!!\n</code></pre> <p>Tip</p> <p>Java never performs autoboxing + widening/narrowing in one step.</p> <p>Warning</p> <ul> <li>AUTOBOXING and Implicit cast are not allowed in the same statement: you can't do both at the same time. (see example above)</li> <li>This rule apply also in method calls.</li> </ul> <p></p>"},{"location":"en/module-01/instantiating-types/#633-parsing-and-conversion","title":"6.3.3  Parsing and Conversion","text":"<p>Wrappers provide static methods to convert strings or other types into primitives:</p> <pre><code>int x = Integer.parseInt(\"123\");    // returns primitive int\nInteger y = Integer.valueOf(\"456\"); // returns Integer object\ndouble d = Double.parseDouble(\"3.14\");\n\n// On the numeric wrapper class valueOf() throws a NumberFormatException on invalid input.\n// Example:\n\nInteger w = Integer.valueOf(\"two\"); // NumberFormatException\n\n// On Boolean, the method returns Boolean.TRUE for any value that matches \"true\" ignoring case, otherwise Boolean.false\n// Example:\n\nBoolean.valueOf(\"true\");    // true\nBoolean.valueOf(\"TrUe\");    // true\nBoolean.valueOf(\"TRUE\");    // true\nBoolean.valueOf(\"false\");   // false\nBoolean.valueOf(\"FALSE\");   // false\nBoolean.valueOf(\"xyz\");     // false\nBoolean.valueOf(null);      // false\n\n// The numeric integral classes Byte, Short, Integer and Long include an overloaded **valueOf(String str, int base)** method which takes a base value\n// Example with base 16 (hexadecimal) which includes character 0 -&gt; 9 and A -&gt; F (ignore case)\n\nInteger.valueOf(\"6\", 16);   // 6\nInteger.valueOf(\"a\", 16);   // 10\nInteger.valueOf(\"A\", 16);   // 10\nInteger.valueOf(\"F\", 16);   // 15\nInteger.valueOf(\"G\", 16);   // NumberFormatException\n</code></pre> <p>Note</p> <p>methods parseXxx() return a primitive while valueOf() returns a wrapper object.</p> <p></p>"},{"location":"en/module-01/instantiating-types/#634-helper-methods","title":"6.3.4  Helper methods","text":"<p>All the numeric wrapper classes extend the Number class and, for that, they inherit some helper methods such as: byteValue(), shortValue(), intValue(), longValue(), floatValue(), doubleValue().</p> <p>The Boolean and Character wrapper classes include: booleanValue() and charValue().</p> <ul> <li>Example:</li> </ul> <pre><code>        // In trying to convert those helper methods can result in a loss of precision.\n\n        Double baseDouble = Double.valueOf(\"300.56\");\n\n        double wrapDouble = baseDouble.doubleValue();\n        System.out.println(\"baseDouble.doubleValue(): \" + wrapDouble);  // 300.56\n\n        byte wrapByte = baseDouble.byteValue();\n        System.out.println(\"baseDouble.byteValue(): \" + wrapByte);      // 44  -&gt; There is no 300 in byte\n\n        int wrapInt = baseDouble.intValue();\n        System.out.println(\"baseDouble.intValue(): \" + wrapInt);        // 300 -&gt; The value is truncated\n</code></pre> <p></p>"},{"location":"en/module-01/instantiating-types/#635-null-values","title":"6.3.5  Null Values","text":"<p>Unlike primitives, wrapper types can hold null.  Attempting to unbox null causes a NullPointerException:</p> <pre><code>Integer val = null;\nint z = val; // \u274c NullPointerException at runtime\n</code></pre> <p></p>"},{"location":"en/module-01/instantiating-types/#64-equality-in-java","title":"6.4 Equality in Java","text":"<p>Java provides two different mechanisms for checking equality:</p> <ul> <li><code>==</code> (equality operator)</li> <li><code>.equals()</code> (method defined in <code>Object</code> and overridden in many classes)</li> </ul> <p>Understanding the difference is essential.</p> <p></p>"},{"location":"en/module-01/instantiating-types/#641-equality-with-primitive-types","title":"6.4.1 Equality with Primitive Types","text":"<p>For primitive values (<code>int</code>, <code>double</code>, <code>char</code>, <code>boolean</code>, etc.), the operator <code>==</code> compares their actual numeric or boolean value.</p> <p>Example: <pre><code>int a = 5;\nint b = 5;\nSystem.out.println(a == b);     // true\n\nchar c1 = 'A';\nchar c2 = 65;                   // same Unicode code point\nSystem.out.println(c1 == c2);   // true\n</code></pre></p> <p></p>"},{"location":"en/module-01/instantiating-types/#6411-key-points","title":"6.4.1.1 Key points","text":"<ul> <li><code>==</code> performs value comparison for primitives.</li> <li>Primitive types have no <code>.equals()</code> method.</li> <li>Mixed primitive types follow numeric promotion rules   (e.g., <code>int == long</code> \u2192 <code>int</code> promoted to <code>long</code>).</li> </ul>"},{"location":"en/module-01/instantiating-types/#642-equality-with-reference-types","title":"6.4.2 Equality with Reference Types","text":"<p>With objects (reference types), the meaning of <code>==</code> changes.</p> <p></p>"},{"location":"en/module-01/instantiating-types/#6421-identity-comparison","title":"6.4.2.1 <code>==</code>(Identity Comparison)","text":"<p><code>==</code> checks whether two references point to the same object in memory.</p> <pre><code>String s1 = new String(\"Hi\");\nString s2 = new String(\"Hi\");\n\nSystem.out.println(s1 == s2);      // false \u2192 different objects\n</code></pre> <p>Even if contents are identical, <code>==</code> is false unless both variables refer to the exact same object.</p> <p></p>"},{"location":"en/module-01/instantiating-types/#6422-equals-logical-comparison","title":"6.4.2.2 <code>.equals()</code> (Logical Comparison)","text":"<p>Many classes override <code>.equals()</code> to compare values, not memory addresses.</p> <pre><code>System.out.println(s1.equals(s2)); // true \u2192 same content\n</code></pre> <p></p>"},{"location":"en/module-01/instantiating-types/#6423-key-points","title":"6.4.2.3 Key points","text":"<ul> <li><code>.equals()</code> is defined in <code>Object</code>.</li> <li>If a class does not override <code>.equals()</code>, it behaves like <code>==</code>.</li> <li>Classes like <code>String</code>, <code>Integer</code>, <code>List</code>, etc. override <code>.equals()</code>   to provide meaningful value comparison.</li> </ul>"},{"location":"en/module-01/instantiating-types/#643-string-pool-and-equality","title":"6.4.3 String Pool and Equality","text":"<p>String literals are stored in the String pool, so identical literals refer to the same object.</p> <pre><code>String a = \"Java\";\nString b = \"Java\";\nSystem.out.println(a == b);       // true \u2192 same pooled literal\n</code></pre> <p>But using <code>new</code> creates a different object:</p> <pre><code>String x = new String(\"Java\");\nString y = \"Java\";\n\nSystem.out.println(x == y);       // false \u2192 x is not pooled\nSystem.out.println(x.equals(y));  // true\n</code></pre> <p>Common Pitfalls</p> <pre><code>String x = \"Java string literal\";\nString y = \" Java string literal\".trim();\n\nSystem.out.println(x == y);       // false \u2192 x and y are not the same at compile time\n\nString a = \"Java string literal\";\nString b = \"Java \";\nb += \"string literal\";\n\nSystem.out.println(a == b);  // false\n</code></pre> <p>Warning</p> <p>Any String created at runtime does not go into the pool automatically. Use <code>intern()</code> if you want pooling.</p> <p>Tip</p> <p><code>\"Hello\" == \"Hel\" + \"lo\"</code> \u2192 true (compile-time constant)</p> <p><code>\"Hello\" == getHello()</code> \u2192 false (runtime concatenation)</p> <pre><code>String x = \"Hello\";\nString y = \"Hel\" + \"lo\";   // compile-time \u2192 same literal\nString z = \"Hel\";\nz += \"lo\";                 // runtime \u2192 new String\n\nSystem.out.println(x == y); // true\nSystem.out.println(x == z); // false\n</code></pre> <p></p>"},{"location":"en/module-01/instantiating-types/#6431-the-intern-method","title":"6.4.3.1 The intern method","text":"<p>You can also tell Java to use a String from the String Pool (in case it already exist) through the <code>intern()</code> method:</p> <pre><code>String x = \"Java\";\nString y = new String(\"Java\").intern();\n\n\nSystem.out.println(x == y);       // true\n</code></pre> <p></p>"},{"location":"en/module-01/instantiating-types/#644-equality-with-wrapper-types","title":"6.4.4 Equality with Wrapper Types","text":"<p>Wrapper classes (<code>Integer</code>, <code>Double</code>, etc.) behave like objects:</p> <ul> <li><code>==</code> \u2192 compares references  </li> <li><code>.equals()</code> \u2192 compares values  </li> </ul> <p>However, some wrappers are cached (Integer from \u2212128 to 127):</p> <pre><code>Integer a = 100;\nInteger b = 100;\nSystem.out.println(a == b);        // true \u2192 cached\n\nInteger c = 1000;\nInteger d = 1000;\nSystem.out.println(c == d);        // false \u2192 not cached\n\nSystem.out.println(c.equals(d));   // true \u2192 same numeric value\n</code></pre> <p>Warning</p> <p>Be very careful with wrapper caching</p> <p></p>"},{"location":"en/module-01/instantiating-types/#645-equality-and-null","title":"6.4.5 Equality and <code>null</code>","text":"<ul> <li><code>== null</code> is always safe.</li> <li>Calling <code>.equals()</code> on a <code>null</code> reference throws a NullPointerException.</li> </ul> <pre><code>String s = null;\nSystem.out.println(s == null);   // true\n// s.equals(\"Hi\");               // \u274c NullPointerException\n</code></pre>"},{"location":"en/module-01/instantiating-types/#646-summary-table","title":"6.4.6 Summary Table","text":"Comparison Primitives Objects / Wrappers Strings <code>==</code> compares value compares reference identity (affected by String pool) <code>.equals()</code> N/A compares content if overridden content comparison"},{"location":"en/module-01/java-operators/","title":"5. Java Operators","text":""},{"location":"en/module-01/java-operators/#table-of-contents","title":"Table of Contents","text":"<ul> <li>5.1 Definition</li> <li>5.2 Types of Operators</li> <li>5.3 Categories of Operators</li> <li>5.4 Operator Precedence and Order of Evaluation</li> <li>5.5 Summary Table of Java Operators<ul> <li>5.5.1 Additional Notes</li> </ul> </li> <li>5.6 Unary Operators<ul> <li>5.6.1 Categories of Unary Operators</li> <li>5.6.2 Examples</li> </ul> </li> <li>5.7 Binary Operators<ul> <li>5.7.1 Categories of Binary Operators</li> <li>5.7.2 Division and Modulus Operators<ul> <li>5.7.2.1 Division Operator</li> <li>5.7.2.2 Modulus Operator</li> </ul> </li> <li>5.7.3 The Return Value of an Assignment Operator</li> <li>5.7.4 Compound Assignment Operators</li> <li>5.7.5 Equality Operators == and !=<ul> <li>5.7.5.1 Equality with Primitive Types</li> <li>5.7.5.2 Equality with Reference Types Objects</li> </ul> </li> <li>5.7.6 The instanceof Operator<ul> <li>5.7.6.1 Compile-Time Check vs Runtime Check</li> <li>5.7.6.2 Pattern Matching for instanceof</li> <li>5.7.6.3 Flow Scoping &amp; Short-Circuit Logic</li> <li>5.7.6.4 Arrays and Reifiable Types</li> </ul> </li> </ul> </li> <li>5.8 Ternary Operator<ul> <li>5.8.1 Type Rules for the Ternary Operator<ul> <li>5.8.1.1 Numeric Operands</li> <li>5.8.1.2 Reference Types</li> </ul> </li> <li>5.8.2 Syntax</li> <li>5.8.3 Example</li> <li>5.8.4 Nested Ternary Example</li> <li>5.8.5 Notes</li> </ul> </li> </ul>"},{"location":"en/module-01/java-operators/#51-definition","title":"5.1 Definition","text":"<p>In Java, operators are special symbols that perform operations on variables and values. They are the building blocks of expressions and allow developers to manipulate data, compare values, perform arithmetic, and control logic flow.</p> <p>An expression is a combination of operators and operands that produces a result. </p> <p>For example: <pre><code>int result = (a + b) * c;\n</code></pre></p> <p>Here, <code>+</code> and <code>*</code> are operators, and <code>a</code>, <code>b</code>, and <code>c</code> are operands.</p> <p></p>"},{"location":"en/module-01/java-operators/#52-types-of-operators","title":"5.2 Types of Operators","text":"<p>Java defines three types of operators, grouped by the number of operands they use:</p> Type Description Examples Unary Operate on a single operand <code>+x</code>, <code>-x</code>, <code>++x</code>, <code>--x</code>, <code>!flag</code>, <code>~num</code> Binary Operate on two operands <code>a + b</code>, <code>a - b</code>, <code>x * y</code>, <code>x / y</code>, <code>x % y</code> Ternary Operate on three operands (only one in Java) <code>condition ? valueIfTrue : valueIfFalse</code> <p></p>"},{"location":"en/module-01/java-operators/#53-categories-of-operators","title":"5.3 Categories of Operators","text":"<p>Operators can also be grouped, by their purpose, into categories:</p> Category Description Examples Assignment Assign values to variables <code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code> Relational Compare values <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> Logical Combine or invert boolean expressions <code>|</code>, <code>&amp;</code>, <code>^</code> Conditional Combine or invert boolean expressions <code>||</code>, <code>&amp;&amp;</code> Bitwise Manipulate bits <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>~</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code> Instanceof Test object type <code>obj instanceof ClassName</code> Lambda Used in lambda expressions <code>(x, y) -&gt; x + y</code> <p></p>"},{"location":"en/module-01/java-operators/#54-operator-precedence-and-order-of-evaluation","title":"5.4 Operator Precedence and Order of Evaluation","text":"<p>Operator precedence determines how operators are grouped in an expression \u2014 that is, which operations are performed first. Associativity (or order of evaluation) determines whether the expression is evaluated from left to right or right to left when operators have the same precedence.</p> <p>Example:</p> <pre><code>int result = 10 + 5 * 2;  // Multiplication happens before addition \u2192 result = 20\n</code></pre> <p>Parentheses <code>()</code> can be used to override precedence:</p> <pre><code>int result = (10 + 5) * 2;  // Parentheses evaluated first \u2192 result = 30\n</code></pre> <p>Note</p> <ul> <li>Operator precedence is about grouping, not evaluation order.</li> <li>Use parentheses for precedence and clarity in complex expressions.</li> </ul> <p></p>"},{"location":"en/module-01/java-operators/#55-summary-table-of-java-operators","title":"5.5 Summary Table of Java Operators","text":"Precedence (High \u2192 Low) Type Operators Example Evaluation Order Applicable To 1 Postfix Unary <code>expr++</code>, <code>expr--</code> <code>x++</code> Left \u2192 Right Numeric types 2 Prefix Unary <code>++expr</code>, <code>--expr</code> <code>--x</code> Left \u2192 Right Numeric 3 Other Unary <code>(type)</code>, <code>+</code>, <code>-</code>, <code>~</code>, <code>!</code> <code>-x</code>, <code>!flag</code> Right \u2192 Left Numeric, boolean 4 Cast Unary <code>(Type) reference</code> <code>(short) 22</code> Right \u2192 Left reference, primitive 5 Multiplication/division/modulus <code>*</code>, <code>/</code>, <code>%</code> <code>a * b</code> Left \u2192 Right Numeric types 6 Additive <code>+</code>, <code>-</code> <code>a + b</code> Left \u2192 Right Numeric, String (concatenation) 7 Shift <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code> <code>a &lt;&lt; 2</code> Left \u2192 Right Integral types 8 Relational <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>instanceof</code> <code>a &lt; b</code>, <code>obj instanceof Person</code> Left \u2192 Right Numeric, reference 9 Equality <code>==</code>, <code>!=</code> <code>a == b</code> Left \u2192 Right All types (except boolean for <code>&lt;</code>, <code>&gt;</code>) 10 Logical AND <code>&amp;</code> <code>a &amp; b</code> Left \u2192 Right boolean 11 Logical exclusive OR <code>^</code> <code>a ^ b</code> Left \u2192 Right boolean 12 Logical inclusive OR <code>|</code> <code>a</code><code>|</code><code>b</code> Left \u2192 Right boolean 13 Conditional AND <code>&amp;&amp;</code> <code>a</code><code>&amp;&amp;</code><code>b</code> Left \u2192 Right boolean 14 Conditional OR <code>||</code> <code>a</code><code>||</code><code>b</code> Left \u2192 Right boolean 15 Ternary (Conditional) <code>? :</code> <code>a &gt; b ? x : y</code> Right \u2192 Left All types 16 Assignment <code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code> <code>x += 5</code> Right \u2192 Left All assignable types 17 Arrow operator <code>-&gt;</code> <code>(x, y) -&gt; x + y</code> Right \u2192 Left Lambda expressions, switch rules"},{"location":"en/module-01/java-operators/#551-additional-notes","title":"5.5.1 Additional Notes","text":"<ul> <li>String concatenation (<code>+</code>) has lower precedence than arithmetic <code>+</code> with numbers.</li> <li>Use parentheses <code>()</code> for precedence and readability \u2014 they don\u2019t change semantics but make intent explicit.</li> </ul>"},{"location":"en/module-01/java-operators/#56-unary-operators","title":"5.6 Unary Operators","text":"<p>Unary operators operate on a single operand to produce a new value. They are used for operations like incrementing/decrementing, negating a value, inverting a boolean, or performing bitwise complement.</p> <p></p>"},{"location":"en/module-01/java-operators/#561-categories-of-unary-operators","title":"5.6.1 Categories of Unary Operators","text":"Operator Name Description Example Result <code>+</code> Unary plus Indicates a positive value (usually redundant). <code>+x</code> Same as <code>x</code> <code>-</code> Unary minus Indicates a literal number is negative or negates an expression. <code>-5</code> <code>-5</code> <code>++</code> Increment Increases a variable by 1. Can be prefix or postfix. <code>++x</code>, <code>x++</code> <code>x+1</code> <code>--</code> Decrement Decreases a variable by 1. Can be prefix or postfix. <code>--x</code>, <code>x--</code> <code>x-1</code> <code>!</code> Logical complement Inverts a boolean value. <code>!true</code> <code>false</code> <code>~</code> Bitwise complement Inverts each bit of an integer. <code>~5</code> <code>-6</code> <code>(type)</code> Cast Converts value to another type. <code>(int) 3.9</code> <code>3</code>"},{"location":"en/module-01/java-operators/#562-examples","title":"5.6.2 Examples","text":"<pre><code>int x = 5;\nSystem.out.println(++x);  // 6  (prefix: increments x to 6, then returns 6)\nSystem.out.println(x++);  // 6  (postfix: returns 6, then increments x to 7)\nSystem.out.println(x);    // 7\n\nboolean flag = false;\nSystem.out.println(!flag);  // true\n\nint a = 5;                  // binary: 0000 0101\nSystem.out.println(~a);     // -6 \u2192 binary: 1111 1010 (two's complement)\n</code></pre> <p>Note</p> <ul> <li>Prefix (<code>++x</code> / <code>--x</code>): updates the value first, then returns the new value.</li> <li>Postfix (<code>x++</code> / <code>x--</code>): returns the current value first, then updates it.</li> <li>The <code>!</code> operator applies to boolean values; <code>~</code> applies to integral numeric types.</li> </ul> <p></p>"},{"location":"en/module-01/java-operators/#57-binary-operators","title":"5.7 Binary Operators","text":"<p>Binary operators require two operands. They perform arithmetic, relational, logical, bitwise, and assignment operations.</p> <p></p>"},{"location":"en/module-01/java-operators/#571-categories-of-binary-operators","title":"5.7.1 Categories of Binary Operators","text":"Category Operators Example Description Arithmetic <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code> <code>a + b</code> Basic math operations. Relational <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code>, <code>!=</code> <code>a &lt; b</code> Compare values. Logical (boolean) <code>&amp;</code>, <code>|</code>, <code>^</code> <code>a</code><code>&amp;</code><code>b</code> See note below Conditional <code>&amp;&amp;</code>, <code>||</code> <code>a</code><code>&amp;&amp;</code><code>b</code> See note below Bitwise (integral) <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code> <code>a &lt;&lt; 2</code> Operate on bits. Assignment <code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code> <code>x += 3</code> Modify and assign. String Concatenation <code>+</code> <code>\"Hello \" + name</code> Joins strings together. <p>Important</p> <p>Logical operators (<code>&amp;</code>, <code>|</code>, <code>^</code>) always evaluate both sides.</p> <p>Conditional operators (<code>&amp;&amp;</code>, <code>||</code>) are short-circuiting: - <code>a &amp;&amp; b</code> \u2192 <code>b</code> evaluated only if <code>a</code> is true - <code>a || b</code> \u2192 <code>b</code> evaluated only if <code>a</code> is false</p> <ul> <li>Examples:</li> </ul> <p>Arithmetic Example: <pre><code>int a = 10, b = 4;\nSystem.out.println(a + b);  // 14\nSystem.out.println(a - b);  // 6\nSystem.out.println(a * b);  // 40\nSystem.out.println(a / b);  // 2\nSystem.out.println(a % b);  // 2\n</code></pre></p> <p>Relational Example: <pre><code>int a = 5, b = 8;\nSystem.out.println(a &lt; b);   // true\nSystem.out.println(a &gt;= b);  // false\nSystem.out.println(a == b);  // false\nSystem.out.println(a != b);  // true\n</code></pre></p> <p>Logical Example: <pre><code>boolean x = true, y = false;\nSystem.out.println(x &amp;&amp; y);  // false\nSystem.out.println(x || y);  // true\nSystem.out.println(!x);      // false\n</code></pre></p> <p>Bitwise Example: <pre><code>int a = 5;   // 0101\nint b = 3;   // 0011\nSystem.out.println(a &amp; b);  // 1  (0001)\nSystem.out.println(a | b);  // 7  (0111)\nSystem.out.println(a ^ b);  // 6  (0110)\nSystem.out.println(a &lt;&lt; 1); // 10 (1010)\nSystem.out.println(a &gt;&gt; 1); // 2  (0010)\n</code></pre></p> <p></p>"},{"location":"en/module-01/java-operators/#572-division-and-modulus-operators","title":"5.7.2 Division and Modulus Operators","text":""},{"location":"en/module-01/java-operators/#5721-division-operator","title":"5.7.2.1 Division Operator","text":"<p>Dividing an <code>integer</code> by zero (for example, 10 / 0) causes the JVM to throw a <code>java.lang.ArithmeticException: / by zero</code>.</p> <p>However, floating-point division behaves differently. </p> <p>When a <code>float</code> or <code>double</code> value is divided by 0 or 0.0, no exception is thrown. Instead, the result is:</p> <ul> <li>Float.POSITIVE_INFINITY or Float.NEGATIVE_INFINITY</li> <li>Double.POSITIVE_INFINITY or Double.NEGATIVE_INFINITY</li> </ul> <p>The sign depends on the operands involved in the operation.</p> <p>To determine whether a floating-point value represents infinity, the <code>Float</code> and <code>Double</code> classes provide utility methods:</p> <p>Static methods:</p> <ul> <li>Float.isInfinite(float value)</li> <li>Double.isInfinite(double value)</li> </ul> <p>Instance methods:</p> <ul> <li>Float.isInfinite()</li> <li>Double.isInfinite()</li> </ul> <p>These methods return true if the value corresponds to either positive or negative infinity.</p> <p></p>"},{"location":"en/module-01/java-operators/#5722-modulus-operator","title":"5.7.2.2 Modulus Operator","text":"<p>The modulus operator is the remainder when two numbers are divided. If two numbers divide evenly, the reminder is 0: for example 10 % 5 is 0. On the other hand, 13 % 4 gives the reminder of 1.</p> <p>We can use modulus with negative numbers according to the following rules:</p> <ul> <li>if the divisor is negative (Ex: 7 % -5), then the sign is ignored and the result is 2;</li> <li>if the dividend is negative (Ex: -7 % 5), then the sign is preserved and the result is -2;</li> </ul> <pre><code>System.out.println(8 % 5);      // GIVES 3\nSystem.out.println(10 % 5);     // GIVES 0\nSystem.out.println(10 % 3);     // GIVES 1    \nSystem.out.println(-10 % 3);    // GIVES -1    \nSystem.out.println(10 % -3);    // GIVES 1   \nSystem.out.println(-10 % -3);   // GIVES -1 \n\nSystem.out.println(8 % 9);      // GIVES 8\nSystem.out.println(3 % 4);      // GIVES 3    \nSystem.out.println(2 % 4);      // GIVES 2\nSystem.out.println(-8 % 9);     // GIVES -8\n</code></pre> <p></p>"},{"location":"en/module-01/java-operators/#573-the-return-value-of-an-assignment-operator","title":"5.7.3 The Return Value of an Assignment Operator","text":"<p>In Java, the assignment operator (<code>=</code>) not only stores a value in a variable \u2014 it also returns the assigned value as the result of the entire expression.</p> <p>This means that the assignment operation itself can be used as part of another expression, such as inside an <code>if</code> statement, a loop condition, or even another assignment.</p> <pre><code>int x;\nint y = (x = 10);   // the assignment (x = 10) returns 10\nSystem.out.println(y);  // 10\n\n// x = 10 assigns 10 to x.\n// The expression (x = 10) evaluates to 10.\n// That value is then assigned to y.\n// So both x and y end up with the same value (10).\n</code></pre> <p>Because assignment returns a value, it can also appear inside an if statement. However, this often leads to logical errors if used unintentionally.</p> <pre><code>boolean flag = false;\n\nif (flag = true) {\n    System.out.println(\"This will always execute!\");\n}\n\n// Here the condition (flag = true) assigns true to flag, and then evaluates to true, so the if block always runs.\n\n// Correct usage (comparison instead of assignment):\n\nif (flag == true) {\n    System.out.println(\"Condition checked, not assigned\");\n}\n</code></pre> <p>Warning</p> <p>If you see <code>if (x = something)</code>, stop: it\u2019s assignment, not comparison.</p> <p></p>"},{"location":"en/module-01/java-operators/#574-compound-assignment-operators","title":"5.7.4 Compound Assignment Operators","text":"<p>Compound assignment operators in Java combine an arithmetic or bitwise operation with assignment in a single step. Instead of writing <code>x = x + 5</code>, you can use the shorthand <code>x += 5</code>. They automatically perform type casting to the left-hand variable type when necessary.</p> <p>Common compound operators include: <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&amp;=</code>, <code>|=</code>, <code>^=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, and <code>&gt;&gt;&gt;=</code>.</p> <pre><code>int x = 10;\n\n// Arithmetic compound assignments\nx += 5;   // same as x = x + 5 \u2192 x = 15\nx -= 3;   // same as x = x - 3 \u2192 x = 12\nx *= 2;   // same as x = x * 2 \u2192 x = 24\nx /= 4;   // same as x = x / 4 \u2192 x = 6\nx %= 5;   // same as x = x % 5 \u2192 x = 1\n\n// Bitwise compound assignments\nint y = 6;   // 0110 (binary)\ny &amp;= 3;      // y = y &amp; 3 \u2192 0110 &amp; 0011 = 0010 \u2192 y = 2\ny |= 4;      // y = y | 4 \u2192 0010 | 0100 = 0110 \u2192 y = 6\ny ^= 5;      // y = y ^ 5 \u2192 0110 ^ 0101 = 0011 \u2192 y = 3\n\n// Shift compound assignments\nint z = 8;   // 0000 1000\nz &lt;&lt;= 2;     // z = z &lt;&lt; 2 \u2192 0010 0000 \u2192 z = 32\nz &gt;&gt;= 1;     // z = z &gt;&gt; 1 \u2192 0001 0000 \u2192 z = 16\nz &gt;&gt;&gt;= 2;    // z = z &gt;&gt;&gt; 2 \u2192 0000 0100 \u2192 z = 4\n\n// Type casting example\nbyte b = 10;\n// b = b + 1;   // \u274c compile-time error: int result cannot be assigned to byte\nb += 1;         // \u2705 works: implicit cast back to byte\n</code></pre> <p>Note</p> <p>Compound assignments perform an implicit cast to the variable type on the left. That\u2019s why <code>b += 1</code> compiles even though <code>b = b + 1</code> does not.</p> <p></p>"},{"location":"en/module-01/java-operators/#575-equality-operators-and","title":"5.7.5 Equality Operators (<code>==</code> and <code>!=</code>)","text":"<p>The equality operators in Java <code>==</code> (equal to) and <code>!=</code> (not equal to) are used to compare two operands for equality. However, their behavior differs depending on whether they are applied to primitive types or reference types (objects).</p> <p>Note</p> <ul> <li><code>==</code> compares values for primitives</li> <li><code>==</code> compares references for objects  </li> <li><code>.equals()</code> compares object content (if implemented)</li> </ul> <p></p>"},{"location":"en/module-01/java-operators/#5751-equality-with-primitive-types","title":"5.7.5.1 Equality with Primitive Types","text":"<p>When comparing primitive values, <code>==</code> and <code>!=</code> compare the actual stored values.</p> <pre><code>int a = 5, b = 5;\nSystem.out.println(a == b);  // true  \u2192 both have the same value\nSystem.out.println(a != b);  // false \u2192 values are equal\n</code></pre> <p>Important</p> <ul> <li>If the operands are of different numeric types, Java automatically promotes them to a common type before comparison.</li> <li>However, comparing float and double can produce unexpected results due to precision errors (check example below)</li> </ul> <pre><code>int x = 10;\ndouble y = 10.0;\nSystem.out.println(x == y);  // true \u2192 x promoted to double (10.0)\n\n\ndouble d = 0.1 + 0.2;\nSystem.out.println(d == 0.3); // false \u2192 floating-point rounding issue\n</code></pre> <p></p>"},{"location":"en/module-01/java-operators/#5752-equality-with-reference-types-objects","title":"5.7.5.2 Equality with Reference Types (Objects)","text":"<p>For objects, == and != compare references, not object content. They return true only if both references point to the exact same object in memory.</p> <pre><code>String s1 = new String(\"Java\");\nString s2 = new String(\"Java\");\nSystem.out.println(s1 == s2);      // false \u2192 different objects in memory\nSystem.out.println(s1 != s2);      // true  \u2192 not the same reference\n</code></pre> <p>Even if two objects have identical content, == compares their addresses, not values. To compare the contents of objects, use the .equals() method instead.</p> <pre><code>System.out.println(s1.equals(s2)); // true \u2192 same string content\n</code></pre> <p>Special Case: null and String Literals</p> <ul> <li>Any reference can be compared with null using == or !=.</li> </ul> <pre><code>String text = null;\nSystem.out.println(text == null);  // true\n</code></pre> <ul> <li>String literals are interned by the Java Virtual Machine (JVM): This means identical literal strings may point to the same reference in memory:</li> </ul> <p>```java String a = \"Java\"; String b = \"Java\"; System.out.println(a == b);       // true \u2192 same interned literal <pre><code>- Equality with Mixed Types:\nWhen using == between operands of different categories (e.g., primitive vs. object),\nthe compiler tries to perform unboxing if one of them is a **wrapper class**.\n\n```java\nInteger i = 100;\nint j = 100;\nSystem.out.println(i == j);   // true \u2192 unboxed before comparison\n</code></pre></p> <p></p>"},{"location":"en/module-01/java-operators/#576-the-instanceof-operator","title":"5.7.6 The <code>instanceof</code> Operator","text":"<p><code>instanceof</code> is a relational operator that tests whether a reference value is an instance of a given reference type at runtime. It returns a <code>boolean</code>.</p> <pre><code>Object o = \"Java\";\nboolean b1 = (o instanceof String);   // true\nboolean b2 = (o instanceof Number);   // false\n</code></pre> <p>null behavior: If expr is null, expr instanceof Type is always false.</p> <pre><code>Object n = null;\nSystem.out.println(n instanceof Object);  // false\n</code></pre> <p>Warning</p> <p><code>instanceof</code> always returns <code>false</code> when the left operand is <code>null</code>.</p> <p></p>"},{"location":"en/module-01/java-operators/#5761-compile-time-check-vs-runtime-check","title":"5.7.6.1 Compile-Time Check vs Runtime Check","text":"<ul> <li>At compile time, the compiler rejects inconvertible types (types that cannot possibly relate at runtime).</li> <li>At runtime, if the compile-time check passed, the JVM evaluates the actual object type.</li> </ul> <pre><code>// \u274c Compile-time error: inconvertible types (String is unrelated to Integer)\n\nboolean bad = (\"abc\" instanceof Integer);\n\n// \u2705 Compiles, but runtime result depends on actual object:\n\nNumber num = Integer.valueOf(10);\nSystem.out.println(num instanceof Integer); // true at runtime\nSystem.out.println(num instanceof Double);  // false at runtime\n</code></pre>"},{"location":"en/module-01/java-operators/#5762-pattern-matching-for-instanceof","title":"5.7.6.2 Pattern Matching for instanceof","text":"<p>Java supports type patterns with instanceof, which both test and bind the variable when the test succeeds. Adding a variable after the type instructs the compiler to treat it as Pattern Matching</p> <p>Syntax (pattern form):</p> <pre><code>Object obj = \"Hello\";\n\nif (obj instanceof String str) {\n    // Adding the variable str after the type instructs the compiler to treat it as Pattern Matching\n\n    System.out.println(str.toUpperCase()); // identifier is in scope here, of type Type: (safe: str is a String here). \n}\n</code></pre> <p>Key properties:</p> <ul> <li>If the test succeeds, the pattern variable (e.g., s) is definitely assigned and in scope in the true branch.</li> <li>Pattern variables are implicitly final (cannot be reassigned).</li> <li>The name must not clash with an existing variable in the same scope.</li> </ul> <p></p>"},{"location":"en/module-01/java-operators/#5763-flow-scoping-short-circuit-logic","title":"5.7.6.3 Flow Scoping &amp; Short-Circuit Logic","text":"<p>Pattern variables become available based on flow analysis:</p> <pre><code>Object obj = \"data\";\n\n// Negated test, variable available in the else branch\nif (!(obj instanceof String s)) {\n    // s not in scope here\n} else {\n    System.out.println(s.length()); // s is in scope here\n}\n\n// With &amp;&amp;, pattern variable can be used on the right side if the left side established it\nif (obj instanceof String s &amp;&amp; s.length() &gt; 3) {\n    System.out.println(s.substring(0, 3)); // s in scope\n}\n\n// With ||, the pattern variable is NOT safe on the right side (short-circuit may fail to establish it)\nif (obj instanceof String s || s.length() &gt; 3) {  // \u274c s not in scope here\n    // ...\n}\n\n// Parentheses can help group logic\nif ((obj instanceof String s) &amp;&amp; s.contains(\"a\")) { // \u2705 s in scope after grouped test\n    System.out.println(s);\n}\n</code></pre> <p>Pattern matching with <code>null</code> evaluates, like always for <code>instanceof</code>, to <code>false</code></p> <pre><code>String str = null;\n\n// Regular instanceof\nif (str instanceof String) {  \n    System.out.print(\"NOT EXECUTED\"); // instanceof evaluates to false\n}\n\n// Pattern matching\nif (str instanceof String s) {  \n    System.out.print(\"NOT EXECUTED\"); // instanceof still evaluates to false\n}\n</code></pre> <p>Supported Types:</p> <p>The type of the pattern variable must be a subtype, a supertype or of the same type of the reference variable.</p> <pre><code>Number num = Short.valueOf(10);\n\nif (num instanceof String s) {}  // \u274c Compile-time error\nif (num instanceof Short s) {}   // \u2705 Ok\nif (num instanceof Object s) {}  // \u2705 Ok\nif (num instanceof Number s) {}  // \u2705 Ok\n</code></pre> <p></p>"},{"location":"en/module-01/java-operators/#5764-arrays-and-reifiable-types","title":"5.7.6.4 Arrays and Reifiable Types","text":"<p>instanceof works with arrays (which are reifiable) and with erased or wildcard generic forms. Reifiable types are those whose runtime representation fully preserves their type (e.g., raw types, arrays, non-generic classes, wildcard ?).  Due to type erasure, List cannot be tested directly at runtime. <pre><code>Object arr = new int[]{1,2,3};\nSystem.out.println(arr instanceof int[]); // true\n\nObject list = java.util.List.of(1,2,3);\n// System.out.println(list instanceof List&lt;Integer&gt;); // \u274c Compile-time error: parameterized type not reifiable\nSystem.out.println(list instanceof java.util.List&lt;?&gt;); // \u2705 true\n</code></pre> <p></p>"},{"location":"en/module-01/java-operators/#58-ternary-operator","title":"5.8 Ternary Operator","text":"<p>The ternary operator (<code>? :</code>) is the only operator in Java that takes three operands. It acts as a concise form of an <code>if-else</code> statement.</p> <p></p>"},{"location":"en/module-01/java-operators/#581-type-rules-for-the-ternary-operator","title":"5.8.1 Type Rules for the Ternary Operator","text":"<p>The type of a conditional (ternary) expression is determined by the types of its second and third operands.</p> <p></p>"},{"location":"en/module-01/java-operators/#5811-numeric-operands","title":"5.8.1.1 Numeric Operands","text":"<ul> <li>If one operand is <code>byte</code> and the other is <code>short</code>, the result type is <code>short</code>.</li> <li>If one operand is of type <code>T</code> (<code>byte</code>, <code>short</code>, or <code>char</code>) and the other operand is an <code>int</code> constant expression whose value fits within type <code>T</code>, then the result type is <code>T</code>.</li> <li>In all other numeric cases, binary numeric promotion is applied to the second and third operands.   The type of the conditional expression becomes the promoted type.</li> </ul> <p>Binary numeric promotion includes unboxing conversion and value set conversion.</p> <p></p>"},{"location":"en/module-01/java-operators/#5812-reference-types","title":"5.8.1.2 Reference Types","text":"<ul> <li>If one operand is <code>null</code> and the other is a reference type, the result type is that reference type.</li> <li>If the operands are different reference types, one type must be assignment-compatible with the other.   The resulting type is the more general type (the one to which the other can be assigned).</li> <li>If neither type can be assigned to the other, the expression causes a compile-time error.</li> </ul> <p>In short, the ternary operator determines its type by applying:</p> <ul> <li>Special narrowing rules for small integral types  </li> <li>Binary numeric promotion for numeric values  </li> <li>Assignment compatibility rules for reference types  </li> </ul> <p>Tip</p> <p>The ternary operator must produce a value of a compatible type. If the two branches produce unrelated types, compilation fails.</p> <pre><code>String s = true ? \"ok\" : 5; // \u274c compile error: incompatible types\n</code></pre> <p></p>"},{"location":"en/module-01/java-operators/#582-syntax","title":"5.8.2 Syntax","text":"<pre><code>condition ? expressionIfTrue : expressionIfFalse;\n</code></pre>"},{"location":"en/module-01/java-operators/#583-example","title":"5.8.3 Example","text":"<pre><code>int age = 20;\nString access = (age &gt;= 18) ? \"Allowed\" : \"Denied\";\nSystem.out.println(access);  // \"Allowed\"\n</code></pre>"},{"location":"en/module-01/java-operators/#584-nested-ternary-example","title":"5.8.4 Nested Ternary Example","text":"<pre><code>int score = 85;\nString grade = (score &gt;= 90) ? \"A\" :\n               (score &gt;= 75) ? \"B\" :\n               (score &gt;= 60) ? \"C\" : \"F\";\nSystem.out.println(grade);  // \"B\"\n</code></pre>"},{"location":"en/module-01/java-operators/#585-notes","title":"5.8.5 Notes","text":"<p>Warning</p> <ul> <li>Nested ternary expressions can reduce readability. Use parentheses for clarity.</li> <li>The ternary operator returns a value, unlike <code>if-else</code>,</li> </ul>"},{"location":"en/module-01/naming-rules/","title":"3. Java Naming Rules","text":""},{"location":"en/module-01/naming-rules/#table-of-contents","title":"Table of Contents","text":"<ul> <li>3.1 Rules for Identifiers<ul> <li>3.1.1 Reserved Words<ul> <li>3.1.1.1 Java Reserved Keywords</li> <li>3.1.1.2 Reserved Literals</li> </ul> </li> <li>3.1.2 Case Sensitivity</li> <li>3.1.3 Beginning of Identifiers</li> <li>3.1.4 Numbers in Identifiers</li> <li>3.1.5 Single _ Token</li> <li>3.1.6 Numeric Literals &amp; Underscore Character</li> </ul> </li> </ul> <p>Java defines precise rules for identifiers, which are the names given to variables, methods, classes, interfaces, and packages.</p> <p>As long as you follow the naming rules described below, you are free to choose meaningful names for your program elements.</p> <p></p>"},{"location":"en/module-01/naming-rules/#31-rules-for-identifiers","title":"3.1 Rules for Identifiers","text":""},{"location":"en/module-01/naming-rules/#311-reserved-words","title":"3.1.1 Reserved Words","text":"<p><code>Identifiers</code> cannot be the same as Java\u2019s keywords or reserved literals.</p> <p><code>Keywords</code> are predefined, special words in the Java language which you are not allowed to use (see Table below).</p> <p><code>Literals</code> such as <code>true</code>, <code>false</code>, and <code>null</code> are also reserved and cannot be used as identifiers.</p> <ul> <li>Example: <pre><code>int class = 5;        // invalid: 'class' is a keyword\nboolean true = false; // invalid: 'true' is a literal\nint year = 2024;    // valid\n</code></pre></li> </ul> <p></p>"},{"location":"en/module-01/naming-rules/#3111-java-reserved-keywords","title":"3.1.1.1 Java Reserved Keywords","text":"a -&gt; c c -&gt; f f -&gt; n n -&gt; s s -&gt; w abstract continue for new switch assert default goto* package synchronized boolean do if private this break double implements protected throw byte else import public throws case enum instanceof return transient catch extends int short try char final interface static void class finally long strictfp volatile const* float native super while <p>Note</p> <p><code>goto</code> and <code>const</code> are reserved but not used.</p> <p></p>"},{"location":"en/module-01/naming-rules/#3112-reserved-literals","title":"3.1.1.2 Reserved Literals","text":"<ul> <li><code>true</code> </li> <li><code>false</code> </li> <li><code>null</code> </li> </ul>"},{"location":"en/module-01/naming-rules/#312-case-sensitivity","title":"3.1.2 Case Sensitivity","text":"<p>Identifiers in Java are case sensitive. This means <code>myVar</code>, <code>MyVar</code>, and <code>MYVAR</code> are all different identifiers.</p> <ul> <li>Example: <pre><code>int myVar = 1;\nint MyVar = 2;\nint MYVAR = 3;\nint CLASS = 6; // legal but, please, don't do it!!\n</code></pre></li> </ul> <p>Tip</p> <p>Java treats identifiers literally: Count, count, and COUNt are unrelated and may exist together.</p> <p>Because of case sensitivity, you could use versions of keywords which differ in case.  While legal, such naming is discouraged because it reduces readability and it is considered a very bad practice.</p> <p></p>"},{"location":"en/module-01/naming-rules/#313-beginning-of-identifiers","title":"3.1.3 Beginning of Identifiers","text":"<p>Identifiers in Java must begin with a letter, a currency symbol ( $, \u20ac, \u00a3, \u20b9...) or a _ symbol.   </p> <p>Example: <pre><code>int myVarA;\nint $myVarB;\nint _myVarC;\nString \u20acuro = \"currency\"; // legal (rarely seen in practice)\n</code></pre></p> <p>Note</p> <p>Currency symbols are legal but not recommended in real-world code.</p> <p></p>"},{"location":"en/module-01/naming-rules/#314-numbers-in-identifiers","title":"3.1.4 Numbers in Identifiers","text":"<p>Identifiers in Java can include numbers but they cannot start with them.   </p> <p>Example: <pre><code>int my33VarA;\nint $myVar44;\nint 3myVarC; // invalid: identifier cannot start with a digit\nint var2024 = 10; // valid\n</code></pre></p> <p></p>"},{"location":"en/module-01/naming-rules/#315-single-_-token","title":"3.1.5 Single <code>_</code> token","text":"<ul> <li>A single underscore (<code>_</code>) is not allowed as an identifier.</li> <li> <p>Since Java 9, <code>_</code> is a reserved token for future language use.</p> </li> <li> <p>Example: <pre><code>int _;  // invalid since Java 9\n</code></pre></p> </li> </ul> <p>Warning</p> <p><code>_</code> is legal inside number literals (see next section), but not as a standalone identifier.</p> <p></p>"},{"location":"en/module-01/naming-rules/#316-numeric-literals-underscore-character","title":"3.1.6 Numeric literals &amp; Underscore character","text":"<p>You can have one or more <code>_</code> (underscore) character in number literals in order to make them easier to read.</p> <p>You can have underscores anywhere except at the beginning, at the end or right around (before/after) a decimal point.</p> <ul> <li>Example: <pre><code>int firstNum = 1_000_000;\nint secondNum = 1 _____________ 2;\n\ndouble firstDouble = _1000.00   // DOES NOT COMPILE\ndouble secondDouble = 1000_.00  // DOES NOT COMPILE\ndouble thirdDouble = 1000._00   // DOES NOT COMPILE\ndouble fourthDouble = 1000.00_  // DOES NOT COMPILE\n\ndouble pi = 3.14_159_265; // valid\nlong mask = 0b1111_0000;  // valid in binary literals\n</code></pre></li> </ul> <p>Tip</p> <p>Underscores improve readability: 1_000_000 is easier than 1000000.</p>"},{"location":"en/module-01/syntax-building-blocks/","title":"1. Syntax Building Blocks","text":""},{"location":"en/module-01/syntax-building-blocks/#table-of-contents","title":"Table of Contents","text":"<ul> <li>1.1 Value</li> <li>1.2 Literal</li> <li>1.3 Identifier</li> <li>1.4 Variable</li> <li>1.5 Type</li> <li>1.6 Operator</li> <li>1.7 Expression</li> <li>1.8 Statement</li> <li>1.9 Code Block</li> <li>1.10 Function / Method</li> <li>1.11 Class / Object</li> <li>1.12 Module / Package</li> <li>1.13 Program</li> <li>1.14 System</li> <li>1.15 Summary as a Growing Scale</li> <li>1.16 Hierarchy Diagram ASCII</li> <li>1.17 Hierarchy Diagram Mermaid</li> </ul> <p>Every software system or computer program is composed of a set of data and a set of operations that are applied to this data in order to produce a result.</p> <p>More formally:</p> <p>A computer program consists of a collection of data structures that represent the state of the system, together with algorithms that specify the operations to be performed on this state in order to produce outputs.</p> <p>This document describes a hierarchy of abstractions: the elementary building blocks which, combined into increasingly complex structures, form software.</p> <p>The sequence is presented in increasing order of complexity, with general definitions (computer science) and Java references.</p> <p></p>"},{"location":"en/module-01/syntax-building-blocks/#11-value","title":"1.1 Value","text":"<ul> <li>Definition: An abstract entity representing information (number, character, boolean, string, etc.).</li> <li>Theory: A value belongs to a mathematical domain (set), such as \u2115 for natural numbers or \u03a3* for strings.</li> <li>Example (abstract): the number forty-two, the truth value true, the character \"a\".</li> </ul> <p>Java example (values):</p> <pre><code>// These are values:\n42        // an int value\ntrue      // a boolean value\n'a'       // a char value\n\"Hello\"   // a String value\n</code></pre> <p></p>"},{"location":"en/module-01/syntax-building-blocks/#12-literal","title":"1.2 Literal","text":"<ul> <li>Definition: A literal is the concrete notation in source code that directly denotes a fixed value.</li> <li>In Java: <code>42</code>, <code>'a'</code>, <code>true</code>, <code>\"Hello\"</code>.</li> <li>Theory: A literal is syntax, while a value is its semantics.</li> <li>Note: Literals are the most common way to introduce values into programs.</li> </ul> <p>Java example (literals):</p> <pre><code>int answer = 42;          // 42 is an int literal\nchar letter = 'a';        // 'a' is a char literal\nboolean flag = true;      // true is a boolean literal\nString msg = \"Hello\";     // \"Hello\" is a String literal\n</code></pre> <p></p>"},{"location":"en/module-01/syntax-building-blocks/#13-identifier","title":"1.3 Identifier","text":"<ul> <li>Definition: A symbolic name that associates a value (or a structure) with a readable label.</li> <li>In Java:<ul> <li>User-defined identifiers: chosen by the programmer to name variables, methods, classes, etc. Examples: <code>x</code>, <code>counter</code>, <code>MyClass</code>, <code>calculateSum</code>.</li> <li>Keywords (reserved words): predefined names reserved by the Java language and cannot be redefined. Examples: <code>class</code>, <code>public</code>, <code>static</code>, <code>if</code>, <code>return</code>.</li> </ul> </li> </ul> <p>Note</p> <p>Identifiers must follow Java naming rules: see Java Naming Rules.</p> <ul> <li>Theory: Binding function: connects a name to a value or resource.</li> </ul> <p>Java example (identifiers):</p> <pre><code>int counter = 0;          // counter is an identifier (variable name)\nString userName = \"Bob\";  // userName is an identifier\nclass MyService { }       // MyService is a class identifier\n</code></pre> <p></p>"},{"location":"en/module-01/syntax-building-blocks/#14-variable","title":"1.4 Variable","text":"<ul> <li>Definition: A \u201cmemory cell\u201d labeled by an identifier, which can hold and change value.</li> <li>In Java: <code>int counter = 0; counter = counter + 1;</code>.</li> <li>Theory: A mutable state that can vary over time during execution.</li> </ul> <p>Java example (variable changing over time):</p> <pre><code>int counter = 0;       // variable initialized\ncounter = counter + 1; // variable updated\ncounter++;             // another update (post-increment)\n</code></pre> <p></p>"},{"location":"en/module-01/syntax-building-blocks/#15-type","title":"1.5 Type","text":"<ul> <li>Definition: A type is a set of values and a set of operations permitted on those values.</li> <li>In Java:<ul> <li>Primitive (simple) types: directly represent basic values.   Examples: <code>int</code>, <code>double</code>, <code>boolean</code>, <code>char</code>, <code>byte</code>, <code>short</code>, <code>long</code>, <code>float</code>.</li> <li>Reference types: represent references (pointers) to objects in memory.   Examples: <code>String</code>, arrays (e.g., <code>int[]</code>), classes, interfaces, and user-defined types.</li> </ul> </li> </ul> <p>Note</p> <p>See Java Data Types.</p> <ul> <li>Theory: A type system is the set of rules that associates sets of values and admissible operations.</li> </ul> <p>Java example (types):</p> <pre><code>int age = 30;           // int type\ndouble price = 9.99;    // double type\nboolean active = true;  // boolean type\nString name = \"Alice\";  // reference type (class String)\n</code></pre> <p></p>"},{"location":"en/module-01/syntax-building-blocks/#16-operator","title":"1.6 Operator","text":"<ul> <li>Definition: A symbol or keyword that performs a computation or action on one or more operands.</li> <li>Role: Operators combine values, variables, and expressions to produce new values or to modify program state.</li> <li>In Java: </li> </ul> <p>Note</p> <p>See Java Operators.</p> <ul> <li>Theory: Operators define allowable computations over types; together with values and variables, they form expressions.</li> </ul> <p>Java example (operators in context):</p> <pre><code>int a = 5 + 3;          // + arithmetic\nboolean ok = a &gt; 3;     // &gt; comparison\nok = ok &amp;&amp; true;        // &amp;&amp; logical\na += 2;                 // += assignment\nint sign = (a &gt;= 0) ? 1 : -1; // ?: ternary\n</code></pre> <p></p>"},{"location":"en/module-01/syntax-building-blocks/#17-expression","title":"1.7 Expression","text":"<ul> <li>Definition: A combination of values, literals, variables, operators, and functions that produces a new value.</li> <li>In Java: <code>x + 3</code>, <code>Math.sqrt(25)</code>, <code>\"Hello\" + \" world\"</code>.</li> <li>Theory: A syntax tree that evaluates to a result.</li> </ul> <p>Java example (expressions):</p> <pre><code>int x = 10;\nint y = x + 3;               // x + 3 is an expression\ndouble r = Math.sqrt(25);    // Math.sqrt(25) is an expression\nString msg = \"Hello\" + \" \";  // \"Hello\" + \" \" is an expression\nmsg = msg + \"world\";         // msg + \"world\" is another expression\n</code></pre> <p></p>"},{"location":"en/module-01/syntax-building-blocks/#18-statement","title":"1.8 Statement","text":"<ul> <li>Definition: A unit of execution that modifies state or controls flow.</li> <li>In Java: <code>x = x + 1;</code>, <code>if (x &gt; 0) { ... }</code>.</li> <li>Theory: A sequence of actions that does not return a value as a result of the statement itself, but changes the configuration of the abstract machine.</li> </ul> <p>Java example (statements):</p> <pre><code>int x = 0;                // declaration statement\nx = x + 1;                // assignment statement\n\nif (x &gt; 0) {              // if statement\n    System.out.println(\"Positive\");\n}\n</code></pre> <p></p>"},{"location":"en/module-01/syntax-building-blocks/#19-code-block","title":"1.9 Code Block","text":"<ul> <li>Definition: A set of statements enclosed between delimiters forming an executable unit.</li> <li>In Java: <code>{ int y = 5; x = x + y; }</code>.</li> <li>Theory: A sequential composition of statements, with rules of scope (visibility).</li> </ul> <p>Java example (code block and scope):</p> <pre><code>int x = 10;\n\n{\n    int y = 5;        // y is only visible inside this block\n    x = x + y;        // OK: x is visible here\n}\n\n// y is not visible here\n// x is still visible here\n</code></pre> <p></p>"},{"location":"en/module-01/syntax-building-blocks/#110-function-method","title":"1.10  Function / Method","text":"<ul> <li>Definition: A sequence of encapsulated statements, identified by a name, which can receive inputs (parameters) and return an output (value).</li> <li>In Java:</li> </ul> <pre><code>int square(int n) {\n    return n * n;\n}\n</code></pre> <ul> <li>Theory: A mapping between input and output domains, with an operational body.</li> </ul> <p>Java usage example:</p> <pre><code>int result = square(5); // result = 25\n</code></pre> <p></p>"},{"location":"en/module-01/syntax-building-blocks/#111-class-object","title":"1.11 Class / Object","text":"<ul> <li>Definition:</li> <li> <ul> <li>Class: abstract description of a set of objects (state + behavior).</li> </ul> </li> <li> <ul> <li>Object: a concrete instance of the class.</li> </ul> </li> <li> <p>In Java:</p> </li> </ul> <pre><code>class Point {\n    int x, y;\n\n    void move(int dx, int dy) {\n        x += dx;\n        y += dy;\n    }\n}\n\nPoint p = new Point();   // p is an object (instance of Point)\np.move(1, 2);            // method call on the object\n</code></pre> <ul> <li>Theory: Abstraction of an ADT (Abstract Data Type).</li> </ul> <p></p>"},{"location":"en/module-01/syntax-building-blocks/#112-module-package","title":"1.12 Module / Package","text":"<ul> <li>Definition: Logical grouping of classes, functions, and resources with a common purpose.</li> <li>In Java: <code>package java.util;</code> \u2192 collects utilities.</li> <li>Theory: Mechanism of organization and reuse, reducing complexity.</li> </ul> <p>Java example (package):</p> <pre><code>package com.example.app;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Hello\");\n    }\n}\n</code></pre> <p></p>"},{"location":"en/module-01/syntax-building-blocks/#113-program","title":"1.13 Program","text":"<ul> <li>Definition: A coherent set of modules, classes, and functions that, when executed on a machine, realizes a global behavior.</li> <li>In Java: The <code>main</code> method and everything it invokes.</li> <li>Theory: A specification of transformations from input to output on an abstract machine.</li> </ul> <p>Java example (minimal program):</p> <pre><code>public class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, Java 21!\");\n    }\n}\n</code></pre> <p></p>"},{"location":"en/module-01/syntax-building-blocks/#114-system","title":"1.14 System","text":"<ul> <li>Definition: A set of cooperating programs that interact with external resources (user, network, devices).</li> <li>Example: An enterprise Java platform with database, REST services, UI.</li> <li>Theory: Complex architecture of software and hardware components.</li> </ul> <p>Example (conceptual):</p> <ul> <li>A Java backend (Spring Boot service)</li> <li>A database (PostgreSQL)</li> <li>A front-end web app</li> <li>External services (REST APIs, message queues)</li> </ul> <p>Together they form a system.</p> <p></p>"},{"location":"en/module-01/syntax-building-blocks/#115-summary-as-a-growing-scale","title":"1.15 \ud83d\udccc Summary as a Growing Scale","text":"<p><code>Value \u2192 Literal \u2192 Identifier \u2192 Variable \u2192 Type \u2192 Operator \u2192 Expression \u2192 Statement \u2192 Code Block \u2192 Function/Method \u2192 Class/Object \u2192 Module/Package \u2192 Program \u2192 System</code></p> <p>This scale shows how small conceptual units are combined into larger and more complex structures.</p> <p></p>"},{"location":"en/module-01/syntax-building-blocks/#116-hierarchy-diagram-ascii","title":"1.16 \ud83d\udcca Hierarchy Diagram (ASCII)","text":"<p>Description: This ASCII diagram shows the hierarchical relation between building blocks, from the most complex (System) down to the simplest (Value and its concrete form, the Literal).</p> <pre><code>System\n\u2514\u2500\u2500 Program\n    \u2514\u2500\u2500 Module / Package\n        \u2514\u2500\u2500 Class / Object\n            \u2514\u2500\u2500 Function / Method\n                \u2514\u2500\u2500 Code Block\n                    \u2514\u2500\u2500 Statement\n                        \u2514\u2500\u2500 Expression\n                            \u2514\u2500\u2500 Operator\n                                \u2514\u2500\u2500 Type\n                                    \u2514\u2500\u2500 Variable\n                                        \u2514\u2500\u2500 Identifier\n                                            \u2514\u2500\u2500 Literal\n                                                \u2514\u2500\u2500 Value\n</code></pre> <p></p>"},{"location":"en/module-01/syntax-building-blocks/#117-hierarchy-diagram-mermaid","title":"1.17 \ud83d\udcca Hierarchy Diagram (Mermaid)","text":"<p>Description: The Mermaid diagram renders the same hierarchy in a top-down tree. It highlights that a Literal is the syntactic form of a Value.</p> <pre><code>graph TD\n    A[System]\n    A --&gt; B[Program]\n    B --&gt; C[Module / Package]\n    C --&gt; D[Class / Object]\n    D --&gt; E[Function / Method]\n    E --&gt; F[Code Block]\n    F --&gt; G[Statement]\n    G --&gt; H[Expression]\n    H --&gt; H2[Operator]\n    H2 --&gt; I[Type]\n    I --&gt; J[Variable]\n    J --&gt; K[Identifier]\n    K --&gt; L[Literal]\n    L --&gt; M[Value]\n</code></pre>"},{"location":"en/module-02/control-flow/","title":"7. Control Flow","text":""},{"location":"en/module-02/control-flow/#table-of-contents","title":"Table of Contents","text":"<ul> <li>7.1 The if Statement</li> <li>7.2 The switch Statement &amp; Expression<ul> <li>7.2.1 The switch target variable can be</li> <li>7.2.2 Acceptable Case Values</li> <li>7.2.3 Type Compatibility Between Selector and Case</li> <li>7.2.4 Pattern Matching in Switch<ul> <li>7.2.4.1 Variable Names and Scope Across Branches</li> <li>7.2.4.2 Ordering Dominance and Exhaustiveness in Pattern Switches</li> </ul> </li> </ul> </li> <li>7.3 Two Forms of switch Statement vs switch Expression<ul> <li>7.3.1 The Switch Statement<ul> <li>7.3.1.1 Fall-Through Behavior</li> </ul> </li> <li>7.3.2 The Switch Expression<ul> <li>7.3.2.1 yield in Switch Expression Blocks</li> <li>7.3.2.2 Exhaustiveness for Switch Expressions</li> </ul> </li> </ul> </li> <li>7.4 Null Handling</li> </ul> <p>Control flow in Java refers to the order in which individual statements, instructions, or method calls are executed during program runtime. </p> <p>By default, statements run sequentially from top to bottom, but control flow statements allow the program to make decisions, repeat actions, or branch execution paths based on conditions.</p> <p>Java provides three main categories of control flow constructs:</p> <ul> <li>Decision-making statements \u2014 <code>if</code>, <code>if-else</code>, <code>switch</code></li> <li>Looping statements \u2014 <code>for</code>, <code>while</code>, <code>do-while</code>, and the enhanced <code>for</code></li> <li>Branching statements \u2014 <code>break</code>, <code>continue</code>, and <code>return</code></li> </ul> <p>Tip</p> <p>Understanding control flow is essential to seeing how data moves through your program and how each logic decision is evaluated step by step.</p> <p></p>"},{"location":"en/module-02/control-flow/#71-the-if-statement","title":"7.1 The <code>if</code> Statement","text":"<p>The <code>if</code> statement is a conditional control-flow structure that executes a block of code only if a specified boolean expression evaluates to <code>true</code>. It allows the program to make decisions at runtime.</p> <p>Syntax:</p> <pre><code>if (condition) {\n    // executed only when condition is true\n}\n</code></pre> <p>An optional <code>else</code> clause handles the alternative path:</p> <pre><code>if (score &gt;= 60) {\n    System.out.println(\"Passed\");\n} else {\n    System.out.println(\"Failed\");\n}\n</code></pre> <p>Multiple conditions can be chained using <code>else if</code>:</p> <pre><code>if (grade &gt;= 90) {\n    System.out.println(\"A\");\n} else if (grade &gt;= 80) {\n    System.out.println(\"B\");\n} else if (grade &gt;= 70) {\n    System.out.println(\"C\");\n} else {\n    System.out.println(\"D or below\");\n}\n</code></pre> <p>Note</p> <p>The <code>if</code> condition must evaluate to a boolean; numeric or object types cannot be used directly as conditions.</p> <p>Curly braces <code>{}</code> are optional for single statements but strongly recommended to prevent subtle logic errors.</p> <p>An <code>if-else</code> chain is evaluated from top to bottom, and only the first branch with a condition evaluating to <code>true</code> is executed.</p> <p></p>"},{"location":"en/module-02/control-flow/#72-the-switch-statement-expression","title":"7.2 The <code>switch</code> Statement &amp; Expression","text":"<p>The <code>switch</code> construct is a control-flow structure that selects one branch among multiple alternatives based on the value of an expression (the selector).</p> <p>Compared to long chains of <code>if-else-if</code>, a <code>switch</code>:</p> <ul> <li>Is often easier to read when testing many discrete values (constants, enums, strings).</li> <li>Can be safer and more concise when used as a switch expression </li> </ul> <p>because:</p> <ul> <li>It produces a value.</li> <li>The compiler can enforce exhaustiveness and type consistency.</li> </ul> <p>Java 21 supports:</p> <ul> <li>The classic <code>switch</code> statement (control flow only).</li> <li>The <code>switch</code> expression (produces a result).</li> <li>Pattern matching inside <code>switch</code>, including type patterns and guards.</li> </ul> <p>Both forms of <code>switch</code> share the same rules concerning the selector (switch target variable) and acceptable case values.</p> <p></p>"},{"location":"en/module-02/control-flow/#721-the-switch-target-variable-can-be","title":"7.2.1 The switch <code>target variable</code> can be","text":"Control Variable type <code>byte</code> / <code>Byte</code> <code>short</code> / <code>Short</code> <code>char</code> / <code>Character</code> <code>int</code> / <code>Integer</code> <code>String</code> Enum types (selectors of an <code>enum</code>) Any reference type (with pattern matching) <code>var</code> (if it resolves to one of the allowed types) <p>Warning</p> <p>Not allowed as selector types for switch:</p> <ul> <li><code>boolean</code></li> <li><code>long</code></li> <li><code>float</code></li> <li><code>double</code></li> </ul> <p></p>"},{"location":"en/module-02/control-flow/#722-acceptable-case-values","title":"7.2.2 Acceptable <code>case</code> Values","text":"<p>For a non-pattern switch, each <code>case</code> label must be a compile-time constant compatible with the selector type.</p> <p>Allowed as case labels:</p> <ul> <li>Literals such as <code>0</code>, <code>'A'</code>, <code>\"ON\"</code>.</li> <li>Enum constants, e.g., <code>RED</code> or <code>Color.GREEN</code>.</li> <li>Final constant variables (compile-time constants).</li> </ul> <p>A compile-time constant variable:</p> <ul> <li>Must be declared with <code>final</code> and initialized in the same statement.</li> <li>Its initializer must itself be a constant expression (typically using literals and other compile-time constants).</li> </ul> <p></p>"},{"location":"en/module-02/control-flow/#723-type-compatibility-between-selector-and-case","title":"7.2.3 Type Compatibility Between Selector and Case","text":"<p>The selector type and each <code>case</code> label must be compatible:</p> <ul> <li>Numeric case constants must be within the range of the selector type.</li> <li>For an <code>enum</code> selector, case labels must be constants of that <code>enum</code>.</li> <li>For a <code>String</code> selector, case labels must be string constants.</li> </ul> <p></p>"},{"location":"en/module-02/control-flow/#724-pattern-matching-in-switch","title":"7.2.4 Pattern Matching in Switch","text":"<p>Switch in Java 21 supports pattern matching, including:</p> <ul> <li>Type patterns: <code>case String s</code></li> <li>Guarded patterns: <code>case String s when s.length() &gt; 3</code></li> <li>Null pattern: <code>case null</code></li> </ul> <p>Example:</p> <pre><code>String describe(Object o) {\n    return switch (o) {\n        case null -&gt; \"null\";\n        case Integer i -&gt; \"int \" + i;\n        case String s when s.isEmpty() -&gt; \"empty string\";\n        case String s -&gt; \"string (\" + s.length() + \")\";\n        default -&gt; \"other\";\n    };\n}\n</code></pre> <p>Key points:</p> <ul> <li>Each pattern introduces a pattern variable (such as <code>i</code> or <code>s</code>).</li> <li>Pattern variables are in scope only within their own arm (or paths where the pattern is known to match).</li> <li>Order matters because of dominance: more specific patterns must precede more general ones.</li> </ul> <p></p>"},{"location":"en/module-02/control-flow/#7241-variable-names-and-scope-across-branches","title":"7.2.4.1 Variable Names and Scope Across Branches","text":"<p>With pattern matching, the pattern variable exists only in the scope of the arm in which it is defined. This means you can reuse the same variable name in different case branches.</p> <ul> <li>Example:</li> </ul> <pre><code>switch (o) {\n    case String str -&gt; System.out.println(str.length());\n    case CharSequence str -&gt; System.out.println(str.charAt(0));\n    default -&gt; { }\n}\n</code></pre> <p>Note</p> <p>This last example does not return a value, so it is a statement switch, not a switch expression.</p> <p></p>"},{"location":"en/module-02/control-flow/#7242-ordering-dominance-and-exhaustiveness-in-pattern-switches","title":"7.2.4.2 Ordering, Dominance and Exhaustiveness in Pattern Switches","text":"<p>When dealing with pattern matching, the ordering of branches is crucial because of dominance and potential unreachable code.</p> <p>A more general pattern must not appear before a more specific one, or the specific one becomes unreachable.</p> <ul> <li>Example (unreachable branch):</li> </ul> <pre><code>return switch (o) {\n    case Object obj -&gt; \"object\";\n    case String s -&gt; \"string\"; // \u274c DOES NOT COMPILE: unreachable, String is already matched by Object\n};\n</code></pre> <ul> <li>Another example with a guard:</li> </ul> <pre><code>return switch (o) {\n    case Integer a -&gt; \"First\";\n    case Integer a when a &gt; 0 -&gt; \"Second\"; // \u274c DOES NOT COMPILE: unreachable, the first case matches all Integers\n    // ...\n};\n</code></pre> <p>When using pattern matching, switches must be exhaustive; that is, they must handle all possible selector values.</p> <p>This can be achieved by:</p> <ul> <li>Providing a <code>default</code> case that handles all values not matched by any other case.</li> <li> <p>Providing a final case clause with a pattern type that matches the selector reference type.</p> </li> <li> <p>Example (not exhaustive):</p> </li> </ul> <pre><code>Number number = Short.valueOf(10);\n\nswitch (number) {\n    case Short s -&gt; System.out.println(\"A\"); // \u274c DOES NOT COMPILE: not exhaustive, selector is of type Number\n}\n</code></pre> <p>To fix this, you can:</p> <ul> <li>Change the reference type of <code>number</code> to <code>Short</code> (then exhaustiveness is satisfied by the single case).</li> <li>Add a <code>default</code> clause that covers all remaining values.</li> <li>Add a final case clause covering the type of the selector variable, for example:</li> </ul> <pre><code>Number number = Short.valueOf(10);\n\nswitch (number) {\n    case Short s -&gt; System.out.println(\"A\");\n    case Number n -&gt; System.out.println(\"B\");\n}\n</code></pre> <p>Warning</p> <p>The following example, which uses both a <code>default</code> clause and a final clause with the same type as the selector variable, does not compile: the compiler considers one of the two cases as always dominating the other.</p> <pre><code>Number number = Short.valueOf(10);\n\nswitch (number) {\n    case Short s -&gt; System.out.println(\"A\");\n    case Number n -&gt; System.out.println(\"B\"); // \u274c DOES NOT COMPILE: dominated by either the default or the Number pattern\n    default -&gt; System.out.println(\"C\");\n}\n</code></pre> <p></p>"},{"location":"en/module-02/control-flow/#73-two-forms-of-switch-switch-statement-vs-switch-expression","title":"7.3 Two Forms of <code>switch</code>: <code>switch</code> Statement vs <code>switch</code> Expression","text":""},{"location":"en/module-02/control-flow/#731-the-switch-statement","title":"7.3.1 The Switch Statement","text":"<p>A switch statement is used as a control-flow construct. </p> <p>It does not, by itself, evaluate to a value, although its branches may contain <code>return</code> statements that return from the enclosing method.</p> <pre><code>switch (mode) { // switch statement\n    case \"ON\":\n        start();\n        break; // prevents fall-through\n    case \"OFF\":\n        stop();\n        break;\n    default:\n        reset();\n}\n</code></pre> <p>Key points:</p> <ul> <li>Each <code>case</code> clause includes one or more matching values separated by commas <code>,</code>. A separator follows, which can be either a colon <code>:</code> or, less commonly for statements, the arrow operator <code>-&gt;</code>. Finally, an expression or a block (enclosed in <code>{}</code>) defines the code to execute when a match occurs. If you use the arrow operator for one clause, you must use it for all clauses in that switch statement.</li> <li>Fall-through is possible for colon-style cases unless a branch uses <code>break</code>, <code>return</code>, or <code>throw</code>. When present, <code>break</code> terminates the switch after executing its case; without it, execution continues, in order, into the following branches.</li> <li>A <code>default</code> clause is optional and can appear anywhere in the switch statement. It runs if there is no match for previous cases.</li> <li>A switch statement does not yield a value as an expression; you cannot assign a switch statement directly to a variable.</li> </ul> <p></p>"},{"location":"en/module-02/control-flow/#7311-fall-through-behavior","title":"7.3.1.1 Fall-Through Behavior","text":"<p>With colon-style cases, execution jumps to the matching case label. </p> <p>If there is no <code>break</code>, it continues into the next case until a <code>break</code>, <code>return</code>, or <code>throw</code> is encountered.</p> <pre><code>int n = 2;\n\nswitch (n) {\n    case 1:\n        System.out.println(\"1\");\n    case 2:\n        System.out.println(\"2\"); // printed\n    case 3:\n        System.out.println(\"3\"); // printed (fall-through)\n        break;\n    default:\n        System.out.println(\"message default\");\n}\n</code></pre> <p>Output:</p> <pre><code>2\n3\n</code></pre> <p>Note</p> <p>If in the previous example we remove the <code>break</code> on <code>case 3</code>, the message from the <code>default</code> branch will also be printed.</p> <p></p>"},{"location":"en/module-02/control-flow/#732-the-switch-expression","title":"7.3.2 The Switch Expression","text":"<p>A switch expression always produces a single value as its result.</p> <ul> <li>Example:</li> </ul> <pre><code>int len = switch (s) { // switch expression\n    case null -&gt; 0;\n    case \"\" -&gt; 0;\n    default -&gt; s.length();\n};\n</code></pre> <p>Key points:</p> <ul> <li>Each <code>case</code> clause includes one or more matching values separated by commas <code>,</code>, followed by the arrow operator <code>-&gt;</code>. Then an expression or a block (enclosed in <code>{}</code>) defines the result for that arm.</li> <li>When used with an assignment or a <code>return</code> statement, a switch expression requires a terminating semicolon <code>;</code> after the expression.</li> <li>There is no fall-through between arrow arms. Each matching arm executes exactly once.</li> <li>A switch expression must be exhaustive: all possible selector values must be covered (via explicit cases and/or <code>default</code>).</li> <li>The result type must be consistent across all branches. For example, if one arm yields an <code>int</code>, the other arms must yield values compatible with <code>int</code>.</li> </ul> <p></p>"},{"location":"en/module-02/control-flow/#7321-yield-in-switch-expression-blocks","title":"7.3.2.1 <code>yield</code> in Switch Expression Blocks","text":"<p>When an arm of a switch expression uses a block instead of a single expression, you must use <code>yield</code> to provide the result of that arm.</p> <pre><code>int len = switch (s) {\n    case null -&gt; 0;\n    default -&gt; {\n        int l = s.trim().length();\n        System.out.println(\"Length: \" + l);\n        yield l; // result of this arm\n    }\n};\n</code></pre> <p>Note</p> <p><code>yield</code> is used only in switch expressions. <code>break value;</code> is not allowed as a way to return a value from a switch expression.</p> <p></p>"},{"location":"en/module-02/control-flow/#7322-exhaustiveness-for-switch-expressions","title":"7.3.2.2 Exhaustiveness for Switch Expressions","text":"<p>Because a switch expression must return a value, it must also be exhaustive; in other words, it must handle all possible selector values.</p> <p>You can ensure this by:</p> <ul> <li>Providing a <code>default</code> case.</li> <li>For an enum selector: covering all enum constants explicitly.</li> <li>For sealed types or pattern switches: covering all permitted subtypes or providing a <code>default</code>.</li> </ul> <p>Example, exhaustive via <code>default</code>:</p> <pre><code>int val = switch (s) {\n    case \"one\" -&gt; 1;\n    case \"two\" -&gt; 2;\n    default -&gt; 0;\n};\n</code></pre> <p></p>"},{"location":"en/module-02/control-flow/#74-null-handling","title":"7.4 Null Handling","text":"<p>Classic switch (without patterns)</p> <p>If the selector expression of a classic switch (without pattern matching) evaluates to <code>null</code>, a <code>NullPointerException</code> is thrown at runtime.</p> <p>To avoid this, check for <code>null</code> before switching:</p> <pre><code>if (s == null) {\n    // handle null\n} else {\n    switch (s) {\n        case \"A\" -&gt; ...\n        default -&gt; ...\n    }\n}\n</code></pre> <p>Pattern switch (with <code>case null</code>)</p> <p>With pattern matching, you can handle <code>null</code> directly inside the switch:</p> <pre><code>int len = switch (s) {\n    case null -&gt; 0;\n    default -&gt; s.length();\n};\n</code></pre> <p>Note</p> <p>For switch expressions:</p> <p>If you do not handle <code>null</code> and the selector is <code>null</code>, a <code>NullPointerException</code> is thrown.</p> <p>Using <code>case null</code> makes the switch explicitly null-safe.</p> <p>Warning</p> <p>Any time <code>case null</code> is used in a switch, the switch is treated as a pattern switch, and all the rules for pattern switches (including exhaustiveness and dominance) apply.</p>"},{"location":"en/module-02/loops/","title":"8. Looping Constructs in Java","text":""},{"location":"en/module-02/loops/#table-of-contents","title":"Table of Contents","text":"<ul> <li>8.1 The while Loop</li> <li>8.2 The do-while Loop</li> <li>8.3 The for Loop</li> <li>8.4 The Enhanced for-each Loop</li> <li>8.5 Nested Loops</li> <li>8.6 Infinite Loops</li> <li>8.7 break and continue</li> <li>8.8 Labeled Loops</li> <li>8.9 Loop Variable Scope</li> <li>8.10 Unreachable Code After break continue and return<ul> <li>8.10.1 Unreachable Code After break</li> <li>8.10.2 Unreachable Code After continue</li> <li>8.10.3 Unreachable Code After return</li> </ul> </li> </ul> <p>Java provides several looping constructs that allow repeated execution of a block of code as long as a condition holds. </p> <p>Loops are essential for iteration, traversal of data structures, repeated computations, and implementing algorithms.</p> <p></p>"},{"location":"en/module-02/loops/#81-the-while-loop","title":"8.1 The <code>while</code> Loop","text":"<p>The <code>while</code> loop evaluates its boolean condition before each iteration. If the condition is <code>false</code> from the beginning, the body is never executed.</p> <p>Syntax <pre><code>while (condition) {\n    // loop body\n}\n</code></pre></p> <ul> <li>The condition must evaluate to a boolean.</li> <li>The loop may execute zero or more times.</li> <li> <p>Common pitfalls include forgetting to update the loop variable, causing an infinite loop.</p> </li> <li> <p>Example: <pre><code>int i = 0;\nwhile (i &lt; 3) {\n    System.out.println(i);\n    i++;\n}\n</code></pre></p> </li> </ul> <p>Output: <pre><code>0\n1\n2\n</code></pre></p> <p></p>"},{"location":"en/module-02/loops/#82-the-do-while-loop","title":"8.2 The <code>do-while</code> Loop","text":"<p>The <code>do-while</code> loop evaluates its condition after executing the body, ensuring the body runs at least once.</p> <p>Syntax <pre><code>do {\n    // loop body\n} while (condition);\n</code></pre></p> <p>Tip</p> <p><code>do-while</code> requires a semicolon after the closing parenthesis.</p> <ul> <li>Example: <pre><code>int x = 5;\ndo {\n    System.out.println(x);\n    x--;\n} while (x &gt; 5); // body runs once even though condition is false\n</code></pre></li> </ul> <p>Output: <pre><code>5\n</code></pre></p> <p></p>"},{"location":"en/module-02/loops/#83-the-for-loop","title":"8.3 The <code>for</code> Loop","text":"<p>The traditional <code>for</code> loop is best suited for loops with a counter variable. It consists of three parts: initialization, condition, update.</p> <p>Syntax <pre><code>for (initialization; condition; update) {\n    // loop body\n}\n</code></pre></p> <ul> <li>Initialization runs once before the loop starts.</li> <li>Condition is evaluated before each iteration.</li> <li>Update runs after each iteration.</li> <li>Initialization and update may contain multiple statements separated by commas.</li> <li>Variables in initialization must all be of the same type.</li> <li> <p>Any component may be omitted, but semicolons remain.</p> </li> <li> <p>Example: <pre><code>for (int i = 0; i &lt; 3; i++) {\n    System.out.println(i);\n}\n</code></pre></p> </li> </ul> <p>Omitting parts: <pre><code>int j = 0;\nfor (; j &lt; 3;) {  // valid\n    j++;\n}\n</code></pre></p> <p>Multiple statements: <pre><code>int x = 0;\nfor (long i = 0, c = 3; x &lt; 3 &amp;&amp; i &lt; 12; x++, i++) {\n    System.out.println(i);\n}\n</code></pre></p> <p></p>"},{"location":"en/module-02/loops/#84-the-enhanced-for-each-loop","title":"8.4 The Enhanced <code>for-each</code> Loop","text":"<p>The enhanced <code>for</code> simplifies iteration over arrays and collections.</p> <p>Syntax <pre><code>for (ElementType var : arrayOrCollection) {\n    // loop body\n}\n</code></pre></p> <ul> <li>Loop variable is read-only relative to the underlying collection.</li> <li>Works with any <code>Iterable</code> or array.</li> <li> <p>Cannot remove elements without an iterator.</p> </li> <li> <p>Example: <pre><code>String[] names = {\"A\", \"B\", \"C\"};\nfor (String n : names) {\n    System.out.println(n);\n}\n</code></pre></p> </li> </ul> <p>Output: <pre><code>A\nB\nC\n</code></pre></p> <p></p>"},{"location":"en/module-02/loops/#85-nested-loops","title":"8.5 Nested Loops","text":"<p>Loops may be nested; each maintains its own variables and conditions.</p> <pre><code>for (int i = 1; i &lt;= 2; i++) {\n    for (int j = 1; j &lt;= 3; j++) {\n        System.out.println(i + \",\" + j);\n    }\n}\n</code></pre> <p>Output: <pre><code>1,1\n1,2\n1,3\n2,1\n2,2\n2,3\n</code></pre></p> <p></p>"},{"location":"en/module-02/loops/#86-infinite-loops","title":"8.6 Infinite Loops","text":"<p>A loop is infinite when its condition always evaluates to <code>true</code> or is omitted.</p> <pre><code>while (true) { ... }\n</code></pre> <pre><code>for (;;) { ... }\n</code></pre> <p>Tip</p> <p>Infinite loops must contain <code>break</code>, <code>return</code>, or external control.</p> <p></p>"},{"location":"en/module-02/loops/#87-break-and-continue","title":"8.7 <code>break</code> and <code>continue</code>","text":"<p>break Exits the innermost loop immediately. <pre><code>for (int i = 0; i &lt; 5; i++) {\n    if (i == 2) break;\n    System.out.println(i);\n}\n</code></pre></p> <p>continue Skips the rest of the loop body and continues to next iteration. <pre><code>for (int i = 0; i &lt; 5; i++) {\n    if (i % 2 == 0) continue;\n    System.out.println(i);\n}\n</code></pre></p> <p>Note</p> <p><code>break</code> and <code>continue</code> apply to the nearest loop unless labels are used.</p> <p></p>"},{"location":"en/module-02/loops/#88-labeled-loops","title":"8.8 Labeled Loops","text":"<p>A label (identifier + colon) may be applied to a loop to allow break/continue to affect outer loops.</p> <pre><code>labelName:\nfor (...) {\n    for (...) {\n        break labelName;\n    }\n}\n</code></pre> <ul> <li>Example: <pre><code>outer:\nfor (int i = 1; i &lt;= 3; i++) {\n    for (int j = 1; j &lt;= 3; j++) {\n        if (j == 2) break outer;\n        System.out.println(i + \",\" + j);\n    }\n}\n</code></pre></li> </ul> <p></p>"},{"location":"en/module-02/loops/#89-loop-variable-scope","title":"8.9 Loop Variable Scope","text":"<ul> <li>Variables declared in the loop header are scoped to that loop.</li> <li>Variables declared inside the body exist only inside that block.</li> </ul> <pre><code>for (int i = 0; i &lt; 3; i++) {\n    int x = i * 2;\n}\n// i and x are not accessible here\n</code></pre>"},{"location":"en/module-02/loops/#810-unreachable-code-after-break-continue-and-return","title":"8.10 Unreachable code after <code>break</code>, <code>continue</code>, and <code>return</code>","text":"<p>Any statement placed after <code>break</code>, <code>continue</code>, or <code>return</code> in the same block is considered unreachable and will not compile.</p> <p></p>"},{"location":"en/module-02/loops/#8101-unreachable-code-after-break","title":"8.10.1 Unreachable Code After <code>break</code>","text":"<pre><code>for (int i = 0; i &lt; 3; i++) {\n    break;\n    System.out.println(\"Unreachable\"); // \u274c Compile-time error\n}\n</code></pre>"},{"location":"en/module-02/loops/#8102-unreachable-code-after-continue","title":"8.10.2 Unreachable Code After <code>continue</code>","text":"<pre><code>for (int i = 0; i &lt; 3; i++) {\n    continue;\n    System.out.println(\"Unreachable\"); // \u274c Compile-time error\n}\n</code></pre> <p>Note</p> <p><code>continue</code> jumps to the next iteration, so following code is never executed.</p> <p></p>"},{"location":"en/module-02/loops/#8103-unreachable-code-after-return","title":"8.10.3 Unreachable Code After <code>return</code>","text":"<pre><code>int test() {\n    return 5;\n    System.out.println(\"Unreachable\"); // \u274c Compile-time error\n}\n</code></pre> <p>Note</p> <p><code>return</code> exits the method immediately; no statements can follow.</p>"},{"location":"en/module-03/arrays/","title":"10. Arrays in Java","text":""},{"location":"en/module-03/arrays/#table-of-contents","title":"Table of Contents","text":"<ul> <li>10.1 What an Array Is<ul> <li>10.1.1 Declaring Arrays</li> <li>10.1.2 Creating Arrays Instantiation</li> <li>10.1.3 Default Values in Arrays</li> <li>10.1.4 Accessing Elements</li> <li>10.1.5 Array Initialization Shorthands<ul> <li>10.1.5.1 Anonymous Array Creation</li> <li>10.1.5.2 Short Syntax Only at Declaration</li> </ul> </li> </ul> </li> <li>10.2 Multidimensional Arrays Arrays of Arrays<ul> <li>10.2.1 Creating a Rectangular Array</li> <li>10.2.2 Creating a Jagged Irregular Array</li> </ul> </li> <li>10.3 Array Length vs String Length</li> <li>10.4 Array Reference Assignments<ul> <li>10.4.1 Assigning Compatible References</li> <li>10.4.2 Incompatible Assignments Compile-Time Errors</li> <li>10.4.3 Covariance Runtime Danger ArrayStoreException</li> </ul> </li> <li>10.5 Comparing Arrays</li> <li>10.6 Arrays Utility Methods<ul> <li>10.6.1 Arrays.toString</li> <li>10.6.2 Arrays.deepToString for Nested Arrays</li> <li>10.6.3 Arrays.sort</li> <li>10.6.4 Arrays.binarySearch</li> <li>10.6.5 Arrays.compare</li> </ul> </li> <li>10.7 Enhanced for-loop with Arrays</li> <li>10.8 Common Pitfalls</li> <li>10.9 Summary</li> </ul>"},{"location":"en/module-03/arrays/#101-what-an-array-is","title":"10.1 What an Array Is","text":"<p>Arrays in Java are fixed-size, indexed, ordered collections of elements of the same type.</p> <p>They are objects, even when the elements are primitives.</p> <p></p>"},{"location":"en/module-03/arrays/#1011-declaring-arrays","title":"10.1.1 Declaring Arrays","text":"<p>You can declare an array in two ways:</p> <pre><code>int[] a;      // preferred modern syntax\nint b[];      // legal, older style\nString[] names;\nPerson[] people;\n\n// [] can be before or after the name: all the following declarations are equivalent.\n\nint[] x;\nint [] x1;\nint []x2;\nint x3[];\nint x5 [];\n\n// MULTIPLE ARRAY DECLARATIONS\n\nint[] arr1, arr2;   // Declares two arrays of int\n\n// WARNING:\n// Here arr1 is an int[] and arr2 is just an int (NOT an array!)\nint arr1[], arr2;\n</code></pre> <p>Declaring does NOT create the array \u2014 it only creates a variable capable of referencing one.</p> <p></p>"},{"location":"en/module-03/arrays/#1012-creating-arrays-instantiation","title":"10.1.2 Creating Arrays (Instantiation)","text":"<p>An array is created using <code>new</code> followed by the element type and the array length:</p> <pre><code>int[] numbers = new int[5];\nString[] words = new String[3];\n</code></pre> <p>Key rules - The length must be non-negative and specified at creation time. - The length cannot be changed later. - The array length can be any <code>int</code> expression.</p> <pre><code>int size = 4;\ndouble[] values = new double[size];\n</code></pre> <ul> <li>Illegal array creation examples:</li> </ul> <pre><code>// int length = -1;           \n// int[] arr = new int[-1];   // Runtime: NegativeArraySizeException\n\n// int[] arr = new int[2.5];  // Compile error: size must be int\n</code></pre> <p></p>"},{"location":"en/module-03/arrays/#1013-default-values-in-arrays","title":"10.1.3 Default Values in Arrays","text":"<p>Arrays (because they are objects) always receive default initialization:</p> Element Type Default Value Numeric 0 boolean false char '\\u0000' Reference types null <ul> <li>Example:</li> </ul> <pre><code>int[] nums = new int[3]; \nSystem.out.println(nums[0]); // 0\n\nString[] s = new String[3];\nSystem.out.println(s[0]);    // null\n</code></pre> <p></p>"},{"location":"en/module-03/arrays/#1014-accessing-elements","title":"10.1.4 Accessing Elements","text":"<p>Elements are accessed using zero-based indexing:</p> <pre><code>int[] a = new int[3];\na[0] = 10;\na[1] = 20;\nSystem.out.println(a[1]); // 20\n</code></pre> <p>Common exception - <code>ArrayIndexOutOfBoundsException</code> (runtime)</p> <pre><code>// int[] x = new int[2];\n// System.out.println(x[2]); // \u274c index 2 out of bounds\n</code></pre> <p></p>"},{"location":"en/module-03/arrays/#1015-array-initialization-shorthands","title":"10.1.5 Array Initialization Shorthands","text":""},{"location":"en/module-03/arrays/#10151-anonymous-array-creation","title":"10.1.5.1 Anonymous Array Creation","text":"<pre><code>int[] a = new int[] {1,2,3};\n</code></pre>"},{"location":"en/module-03/arrays/#10152-short-syntax-only-at-declaration","title":"10.1.5.2 Short Syntax (Only at Declaration)","text":"<pre><code>int[] b = {1,2,3};\n</code></pre> <p>The short syntax <code>{1,2,3}</code> can only be used at the point of declaration.</p> <pre><code>// int[] c;\n// c = {1,2,3};  // \u274c does not compile\n</code></pre> <p></p>"},{"location":"en/module-03/arrays/#102-multidimensional-arrays-arrays-of-arrays","title":"10.2 Multidimensional Arrays (Arrays of Arrays)","text":"<p>Java implements multi-dimensional arrays as arrays of arrays.</p> <p>Declaration:</p> <pre><code>int[][] matrix;\nString[][][] cube;\n</code></pre> <p></p>"},{"location":"en/module-03/arrays/#1021-creating-a-rectangular-array","title":"10.2.1 Creating a Rectangular Array","text":"<pre><code>int[][] rect = new int[3][4]; // 3 rows, 4 columns each\n</code></pre>"},{"location":"en/module-03/arrays/#1022-creating-a-jagged-irregular-array","title":"10.2.2 Creating a Jagged (Irregular) Array","text":"<p>You can create rows with different lengths:</p> <pre><code>int[][] jagged = new int[3][];\njagged[0] = new int[2];\njagged[1] = new int[5];\njagged[2] = new int[1];\n</code></pre> <p></p>"},{"location":"en/module-03/arrays/#103-array-length-vs-string-length","title":"10.3 Array Length vs String Length","text":"<ul> <li>Arrays use <code>.length</code> (public final field).</li> <li>Strings use <code>.length()</code> (method).</li> </ul> <p>Tip</p> <p>This is a classic trap: fields vs methods.</p> <pre><code>// int x = arr.length;   // OK\n// int y = s.length;     // \u274c does not compile: missing ()\nint yOk = s.length();\n</code></pre> <p></p>"},{"location":"en/module-03/arrays/#104-array-reference-assignments","title":"10.4 Array Reference Assignments","text":""},{"location":"en/module-03/arrays/#1041-assigning-compatible-references","title":"10.4.1 Assigning Compatible References","text":"<pre><code>int[] a = {1,2,3};\nint[] b = a; // both now point to the same array\n</code></pre> <p>Modifying one reference affects the other:</p> <pre><code>b[0] = 99;\nSystem.out.println(a[0]); // 99\n</code></pre> <p></p>"},{"location":"en/module-03/arrays/#1042-incompatible-assignments-compile-time-errors","title":"10.4.2 Incompatible Assignments (Compile-Time Errors)","text":"<pre><code>// int[] x = new int[3];\n// long[] y = x;     // \u274c incompatible types\n</code></pre> <p>Array references follow normal inheritance rules:</p> <pre><code>String[] s = new String[3];\nObject[] o = s;      // OK: arrays are covariant\n</code></pre> <p></p>"},{"location":"en/module-03/arrays/#1043-covariance-runtime-danger-arraystoreexception","title":"10.4.3 Covariance Runtime Danger: ArrayStoreException","text":"<pre><code>Object[] objs = new String[3];\n// objs[0] = Integer.valueOf(5); // \u274c ArrayStoreException at runtime\n</code></pre>"},{"location":"en/module-03/arrays/#105-comparing-arrays","title":"10.5 Comparing Arrays","text":"<p><code>==</code> compares references (identity):</p> <pre><code>int[] a = {1,2};\nint[] b = {1,2};\nSystem.out.println(a == b); // false\n</code></pre> <p><code>equals()</code> on arrays does not compare contents (it behaves like <code>==</code>):</p> <pre><code>System.out.println(a.equals(b)); // false\n</code></pre> <p>To compare contents, use methods from <code>java.util.Arrays</code>:</p> <pre><code>Arrays.equals(a, b);         // shallow comparison\nArrays.deepEquals(o1, o2);   // deep comparison for nested arrays\n</code></pre> <p></p>"},{"location":"en/module-03/arrays/#106-arrays-utility-methods","title":"10.6 <code>Arrays</code> Utility Methods","text":""},{"location":"en/module-03/arrays/#1061-arraystostring","title":"10.6.1 <code>Arrays.toString()</code>","text":"<pre><code>System.out.println(Arrays.toString(new int[]{1,2,3})); // [1, 2, 3]\n</code></pre>"},{"location":"en/module-03/arrays/#1062-arraysdeeptostring-for-nested-arrays","title":"10.6.2 <code>Arrays.deepToString()</code> (for nested arrays)","text":"<pre><code>System.out.println(Arrays.deepToString(new int[][] {{1,2},{3,4}}));\n// [[1, 2], [3, 4]]\n</code></pre>"},{"location":"en/module-03/arrays/#1063-arrayssort","title":"10.6.3 <code>Arrays.sort()</code>","text":"<pre><code>int[] a = {4,1,3};\nArrays.sort(a); // [1, 3, 4]\n</code></pre> <p>Tip</p> <ul> <li>Strings are sorted in natural (lexicographic) order.</li> <li>Numbers sort before letters, and uppercase letters sort before lowercase letters (numbers &lt; uppercase &lt; lowercase).</li> <li>For reference types, <code>null</code> is considered smaller than any non-null value.</li> </ul> <pre><code>String[] arr = {\"AB\", \"ac\", \"Ba\", \"bA\", \"10\", \"99\"};\n\nArrays.sort(arr);\n\nSystem.out.println(Arrays.toString(arr));  // [10, 99, AB, Ba, ac, bA]\n</code></pre> <p></p>"},{"location":"en/module-03/arrays/#1064-arraysbinarysearch","title":"10.6.4 <code>Arrays.binarySearch()</code>","text":"<p>Requirements: the array must be sorted using the same ordering; otherwise the result is unpredictable.</p> <pre><code>int[] a = {1,3,5,7};\nint idx = Arrays.binarySearch(a, 5); // returns 2\n</code></pre> <p>When the value is not found, <code>binarySearch</code> returns <code>-(insertionPoint) - 1</code>:</p> <pre><code>int pos = Arrays.binarySearch(a, 4); // returns -3\n// Insertion point is index 2 \u2192 -(2) - 1 = -3\n</code></pre> <p></p>"},{"location":"en/module-03/arrays/#1065-arrayscompare","title":"10.6.5 <code>Arrays.compare()</code>","text":"<p>The class <code>Arrays</code> offers an overloaded <code>equals()</code> that checks if two arrays contain the same elements (and have the same length):</p> <pre><code>System.out.println(Arrays.equals(new int[] {200}, new int[] {100}));        // false\nSystem.out.println(Arrays.equals(new int[] {200}, new int[] {200}));        // true\nSystem.out.println(Arrays.equals(new int[] {200}, new int[] {100, 200}));   // false\n</code></pre> <p>It also provides a <code>compare()</code> method with these rules:</p> <ul> <li>If the result <code>n &lt; 0</code> \u2192 the first array is considered \u201csmaller\u201d than the second.</li> <li>If the result <code>n &gt; 0</code> \u2192 the first array is considered \u201cgreater\u201d than the second.</li> <li> <p>If the result <code>n == 0</code> \u2192 the arrays are equal.</p> </li> <li> <p>Examples:</p> </li> </ul> <pre><code>int[] arr1 = new int[] {200, 300};\nint[] arr2 = new int[] {200, 300, 400};\nSystem.out.println(Arrays.compare(arr1, arr2));  // -1\n\nint[] arr3 = new int[] {200, 300, 400};\nint[] arr4 = new int[] {200, 300};\nSystem.out.println(Arrays.compare(arr3, arr4));  // 1\n\nString[] arr5 = new String[] {\"200\", \"300\", \"aBB\"};\nString[] arr6 = new String[] {\"200\", \"300\", \"ABB\"};\nSystem.out.println(Arrays.compare(arr5, arr6));     // Positive: \"aBB\" &gt; \"ABB\"\n\nString[] arr7 = new String[] {\"200\", \"300\", \"ABB\"};\nString[] arr8 = new String[] {\"200\", \"300\", \"aBB\"};\nSystem.out.println(Arrays.compare(arr7, arr8));     // Negative: \"ABB\" &lt; \"aBB\"\n\nString[] arr9 = null;\nString[] arr10 = new String[] {\"200\", \"300\", \"ABB\"};\nSystem.out.println(Arrays.compare(arr9, arr10));    // -1 (null considered smaller)\n</code></pre> <p></p>"},{"location":"en/module-03/arrays/#107-enhanced-for-loop-with-arrays","title":"10.7 Enhanced for-loop with Arrays","text":"<pre><code>for (int value : new int[]{1,2,3}) {\n    System.out.println(value);\n}\n</code></pre> <p>Rules - The right side must be an array or an <code>Iterable</code>. - The loop variable type must be compatible with the element type (no primitive widening here).</p> <p>Common error:</p> <pre><code>// for (long v : new int[]{1,2}) {} // \u274c not allowed: int elements cannot be assigned to long in enhanced for-loop\n</code></pre> <p></p>"},{"location":"en/module-03/arrays/#108-common-pitfalls","title":"10.8 Common Pitfalls","text":"<ul> <li> <p>Accessing out of bounds \u2192 throws <code>ArrayIndexOutOfBoundsException</code>.</p> </li> <li> <p>Using short array initializer incorrectly</p> </li> </ul> <pre><code>// int[] x;\n// x = {1,2}; // \u274c does not compile\n</code></pre> <ul> <li>Confusing <code>.length</code> and <code>.length()</code></li> <li> <p>Forgetting that arrays are objects (they live on the heap and are referenced).</p> </li> <li> <p>Mixing primitive arrays and wrapper arrays</p> </li> </ul> <pre><code>// int[] p = new Integer[3]; // \u274c incompatible\n</code></pre> <ul> <li>Using <code>binarySearch</code> on unsorted arrays \u2192 unpredictable results.</li> <li>Covariant array runtime exceptions (<code>ArrayStoreException</code>).</li> </ul> <p></p>"},{"location":"en/module-03/arrays/#109-summary","title":"10.9 Summary","text":"<p>Arrays in Java are:</p> <ul> <li>Objects (even if they hold primitives).</li> <li>Fixed-size, indexed collections.</li> <li>Always initialized with default values.</li> <li>Type-safe, but subject to covariance rules (which can cause runtime exceptions if misused).</li> </ul>"},{"location":"en/module-03/date-time/","title":"12. Date and Time in Java","text":""},{"location":"en/module-03/date-time/#table-of-contents","title":"Table of Contents","text":"<ul> <li>12.1 Date and Time<ul> <li>12.1.1 Creating Specific Dates and Times</li> <li>12.1.2 Date and Time Arithmetic plus and minus Methods</li> <li>12.1.3 Common Patterns</li> <li>12.1.4 LocalDate Arithmetic</li> <li>12.1.5 LocalTime Arithmetic</li> <li>12.1.6 LocalDateTime Arithmetic</li> <li>12.1.7 ZonedDateTime Arithmetic</li> <li>12.1.8 Summary Table</li> </ul> </li> <li>12.2 withXxx Methods</li> <li>12.3 Conversion and at Methods Linking Date Time and Zone</li> <li>12.4 Period Duration and Instant</li> <li>12.5 Period \u2014 Human Date Amounts</li> <li>12.6 Duration \u2014 Machine Time Amounts</li> <li>12.7 Instant \u2014 Point on the UTC Timeline</li> <li>12.8 Summary Table Period vs Duration vs Instant</li> <li>12.9 TemporalUnit and TemporalAmount<ul> <li>12.9.1 TemporalUnit</li> <li>12.9.2 ChronoUnit enum</li> <li>12.9.3 TemporalAmount</li> <li>12.9.4 Period as a TemporalAmount</li> <li>12.9.5 Duration as a TemporalAmount</li> <li>12.9.6 Using TemporalAmount vs TemporalUnit</li> <li>12.9.7 between Methods</li> <li>12.9.8 Common Pitfalls</li> <li>12.9.9 Summary</li> </ul> </li> </ul>"},{"location":"en/module-03/date-time/#121-date-and-time","title":"12.1 Date and Time","text":"<p>Java provides a modern, consistent, immutable date/time API in the package <code>java.time.*</code>. </p> <p>This API replaces the old <code>java.util.Date</code> and <code>java.util.Calendar</code> classes.</p> <p>Depending on the level of detail required, Java offers four main classes:</p> <ul> <li><code>LocalDate</code> \u2192 represents a date only (year\u2013month\u2013day)</li> <li><code>LocalTime</code> \u2192 represents a time only (hour\u2013minute\u2013second\u2013nanosecond)</li> <li><code>LocalDateTime</code> \u2192 combines date + time, but no time zone</li> <li><code>ZonedDateTime</code> \u2192 full date + time + offset + time zone</li> </ul> <p>Note</p> <ul> <li>A time zone defines rules such as daylight saving changes (for example, <code>Europe/Paris</code>).</li> <li>A zone offset is a fixed shift from UTC/GMT (for example, <code>+01:00</code>, <code>-07:00</code>).  </li> <li>To compare two instants from different time zones, convert them to UTC (GMT) by applying the offset.</li> </ul> <p>Getting the Current Date/Time</p> <p>You can retrieve the current system values using the static <code>now()</code> methods:</p> <pre><code>System.out.println(LocalDate.now());\nSystem.out.println(LocalTime.now());\nSystem.out.println(LocalDateTime.now());\nSystem.out.println(ZonedDateTime.now());\n</code></pre> <ul> <li>Example output (your system may differ):</li> </ul> <pre><code>2025-12-01\n19:11:53.213856300\n2025-12-01T19:11:53.213856300\n2025-12-01T19:11:53.214856900+01:00[Europe/Paris]\n</code></pre> <ul> <li>Example: converting <code>ZonedDateTime</code> to GMT (UTC)</li> </ul> <pre><code>// Conceptual examples (not real code, just illustrating offsets):\n// 2024-07-01T12:00+09:00[Asia/Tokyo]        ---&gt; 12:00 minus 9 hours ---&gt; 03:00 UTC\n// 2024-07-01T20:00-07:00[America/Los_Angeles] ---&gt; 20:00 plus 7 hours ---&gt; 03:00 UTC\n</code></pre> <p>Both represent the same instant in time, simply expressed in different time zones.</p> <p></p>"},{"location":"en/module-03/date-time/#1211-creating-specific-dates-and-times","title":"12.1.1 Creating Specific Dates and Times","text":"<p>You can build precise date/time objects using the <code>of()</code> factory methods.  </p> <p>All classes include multiple overloaded versions of <code>of()</code> (only the most common are listed here).</p> <p>LocalDate \u2014 overloaded <code>of()</code> forms - <code>of(int year, int month, int dayOfMonth)</code> - <code>of(int year, Month month, int dayOfMonth)</code></p> <p>LocalTime \u2014 overloaded <code>of()</code> forms - <code>of(int hour, int minute)</code> - <code>of(int hour, int minute, int second)</code> - <code>of(int hour, int minute, int second, int nanoOfSecond)</code></p> <p>LocalDateTime \u2014 overloaded <code>of()</code> forms - <code>of(int year, int month, int day, int hour, int minute)</code> - <code>of(int year, int month, int day, int hour, int minute, int second)</code> - <code>of(int year, int month, int day, int hour, int minute, int second, int nano)</code> - <code>of(LocalDate date, LocalTime time)</code></p> <p>ZonedDateTime \u2014 overloaded <code>of()</code> forms - <code>of(LocalDate date, LocalTime time, ZoneId zone)</code> - <code>of(int y, int m, int d, int h, int min, int s, int nano, ZoneId zone)</code></p> <ul> <li>Examples</li> </ul> <pre><code>// Creating specific dates\n\nvar localDate1 = LocalDate.of(2025, 7, 31);\nvar localDate2 = LocalDate.of(2025, Month.JULY, 31);\n\n// Creating specific times\n\nvar localTime1 = LocalTime.of(13, 21);\nSystem.out.println(localTime1);                     // 13:21\nSystem.out.println(LocalTime.of(13, 21, 52));       // 13:21:52\nSystem.out.println(LocalTime.of(13, 21, 52, 200));  // 13:21:52.000000200\n\n// Creating LocalDateTime\n\nvar localDateTime1 = LocalDateTime.of(2025, 7, 31, 13, 55, 22);\nvar localDateTime2 = LocalDateTime.of(localDate1, localTime1);\n\n// Creating a ZonedDateTime\n\nvar zoned = ZonedDateTime.of(2025, 7, 31, 13, 55, 22, 0, ZoneId.of(\"Europe/Paris\"));\n</code></pre> <p></p>"},{"location":"en/module-03/date-time/#1212-date-and-time-arithmetic-plus-and-minus-methods","title":"12.1.2 Date and Time Arithmetic: <code>plus</code> and <code>minus</code> Methods","text":"<p>All classes in the <code>java.time</code> package (such as <code>LocalDate</code>, <code>LocalTime</code>, <code>LocalDateTime</code>, <code>ZonedDateTime</code>, etc.) are immutable. </p> <p>This means that methods like <code>plusXxx()</code> and <code>minusXxx()</code> never modify the original object \u2014 instead, they return a new instance with the adjusted value.</p> <p></p>"},{"location":"en/module-03/date-time/#1213-common-patterns","title":"12.1.3 Common Patterns","text":"<p>Most date/time classes support three kinds of arithmetic methods:</p> <ul> <li>Type-specific shortcuts </li> <li><code>plusDays(long daysToAdd)</code> </li> <li><code>plusHours(long hoursToAdd)</code> </li> <li> <p>etc.</p> </li> <li> <p>Generic amount-based methods </p> </li> <li><code>plus(TemporalAmount amount)</code> \u2192 for example <code>Period</code>, <code>Duration</code> </li> <li> <p><code>minus(TemporalAmount amount)</code></p> </li> <li> <p>Generic unit-based methods </p> </li> <li><code>plus(long amountToAdd, TemporalUnit unit)</code> </li> <li><code>minus(long amountToSubtract, TemporalUnit unit)</code></li> </ul> <p>These allow flexible and readable date/time arithmetic.</p> <p></p>"},{"location":"en/module-03/date-time/#1214-localdate-arithmetic","title":"12.1.4 <code>LocalDate</code> Arithmetic","text":"<p><code>LocalDate</code> represents a date only (no time, no zone).</p> <p>Main <code>plus</code> / <code>minus</code> methods (overloads)</p> Method Description <code>plusDays(long days)</code> Add days <code>plusWeeks(long weeks)</code> Add weeks <code>plusMonths(long months)</code> Add months <code>plusYears(long years)</code> Add years <code>minusDays(long days)</code> Subtract days <code>minusWeeks(long weeks)</code> Subtract weeks <code>minusMonths(long months)</code> Subtract months <code>minusYears(long years)</code> Subtract years <code>plus(TemporalAmount amount)</code> Add a Period <code>minus(TemporalAmount amount)</code> Subtract a Period <code>plus(long amountToAdd, TemporalUnit unit)</code> Add using ChronoUnit (e.g., DAYS, MONTHS) <code>minus(long amountToSubtract, TemporalUnit unit)</code> Subtract using ChronoUnit <ul> <li>Examples:</li> </ul> <pre><code>LocalDate date = LocalDate.of(2025, 3, 10);\n\nLocalDate d1 = date.plusDays(5);            // 2025-03-15\nLocalDate d2 = date.minusWeeks(2);          // 2025-02-24\nLocalDate d3 = date.plusMonths(1);          // 2025-04-10\nLocalDate d4 = date.plusYears(2);           // 2027-03-10\n\n// Using ChronoUnit\nLocalDate d5 = date.plus(10, ChronoUnit.DAYS);   // 2025-03-20\n\n// Using Period\nPeriod p = Period.of(1, 2, 3);  // 1 year, 2 months, 3 days\nLocalDate d6 = date.plus(p);\n</code></pre> <p></p>"},{"location":"en/module-03/date-time/#1215-localtime-arithmetic","title":"12.1.5 <code>LocalTime</code> Arithmetic","text":"<p><code>LocalTime</code> represents time only (no date, no zone).</p> <p>Main <code>plus</code> / <code>minus</code> methods (overloads)</p> Method Description <code>plusNanos(long nanos)</code> Add nanoseconds <code>plusSeconds(long seconds)</code> Add seconds <code>plusMinutes(long minutes)</code> Add minutes <code>plusHours(long hours)</code> Add hours <code>minusNanos(long nanos)</code> Subtract nanoseconds <code>minusSeconds(long seconds)</code> Subtract seconds <code>minusMinutes(long minutes)</code> Subtract minutes <code>minusHours(long hours)</code> Subtract hours <code>plus(TemporalAmount amount)</code> Add a Duration <code>minus(TemporalAmount amount)</code> Subtract a Duration <code>plus(long amountToAdd, TemporalUnit unit)</code> Add using ChronoUnit <code>minus(long amountToSubtract, TemporalUnit unit)</code> Subtract using ChronoUnit <ul> <li>Examples</li> </ul> <pre><code>LocalTime time = LocalTime.of(13, 30);       // 13:30\n\nLocalTime t1 = time.plusHours(2);            // 15:30\nLocalTime t2 = time.minusMinutes(45);        // 12:45\nLocalTime t3 = time.plusSeconds(90);         // 13:31:30\n\n// Using ChronoUnit\nLocalTime t4 = time.plus(3, ChronoUnit.HOURS);    // 16:30\n\n// Using Duration\nDuration d = Duration.ofMinutes(90);\nLocalTime t5 = time.plus(d);                // 15:00\n</code></pre> <p>Note</p> <p>When time arithmetic crosses midnight, the date is ignored with <code>LocalTime</code>. For example, 23:30 + 2 hours = 01:30 (with no date involved).</p> <p></p>"},{"location":"en/module-03/date-time/#1216-localdatetime-arithmetic","title":"12.1.6 <code>LocalDateTime</code> Arithmetic","text":"<p><code>LocalDateTime</code> combines date + time, but still no time zone.  </p> <p>It supports both the date-related and time-related shortcut methods.</p> <p>Main <code>plus</code> / <code>minus</code> methods (overloads)</p> Method Description <code>plusYears(long years)</code> / <code>minusYears(long years)</code> Adjust years <code>plusMonths(long months)</code> / <code>minusMonths(long months)</code> Adjust months <code>plusWeeks(long weeks)</code> / <code>minusWeeks(long weeks)</code> Adjust weeks <code>plusDays(long days)</code> / <code>minusDays(long days)</code> Adjust days <code>plusHours(long hours)</code> / <code>minusHours(long hours)</code> Adjust hours <code>plusMinutes(long minutes)</code> / <code>minusMinutes(long minutes)</code> Adjust minutes <code>plusSeconds(long seconds)</code> / <code>minusSeconds(long seconds)</code> Adjust seconds <code>plusNanos(long nanos)</code> / <code>minusNanos(long nanos)</code> Adjust nanoseconds <code>plus(TemporalAmount amount)</code> / <code>minus(TemporalAmount amount)</code> Add/subtract Period or Duration <code>plus(long amountToAdd, TemporalUnit unit)</code> / <code>minus(long amountToSubtract, TemporalUnit unit)</code> Using ChronoUnit <ul> <li>Examples</li> </ul> <pre><code>LocalDateTime ldt = LocalDateTime.of(2025, 3, 10, 13, 30); // 2025-03-10T13:30\n\nLocalDateTime l1 = ldt.plusDays(1);          // 2025-03-11T13:30\nLocalDateTime l2 = ldt.minusHours(3);        // 2025-03-10T10:30\nLocalDateTime l3 = ldt.plusMinutes(90);      // 2025-03-10T15:00\n\n// Using ChronoUnit\nLocalDateTime l4 = ldt.plus(2, ChronoUnit.WEEKS); // 2025-03-24T13:30\n\n// Using Period and Duration\nPeriod p = Period.ofDays(10);\nDuration d = Duration.ofHours(5);\n\nLocalDateTime l5 = ldt.plus(p);    // 2025-03-20T13:30\nLocalDateTime l6 = ldt.plus(d);    // 2025-03-10T18:30\n</code></pre> <p></p>"},{"location":"en/module-03/date-time/#1217-zoneddatetime-arithmetic","title":"12.1.7 <code>ZonedDateTime</code> Arithmetic","text":"<p><code>ZonedDateTime</code> represents date + time + time zone + offset.</p> <p>It supports the same <code>plus</code>/<code>minus</code> methods as <code>LocalDateTime</code>, but with extra attention to time zones and Daylight Saving Time (DST).</p> <p>Main <code>plus</code> / <code>minus</code> methods (overloads)</p> Method Description <code>plusYears(long years)</code> / <code>minusYears(long years)</code> Adjust years <code>plusMonths(long months)</code> / <code>minusMonths(long months)</code> Adjust months <code>plusWeeks(long weeks)</code> / <code>minusWeeks(long weeks)</code> Adjust weeks <code>plusDays(long days)</code> / <code>minusDays(long days)</code> Adjust days <code>plusHours(long hours)</code> / <code>minusHours(long hours)</code> Adjust hours <code>plusMinutes(long minutes)</code> / <code>minusMinutes(long minutes)</code> Adjust minutes <code>plusSeconds(long seconds)</code> / <code>minusSeconds(long seconds)</code> Adjust seconds <code>plusNanos(long nanos)</code> / <code>minusNanos(long nanos)</code> Adjust nanoseconds <code>plus(TemporalAmount amount)</code> / <code>minus(TemporalAmount amount)</code> Period / Duration <code>plus(long amountToAdd, TemporalUnit unit)</code> / <code>minus(long amountToSubtract, TemporalUnit unit)</code> Using ChronoUnit <ul> <li>Examples (with time zones and DST):</li> </ul> <pre><code>ZonedDateTime zdt = ZonedDateTime.of(\n    2025, 3, 30, 1, 30, 0, 0,\n    ZoneId.of(\"Europe/Paris\")\n);\n\n// Add 2 hours across a possible DST change\nZonedDateTime z1 = zdt.plusHours(2);\nSystem.out.println(zdt);\nSystem.out.println(z1);\n</code></pre> <p>Depending on Daylight Saving rules for that date:</p> <ul> <li>The local time might jump from 02:00 to 03:00 or similar.</li> <li><code>ZonedDateTime</code> adjusts the offset and local time according to the zone rules, but still represents the correct instant on the timeline.</li> </ul> <p>Important</p> <p>For <code>ZonedDateTime</code>, arithmetic is defined in terms of the local timeline and time zone rules, which can cause hour shifts during DST transitions.</p> <p></p>"},{"location":"en/module-03/date-time/#1218-summary-table","title":"12.1.8 Summary Table","text":"Class Shortcut plus/minus methods Generic methods LocalDate plusDays, plusWeeks, plusMonths, plusYears (and minus) plus/minus(TemporalAmount), plus/minus(long, TemporalUnit) LocalTime plusNanos, plusSeconds, plusMinutes, plusHours (and minus) plus/minus(TemporalAmount), plus/minus(long, TemporalUnit) LocalDateTime All LocalDate + LocalTime shortcuts plus/minus(TemporalAmount), plus/minus(long, TemporalUnit) ZonedDateTime Same as LocalDateTime, but zone-aware plus/minus(TemporalAmount), plus/minus(long, TemporalUnit)"},{"location":"en/module-03/date-time/#122-withxxx-methods","title":"12.2 <code>withXxx(...)</code> Methods","text":"<p>The <code>with...</code> methods return a copy of the object with one field changed. They never mutate the original instance.</p> Class Common with... methods (not exhaustive) Description <code>LocalDate</code> withYear(int year) Same date, but with a different year LocalDate.withMonth(int month) Same date, different month (1\u201312) LocalDate.withDayOfMonth(int dayOfMonth) Same date, different day of month LocalDate.with(TemporalField field, long newValue) Generic field-based adjustment LocalDate.with(TemporalAdjuster adjuster) Uses an adjuster (e.g. firstDayOfMonth()) <code>LocalTime</code> withHour(int hour) Same time, different hour LocalTime.withMinute(int minute) Same time, different minute LocalTime.withSecond(int second) Same time, different second LocalTime.withNano(int nanoOfSecond) Same time, different nanosecond LocalTime.with(TemporalField field, long newValue) Generic field-based adjustment LocalTime.with(TemporalAdjuster adjuster) Adjust using a temporal adjuster <code>LocalDateTime</code> withYear(int year), withMonth(int month), withDayOfMonth(int day) Change date part only withHour(int hour), withMinute(int minute), withSecond(int second) Change time part only withNano(int nanoOfSecond) Change nanosecond with(TemporalField field, long newValue) Generic field-based adjustment with(TemporalAdjuster adjuster) Adjust using a temporal adjuster <code>ZonedDateTime</code> all the withXxx(...) of LocalDateTime Change local date/time components withZoneSameInstant(ZoneId zone) Same instant, different zone (changes local time) withZoneSameLocal(ZoneId zone) Same local date/time, different zone (changes instant) <p></p>"},{"location":"en/module-03/date-time/#123-conversion-at-methods-linking-date-time-and-zone","title":"12.3 Conversion &amp; <code>at...</code> Methods (Linking Date, Time, and Zone)","text":"<p>These methods are used to combine or convert between <code>LocalDate</code>, <code>LocalTime</code>, <code>LocalDateTime</code>, and <code>ZonedDateTime</code>.</p> From Method Result Description <code>LocalDate</code> <code>atTime(LocalTime time)</code> LocalDateTime Combines this date with a given time LocalDate <code>atTime(int hour, int minute)</code> LocalDateTime Convenience overloads with numeric time components LocalDate <code>atTime(int hour, int minute, int second)</code> LocalDateTime \u2014 LocalDate <code>atTime(int hour, int minute, int second, int nano)</code> LocalDateTime \u2014 LocalDate <code>atStartOfDay()</code> LocalDateTime This date at time 00:00 LocalDate <code>atStartOfDay(ZoneId zone)</code> ZonedDateTime This date at start of day in a specific zone <code>LocalTime</code> <code>atDate(LocalDate date)</code> LocalDateTime Combines this time with a given date <code>LocalDateTime</code> <code>atZone(ZoneId zone)</code> ZonedDateTime Adds a time zone to a local date-time LocalDateTime <code>toLocalDate()</code> LocalDate Extracts the date component LocalDateTime <code>toLocalTime()</code> LocalTime Extracts the time component <code>ZonedDateTime</code> <code>toLocalDate()</code> LocalDate Drops zone/offset, keeps local date ZonedDateTime <code>toLocalTime()</code> LocalTime Drops zone/offset, keeps local time ZonedDateTime <code>toLocalDateTime()</code> LocalDateTime Drops zone/offset, keeps local date-time <p></p>"},{"location":"en/module-03/date-time/#124-period-duration-and-instant","title":"12.4 Period, Duration, and Instant","text":"<p>The <code>java.time</code> package provides three essential temporal classes that represent amounts of time or points on the timeline:</p> <ul> <li>Period \u2192 human-based date amounts (years, months, days)</li> <li>Duration \u2192 machine-based time amounts (seconds, nanoseconds)</li> <li>Instant \u2192 a point on the UTC timeline</li> </ul> <p></p>"},{"location":"en/module-03/date-time/#125-period-human-date-amounts","title":"12.5 <code>Period</code> \u2014 Human Date Amounts","text":"<p><code>Period</code> represents a date-based amount of time, such as \u201c3 years, 2 months, and 5 days\u201d.  </p> <p>It is used with <code>LocalDate</code> and <code>LocalDateTime</code> (because they contain date parts).</p> <p>Creation Methods</p> Method Description Period.ofYears(int years) Only years Period.ofMonths(int months) Only months Period.ofWeeks(int weeks) Converts weeks to days Period.ofDays(int days) Only days Period.of(int years, int months, int days) Full period Period.parse(CharSequence text) ISO-8601 format: \"P1Y2M3D\", \"P7D\", \"P1W\", ... <p>Key properties</p> <ul> <li>Does not support hours, minutes, seconds, nanoseconds.</li> <li>Can be negative.</li> <li> <p>Immutable.</p> </li> <li> <p>Examples</p> </li> </ul> <pre><code>Period p1 = Period.ofYears(1);             // P1Y\nPeriod p2 = Period.of(1, 2, 3);            // P1Y2M3D\nPeriod p3 = Period.ofWeeks(2);             // P14D (converted to days)\n\nLocalDate base = LocalDate.of(2025, 1, 10);\nLocalDate result = base.plus(p2);          // 2026-03-13\n</code></pre> <p>Note</p> <p>Period.parse(\"P1W\") is allowed and represents a period of 7 days (equivalent to \"P7D\").</p> <p>Tip</p> <p>Period is calendar-based: adding a period of months/years respects month lengths and leap years.</p> <p></p>"},{"location":"en/module-03/date-time/#126-duration-machine-time-amounts","title":"12.6 <code>Duration</code> \u2014 Machine Time Amounts","text":"<p><code>Duration</code> represents a time-based amount in seconds and nanoseconds.</p> <p>It is used with <code>LocalTime</code>, <code>LocalDateTime</code>, <code>ZonedDateTime</code>, and <code>Instant</code>.</p> <p>Creation Methods</p> Method Description Duration.ofDays(long days) Converts days to seconds Duration.ofHours(long hours) Converts hours to seconds Duration.ofMinutes(long minutes) Converts minutes to seconds Duration.ofSeconds(long seconds) Base representation in seconds Duration.ofSeconds(long seconds, long nanoAdjustment) Seconds plus additional nanos Duration.ofMillis(long millis) Converts milliseconds to nanos Duration.ofNanos(long nanos) Nanoseconds only Duration.between(Temporal start, Temporal end) Compute duration between two instants Duration.parse(CharSequence text) ISO: \"PT20H\", \"PT15M\", \"PT10S\" <p>Key characteristics</p> <ul> <li>Supports hours down to nanoseconds, but not years/months/weeks directly.</li> <li>Ideal for machine-level time computations.</li> <li> <p>Immutable.</p> </li> <li> <p>Examples</p> </li> </ul> <pre><code>Duration d1 = Duration.ofHours(5);           // PT5H\nDuration d2 = Duration.ofMinutes(90);        // PT1H30M\n\nLocalTime t = LocalTime.of(10, 0);\nLocalTime t2 = t.plus(d2);                   // 11:30\n\nZonedDateTime z1 = ZonedDateTime.of(\n    2024, 3, 30, 1, 0, 0, 0,\n    ZoneId.of(\"Europe/Paris\")\n);\n\nZonedDateTime z2 = z1.plusHours(2);          // DST-aware\nZonedDateTime z3 = z1.plus(d2);              // Duration-based\n</code></pre> <p>Note</p> <p>Duration.ofDays(1) represents exactly 24 hours of machine time. In a zone with DST, 24 hours may not align with \u201cthe same local time tomorrow\u201d.</p> <p></p>"},{"location":"en/module-03/date-time/#127-instant-point-on-the-utc-timeline","title":"12.7 <code>Instant</code> \u2014 Point on the UTC Timeline","text":"<p><code>Instant</code> represents a single moment in time relative to UTC, with nanosecond precision.</p> <p>It contains:</p> <ul> <li>Seconds since the epoch (1970-01-01T00:00Z).</li> <li>A nanoseconds adjustment.</li> </ul> <p>Creation Methods</p> Method Description Instant.now() Current moment in UTC Instant.ofEpochSecond(long seconds) From epoch seconds Instant.ofEpochSecond(long seconds, long nanos) From seconds plus nanos Instant.ofEpochMilli(long millis) From epoch milliseconds Instant.parse(CharSequence text) ISO: \"2024-01-01T10:15:30Z\" <p>Conversions</p> Action Method Instant \u2192 zoned time instant.atZone(zoneId) ZonedDateTime \u2192 Instant zdt.toInstant() LocalDateTime \u2192 Instant Not allowed directly (needs a zone) <ul> <li>Example</li> </ul> <pre><code>Instant i = Instant.now();\n\nZonedDateTime z = i.atZone(ZoneId.of(\"Europe/Paris\"));\nInstant back = z.toInstant();  // same moment\n\n// Duration between instants\nInstant start = Instant.parse(\"2024-01-01T10:00:00Z\");\nInstant end   = Instant.parse(\"2024-01-01T12:30:00Z\");\n\nDuration between = Duration.between(start, end); // PT2H30M\n</code></pre> <p>Important</p> <p>Instant is always UTC, with no time zone information attached. It cannot be combined with a Period; use Duration instead.</p> <p></p>"},{"location":"en/module-03/date-time/#128-summary-table-period-vs-duration-vs-instant","title":"12.8 Summary Table (Period vs Duration vs Instant)","text":"Concept Represents Good For Works With Notes Period Years, months, days Calendar arithmetic LocalDate, LocalDateTime Human-based units Duration Hours to nanoseconds Precise time calculations LocalTime, LocalDateTime, ZonedDateTime, Instant Machine-based Instant Exact point on UTC timeline Timestamp representation Convertible to/from ZonedDateTime Cannot combine with Period <p>Common Traps</p> <ul> <li><code>Period.of(1, 0, 0)</code> is not the same as <code>Duration.ofDays(365)</code> (leap years!).</li> <li><code>Duration.ofDays(1)</code> may not equal a full \u201ccalendar day\u201d in a DST zone.</li> <li><code>LocalDateTime</code> cannot be converted to an <code>Instant</code> without a time zone.</li> <li><code>Period.parse(\"P1W\")</code> is valid and results in a period of 7 days.</li> </ul> <p></p>"},{"location":"en/module-03/date-time/#129-temporalunit-and-temporalamount","title":"12.9 TemporalUnit and TemporalAmount","text":"<p>The <code>java.time</code> API is built on two key interfaces that define how dates, times, and durations are manipulated:</p> <ul> <li><code>TemporalUnit</code> \u2192 represents a unit of time (for example, DAYS, HOURS, MINUTES).</li> <li><code>TemporalAmount</code> \u2192 represents an amount of time (for example, <code>Period</code>, <code>Duration</code>).</li> </ul> <p>Both are essential for understanding how the <code>plus</code>, <code>minus</code>, and <code>with</code> methods work.</p> <p></p>"},{"location":"en/module-03/date-time/#1291-temporalunit","title":"12.9.1 <code>TemporalUnit</code>","text":"<p><code>TemporalUnit</code> represents a single unit of date/time measurement. The main implementation used in Java is:</p> <p></p>"},{"location":"en/module-03/date-time/#1292-chronounit-enum","title":"12.9.2 <code>ChronoUnit</code> enum","text":"<p>This enum provides the standard units used in the ISO-8601 chronology:</p> Category Units Date units DAYS, WEEKS, MONTHS, YEARS, DECADES, CENTURIES, MILLENNIA, ERAS Time units NANOS, MICROS, MILLIS, SECONDS, MINUTES, HOURS, HALF_DAYS Special FOREVER <p>A <code>TemporalUnit</code> can be used directly with <code>plus()</code> and <code>minus()</code> methods.</p> <ul> <li>Examples using <code>ChronoUnit</code>:</li> </ul> <pre><code>LocalDate date = LocalDate.of(2025, 3, 10);\n\nLocalDate d1 = date.plus(10, ChronoUnit.DAYS);     // 2025-03-20\nLocalDate d2 = date.minus(2, ChronoUnit.MONTHS);   // 2025-01-10\n\nLocalTime time = LocalTime.of(10, 0);\nLocalTime t1 = time.plus(90, ChronoUnit.MINUTES);  // 11:30\n</code></pre> <p>Important</p> <p>You cannot use time-based units with LocalDate, nor date-based units with LocalTime.</p> <ul> <li>Examples:</li> </ul> <pre><code>// \u274c UnsupportedTemporalTypeException\nLocalDate d = LocalDate.now().plus(5, ChronoUnit.HOURS);\n\n// \u274c UnsupportedTemporalTypeException\nLocalTime t = LocalTime.now().plus(1, ChronoUnit.DAYS);\n</code></pre> <p></p>"},{"location":"en/module-03/date-time/#1293-temporalamount","title":"12.9.3 <code>TemporalAmount</code>","text":"<p><code>TemporalAmount</code> represents a multiple-unit amount of time (for example, \u201c2 years, 3 months\u201d, or \u201c90 minutes\u201d). It is implemented by:</p> <ul> <li><code>Period</code> \u2192 years, months, days (date-based)</li> <li><code>Duration</code> \u2192 seconds, nanoseconds (time-based)</li> </ul> <p>Both can be passed to date/time objects to adjust them using <code>plus()</code> and <code>minus()</code>.</p> <p></p>"},{"location":"en/module-03/date-time/#1294-period-as-a-temporalamount","title":"12.9.4 <code>Period</code> as a <code>TemporalAmount</code>","text":"<p><code>Period</code> represents a human-based amount: years, months, days.</p> <ul> <li>Examples:</li> </ul> <pre><code>Period p = Period.of(1, 2, 3);  // 1 year, 2 months, 3 days\n\nLocalDate base = LocalDate.of(2025, 3, 10);\nLocalDate result = base.plus(p); // 2026-05-13\n</code></pre> <p>Notes</p> <ul> <li><code>Period</code> cannot be used with <code>LocalTime</code> (no date component).</li> <li><code>Period.ofWeeks(n)</code> is converted internally to days (n \u00d7 7).</li> </ul> <p></p>"},{"location":"en/module-03/date-time/#1295-duration-as-a-temporalamount","title":"12.9.5 <code>Duration</code> as a <code>TemporalAmount</code>","text":"<p><code>Duration</code> represents machine-based time: seconds + nanoseconds.</p> <ul> <li>Examples:</li> </ul> <pre><code>Duration d = Duration.ofHours(5).plusMinutes(30); // PT5H30M\n\nLocalDateTime ldt = LocalDateTime.of(2025, 3, 10, 10, 0);\nLocalDateTime result = ldt.plus(d); // 2025-03-10T15:30\n</code></pre> <p>Notes</p> <ul> <li><code>Duration</code> can be used with classes that have time components (<code>LocalTime</code>, <code>LocalDateTime</code>, <code>ZonedDateTime</code>, <code>Instant</code>).</li> <li><code>Duration</code> cannot be applied to <code>LocalDate</code> \u2192 it will throw <code>UnsupportedTemporalTypeException</code>.</li> <li><code>Duration</code> interacts with zones and DST transitions when applied to <code>ZonedDateTime</code>.</li> </ul> <p></p>"},{"location":"en/module-03/date-time/#1296-using-temporalamount-vs-temporalunit","title":"12.9.6 Using <code>TemporalAmount</code> vs <code>TemporalUnit</code>","text":"<p>Using a <code>TemporalUnit</code>:</p> <pre><code>LocalDate d1 = LocalDate.now().plus(5, ChronoUnit.DAYS);\n</code></pre> <p>Using a <code>TemporalAmount</code>:</p> <pre><code>Period p = Period.ofDays(5);\nLocalDate d2 = LocalDate.now().plus(p);\n</code></pre> <p>Both produce the same result when supported.</p> <p>Differences</p> Aspect TemporalUnit TemporalAmount Represents A single unit (e.g., DAYS) A structured quantity (e.g. 2Y, 5M, 3D) Examples ChronoUnit.DAYS Period.of(2,5,3) Supports multiple fields No Yes Good for Simple increments Complex increments Common with All date/time classes Restricted by type <p></p>"},{"location":"en/module-03/date-time/#1297-between-methods","title":"12.9.7 <code>between(...)</code> Methods","text":"<p>Many classes provide a <code>between</code> method from <code>ChronoUnit</code>, <code>Duration</code>, or <code>Period</code>.</p> <p>Using <code>Duration.between</code> (for time-based classes)</p> <pre><code>Duration d = Duration.between(\n    LocalTime.of(10, 0),\n    LocalTime.of(13, 30)\n);\n// PT3H30M\n</code></pre> <p>Using <code>Period.between</code> (only for dates)</p> <pre><code>Period p = Period.between(\n    LocalDate.of(2025, 3, 1),\n    LocalDate.of(2025, 5, 10)\n);\n// P2M9D\n</code></pre> <p>Using <code>ChronoUnit</code> <code>between</code></p> <pre><code>long days = ChronoUnit.DAYS.between(\n    LocalDate.of(2025, 3, 1),\n    LocalDate.of(2025, 3, 10)\n);\n// 9\n</code></pre> <p>Important</p> <p>ChronoUnit.between(...) always returns a long, while Period.between returns a Period, and Duration.between returns a Duration.</p> <p></p>"},{"location":"en/module-03/date-time/#1298-common-pitfalls","title":"12.9.8 Common Pitfalls","text":"<ul> <li>Applying the wrong <code>TemporalAmount</code>:</li> </ul> <pre><code>// LocalTime.plus(Period.ofDays(1))   // \u274c compile-time error\n// LocalDate.plus(Duration.ofHours(1)) // \u274c runtime error: UnsupportedTemporalTypeException\n</code></pre> <ul> <li>DST changes with Duration: adding 24 hours is not always \u201ctomorrow\u201d in a zone with DST changes.</li> <li><code>Period.ofWeeks(1)</code> is exactly 7 days; DST effects show up when applied to zone-aware types.</li> <li><code>Instant.plus(Period)</code> \u2192 runtime <code>UnsupportedTemporalTypeException</code>; use <code>Duration</code> instead.</li> <li><code>Instant</code> cannot be created directly from a <code>LocalDateTime</code>; you must first apply a time zone: <code>ldt.atZone(zone).toInstant()</code>.</li> </ul>"},{"location":"en/module-03/date-time/#1299-summary","title":"12.9.9 Summary","text":"Feature TemporalUnit TemporalAmount ChronoUnit Period Duration Represents A unit An amount enum of units Y/M/D S + nanos Multi-field No Yes No Yes No Works with plus/minus plus/minus date/time LocalDate/LocalDateTime Time/time-zone Human-based No Yes No Yes No Machine-based Yes Yes Yes No Yes"},{"location":"en/module-03/formatting/","title":"13. Formatting and Localizing in Java","text":""},{"location":"en/module-03/formatting/#table-of-contents","title":"Table of Contents","text":"<ul> <li>13.1 String Formatting<ul> <li>13.1.1 String.format and formatted<ul> <li>13.1.1.1 Floating-point Flags</li> <li>13.1.1.2 Precision n</li> <li>13.1.1.3 Width m</li> <li>13.1.1.4 Zero Padding 0 Flag</li> <li>13.1.1.5 Left Justification - Flag</li> <li>13.1.1.6 Explicit Sign + Flag</li> <li>13.1.1.7 Parentheses for Negatives ( Flag</li> <li>13.1.1.8 Combining Flags</li> <li>13.1.1.9 Locale Effects</li> <li>13.1.1.10 Common Pitfalls</li> </ul> </li> <li>13.1.2 Custom Text Values and Escaping</li> </ul> </li> <li>13.2 Number Formatting<ul> <li>13.2.1 NumberFormat</li> <li>13.2.2 Localizing Numbers</li> <li>13.2.3 DecimalFormat and NumberFormat</li> <li>13.2.4 DecimalFormat Pattern Structure</li> <li>13.2.5 The 0 Symbol Mandatory Digit</li> <li>13.2.6 The # Symbol Optional Digit</li> <li>13.2.7 Combining 0 and #</li> <li>13.2.8 Decimal and Grouping Separators</li> <li>13.2.9 DecimalFormatSymbols Locale-Specific Formatting Symbols</li> <li>13.2.10 Special DecimalFormat Patterns</li> <li>13.2.11 Common Rules and Pitfalls</li> </ul> </li> <li>13.3 Parsing Numbers<ul> <li>13.3.1 Parsing with DecimalFormat</li> <li>13.3.2 CompactNumberFormat</li> </ul> </li> <li>13.4 Date and Time Formatting<ul> <li>13.4.1 DateTimeFormatter</li> <li>13.4.2 Standard Date Time Symbols</li> <li>13.4.3 datetime.format vs formatter.format</li> <li>13.4.4 Localizing Dates</li> </ul> </li> <li>13.5 Internationalization i18n and Localization l10n<ul> <li>13.5.1 Locales</li> <li>13.5.2 Locale Categories</li> <li>13.5.3 Real-world Example</li> </ul> </li> <li>13.6 Properties and Resource Bundles<ul> <li>13.6.1 Resource Bundle Resolution Rules</li> </ul> </li> <li>13.7 Common Rules and Pitfalls</li> </ul> <p>This chapter delivers a deep and practical treatment of formatting in Java 21.</p> <p></p>"},{"location":"en/module-03/formatting/#131-string-formatting","title":"13.1 String Formatting","text":""},{"location":"en/module-03/formatting/#1311-stringformat-and-formatted","title":"13.1.1 String.format and formatted","text":"<p><code>String.format()</code> creates formatted strings using printf-style placeholders.</p> <p>It is locale-sensitive and returns a new immutable <code>String</code>.</p> <pre><code>String result = String.format(\"The User: %s | Score: %d\", \"Bob\", 42);\nSystem.out.println(result);\n\n// Or\n\nSystem.out.println(\"The User: %s | Score: %d\".formatted(\"Bob\", 42));\n</code></pre> <p>Output:</p> <pre><code>The User: Bob | Score: 42\n</code></pre> <p>Key characteristics:</p> <ul> <li>Uses format specifiers like <code>%s</code> (any type, commonly String values), <code>%d</code> (integral values), <code>%f</code> (floating-point values).</li> <li>Does not modify existing strings.</li> <li>Throws <code>IllegalFormatException</code> if arguments mismatch the format.</li> <li>Is locale-sensitive when a <code>Locale</code> is provided.</li> </ul> <pre><code>String price = String.format(Locale.GERMANY, \"%.2f\", 1234.5);\n// Output (German locale): 1234,50\n</code></pre> <p></p>"},{"location":"en/module-03/formatting/#13111-floating-point-flags","title":"13.1.1.1 Floating-point Flags","text":"<p><code>%f</code> is used to format floating-point numbers (<code>float</code>, <code>double</code>, <code>BigDecimal</code>) using decimal notation.</p> <pre><code>System.out.printf(\"%f\", 12.345);\n</code></pre> <pre><code>12.345000\n</code></pre> <ul> <li>Always prints 6 digits after the decimal point by default.</li> <li>Uses rounding (not truncation).</li> <li>Is locale-sensitive for the decimal separator.</li> </ul> <p></p>"},{"location":"en/module-03/formatting/#13112-precision-n","title":"13.1.1.2 Precision (.n)","text":"<p>Precision defines the number of digits printed after the decimal point.</p> <pre><code>System.out.printf(\"%.2f\", 12.345);\n</code></pre> <pre><code>12.35\n</code></pre> <ul> <li><code>%.0f</code> prints no decimal digits.</li> <li>Rounding is applied.</li> <li>Precision is applied before width padding.</li> </ul> <p></p>"},{"location":"en/module-03/formatting/#13113-width-m","title":"13.1.1.3 Width (m)","text":"<p>Width defines the minimum total number of characters in the output.</p> <pre><code>System.out.printf(\"%8.2f\", 12.34);\n</code></pre> <pre><code>   12.34\n</code></pre> <ul> <li>Pads with spaces by default.</li> <li>If the value is longer, width is ignored (it never truncates).</li> <li>Padding is applied on the left by default.</li> </ul> <p></p>"},{"location":"en/module-03/formatting/#13114-zero-padding-0-flag","title":"13.1.1.4 Zero Padding <code>0</code> Flag","text":"<p>The <code>0</code> flag replaces space padding with zeros.</p> <pre><code>System.out.printf(\"%08.2f\", 12.34);\n</code></pre> <pre><code>00012.34\n</code></pre> <ul> <li>Requires a width.</li> <li>Zeros are inserted after the sign.</li> <li>Ignored if left-justified (<code>-</code> flag).</li> </ul> <p></p>"},{"location":"en/module-03/formatting/#13115-left-justification-flag","title":"13.1.1.5 Left Justification <code>-</code> Flag","text":"<p>The <code>-</code> flag left-aligns the value within the width.</p> <pre><code>System.out.printf(\"%-8.2f\", 12.34);\n</code></pre> <pre><code>12.34   \n</code></pre> <ul> <li>Padding is moved to the right.</li> <li>Overrides zero padding.</li> </ul> <p></p>"},{"location":"en/module-03/formatting/#13116-explicit-sign-flag","title":"13.1.1.6 Explicit Sign <code>+</code> Flag","text":"<p>The <code>+</code> flag forces display of the sign for positive numbers.</p> <pre><code>System.out.printf(\"%+8.2f\", 12.34);\n</code></pre> <pre><code>   +12.34\n</code></pre> <ul> <li>Negative numbers already show <code>-</code>.</li> <li>Overrides the space flag (which prints a leading space for positive values).</li> </ul> <p></p>"},{"location":"en/module-03/formatting/#13117-parentheses-for-negatives-flag","title":"13.1.1.7 Parentheses for Negatives <code>(</code> Flag","text":"<p>The <code>(</code> flag formats negative numbers using parentheses.</p> <pre><code>System.out.printf(\"%(8.2f\", -12.34);\n</code></pre> <pre><code> (12.34)\n</code></pre> <ul> <li>Only affects negative values.</li> <li>Rarely used in practice.</li> </ul> <p></p>"},{"location":"en/module-03/formatting/#13118-combining-flags","title":"13.1.1.8 Combining Flags","text":"<pre><code>System.out.printf(\"%+010.2f\", 12.34);\n</code></pre> <pre><code>+000012.34\n</code></pre> <p>Evaluation order (semplificato):</p> <ul> <li>Precision is applied.</li> <li>Sign is handled.</li> <li>Width is enforced.</li> <li>Padding (spaces or zeros) is applied.</li> </ul> <p></p>"},{"location":"en/module-03/formatting/#13119-locale-effects","title":"13.1.1.9 Locale Effects","text":"<pre><code>System.out.printf(Locale.FRANCE, \"%,.2f\", 12345.67);\n</code></pre> <pre><code>12 345,67\n</code></pre> <p>Decimal and grouping separators depend on the active <code>Locale</code>.</p> <p></p>"},{"location":"en/module-03/formatting/#131110-common-pitfalls","title":"13.1.1.10 Common Pitfalls","text":"<ul> <li><code>%f</code> defaults to 6 decimal places if no precision is specified.</li> <li>Width never truncates output, it only pads if needed.</li> <li><code>0</code> flag is ignored when <code>-</code> is present.</li> <li><code>+</code> overrides the space flag.</li> <li>Grouping and separators are Locale-dependent.</li> </ul>"},{"location":"en/module-03/formatting/#1312-custom-text-values-and-escaping","title":"13.1.2 Custom Text Values and Escaping","text":"<p>Certain characters have special meaning in format strings and must be escaped.</p> <ul> <li><code>%%</code> \u2192 literal percent sign.</li> <li><code>\\n</code>, <code>\\t</code> \u2192 standard Java escapes.</li> </ul> <pre><code>String msg = String.format(\"Completion: %d%%%nStatus: OK\", 100);\nSystem.out.println(msg);\n</code></pre> <p>Output:</p> <pre><code>Completion: 100%\nStatus: OK\n</code></pre> <p>Note</p> <p>A single % without a valid specifier causes an IllegalFormatException at runtime.</p> <p></p>"},{"location":"en/module-03/formatting/#132-number-formatting","title":"13.2 Number Formatting","text":""},{"location":"en/module-03/formatting/#1321-numberformat","title":"13.2.1 NumberFormat","text":"<p><code>NumberFormat</code> is an abstract class used to format and parse numbers in a locale-aware manner.</p> <pre><code>NumberFormat nf = NumberFormat.getInstance(Locale.FRANCE);\nSystem.out.println(nf.format(1234567.89));\n</code></pre> <p>Important</p> <ul> <li>Factory methods determine formatting style (general, integer, currency, percent, compact, ...).</li> <li>Formatting depends on the provided <code>Locale</code>.</li> <li><code>NumberFormat</code> (and <code>DecimalFormat</code>) are not thread-safe.</li> </ul> <p></p>"},{"location":"en/module-03/formatting/#1322-localizing-numbers","title":"13.2.2 Localizing Numbers","text":"<p>Number localization affects decimal separators, grouping separators, and currency symbols.</p> <pre><code>NumberFormat nfUS = NumberFormat.getInstance(Locale.US);\nNumberFormat nfIT = NumberFormat.getInstance(Locale.ITALY);\n\nSystem.out.println(nfUS.format(1234.56)); // 1,234.56\nSystem.out.println(nfIT.format(1234.56)); // 1.234,56\n</code></pre> <p></p>"},{"location":"en/module-03/formatting/#1323-decimalformat-and-numberformat","title":"13.2.3 DecimalFormat and NumberFormat","text":"<p><code>DecimalFormat</code> is a concrete subclass of <code>NumberFormat</code> that provides fine-grained control over numeric formatting using patterns.</p> <p><code>NumberFormat</code> defines locale-aware formatting via factory methods, while <code>DecimalFormat</code> allows explicit pattern-based control.</p> <pre><code>NumberFormat nf = NumberFormat.getInstance(Locale.US);\nDecimalFormat df = (DecimalFormat) nf;\n</code></pre> <p>Or directly:</p> <pre><code>DecimalFormat df = new DecimalFormat(\"#,##0.00\");\n</code></pre> <p>Note</p> <ul> <li><code>DecimalFormat</code> is mutable (you can change pattern, symbols, etc.).</li> <li><code>DecimalFormat</code> is not thread-safe.</li> <li>Formatting is locale-sensitive via <code>DecimalFormatSymbols</code>.</li> </ul> <p></p>"},{"location":"en/module-03/formatting/#1324-decimalformat-pattern-structure","title":"13.2.4 DecimalFormat Pattern Structure","text":"<p>A pattern may contain a positive and an optional negative subpattern, separated by <code>;</code>.</p> <pre><code>#,##0.00;(#,##0.00)\n</code></pre> <p>Note</p> <ul> <li>First part \u2192 positive numbers.</li> <li>Second part \u2192 negative numbers.</li> <li>If the negative part is omitted, negative numbers use a leading <code>-</code> automatically.</li> </ul> <p></p>"},{"location":"en/module-03/formatting/#1325-the-0-symbol-mandatory-digit","title":"13.2.5 The <code>0</code> Symbol (Mandatory Digit)","text":"<p>The <code>0</code> symbol forces a digit to appear, padding with zeros if necessary.</p> <pre><code>DecimalFormat df = new DecimalFormat(\"0000.00\");\nSystem.out.println(df.format(12.3));\n</code></pre> <pre><code>0012.30\n</code></pre> <ul> <li>Controls the minimum number of digits.</li> <li>Pads with zeros if the number has fewer digits.</li> <li>Useful for fixed-width or aligned output.</li> </ul> <p></p>"},{"location":"en/module-03/formatting/#1326-the-symbol-optional-digit","title":"13.2.6 The <code>#</code> Symbol (Optional Digit)","text":"<p>The `` symbol displays a digit only if it exists.</p> <pre><code>DecimalFormat df = new DecimalFormat(\"####.##\");\nSystem.out.println(df.format(12.3));\n</code></pre> <pre><code>12.3\n</code></pre> <ul> <li>Suppresses leading zeros.</li> <li>Suppresses unnecessary trailing zeros.</li> <li>Good for \u201chuman-friendly\u201d formatting.</li> </ul> <p></p>"},{"location":"en/module-03/formatting/#1327-combining-0-and","title":"13.2.7 Combining <code>0</code> and <code>#</code>","text":"<p>Patterns often combine both symbols for flexibility.</p> <pre><code>DecimalFormat df = new DecimalFormat(\"#,##0.##\");\nSystem.out.println(df.format(12));\nSystem.out.println(df.format(12.5));\nSystem.out.println(df.format(12345.678));\n</code></pre> <pre><code>12\n12.5\n12,345.68\n</code></pre> <p>Pattern explanation:</p> <pre><code>#,##0 . ##\n ^  ^    ^\n |  |    |\n |  |    \u2514\u2500 optional fractional digits (#)\n |  \u2514\u2500\u2500\u2500\u2500\u2500 mandatory integer digit (0)\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 grouping pattern (,)\n</code></pre> <ul> <li>At least one integer digit is guaranteed (the <code>0</code>).</li> <li>Digits are grouped by thousands using the grouping separator.</li> <li>Fractional digits are optional (up to two).</li> </ul> <p></p>"},{"location":"en/module-03/formatting/#1328-decimal-and-grouping-separators","title":"13.2.8 Decimal and Grouping Separators","text":"<p>In patterns:</p> <ul> <li><code>.</code> \u2192 decimal separator.</li> <li><code>,</code> \u2192 grouping separator.</li> </ul> <p>The actual symbols used at runtime depend on the <code>Locale</code> (for example, comma vs dot).</p> <p></p>"},{"location":"en/module-03/formatting/#1329-decimalformatsymbols-locale-specific-formatting-symbols","title":"13.2.9 DecimalFormatSymbols Locale-Specific Formatting Symbols","text":"<pre><code>DecimalFormatSymbols symbols =\n        DecimalFormatSymbols.getInstance(Locale.FRANCE);\n\nDecimalFormat df =\n        new DecimalFormat(\"#,##0.00\", symbols);\n\nSystem.out.println(df.format(1234.5));\n</code></pre> <pre><code>1 234,50\n</code></pre> <ul> <li>Controls decimal and grouping separators.</li> <li>Controls minus sign and currency symbol.</li> <li>Controls NaN and Infinity strings.</li> </ul>"},{"location":"en/module-03/formatting/#13210-special-decimalformat-patterns","title":"13.2.10 Special DecimalFormat Patterns","text":"<pre><code>0.###E0   scientific notation\n###%      percent\n\u00a4#,##0.00 currency (\u00a4 is the currency sign)\n</code></pre>"},{"location":"en/module-03/formatting/#13211-common-rules-and-pitfalls","title":"13.2.11 Common Rules and Pitfalls","text":"<ul> <li><code>DecimalFormat</code> is a <code>NumberFormat</code> subclass.</li> <li><code>0</code> forces digits, <code>#</code> does not.</li> <li>Patterns control formatting, not the rounding mode itself (use <code>setRoundingMode()</code>).</li> <li>Grouping only works if the grouping separator (usually <code>,</code>) is present in the pattern.</li> <li>Parsing may succeed partially without error if trailing characters appear after a valid number.</li> <li><code>DecimalFormat</code> is mutable and not thread-safe.</li> </ul>"},{"location":"en/module-03/formatting/#133-parsing-numbers","title":"13.3 Parsing Numbers","text":"<p>Parsing converts localized text into numeric values. By default, parsing is lenient.</p> <pre><code>NumberFormat nf = NumberFormat.getInstance(Locale.FRANCE);\nNumber n = nf.parse(\"12 345,67abc\"); // parses 12345.67\n</code></pre> <ul> <li>Parsing stops at the first invalid character.</li> <li>Trailing text is ignored unless explicitly checked.</li> </ul> <p></p>"},{"location":"en/module-03/formatting/#1331-parsing-with-decimalformat","title":"13.3.1 Parsing with DecimalFormat","text":"<p><code>DecimalFormat</code> can also parse numbers. Parsing is lenient by default.</p> <pre><code>DecimalFormat df = new DecimalFormat(\"#,##0.##\");\nNumber n = df.parse(\"1,234.56abc\");\n</code></pre> <ul> <li>Parsing stops at the first invalid character.</li> <li>Trailing text is ignored if present.</li> </ul> <p>To enforce strict parsing:</p> <pre><code>df.setParseStrict(true);\n</code></pre> <p></p>"},{"location":"en/module-03/formatting/#1332-compactnumberformat","title":"13.3.2 CompactNumberFormat","text":"<p>Compact formatting shortens large numbers for human readability.</p> <ul> <li>Supports SHORT vs LONG styles.</li> <li>Uses locale-dependent abbreviations (for example, K, M, \u201cmillion\u201d).</li> </ul> <pre><code>NumberFormat cnf =\n        NumberFormat.getCompactNumberInstance(\n                Locale.US, NumberFormat.Style.SHORT);\n\nSystem.out.println(cnf.format(1_200));        // 1.2K\nSystem.out.println(cnf.format(5_000_000));    // 5M\n\nNumberFormat cnf1 =\n        NumberFormat.getCompactNumberInstance(\n                Locale.US, NumberFormat.Style.SHORT);\n\nNumberFormat cnf2 =\n        NumberFormat.getCompactNumberInstance(\n                Locale.US, NumberFormat.Style.LONG);\n\nSystem.out.println(cnf1.format(315_000_000));   // 315M\nSystem.out.println(cnf2.format(315_000_000));   // 315 million\n</code></pre> <p></p>"},{"location":"en/module-03/formatting/#134-date-and-time-formatting","title":"13.4 Date and Time Formatting","text":""},{"location":"en/module-03/formatting/#1341-datetimeformatter","title":"13.4.1 DateTimeFormatter","text":"<p>Java 21 relies on <code>java.time</code> and <code>DateTimeFormatter</code> for modern date/time formatting.</p> <pre><code>DateTimeFormatter f =\n        DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\");\nSystem.out.println(LocalDateTime.now().format(f));\n</code></pre> <p>Core properties:</p> <ul> <li>Immutable.</li> <li>Thread-safe.</li> <li>Locale-aware.</li> </ul> <p></p>"},{"location":"en/module-03/formatting/#1342-standard-datetime-symbols","title":"13.4.2 Standard Date/Time Symbols","text":"<pre><code>y   year\nM   month number (or name with more letters)\nd   day of month\nE   day name\nH   hour (0\u201323)\nh   hour (1\u201312)\nm   minute\ns   second\na   AM/PM marker\nz   time zone\n</code></pre>"},{"location":"en/module-03/formatting/#1343-datetimeformat-vs-formatterformat","title":"13.4.3 datetime.format vs formatter.format","text":"<p>Both methods are functionally identical:</p> <pre><code>date.format(formatter);\nformatter.format(date);\n</code></pre> <ul> <li><code>date.format(formatter)</code> \u2192 preferred for readability (data first, then formatting).</li> <li><code>formatter.format(date)</code> \u2192 sometimes convenient in functional or reusable formatter code.</li> </ul> <p></p>"},{"location":"en/module-03/formatting/#1344-localizing-dates","title":"13.4.4 Localizing Dates","text":"<p>Localized styles adapt date output to cultural norms.</p> <pre><code>DateTimeFormatter fullIt =\n        DateTimeFormatter\n                .ofLocalizedDate(FormatStyle.FULL)\n                .withLocale(Locale.ITALY);\n\nDateTimeFormatter shortIt =\n        DateTimeFormatter\n                .ofLocalizedDate(FormatStyle.SHORT)\n                .withLocale(Locale.ITALY);\n\nLocalDate today = LocalDate.of(2025, 12, 17);\n\nSystem.out.println(today.format(fullIt));\nSystem.out.println(today.format(shortIt));\n</code></pre> <p>Possible output:</p> <pre><code>mercoled\u00ec 17 dicembre 2025\n17/12/25\n</code></pre> <p></p>"},{"location":"en/module-03/formatting/#135-internationalization-i18n-and-localization-l10n","title":"13.5 Internationalization (i18n) and Localization (l10n)","text":""},{"location":"en/module-03/formatting/#1351-locales","title":"13.5.1 Locales","text":"<p>A <code>Locale</code> defines language, country, and optional variant.</p> <pre><code>Locale l1 = Locale.US;\nLocale l2 = Locale.of(\"fr\", \"FR\");\nLocale l3 = new Locale.Builder()\n        .setLanguage(\"en\")\n        .setRegion(\"US\")\n        .build();\n</code></pre> <p>Locale formats:</p> <ul> <li><code>en</code> (it, fr, etc.): lowercase language code.</li> <li><code>en_US</code> (fr_CA, it_IT, etc.): lowercase language code + underscore + uppercase country code.</li> </ul> <p></p>"},{"location":"en/module-03/formatting/#1352-locale-categories","title":"13.5.2 Locale Categories","text":"<p>Locale categories separate formatting from UI language.</p> <p><code>Locale.Category</code> lets Java use different default locales for different purposes.</p> <p>There are two categories:</p> Category Used for FORMAT Numbers, dates, currency, other formatting DISPLAY Human-readable text (UI, names, messages) <p></p>"},{"location":"en/module-03/formatting/#1353-real-world-example","title":"13.5.3 Real-world Example","text":"<p>A French user living in Germany might want:</p> <ul> <li>Numbers and dates \u2192 German format.</li> <li>UI language \u2192 French.</li> </ul> <p>Before Java 7, this was not possible.</p> <pre><code>Locale.setDefault(Locale.Category.FORMAT, Locale.GERMANY);\nLocale.setDefault(Locale.Category.DISPLAY, Locale.FRANCE);\n</code></pre> <p>Sample effects:</p> Aspect Result (example) Numbers 1.234,56 Dates 31.12.2025 Currency \u20ac UI text French Month names d\u00e9cembre Country names Allemagne <p></p>"},{"location":"en/module-03/formatting/#136-properties-and-resource-bundles","title":"13.6 Properties and Resource Bundles","text":"<p>Resource bundles externalize text and allow localization without code changes.</p> <pre><code>ResourceBundle rb =\n        ResourceBundle.getBundle(\"messages\", Locale.GERMAN);\n\nString msg = rb.getString(\"welcome\");\n</code></pre> <p></p>"},{"location":"en/module-03/formatting/#1361-resource-bundle-resolution-rules","title":"13.6.1 Resource Bundle Resolution Rules","text":"<p>Java searches bundles in a strict fallback order. For example, with base name <code>messages</code> and locale <code>de_DE</code>:</p> <ul> <li>messages_de_DE.properties</li> <li>messages_de.properties</li> <li>messages.properties</li> </ul> <p>If none is found \u2192 <code>MissingResourceException</code>.</p> <p>Note</p> <p>Traditional .properties files are specified as ISO-8859-1; non-ASCII characters must be encoded as Unicode escapes (for example, \\u00E9 for \u00e9) unless you use alternate loading mechanisms.</p> <p></p>"},{"location":"en/module-03/formatting/#137-common-rules-and-pitfalls","title":"13.7 Common Rules and Pitfalls","text":"<ul> <li><code>DateTimeFormatter</code> is immutable and thread-safe.</li> <li><code>NumberFormat</code>/<code>DecimalFormat</code> are mutable and not thread-safe.</li> <li>Changing the <code>Locale</code> affects how values are formatted and parsed, not the underlying numeric or temporal values.</li> <li>Parsing with <code>NumberFormat</code> or <code>DecimalFormat</code> may succeed partially without throwing if extra text follows a valid number.</li> <li><code>java.time</code> replaces most uses of the old <code>java.util.Date</code> / <code>Calendar</code> APIs in modern code and in the exam.</li> </ul>"},{"location":"en/module-03/math/","title":"11. Math in Java","text":""},{"location":"en/module-03/math/#table-of-contents","title":"Table of Contents","text":"<ul> <li>11.1 Math APIs<ul> <li>11.1.1 Maximum and Minimum Between Two Values</li> <li>11.1.2 Math.round</li> <li>11.1.3 Math.ceil Ceiling</li> <li>11.1.4 Math.floor Floor</li> <li>11.1.5 Math.pow</li> <li>11.1.6 Math.random</li> <li>11.1.7 Math.abs</li> <li>11.1.8 Math.sqrt</li> <li>11.1.9 Summary Table</li> </ul> </li> <li>11.2 BigInteger and BigDecimal<ul> <li>11.2.1 Why double and float Are Not Enough</li> <li>11.2.2 BigInteger \u2014 Arbitrary-Precision Integers</li> <li>11.2.3 Creating BigInteger</li> <li>11.2.4 Operations No Operators</li> </ul> </li> </ul>"},{"location":"en/module-03/math/#111-math-apis","title":"11.1 Math APIs","text":"<p>The <code>java.lang.Math</code> class provides a set of static methods useful for numerical operations.</p> <p>These methods work with primitive numeric types.</p> <p>Below is a summary of the most frequently used ones, together with their overloaded forms.</p> <p></p>"},{"location":"en/module-03/math/#1111-maximum-and-minimum-between-two-values","title":"11.1.1 Maximum and Minimum Between Two Values","text":"<p><code>Math.max()</code> and <code>Math.min()</code> compare the two provided values and return the maximum or minimum between them.</p> <p>There are four overloaded versions for each method:</p> <pre><code>public static int min(int x, int y);\npublic static float min(float x, float y);\npublic static long min(long x, long y);\npublic static double min(double x, double y);\n\npublic static int max(int x, int y);\npublic static float max(float x, float y);\npublic static long max(long x, long y);\npublic static double max(double x, double y);\n</code></pre> <ul> <li>Example:</li> </ul> <pre><code>System.out.println(Math.max(10.50, 7.5));   // 10.5\nSystem.out.println(Math.min(10, -20));      // -20\n</code></pre> <p></p>"},{"location":"en/module-03/math/#1112-mathround","title":"11.1.2 <code>Math.round()</code>","text":"<p><code>round()</code> returns the nearest integer to its argument, following standard rounding rules: values with fractional part 0.5 and above are rounded up; below 0.5 are rounded down (toward the nearest integer).</p> <p>Overloads - <code>long round(double value)</code> - <code>int round(float value)</code></p> <ul> <li>Examples:</li> </ul> <pre><code>Math.round(3.2);    // 3   (returns long)\nMath.round(3.6);    // 4\nMath.round(-3.5f);  // -3  (float version returns int)\n</code></pre> <p>Note</p> <ul> <li>The float version returns an <code>int</code>.</li> <li>The double version returns a <code>long</code>.</li> </ul> <p></p>"},{"location":"en/module-03/math/#1113-mathceil-ceiling","title":"11.1.3 <code>Math.ceil()</code> (Ceiling)","text":"<p><code>ceil()</code> returns the smallest <code>double</code> value that is greater than or equal to the argument.</p> <p>Overloads - <code>double ceil(double value)</code></p> <ul> <li>Examples:</li> </ul> <pre><code>Math.ceil(3.1);   // 4.0\nMath.ceil(-3.1);  // -3.0\n</code></pre> <p></p>"},{"location":"en/module-03/math/#1114-mathfloor-floor","title":"11.1.4 <code>Math.floor()</code> (Floor)","text":"<p><code>floor()</code> returns the largest <code>double</code> value that is less than or equal to the argument.</p> <p>Overloads - <code>double floor(double value)</code></p> <ul> <li>Examples:</li> </ul> <pre><code>Math.floor(3.9);   // 3.0\nMath.floor(-3.1);  // -4.0\n</code></pre> <p></p>"},{"location":"en/module-03/math/#1115-mathpow","title":"11.1.5 <code>Math.pow()</code>","text":"<p><code>pow()</code> raises a value to a power.</p> <p>Overloads - <code>double pow(double base, double exponent)</code></p> <ul> <li>Examples:</li> </ul> <pre><code>Math.pow(2, 3);      // 8.0\nMath.pow(9, 0.5);    // 3.0  (square root)\nMath.pow(10, -1);    // 0.1\n</code></pre> <p></p>"},{"location":"en/module-03/math/#1116-mathrandom","title":"11.1.6 <code>Math.random()</code>","text":"<p><code>random()</code> returns a <code>double</code> in the range <code>[0.0, 1.0)</code> (0.0 inclusive, 1.0 exclusive).</p> <p>Overloads - <code>double random()</code></p> <ul> <li>Examples:</li> </ul> <pre><code>double r = Math.random();   // 0.0 &lt;= r &lt; 1.0\n\n// Example: random int 0\u20139\nint x = (int)(Math.random() * 10);\n</code></pre> <p></p>"},{"location":"en/module-03/math/#1117-mathabs","title":"11.1.7 <code>Math.abs()</code>","text":"<p><code>abs()</code> returns the absolute value (distance from zero).</p> <p>Overloads - <code>int abs(int value)</code> - <code>long abs(long value)</code> - <code>float abs(float value)</code> - <code>double abs(double value)</code></p> <p></p>"},{"location":"en/module-03/math/#1118-mathsqrt","title":"11.1.8 <code>Math.sqrt()</code>","text":"<p><code>sqrt()</code> computes the square root and returns a <code>double</code>.</p> <pre><code>Math.sqrt(9);    // 3.0\nMath.sqrt(-1);   // NaN (not a number)\n</code></pre> <p></p>"},{"location":"en/module-03/math/#1119-summary-table","title":"11.1.9 Summary Table","text":"Method Returns Overloads Notes <code>round()</code> int or long float, double Nearest integer <code>ceil()</code> double double Smallest value &gt;= argument <code>floor()</code> double double Largest value &lt;= argument <code>pow()</code> double double, double Exponentiation <code>random()</code> double none 0.0 &lt;= r &lt; 1.0 <code>min()/max()</code> same type int, long, float, double Compare two values <code>abs()</code> same type int, long, float, double Absolute value <code>sqrt()</code> double double Square root"},{"location":"en/module-03/math/#112-biginteger-and-bigdecimal","title":"11.2 BigInteger and BigDecimal","text":"<p>The classes <code>BigInteger</code> and <code>BigDecimal</code> (in <code>java.math</code>) provide arbitrary-precision number types.</p> <p>They are used when:</p> <ul> <li>Primitive types (<code>int</code>, <code>long</code>, <code>double</code>, etc.) don\u2019t have enough range.</li> <li>Floating-point rounding errors of <code>float</code>/<code>double</code> are not acceptable (for example, in financial calculations).</li> </ul> <p>Both are immutable: every operation returns a new instance.</p> <p></p>"},{"location":"en/module-03/math/#1121-why-double-and-float-are-not-enough","title":"11.2.1 Why <code>double</code> and <code>float</code> Are Not Enough","text":"<p>Floating-point types (<code>float</code>, <code>double</code>) use a binary representation. Many decimal fractions can\u2019t be represented exactly (like 0.1 or 0.2), so you get rounding errors:</p> <pre><code>System.out.println(0.1 + 0.2); // 0.30000000000000004 \n</code></pre> <p>For tasks like financial calculations, this is unacceptable.</p> <p><code>BigDecimal</code> solves this by representing numbers using a decimal model with a configurable scale (number of digits after the decimal point).</p> <p></p>"},{"location":"en/module-03/math/#1122-biginteger-arbitrary-precision-integers","title":"11.2.2 BigInteger \u2014 Arbitrary-Precision Integers","text":"<p><code>BigInteger</code> represents integer values of virtually any size, limited only by available memory.</p> <p></p>"},{"location":"en/module-03/math/#1123-creating-biginteger","title":"11.2.3 Creating BigInteger","text":"<p>Common ways:</p> <p>From a long</p> <pre><code>static BigInteger valueOf(long val);\n</code></pre> <p>From a String</p> <pre><code>BigInteger(String val);        // decimal by default\nBigInteger(String val, int radix);\n</code></pre> <p>Random big value</p> <pre><code>BigInteger(int numBits, Random rnd);\n</code></pre> <ul> <li>Examples:</li> </ul> <pre><code>import java.math.BigInteger;\nimport java.math.BigDecimal;\nimport java.util.Random;\n\nBigInteger a = BigInteger.valueOf(10L);\n\n// You can pass a long to both types, but a double only to BigDecimal\n\nBigInteger g = BigInteger.valueOf(3000L);\nBigDecimal p = BigDecimal.valueOf(3000L);\nBigDecimal q = BigDecimal.valueOf(3000.00);\n\nBigInteger b = new BigInteger(\"12345678901234567890\"); // decimal string\nBigInteger c = new BigInteger(\"FF\", 16);               // 255 in base 16\nBigInteger r = new BigInteger(128, new Random());      // random 128-bit number\n</code></pre> <p></p>"},{"location":"en/module-03/math/#1124-operations-no-operators","title":"11.2.4 Operations (No Operators!)","text":"<p>You cannot use the standard arithmetic operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>) with <code>BigInteger</code> or <code>BigDecimal</code>.</p> <p>Instead, you must call methods (all of which return new instances). Here are some common ones for <code>BigInteger</code>:</p> <ul> <li><code>add(BigInteger val)</code></li> <li><code>subtract(BigInteger val)</code></li> <li><code>multiply(BigInteger val)</code></li> <li><code>divide(BigInteger val)</code> \u2013 integer division</li> <li><code>remainder(BigInteger val)</code></li> <li><code>pow(int exponent)</code></li> <li><code>negate()</code></li> <li><code>abs()</code></li> <li><code>gcd(BigInteger val)</code></li> <li> <p><code>compareTo(BigInteger val)</code> \u2013 ordering</p> </li> <li> <p>Example:</p> </li> </ul> <pre><code>BigInteger x = new BigInteger(\"100000000000000000000\");\nBigInteger y = new BigInteger(\"3\");\n\nBigInteger sum = x.add(y);        // x + y\nBigInteger prod = x.multiply(y);  // x * y\nBigInteger div = x.divide(y);     // integer division\nBigInteger rem = x.remainder(y);  // modulus\n\nif (x.compareTo(y) &gt; 0) {\n    System.out.println(\"x is larger\");\n}\n</code></pre>"},{"location":"en/module-03/strings/","title":"9. Strings in Java","text":""},{"location":"en/module-03/strings/#table-of-contents","title":"Table of Contents","text":"<ul> <li>9.1 Strings &amp; Text Blocks<ul> <li>9.1.1 Strings<ul> <li>9.1.1.1 Initializing Strings</li> <li>9.1.1.2 The String Pool</li> <li>9.1.1.3 Special Characters and Escape Sequences</li> <li>9.1.1.4 Rules for String Concatenation</li> <li>9.1.1.5 Concatenation Rules</li> </ul> </li> <li>9.1.2 Text Blocks since Java 15<ul> <li>9.1.2.1 Formatting Essential vs Incidental Whitespace</li> <li>9.1.2.2 Line Count Blank Lines and Line Breaks</li> <li>9.1.2.3 Text Blocks and Escape Characters</li> <li>9.1.2.4 Common Errors with fixes</li> </ul> </li> </ul> </li> <li>9.2 Core String Methods<ul> <li>9.2.1 String Indexing</li> <li>9.2.2 length Method</li> <li>9.2.3 Boundary Rules Start Index vs End Index</li> <li>9.2.4 Methods Using Only Start Index Inclusive</li> <li>9.2.5 Methods with Start Inclusive End Exclusive</li> <li>9.2.6 Methods That Operate on Entire String</li> <li>9.2.7 Character Access</li> <li>9.2.8 Searching</li> <li>9.2.9 Replacement Methods</li> <li>9.2.10 Splitting and Joining</li> <li>9.2.11 Methods Returning Arrays</li> <li>9.2.12 Indentation</li> <li>9.2.13 Additional Examples</li> </ul> </li> </ul>"},{"location":"en/module-03/strings/#91-strings-text-blocks","title":"9.1 Strings &amp; Text Blocks","text":""},{"location":"en/module-03/strings/#911-strings","title":"9.1.1 Strings","text":""},{"location":"en/module-03/strings/#9111-initializing-strings","title":"9.1.1.1 Initializing Strings","text":"<p>In Java, a String is an object of the <code>java.lang.String</code> class, used to represent a sequence of characters.</p> <p>Strings are immutable: once created, their content cannot be changed. Any operation that seems to modify a string actually creates a new one.</p> <p>You can create and initialize strings in several ways:</p> <pre><code>String s1 = \"Hello\";                    // string literal\nString s2 = new String(\"Hello\");        // using constructor (not recommended)\nString s3 = s1.toUpperCase();           // creates a new String (\"HELLO\")\n</code></pre> <p>Note</p> <ul> <li>String literals are stored in the <code>String pool</code>, a special memory area used to avoid creating duplicate string objects.</li> <li>Using the <code>new</code> keyword always creates a new object outside the pool.</li> </ul> <p></p>"},{"location":"en/module-03/strings/#9112-the-string-pool","title":"9.1.1.2 The String Pool","text":"<p>Because <code>String</code> objects are immutable and widely used, they could easily occupy a large amount of memory in a Java program.</p> <p>To reduce duplication, Java reuses all strings that are declared as literals (see example above), storing them in a dedicated area of the JVM known as the String Pool or Intern Pool.</p> <p>Please check the Paragraph: \"6.4.3 String Pool and Equality\" in Chapter: 6. Instantiating Types for a deeper explanation and examples.</p> <p></p>"},{"location":"en/module-03/strings/#9113-special-characters-and-escape-sequences","title":"9.1.1.3 Special Characters and Escape Sequences","text":"<p>Strings can contain escape characters, which allow you to include special symbols or control characters (characters with a special meaning in Java). An escape sequence starts with a backslash <code>\\</code>.</p> <p>Note</p> <p>Table of Special Characters &amp; Escape Sequences in Strings</p> Escape Meaning Java Example Result <code>\\\"</code> double quote <code>\"She said \\\"Hi\\\"\"</code> <code>She said \"Hi\"</code> <code>\\\\</code> backslash <code>\"C:\\\\Users\\\\Alex\"</code> <code>C:\\Users\\Alex</code> <code>\\n</code> newline (LF) <code>\"Hello\\nWorld\"</code> <code>Hello</code> <code>World</code> <code>\\r</code> carriage return (CR) <code>\"A\\rB\"</code> <code>CR before B</code> <code>\\t</code> tab <code>\"Name\\tAge\"</code> <code>Name\u00a0\u00a0\u00a0\u00a0Age</code> <code>\\'</code> single quote <code>\"It\\'s ok\"</code> <code>It's ok</code> <code>\\b</code> backspace <code>\"AB\\bC\"</code> <code>AC</code> (the <code>B</code> is removed visually) <code>\\uXXXX</code> Unicode code unit <code>\"\\u00A9\"</code> <code>\u00a9</code> <p></p>"},{"location":"en/module-03/strings/#9114-rules-for-string-concatenation","title":"9.1.1.4 Rules for String Concatenation","text":"<p>As introduced in the Chapter on 5. Java Operators, the symbol <code>+</code> normally represents arithmetic addition when used with numeric operands.</p> <p>However, when applied to Strings, the same operator performs string concatenation \u2014 it creates a new string by joining operands together.</p> <p>Since the operator <code>+</code> may appear in expressions where both numbers and strings are present, Java applies a specific set of rules to determine whether <code>+</code> means numeric addition or string concatenation.</p> <p></p>"},{"location":"en/module-03/strings/#9115-concatenation-rules","title":"9.1.1.5 Concatenation Rules","text":"<ul> <li>If both operands are numeric, <code>+</code> performs numeric addition.</li> <li>If at least one operand is a <code>String</code>, the <code>+</code> operator performs string concatenation.</li> <li>Evaluation is strictly left-to-right, because <code>+</code> is left-associative.  </li> </ul> <p>This means that once a <code>String</code> appears on the left side of the expression, all subsequent <code>+</code> operations become concatenations.</p> <p>Tip</p> <p>Because evaluation is left-to-right, the position of the first <code>String</code> operand determines how the rest of the expression is evaluated.</p> <ul> <li>Examples</li> </ul> <pre><code>// *** Pure numeric addition\n\nint a = 10 + 20;        // 30\ndouble b = 1.5 + 2.3;   // 3.8\n\n\n\n// *** String concatenation when at least one operand is a String\n\nString s = \"Hello\" + \" World\";  // \"Hello World\"\nString t = \"Value: \" + 10;      // \"Value: 10\"\n\n\n\n// *** Left-to-right evaluation affects the result\n\nSystem.out.println(1 + 2 + \" apples\"); \n// 3 + \" apples\"  \u2192 \"3 apples\"\n\nSystem.out.println(\"apples: \" + 1 + 2); \n// \"apples: 1\" + 2 \u2192 \"apples: 12\"\n\n\n\n// *** Adding parentheses changes the meaning\n\nSystem.out.println(\"apples: \" + (1 + 2)); \n// parentheses force numeric addition \u2192 \"apples: 3\"\n\n\n\n// *** Mixed types with multiple operands\n\nString result = 10 + 20 + \"\" + 30 + 40;\n// (10 + 20) = 30\n// 30 + \"\"  = \"30\"\n// \"30\" + 30 = \"3030\"\nString out = \"3030\" + 40; // \"303040\"\n\nSystem.out.println(1 + 2 + \"3\" + 4 + 5);\n// Step 1: 1 + 2 = 3\n// Step 2: 3 + \"3\" = \"33\"\nString r = \"33\" + 4;  // \"334\"\n// Step 4: \"334\" + 5 = \"3345\"\n\n\n\n// *** null is represented as a string when concatenated\n\nSystem.out.println(\"AB\" + null);\n// ABnull\n</code></pre> <p></p>"},{"location":"en/module-03/strings/#912-text-blocks-since-java-15","title":"9.1.2 Text Blocks (since Java 15)","text":"<p>A text block is a multi-line string literal introduced to simplify writing large strings (such as HTML, JSON, or code) without the need for many escape sequences.</p> <p>A text block starts and ends with three double quotes (<code>\"\"\"</code>).</p> <p>You can use text blocks everywhere you would use strings.</p> <pre><code>String html = \"\"\"\n    &lt;html&gt;\n        &lt;body&gt;\n            &lt;p&gt;Hello, world!&lt;/p&gt;\n        &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\";\n</code></pre> <p>Note</p> <ul> <li>Text blocks automatically include line breaks and indentation for readability. Newlines are normalized to <code>\\n</code>.</li> <li>Double quotes inside the block usually don\u2019t need escaping.</li> <li>The compiler interprets the content between the opening and closing triple quotes as the string\u2019s value.</li> </ul> <p></p>"},{"location":"en/module-03/strings/#9121-formatting-essential-vs-incidental-whitespace","title":"9.1.2.1 Formatting: Essential vs Incidental Whitespace","text":"<ul> <li>Essential whitespace: spaces and newlines that are part of the intended string content.</li> <li>Incidental whitespace: indentation in your source code that you don\u2019t conceptually consider part of the text.</li> </ul> <pre><code>String text = \"\"\"\n        Line 1\n        Line 2\n        Line 3\n        \"\"\";\n</code></pre> <p>Important</p> <ul> <li>Leftmost character (baseline): the position of the first non-space character across all lines (or the closing <code>\"\"\"</code>) defines the indentation baseline. Spaces to the left of this baseline are considered incidental and are removed.</li> <li>The line immediately following the opening <code>\"\"\"</code> is not included in the output if it\u2019s empty (typical formatting).</li> <li>The newline before the closing <code>\"\"\"</code> is included in the content.   In the example above, the resulting string ends with a newline after <code>\"Line 3\"</code>: there are 4 lines in total.</li> </ul> <p>Output with line numbers (showing the trailing blank line):</p> <pre><code>1: Line 1\n2: Line 2\n3: Line 3\n4:\n</code></pre> <p>To suppress the trailing newline:</p> <ul> <li>Use a line-continuation backslash at the end of the last content line.</li> <li>Put the ending triple quotes on the same line as the last content.</li> </ul> <pre><code>String textNoTrail_1 = \"\"\"\n        Line 1\n        Line 2\n        Line 3\\\n        \"\"\";\n\n// OR\n\nString textNoTrail_2 = \"\"\"\n        Line 1\n        Line 2\n        Line 3\"\"\";\n</code></pre> <p></p>"},{"location":"en/module-03/strings/#9122-line-count-blank-lines-and-line-breaks","title":"9.1.2.2 Line Count, Blank Lines, and Line Breaks","text":"<ul> <li>Every visible line break inside the block becomes <code>\\n</code>.</li> <li>Blank lines inside the block are preserved.</li> </ul> <pre><code>String textNoTrail_0 = \"\"\"\n        Line 1  \n        Line 2 \\n\n        Line 3 \n\n        Line 4 \n        \"\"\";\n</code></pre> <p>Output:</p> <pre><code>1: Line 1\n2: Line 2\n3:\n4: Line 3\n5:\n6: Line 4\n7:\n</code></pre> <p></p>"},{"location":"en/module-03/strings/#9123-text-blocks-escape-characters","title":"9.1.2.3 Text Blocks &amp; Escape Characters","text":"<p>Escape sequences still work inside text blocks when needed (for example, for backslashes or explicit control characters).</p> <pre><code>String json = \"\"\"\n    {\n      \"name\": \"Alice\",\n      \"path\": \"C:\\\\\\\\Users\\\\\\\\Alice\"\n    }\\\n    \"\"\";\n</code></pre> <p>You can also format a text block using placeholders and <code>formatted()</code>:</p> <pre><code>String card = \"\"\"\n    Name: %s\n    Age:  %d\n    \"\"\".formatted(\"Alice\", 30);\n</code></pre> <p></p>"},{"location":"en/module-03/strings/#9124-common-errors-with-fixes","title":"9.1.2.4 Common Errors (with fixes)","text":"<pre><code>// \u274c Mismatched delimiters / missing closing triple quote\nString bad = \"\"\"\n  Hello\nWorld\";      // ERROR \u2014 not a closing text block\n\n// \u2705 Fix\nString ok = \"\"\"\n  Hello\n  World\n  \"\"\";\n</code></pre> <pre><code>// \u274c Text blocks require a line break after the opening \"\"\"\nString invalid = \"\"\"Hello\"\"\";  // ERROR\n\n// \u2705 Fix\nString valid = \"\"\"\n    Hello\n    \"\"\";\n</code></pre> <pre><code>// \u274c Unescaped trailing backslash at end of a line inside the block\nString wrong = \"\"\"\n    C:\\Users\\Alex\\     // ERROR \u2014 backslash escapes the newline\n    Documents\n    \"\"\";\n\n// \u2705 Fix: escape backslashes, or avoid backslash at end of line\nString correct = \"\"\"\n    C:\\\\Users\\\\Alex\\\\\n    Documents\\\n    \"\"\";\n</code></pre>"},{"location":"en/module-03/strings/#92-core-string-methods","title":"9.2 Core String Methods","text":""},{"location":"en/module-03/strings/#921-string-indexing","title":"9.2.1 String Indexing","text":"<p>Strings in Java use zero-based indexing, meaning:</p> <ul> <li>The first character is at index <code>0</code></li> <li>The last character is at index <code>length() - 1</code></li> <li> <p>Accessing any index outside this range causes a <code>StringIndexOutOfBoundsException</code></p> </li> <li> <p>Example:</p> </li> </ul> <pre><code>String s = \"Java\";\n// Indexes:  0    1    2    3\n// Chars:    J    a    v    a\n\nchar c = s.charAt(2); // 'v'\n</code></pre> <p></p>"},{"location":"en/module-03/strings/#922-length-method","title":"9.2.2 <code>length()</code> Method","text":"<p><code>length()</code> returns the number of characters in the string.</p> <pre><code>String s = \"hello\";\nSystem.out.println(s.length());  // 5\n</code></pre> <p>The last valid index is always <code>length() - 1</code>.</p> <p></p>"},{"location":"en/module-03/strings/#923-boundary-rules-start-index-vs-end-index","title":"9.2.3 Boundary Rules: Start Index vs End Index","text":"<p>Many String methods use two indices:</p> <ul> <li>Start index \u2014 inclusive</li> <li>End index \u2014 exclusive</li> </ul> <p>In other words, <code>substring(start, end)</code> includes characters from index <code>start</code> up to, but not including, index <code>end</code>.</p> <ul> <li>Start index must be <code>&gt;= 0</code> and <code>&lt;= length() - 1</code></li> <li>End index may be equal to <code>length()</code> (the \u201cvirtual\u201d position after the last character).</li> <li>End index must not exceed <code>length()</code>.</li> <li> <p>Start index must never be greater than end index.</p> </li> <li> <p>Example:</p> </li> </ul> <pre><code>String s = \"abcdef\";\ns.substring(1, 4); // \"bcd\" (indexes 1,2,3)\n</code></pre> <p>This rule applies to most substring-based methods.</p> <p></p>"},{"location":"en/module-03/strings/#924-methods-using-only-start-index-inclusive","title":"9.2.4 Methods Using Only Start Index (Inclusive)","text":"Method Description Parameters Index Rule Example substring(int start) Returns substring from start to end start start inclusive \"abcdef\".substring(2) \u2192 \"cdef\" indexOf(String) First occurrence \u2014 \u2014 \"Java\".indexOf(\"a\") \u2192 1 indexOf(String, start) Start searching at index start start inclusive \"banana\".indexOf(\"a\", 2) \u2192 3 lastIndexOf(String) Last occurrence \u2014 \u2014 \"banana\".lastIndexOf(\"a\") \u2192 5 lastIndexOf(String, fromIndex) Search backward from index fromIndex fromIndex inclusive \"banana\".lastIndexOf(\"a\", 3) \u2192 3"},{"location":"en/module-03/strings/#925-methods-with-start-inclusive-end-exclusive","title":"9.2.5 Methods with Start Inclusive / End Exclusive","text":"<p>These methods follow the same slicing behavior: <code>start</code> included, <code>end</code> excluded.</p> Method Description Signature Example substring(start, end) Extracts part of string (int start, int end) \"abcdef\".substring(1,4) \u2192 \"bcd\" regionMatches Compares substring regions (toffset, other, ooffset, len) \"Hello\".regionMatches(1, \"ell\", 0, 3) \u2192 true getBytes(int srcBegin, int srcEnd, byte[] dst, int dstBegin) Copies chars to byte array start inclusive, end exclusive Copies chars in [srcBegin, srcEnd) copyValueOf(char[] data, int offset, int count) Creates a new string offset inclusive; offset+count exclusive Same rule as substring <p></p>"},{"location":"en/module-03/strings/#926-methods-that-operate-on-entire-string","title":"9.2.6 Methods That Operate on Entire String","text":"Method Description Example toUpperCase() Uppercase version \"java\".toUpperCase() \u2192 \"JAVA\" toLowerCase() Lowercase version \"JAVA\".toLowerCase() \u2192 \"java\" trim() Removes leading/trailing whitespace \"  hi  \".trim() \u2192 \"hi\" strip() Unicode-aware trimming \"  hi\\u2003\".strip() \u2192 \"hi\" stripLeading() Removes leading whitespace \"  hi\".stripLeading() \u2192 \"hi\" stripTrailing() Removes trailing whitespace \"hi  \".stripTrailing() \u2192 \"hi\" isBlank() True if empty or whitespace only \"  \".isBlank() \u2192 true isEmpty() True if length == 0 \"\".isEmpty() \u2192 true"},{"location":"en/module-03/strings/#927-character-access","title":"9.2.7 Character Access","text":"Method Description Example charAt(int index) Returns char at index \"Java\".charAt(2) \u2192 'v' codePointAt(int index) Returns Unicode code point Useful for emojis or characters beyond BMP"},{"location":"en/module-03/strings/#928-searching","title":"9.2.8 Searching","text":"Method Description Example contains(CharSequence) Substring test \"hello\".contains(\"ell\") \u2192 true startsWith(String) Prefix \"abcdef\".startsWith(\"abc\") \u2192 true startsWith(String, offset) Prefix at index \"abc\".startsWith(\"b\", 1) \u2192 true endsWith(String) Suffix \"abcdef\".endsWith(\"def\") \u2192 true"},{"location":"en/module-03/strings/#929-replacement-methods","title":"9.2.9 Replacement Methods","text":"Method Description Example replace(char old, char new) Replace characters \"banana\".replace('a','o') \u2192 \"bonono\" replace(CharSequence old, CharSequence new) Replace substrings \"ababa\".replace(\"aba\",\"X\") \u2192 \"Xba\" replaceAll(String regex, String replacement) Regex replace all \"a1a2\".replaceAll(\"\\d\",\"\") \u2192 \"aa\" replaceFirst(String regex, String replacement) First regex match only \"a1a2\".replaceFirst(\"\\d\",\"\") \u2192 \"aa2\""},{"location":"en/module-03/strings/#9210-splitting-and-joining","title":"9.2.10 Splitting and Joining","text":"Method Description Example split(String regex) Split by regex \"a,b,c\".split(\",\") \u2192 [\"a\",\"b\",\"c\"] split(String regex, int limit) Split with limit limit &lt; 0 keeps all trailing empty strings"},{"location":"en/module-03/strings/#9211-methods-returning-arrays","title":"9.2.11 Methods Returning Arrays","text":"Method Description Example toCharArray() Returns char[] \"abc\".toCharArray() getBytes() Returns byte[] using platform/default encoding \"\u00e1\".getBytes()"},{"location":"en/module-03/strings/#9212-indentation","title":"9.2.12 Indentation","text":"Method Description Example indent(int numSpaces) Adds (positive) or removes (negative) spaces from the beginning of each line; also adds a line break at the end if not already present str.indent(-20) stripIndent() Removes all incidental leading whitespace from each line; does not add a final line break str.stripIndent() <ul> <li>Example:</li> </ul> <pre><code>var txtBlock = \"\"\"\n\n                    a\n                      b\n                     c\"\"\";\n\nvar conc = \" a\\n\" + \" b\\n\" + \" c\";\n\nSystem.out.println(\"length: \" + txtBlock.length());\nSystem.out.println(txtBlock);\nSystem.out.println(\"\");\nString stripped1 = txtBlock.stripIndent();\nSystem.out.println(stripped1);\nSystem.out.println(\"length: \" + stripped1.length());\n\nSystem.out.println(\"*********************\");\n\nSystem.out.println(\"length: \" + conc.length());\nSystem.out.println(conc);\nSystem.out.println(\"\");\nString stripped2 = conc.stripIndent();\nSystem.out.println(stripped2);\nSystem.out.println(\"length: \" + stripped2.length());\n</code></pre> <p>Output:</p> <pre><code>length: 9\n\na\n  b\n c\n\n\na\n  b\n c\nlength: 9\n*********************\nlength: 8\n a\n b\n c\n\na\nb\nc\nlength: 5\n</code></pre> <p></p>"},{"location":"en/module-03/strings/#9213-additional-examples","title":"9.2.13 Additional Examples","text":"<ul> <li>Example 1 \u2014 Extract <code>[start, end)</code></li> </ul> <pre><code>String s = \"012345\";\nSystem.out.println(s.substring(2, 5));\n// includes 2,3,4 \u2192 prints \"234\"\n</code></pre> <ul> <li>Example 2 \u2014 Searching from a start index</li> </ul> <pre><code>String s = \"hellohello\";\nint idx = s.indexOf(\"lo\", 5); // search begins at index 5\n</code></pre> <ul> <li>Example 3 \u2014 Common pitfalls</li> </ul> <pre><code>String s = \"abcd\";\nSystem.out.println(s.substring(1,1)); // \"\" empty string\nSystem.out.println(s.substring(3, 2)); // \u274c Exception: start index (3) &gt; end index (2)\n\nSystem.out.println(\"abcd\".substring(2, 4)); // \"cd\" \u2014 includes indexes 2 and 3; 4 is excluded but legal here\n\nSystem.out.println(\"abcd\".substring(2, 5)); // \u274c StringIndexOutOfBoundsException (end index 5 is invalid)\n</code></pre>"},{"location":"en/module-04/beyond-classes/","title":"17. Beyond Classes","text":""},{"location":"en/module-04/beyond-classes/#table-of-contents","title":"Table of Contents","text":"<ul> <li>17.1 Interfaces<ul> <li>17.1.1 What Interfaces Can Contain</li> <li>17.1.2 Implementing an Interface</li> <li>17.1.3 Multiple Inheritance</li> <li>17.1.4 Interface Inheritance and Conflicts</li> <li>17.1.5 Default methods</li> <li>17.1.6 Static methods</li> <li>17.1.7 Private interface methods</li> </ul> </li> <li>17.2 Sealed, non-sealed, and final Types<ul> <li>17.2.1 Rules</li> </ul> </li> <li>17.3 Enums<ul> <li>17.3.1 Simple Enum Definition</li> <li>17.3.2 Complex Enums with State and Behavior</li> <li>17.3.3 Enum Methods</li> <li>17.3.4 Rules</li> <li>17.4 Records Java 16+</li> <li>17.4.1 Summary of Basic Rules for Records</li> <li>17.4.2 Long Constructor</li> <li>17.4.3 Compact Constructor</li> <li>17.4.4 Pattern Matching for Records</li> <li>17.4.5 Nested Record Patterns and Matching Records with var and Generics<ul> <li>17.4.5.1 Basic Nested Record Pattern</li> <li>17.4.5.2 Nested Record Patterns with var</li> <li>17.4.5.3 Nested Record Patterns and Generics</li> <li>17.4.5.4 Common Errors with Nested Record Patterns</li> </ul> </li> </ul> </li> <li>17.5 Nested Classes in Java<ul> <li>17.5.1 Static Nested Classes<ul> <li>17.5.1.1 Syntax and Access Rules</li> <li>17.5.1.2 Common Pitfalls</li> </ul> </li> <li>17.5.2 Inner Classes Non-Static Nested Classes<ul> <li>17.5.2.1 Syntax and Access Rules</li> <li>17.5.2.2 Common Pitfalls</li> </ul> </li> <li>17.5.3 Local Classes<ul> <li>17.5.3.1 Characteristics</li> <li>17.5.3.2 Common Pitfalls</li> </ul> </li> <li>17.5.4 Anonymous Classes<ul> <li>17.5.4.1 Syntax and Usage</li> <li>17.5.4.2 Anonymous Class Extending a Class</li> </ul> </li> <li>17.5.5 Comparison of Nested Class Types </li> </ul> </li> <li>17.6 Nesting of Interfaces in Java<ul> <li>17.6.1 Where an Interface Can Be Declared</li> <li>17.6.2 Nested Interfaces<ul> <li>17.6.2.1 Interface Nested Inside a Class</li> <li>17.6.2.2 Interface Nested Inside Another Interface</li> </ul> </li> <li>17.6.3 Access Rules</li> <li>17.6.4 Nested Types Inside Interfaces</li> <li>17.6.5 Essential Summary</li> </ul> </li> </ul> <p>This chapter presents several advanced type mechanisms beyond the Java Class design: interfaces, enums, sealed / non-sealed classes, records, and nested classes. </p> <p></p>"},{"location":"en/module-04/beyond-classes/#171-interfaces","title":"17.1 Interfaces","text":"<p>An interface in Java is a reference type that defines a contract of methods that a class agrees to implement. </p> <p>An <code>interface</code> is implicitly <code>abstract</code> and cannot be marked as <code>final</code>: as with top-level classes, an interface can declare visibility as <code>public</code> or <code>default</code> (package-private).</p> <p>A Java class may implement any number of interfaces through the <code>implements</code> keyword.</p> <p>An <code>interface</code> may in turn extend multiple interfaces using the <code>extends</code> keyword.</p> <p>Interfaces enable abstraction, loose coupling, and multiple inheritance of type.</p> <p></p>"},{"location":"en/module-04/beyond-classes/#1711-what-interfaces-can-contain","title":"17.1.1 What Interfaces Can Contain","text":"<ul> <li>Abstract methods (implicitly <code>public</code> and <code>abstract</code>)</li> <li>Concrete methods<ul> <li>Default methods (include code and are implicitly <code>public</code>)</li> <li>Static methods (declared as <code>static</code>, include code and are implicitly <code>public</code>)</li> <li>Private methods (Java 9+) for internal reuse</li> </ul> </li> <li>Constants \u2192 implicitly <code>public static final</code> and initialized at declaration</li> </ul> <pre><code>interface Calculator {\n    int add(int a, int b);                 // abstract\n    default int mult(int a, int b) {       // default method\n        return a * b;\n    }\n    static double pi() { return 3.14; }    // static method\n}\n</code></pre> <p>Warning</p> <p>Because interface abstract methods are implicitly <code>public</code>, you cannot reduce the access level on an implementing method.</p> <p></p>"},{"location":"en/module-04/beyond-classes/#1712-implementing-an-interface","title":"17.1.2 Implementing an Interface","text":"<pre><code>class BasicCalc implements Calculator {\n    public int add(int a, int b) { return a + b; }\n}\n</code></pre> <p>Note</p> <p>Every abstract method must be implemented unless the class is abstract.</p> <p></p>"},{"location":"en/module-04/beyond-classes/#1713-multiple-inheritance","title":"17.1.3 Multiple Inheritance","text":"<p>A class may implement multiple interfaces.</p> <pre><code>interface A { void a(); }\ninterface B { void b(); }\n\nclass C implements A, B {\n    public void a() {}\n    public void b() {}\n}\n</code></pre> <p></p>"},{"location":"en/module-04/beyond-classes/#1714-interface-inheritance-and-conflicts","title":"17.1.4 Interface Inheritance and Conflicts","text":"<p>If two interfaces provide <code>default</code> methods with the same signature, the implementing class must override the method.</p> <pre><code>interface X { default void run() { } }\ninterface Y { default void run() { } }\n\nclass Z implements X, Y {\n    public void run() { } // mandatory\n}\n</code></pre> <p>If you still want to access a particular implementation of the inherited <code>default</code> method, you can use the following syntax:</p> <pre><code>interface X { default int run() { return 1; } }\ninterface Y { default int run() { return 2; } }\n\nclass Z implements X, Y {\n    public int useARun(){\n        return Y.super.run();\n    }\n}\n</code></pre> <p></p>"},{"location":"en/module-04/beyond-classes/#1715-default-methods","title":"17.1.5 <code>Default</code> methods","text":"<p>A <code>default</code> method (declared with the <code>default</code> keyword) is a method that defines an implementation and can be overridden by a class implementing the interface.</p> <ul> <li>A default method include code and is implicitly <code>public</code>;</li> <li>A default method cannot be <code>abstract</code>, <code>static</code> or <code>final</code>;</li> <li>As we saw just above, if two interfaces provide default methods with the same signature, the implementing class must override the method;</li> <li>An implementig class may of course rely on the provided implementation of the <code>default</code> method without overriding it;</li> <li>The <code>default</code> method can be invoked on an instance of the implementing class and NOT as a <code>static</code> method of the containing interface;</li> </ul> <p></p>"},{"location":"en/module-04/beyond-classes/#1716-static-methods","title":"17.1.6 <code>Static</code> methods","text":"<ul> <li>An interface can provide <code>static methods</code> (through the keyword <code>static</code>) which are implicitly <code>public</code>;</li> <li>Static methods must include a method body and are accessed using the interface name;</li> <li>Static methods cannot be <code>abstract</code> or <code>final</code>;</li> </ul>"},{"location":"en/module-04/beyond-classes/#1717-private-interface-methods","title":"17.1.7 <code>Private</code> interface methods","text":"<p>Among all the concrete methods that an interface can implement, we also have:</p> <ul> <li><code>private</code> methods: visible only inside the declaring interface and which can only be invoked from a <code>non-static</code> context (<code>default</code> methods or other <code>non-static private methods</code>).</li> <li><code>private static</code> methods: visible only inside the declaring interface and which can be invoked by any method of the enclosing interface.</li> </ul> <p></p>"},{"location":"en/module-04/beyond-classes/#172-sealed-non-sealed-and-final-types","title":"17.2 Sealed, non-sealed, and final Types","text":"<p><code>Sealed</code> classes and interfaces (Java 17+) restrict which other classes (or interfaces) can extend or implement them.</p> <p>A <code>sealed type</code> is declared by placing the <code>sealed</code> modifier right before the class (or interface) keyword, and adding, after the Type name, the <code>permits</code> keyword followed by the list of types that can extend (or implement) it.</p> <pre><code>public sealed class Shape permits Circle, Rectangle { }\n\nfinal class Circle extends Shape { }\n\nnon-sealed class Rectangle extends Shape { }\n</code></pre> <p></p>"},{"location":"en/module-04/beyond-classes/#1721-rules","title":"17.2.1 Rules","text":"<ul> <li>A sealed Type must declare all permitted subtypes.</li> <li>A permitted subtype must be final, sealed, or non-sealed; because interfaces cannot be final, they can only be marked <code>sealed</code> or <code>non-sealed</code> when extending a sealed interface.</li> <li>Sealed types must be declared in the same package (or named module) as their direct sub-types.</li> </ul>"},{"location":"en/module-04/beyond-classes/#173-enums","title":"17.3 Enums","text":"<p>Enums define a fixed set of constant values. </p> <p><code>Enums</code> can declare <code>fields</code>, <code>constructors</code>, and <code>methods</code> as regular classes do but they can't be extended.</p> <p>The list of enum values must end with a semicolon <code>(;)</code> in case of <code>Complex Enums</code>, but this is not mandatory for <code>Simple Enums</code>.</p> <p></p>"},{"location":"en/module-04/beyond-classes/#1731-simple-enum-definition","title":"17.3.1 <code>Simple</code> Enum Definition","text":"<pre><code>enum Day { MON, TUE, WED, THU, FRI, SAT, SUN } // semicolon not present\n</code></pre>"},{"location":"en/module-04/beyond-classes/#1732-complex-enums-with-state-and-behavior","title":"17.3.2 <code>Complex</code> Enums with State and Behavior","text":"<pre><code>enum Level {\n    LOW(1), MEDIUM(5), HIGH(10); // mandatory semicolon\n\n    private int code; \n\n    Level(int code) { this.code = code; }\n\n    public int getCode() { return code; }\n}\n\npublic static void main(String[] args) {\n    Level.MEDIUM.getCode();     // invoking a method\n}\n</code></pre>"},{"location":"en/module-04/beyond-classes/#1733-enum-methods","title":"17.3.3 Enum Methods","text":"<ul> <li><code>values()</code> \u2013 returns an array of all the constant values that can be used, for example, in a <code>for-each</code> loop</li> <li><code>valueOf(String)</code> \u2013 returns constant by name</li> <li><code>ordinal()</code> \u2013 index (int) of the constant</li> </ul>"},{"location":"en/module-04/beyond-classes/#1734-rules","title":"17.3.4 Rules","text":"<ul> <li>Enum constructors are implicitly <code>private</code>;</li> <li>Enums can contain <code>static</code> and <code>instance</code> methods;</li> <li>Enums can implement <code>interfaces</code>;</li> </ul>"},{"location":"en/module-04/beyond-classes/#174-records-java-16","title":"17.4 Records (Java 16+)","text":"<p>A record is a special class designed to model immutable data: they are, in fact, implicitly final. </p> <p>You can't extend a record, but it is allowed to implement a regular or sealed interface.</p> <p>It automatically provides:</p> <ul> <li>private final fields for each component</li> <li>constructor with parameters in the same order as in the record declaration;</li> <li>getters (named like fields)</li> <li><code>equals()</code>, <code>hashCode()</code>, <code>toString()</code>: you are also permitted to override those methods</li> <li>Records can include <code>nested classes</code>, <code>interfaces</code>, <code>records</code>, <code>enums</code> and <code>annotations</code></li> </ul> <pre><code>public record Point(int x, int y) { }\n\nvar element = new Point(11, 22);\n\nSystem.out.println(element.x);\nSystem.out.println(element.y);\n</code></pre> <p>If you need additional validation or transformation of the provided fields, you can define a <code>long constructor</code> or a <code>compact constructor</code>.</p> <p></p>"},{"location":"en/module-04/beyond-classes/#1741-summary-of-basic-rules-for-records","title":"17.4.1 Summary of Basic Rules for Records","text":"<p>A record may be declared in three locations:</p> <ul> <li>As a top-level record (directly in a package)</li> <li>As a member record (inside a class or interface)</li> <li>As a local record (inside a method)</li> </ul> <p>All <code>member</code> and <code>local</code> record classes are implicitly <code>static</code>.</p> <ul> <li>A member record may redundantly declare <code>static</code>.</li> <li>A local record must not declare <code>static</code> explicitly.</li> </ul> <p>Every record class is implicitly <code>final</code>.</p> <ul> <li>Declaring <code>final</code> explicitly is permitted but redundant.</li> <li>A record cannot be declared <code>abstract</code>, <code>sealed</code>, or <code>non-sealed</code>.</li> </ul> <p>The direct superclass of every record is <code>java.lang.Record</code>.</p> <ul> <li>A record cannot declare an <code>extends</code> clause.</li> <li>A record cannot extend any other class.</li> </ul> <p>Serialization of records differs from ordinary serializable classes.</p> <ul> <li>During deserialization, the canonical constructor is invoked.</li> </ul> <p>The body of a record may contain:</p> <ul> <li>Constructors</li> <li>Methods</li> <li>Static fields</li> <li>Static initializer blocks</li> </ul> <p>The body of a record must NOT contain:</p> <ul> <li>Instance field declarations</li> <li>Instance initializer blocks</li> <li><code>abstract</code> methods</li> <li><code>native</code> methods</li> </ul> <p></p>"},{"location":"en/module-04/beyond-classes/#1742-long-constructor","title":"17.4.2 Long Constructor","text":"<pre><code>public record Person(String name, int age) {\n\n    public Person (String name, int age){\n        if (age &lt; 0) throw new IllegalArgumentException();\n        this.name = name;\n        this.age = age;\n    }\n}\n</code></pre> <p>You can still define overloaded constructors, as long as they ultimately delegate to the canonical one using <code>this(...)</code>:</p> <pre><code>public record Point(int x, int y) {\n\n    // Overloaded constructor (NOT canonical)\n    public Point(int value) {\n        this(value, value); // must call, in the first line, another overloaded constructor and, ultimately, the canonical one.\n    }\n}\n</code></pre> <p>Note</p> <ul> <li>The compiler will not insert a constructor if you manually provide one with the same list of parameters in the defined order;</li> <li>In this case, you must explicitly set every field manually;</li> </ul> <p></p>"},{"location":"en/module-04/beyond-classes/#1743-compact-constructor","title":"17.4.3 Compact Constructor","text":"<p>You can define a <code>compact constructor</code> which implicitly sets all fields, while letting you perform validations and transformations on selected fields.</p> <p>Java will execute the full constructor, setting all fields, after the compact constructor has completed.</p> <pre><code>public record Person(String name, int age) {\n\n    public Person {\n        if (age &lt; 0) throw new IllegalArgumentException();\n\n        name = name.toUpperCase(); // This transformation is still (at this level of initialization) on the input parameter.\n\n        // this.name = name; // \u274c Does not compile.\n    }   \n}\n</code></pre> <p>Warning</p> <ul> <li>If you try to modify a Record field inside a Compact Constructor, your code will not compile</li> </ul> <p></p>"},{"location":"en/module-04/beyond-classes/#1744-pattern-matching-for-records","title":"17.4.4 Pattern Matching for Records","text":"<p>When you use pattern matching with <code>instanceof</code> or with <code>switch</code>, a record pattern must specify:</p> <ul> <li>The record type;</li> <li>A pattern for each field of the record (matching the correct number of components, and compatible types);</li> </ul> <p>Example record:</p> <pre><code>Object obj = new Point(3, 5);\n\nif (obj instanceof Point(int a, int b)) {\n    System.out.println(a + b);   // 8\n}\n</code></pre> <p></p>"},{"location":"en/module-04/beyond-classes/#1745-nested-record-patterns-and-matching-records-with-var-and-generics","title":"17.4.5 Nested Record Patterns and Matching Records with <code>var</code> and Generics","text":"<p>Nested record patterns allow you to destructure records that contain other records or complex types, extracting values recursively directly within the pattern itself.</p> <p>They combine the power of <code>record</code> deconstruction with pattern matching, giving you a concise and expressive way to navigate hierarchical data structures.</p> <p></p>"},{"location":"en/module-04/beyond-classes/#17451-basic-nested-record-pattern","title":"17.4.5.1 Basic Nested Record Pattern","text":"<p>If a record contains another record, you can destructure both at once:</p> <pre><code>record Address(String city, String country) {}\nrecord Person(String name, Address address) {}\n\nvoid printInfo(Object obj) {\n\n    switch (obj) {\n        case Person(String n, Address(String c, String co)) -&gt; System.out.println(n + \" lives in \" + c + \", \" + co);\n        default -&gt; System.out.println(\"Unknown\");\n    }\n}\n</code></pre> <p>In the example above, the <code>Person</code> pattern includes a nested <code>Address</code> pattern.</p> <p>Both are matched structurally.</p> <p></p>"},{"location":"en/module-04/beyond-classes/#17452-nested-record-patterns-with-var","title":"17.4.5.2 Nested Record Patterns with <code>var</code>","text":"<p>Instead of specifying exact types for each field, you can use <code>var</code> inside the pattern to let the compiler infer the type. </p> <pre><code>    switch (obj) {\n        case Person(var name, Address(var city, var country)) -&gt; System.out.println(name + \" \u2014 \" + city + \", \" + country);\n    }\n</code></pre> <p><code>var</code> in patterns works like <code>var</code> in local variables: it means \"infer the type\".</p> <p>Warning</p> <ul> <li>You still need the enclosing record type (Person, Address);</li> <li>only the field types can be replaced with <code>var</code>.</li> </ul> <p></p>"},{"location":"en/module-04/beyond-classes/#17453-nested-record-patterns-and-generics","title":"17.4.5.3 Nested Record Patterns and Generics","text":"<p>Record patterns also work with generic records.</p> <pre><code>record Box&lt;T&gt;(T value) {}\nrecord Wrapper(Box&lt;String&gt; box) {}\n\nstatic void test(Object o) {\n    switch (o) {\n        case Wrapper(Box&lt;String&gt;(var v)) -&gt; System.out.println(\"Boxed string: \" + v);\n        default -&gt; System.out.println(\"Something else\");\n    }\n}\n</code></pre> <p>In this example:</p> <ul> <li>The pattern requires exactly <code>Box&lt;String&gt;</code>, not <code>Box&lt;Integer&gt;</code>.</li> <li>Inside the pattern, <code>var v</code> captures the unboxed generic value.</li> </ul> <p></p>"},{"location":"en/module-04/beyond-classes/#17454-common-errors-with-nested-record-patterns","title":"17.4.5.4 Common Errors with Nested Record Patterns","text":"<p>Mismatched record structure</p> <pre><code>// \u274c ERROR: pattern does not match record structure\ncase Person(var n, var city) -&gt; ...\n</code></pre> <p><code>Person</code> has 2 fields, but one of them is a record. You must destructure correctly.</p> <p>Wrong number of components</p> <pre><code>// \u274c ERROR: Address has 2 components, not 1\ncase Person(var n, Address(var onlyCity)) -&gt; ...\n</code></pre> <p>Generic mismatch</p> <pre><code>// \u274c ERROR: expecting Box&lt;String&gt; but found Box&lt;Integer&gt;\ncase Wrapper(Box&lt;Integer&gt;(var v)) -&gt; ...\n</code></pre> <p>Illegal placement of <code>var</code></p> <pre><code>// \u274c var cannot replace the record type itself\ncase var(Person(var n, var a)) -&gt; ...\n</code></pre> <p>Note</p> <ul> <li><code>var</code> cannot stand in for the whole pattern, only for individual components.</li> </ul> <p></p>"},{"location":"en/module-04/beyond-classes/#175-nested-classes-in-java","title":"17.5 Nested Classes in Java","text":"<p>Java supports several kinds of nested classes \u2014 classes declared inside another class.</p> <p>They are a fundamental tool for encapsulation, code organization, event-handling patterns, and representing logical hierarchies.</p> <p>A nested class always belongs to an enclosing class and has special accessibility and instantiation rules depending on its category.</p> <p>Java defines four kinds of nested classes:</p> <ul> <li>Static Nested Classes \u2013 declared with <code>static</code> inside another class.</li> <li>Inner Classes (non-static nested classes).</li> <li>Local Classes \u2013 declared inside a block (method, constructor, or initializer).</li> <li>Anonymous Classes \u2013 unnamed classes created inline, usually to override a method or implement an interface.</li> </ul> <p>Warning</p> <ul> <li><code>static</code> applies only to nested member classes</li> <li><code>Top-level</code> classes \u2192 cannot be static</li> <li><code>Local</code> classes (inside methods) \u2192 cannot be static</li> <li><code>Anonymous</code> classes \u2192 cannot be static</li> <li>A <code>static nested</code> class cannot access instance members without an explicit outer object reference.</li> </ul> <p></p>"},{"location":"en/module-04/beyond-classes/#1751-static-nested-classes","title":"17.5.1 Static Nested Classes","text":"<p>A static nested class behaves like a top-level class that is namespaced inside its enclosing class. It cannot access instance members of the outer class but can access static members. It does not hold a reference to an instance of the enclosing class. A static nested class can contain non-static member variables.</p> <p></p>"},{"location":"en/module-04/beyond-classes/#17511-syntax-and-access-rules","title":"17.5.1.1 Syntax and Access Rules","text":"<ul> <li>Declared using <code>static class</code> inside another class.</li> <li>Can access only static members of the outer class.</li> <li>Does not have an implicit reference to the enclosing instance.</li> <li>Can be instantiated without an outer instance.</li> </ul> <pre><code>class Outer {\n    static int version = 1;\n\n    static class Nested {\n        void print() {\n            System.out.println(\"Version: \" + version); // OK: accessing static member\n        }\n    }\n}\n\nclass Test {\n    public static void main(String[] args) {\n        Outer.Nested n = new Outer.Nested(); // No Outer instance required\n        n.print();\n    }\n}\n</code></pre>"},{"location":"en/module-04/beyond-classes/#17512-common-pitfalls","title":"17.5.1.2 Common Pitfalls","text":"<ul> <li>Static nested classes cannot access instance variables:</li> </ul> <pre><code>class Outer {\n    int x = 10;\n    static class Nested {\n        void test() {\n            // System.out.println(x); // \u274c Compile error\n        }\n    }\n}\n</code></pre>"},{"location":"en/module-04/beyond-classes/#1752-inner-classes-non-static-nested-classes","title":"17.5.2 Inner Classes (Non-Static Nested Classes)","text":"<p>An inner class is associated with an instance of the outer class and can access all members of the outer class, including private ones.</p> <p></p>"},{"location":"en/module-04/beyond-classes/#17521-syntax-and-access-rules","title":"17.5.2.1 Syntax and Access Rules","text":"<ul> <li>Declared without <code>static</code>.</li> <li>Has an implicit reference to the enclosing instance.</li> <li>Can access both static and instance members of the outer class.</li> <li>Since it is not static, it must be created through an instance of the enclosing class.</li> </ul> <pre><code>class Outer {\n    private int value = 100;\n\n    class Inner {\n        void print() {\n            System.out.println(\"Value = \" + value); // OK: accessing private\n        }\n    }\n\n    void make() {\n        Inner i = new Inner(); // OK inside the outer class\n        i.print();\n    }\n}\n\nclass Test {\n    public static void main(String[] args) {\n        Outer o = new Outer();\n        Outer.Inner i = o.new Inner(); // MUST be created from an instance\n        i.print();\n    }\n}\n</code></pre>"},{"location":"en/module-04/beyond-classes/#17522-common-pitfalls","title":"17.5.2.2 Common Pitfalls","text":"<ul> <li>Inner classes cannot declare static members except static final constants.</li> </ul> <pre><code>class Outer {\n    class Inner {\n        // static int x = 10;     // \u274c Compile error\n        static final int OK = 10; // \u2714 Allowed (constant)\n    }\n}\n</code></pre> <p>Warning</p> <ul> <li>Instantiating an inner class WITHOUT an outer instance is illegal.</li> </ul> <p></p>"},{"location":"en/module-04/beyond-classes/#1753-local-classes","title":"17.5.3 Local Classes","text":"<p>A local class is a nested class defined inside a block \u2014 most commonly a method.</p> <p>It has no access modifier and is visible only within the block where it is declared.</p> <p></p>"},{"location":"en/module-04/beyond-classes/#17531-characteristics","title":"17.5.3.1 Characteristics","text":"<ul> <li>Declared inside a method, constructor, or initializer.</li> <li>Can access members of the outer class.</li> <li>Can access local variables if they are effectively final.</li> <li>Cannot declare static members (except static final constants).</li> </ul> <pre><code>class Outer {\n    void compute() {\n        int base = 5; // must be effectively final\n\n        class Local {\n            void show() {\n                System.out.println(base); // OK\n            }\n        }\n\n        new Local().show();\n    }\n}\n</code></pre>"},{"location":"en/module-04/beyond-classes/#17532-common-pitfalls","title":"17.5.3.2 Common Pitfalls","text":"<ul> <li><code>base</code> must be effectively final; changing it breaks compilation.</li> </ul> <pre><code>void compute() {\n    int base = 5;\n    base++; // \u274c Now base is NOT effectively final\n    class Local {}\n}\n</code></pre>"},{"location":"en/module-04/beyond-classes/#1754-anonymous-classes","title":"17.5.4 Anonymous Classes","text":"<p>An anonymous class is a one-off class created inline, usually to implement an interface or override a method without naming a new class.</p> <p></p>"},{"location":"en/module-04/beyond-classes/#17541-syntax-and-usage","title":"17.5.4.1 Syntax and Usage","text":"<ul> <li>Created using <code>new</code> + type + body.</li> <li>Cannot have constructors (no name).</li> <li>Often used for event handling, callbacks, comparators.</li> </ul> <pre><code>Runnable r = new Runnable() {\n    @Override\n    public void run() {\n        System.out.println(\"Anonymous running\");\n    }\n};\n</code></pre>"},{"location":"en/module-04/beyond-classes/#17542-anonymous-class-extending-a-class","title":"17.5.4.2 Anonymous Class Extending a Class","text":"<pre><code>Button b = new Button(\"Click\");\nb.onClick(new ClickHandler() {\n    @Override\n    public void handle() {\n        System.out.println(\"Handled!\");\n    }\n});\n</code></pre>"},{"location":"en/module-04/beyond-classes/#1755-comparison-of-nested-class-types","title":"17.5.5 Comparison of Nested Class Types","text":"<p>A quick table summarizing all kinds of nested classes.</p> Type Has Outer Instance? Can Access Outer Instance Members? Can Have Static Members? Typical Use Static Nested No No Yes Namespacing, helpers Inner Class Yes Yes No (except constants) Object-bound behavior Local Class Yes Yes No Temporary scoped classes Anonymous Class Yes Yes No Inline customization <p></p>"},{"location":"en/module-04/beyond-classes/#176-nesting-of-interfaces-in-java","title":"17.6 Nesting of Interfaces in Java","text":"<p>In Java, an interface can be declared in different locations and follows specific rules regarding nesting and permitted members.</p> <p></p>"},{"location":"en/module-04/beyond-classes/#1761-where-an-interface-can-be-declared","title":"17.6.1 Where an Interface Can Be Declared","text":"<p>An interface can be:</p> <ul> <li>Top-level (directly inside a package)</li> <li>Nested member interface (declared inside a class or another interface)</li> <li>Local interface \u274c (not allowed)</li> <li>Anonymous interface \u274c (does not exist as a declaration, only anonymous implementations exist)</li> </ul> <p>In Java, it is not permitted to declare a local interface (that is, inside a method or block). Interfaces can only be <code>top-level</code> or <code>member</code>.</p> <p></p>"},{"location":"en/module-04/beyond-classes/#1762-nested-interfaces","title":"17.6.2 Nested Interfaces","text":"<p>A Nested Interface can be declared inside:</p> <p></p>"},{"location":"en/module-04/beyond-classes/#17621-interface-nested-inside-a-class","title":"17.6.2.1 Interface Nested Inside a Class","text":"<ul> <li>It is implicitly <code>static</code></li> <li>It cannot be declared <code>non-static</code></li> <li> <p>It may be declared <code>public</code>, <code>protected</code>, <code>private</code>, or <code>package-private</code></p> </li> <li> <p>Example:</p> </li> </ul> <pre><code>class Outer {\n    interface InnerInterface {\n        void test();\n    }\n}\n</code></pre> <p>The <code>static</code> keyword is implicit:</p> <pre><code>class Outer {\n    static interface InnerInterface {   // allowed but redundant\n        void test();\n    }\n}\n</code></pre> <p></p>"},{"location":"en/module-04/beyond-classes/#17622-interface-nested-inside-another-interface","title":"17.6.2.2 Interface Nested Inside Another Interface","text":"<ul> <li>It is implicitly <code>public</code> and <code>static</code></li> <li>It cannot be <code>private</code> or <code>protected</code></li> </ul> <pre><code>interface A {\n    interface B {\n        void test();\n    }\n}\n</code></pre>"},{"location":"en/module-04/beyond-classes/#1763-access-rules","title":"17.6.3 Access Rules","text":"<p>A <code>nested interface</code>:</p> <ul> <li>Does not have an implicit reference to an instance of the enclosing class</li> <li>Cannot directly access instance members of the enclosing class</li> <li>Can access only <code>static</code> members of the enclosing class</li> </ul> <p></p>"},{"location":"en/module-04/beyond-classes/#1764-nested-types-inside-interfaces","title":"17.6.4 Nested Types Inside Interfaces","text":"<p>An interface may contain:</p> <ul> <li>Nested classes (implicitly <code>public static</code>)</li> <li>Nested records (implicitly <code>public static</code>)</li> <li>Nested enums (implicitly <code>public static</code>)</li> <li>Other nested interfaces (implicitly <code>public static</code>)</li> </ul> <p></p>"},{"location":"en/module-04/beyond-classes/#1765-essential-summary","title":"17.6.5 Essential Summary","text":"<ul> <li>Nested interfaces are always <code>static</code></li> <li>Local interfaces do not exist</li> <li>Fields are always <code>public static final</code></li> <li>Methods are implicitly <code>public abstract</code> (except default/static/private)</li> <li>They may contain other nested types</li> </ul>"},{"location":"en/module-04/class-loading/","title":"15. Class Loading, Initialization, and Object Construction","text":""},{"location":"en/module-04/class-loading/#table-of-contents","title":"Table of Contents","text":"<ul> <li>15.1 Java Memory Areas Relevant to Class and Object Initialization</li> <li>15.2 Class Loading with Inheritance<ul> <li>15.2.1 Class Loading Order</li> <li>15.2.2 What Happens During Class Loading</li> </ul> </li> <li>15.3 Object Creation with Inheritance<ul> <li>15.3.1 Full Instance Creation Order</li> </ul> </li> <li>15.4 A Complete Example Static + Instance Initialization Across Inheritance</li> <li>15.5 Visualization Diagram</li> <li>15.6 Key Rules</li> <li>15.7 Summary Table</li> </ul> <p>In Java, understanding how classes are loaded, how static and instance members are initialized, and how constructors run \u2014 especially with inheritance \u2014 is essential for mastering the language.</p> <p>This chapter provides a unified, clear explanation of:</p> <ul> <li>How a class is loaded into memory</li> <li>How static variables and static initializers are executed</li> <li>How objects are created step-by-step</li> <li>How constructors run in an inheritance chain</li> <li>How different memory areas (Heap, Stack, Method Area) participate</li> </ul> <p></p>"},{"location":"en/module-04/class-loading/#151-java-memory-areas-relevant-to-class-and-object-initialization","title":"15.1 Java Memory Areas Relevant to Class and Object Initialization","text":"<p>Before understanding initialization order, it is useful to recall the three main memory areas involved:</p> <ul> <li>Method Area (a.k.a. Class Area) \u2014 stores class metadata, static variables, and static initializer blocks.</li> <li>Heap \u2014 stores all objects and instance fields.</li> <li>Stack \u2014 stores method calls, local variables, and references.</li> </ul> <p>Note</p> <p>Static members belong to the class and are created once in the Method Area.</p> <p>Instance members belong to each object and live in the Heap.</p> <p></p>"},{"location":"en/module-04/class-loading/#152-class-loading-with-inheritance","title":"15.2 Class Loading (with Inheritance)","text":"<p>When a Java program starts, the JVM loads classes on demand.</p> <p>When a class is referenced for the first time (e.g., by calling <code>new</code> or accessing a static member), its entire inheritance chain must be loaded in memory first.</p> <p></p>"},{"location":"en/module-04/class-loading/#1521-class-loading-order","title":"15.2.1 Class Loading Order","text":"<p>Given a class hierarchy:</p> <pre><code>class A { ... }\nclass B extends A { ... }\nclass C extends B { ... }\n</code></pre> <p>If the code executes:</p> <pre><code>public static void main(String[] args) {\n    new C();\n}\n</code></pre> <p>Then class loading proceeds in this strict order:</p> <ul> <li>Load class A</li> <li>Initialize A\u2019s static variables (default \u2192 explicit)</li> <li>Run A\u2019s static initializer blocks (top \u2192 bottom)</li> <li>Load class B and repeat the same logic</li> <li>Load class C and repeat the same logic</li> </ul> <p></p>"},{"location":"en/module-04/class-loading/#1522-what-happens-during-class-loading","title":"15.2.2 What Happens During Class Loading","text":"<ul> <li>Step 1: Static variables are allocated (default values first).</li> <li>Step 2: Explicit static initializations run.</li> <li>Step 3: Static initializer blocks run in source order.</li> </ul> <p>Note</p> <p>After these steps, the class is fully prepared and may now be used (instantiated or referenced).</p> <p></p>"},{"location":"en/module-04/class-loading/#153-object-creation-with-inheritance","title":"15.3 Object Creation (with Inheritance)","text":"<p>When the <code>new</code> keyword is used, instance creation follows a strict and predictable sequence involving all parent classes.</p> <p></p>"},{"location":"en/module-04/class-loading/#1531-full-instance-creation-order","title":"15.3.1 Full Instance Creation Order","text":"<ul> <li>1. Memory is allocated on the Heap for the new object (fields get default values).</li> <li>2. The constructor chain runs (not yet the bodies) from parent to child \u2014 the top of the hierarchy runs first, then each subclass.</li> <li>3. Instance variables receive explicit initializations.</li> <li>4. Instance initializer blocks execute.</li> <li>5. The constructor body runs: for each class in the inheritance chain, steps 3\u20135 (field initialization, instance blocks, constructor body) are applied from parent to child.</li> </ul>"},{"location":"en/module-04/class-loading/#154-a-complete-example-static-instance-initialization-across-inheritance","title":"15.4 A Complete Example: Static + Instance Initialization Across Inheritance","text":"<p>Consider the following three-level hierarchy:</p> <pre><code>class A {\n    static int sa = init(\"A static var\");\n\n    static {\n        System.out.println(\"A static block\");\n    }\n\n    int ia = init(\"A instance var\");\n\n    {\n        System.out.println(\"A instance block\");\n    }\n\n    A() {\n        System.out.println(\"A constructor\");\n    }\n\n    static int init(String msg) {\n        System.out.println(msg);\n        return 0;\n    }\n}\n\nclass B extends A {\n    static int sb = init(\"B static var\");   // call to the inherited static method init(String)\n\n    static {\n        System.out.println(\"B static block\");\n    }\n\n    int ib = init(\"B instance var\");    // call to the inherited static method init(String)\n\n    {\n        System.out.println(\"B instance block\");\n    }\n\n    B() {\n        System.out.println(\"B constructor\");\n    }\n}\n\nclass C extends B {\n    static int sc = init(\"C static var\");   // call to the inherited static method init(String)\n\n    static {\n        System.out.println(\"C static block\");\n    }\n\n    int ic = init(\"C instance var\");    // call to the inherited static method init(String)\n\n    {\n        System.out.println(\"C instance block\");\n    }\n\n    C() {\n        System.out.println(\"C constructor\");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        new C();\n    }\n}\n</code></pre> <p>Output</p> <pre><code>A static var\nA static block\nB static var\nB static block\nC static var\nC static block\nA instance var\nA instance block\nA constructor\nB instance var\nB instance block\nB constructor\nC instance var\nC instance block\nC constructor\n</code></pre> <p></p>"},{"location":"en/module-04/class-loading/#155-visualization-diagram","title":"15.5 Visualization Diagram","text":"<pre><code>            CLASS LOADING (top to bottom)\n\n                A  ---&gt;  B  ---&gt;  C\n                |         |         |\n      static vars + static blocks executed in order\n\n-------------------------------------------------------\n\n            OBJECT CREATION (bottom to top)\n\n new C() \n    |\n    +--&gt; allocate memory for C (default values)\n    +--&gt; call B() constructor\n            |\n            +--&gt; call A() constructor\n                    |\n                    +--&gt; init A instance vars\n                    +--&gt; run A instance blocks\n                    +--&gt; run A constructor\n            +--&gt; init B instance vars\n            +--&gt; run B instance blocks\n            +--&gt; run B constructor\n    +--&gt; init C instance vars\n    +--&gt; run C instance blocks\n    +--&gt; run C constructor\n</code></pre>"},{"location":"en/module-04/class-loading/#156-key-rules","title":"15.6 Key Rules","text":"<ul> <li>Static initialization happens once per class.</li> <li>Static initializers run in parent \u2192 child order.</li> <li>Instance initialization runs every time an object is created.</li> <li>For each class in the inheritance chain, instance fields and instance blocks run before that class\u2019s constructor body.</li> <li>Overall, both field/instance initialization and constructors execute from parent to child.</li> <li>Constructors always call the parent constructor (explicitly or implicitly).</li> </ul>"},{"location":"en/module-04/class-loading/#157-summary-table","title":"15.7 Summary Table","text":"STATIC (Class Level) INSTANCE (Object Level) One-time-only Happens at every 'new' Executed parent \u2192 child Instance initialization and constructors parent \u2192 child static vars (default \u2192 explicit) instance vars (default \u2192 explicit) static blocks instance blocks + constructor"},{"location":"en/module-04/exceptions/","title":"19. Exceptions and Error Handling","text":""},{"location":"en/module-04/exceptions/#table-of-contents","title":"Table of Contents","text":"<ul> <li>19.1 Exception hierarchy and types<ul> <li>19.1.1 Throwable</li> <li>19.1.2 Error (unchecked)</li> <li>19.1.3 Checked Exceptions (<code>Exception</code>)</li> <li>19.1.4 Unchecked Exceptions (<code>RuntimeException</code>)</li> </ul> </li> <li>19.2 Declaring and throwing exceptions<ul> <li>19.2.1 Declaring exceptions with throws</li> <li>19.2.2 Throwing exceptions</li> </ul> </li> <li>19.3 Overriding methods and exception rules</li> <li>19.4 Handling exceptions: try, catch, finally<ul> <li>19.4.1 Basic try-catch syntax</li> <li>19.4.2 Multiple catch blocks</li> <li>19.4.3 Multi-catch Java-7</li> <li>19.4.4 finally block</li> </ul> </li> <li>19.5 Automatic Resource Management try-with-resources<ul> <li>19.5.1 Basic syntax</li> <li>19.5.2 Declaring multiple resources</li> <li>19.5.3 Scope of resources</li> </ul> </li> <li>19.6 Suppressed exceptions</li> <li>19.7 Exceptions summary</li> </ul> <p><code>Exceptions</code> are Java\u2019s structured mechanism for handling abnormal conditions at runtime. </p> <p>They allow programs to separate normal execution flow from error-handling logic, improving robustness, readability, and correctness. </p> <p></p>"},{"location":"en/module-04/exceptions/#191-exception-hierarchy-and-types","title":"19.1 Exception hierarchy and types","text":"<p>All exceptions derive from <code>Throwable</code>. </p> <p>The hierarchy defines which conditions are recoverable, which must be declared, and which represent fatal system failures.</p> <pre><code>java.lang.Object\n\u2514\u2500\u2500 java.lang.Throwable\n    \u251c\u2500\u2500 java.lang.Error\n    \u2514\u2500\u2500 java.lang.Exception\n        \u2514\u2500\u2500 java.lang.RuntimeException\n</code></pre> <p></p>"},{"location":"en/module-04/exceptions/#1911-throwable","title":"19.1.1 Throwable","text":"<ul> <li>Base class for all errors and exceptions</li> <li>Supports message, cause, and stack trace</li> <li>Only <code>Throwable</code> (and subclasses) can be thrown or caught</li> </ul>"},{"location":"en/module-04/exceptions/#1912-error-unchecked","title":"19.1.2 Error (unchecked)","text":"<ul> <li>Represents serious JVM or system problems</li> <li>Not intended to be caught or handled</li> <li>Examples: <code>OutOfMemoryError</code>, <code>StackOverflowError</code></li> </ul> <p>Note</p> <p>Errors indicate conditions from which the application is generally not expected to recover.</p> <p></p>"},{"location":"en/module-04/exceptions/#1913-checked-exceptions-exception","title":"19.1.3 Checked Exceptions (<code>Exception</code>)","text":"<ul> <li>Subclasses of <code>Exception</code> excluding <code>RuntimeException</code></li> <li>Represent conditions that applications may want to handle</li> <li>Must be either caught or declared</li> <li>Examples: <code>IOException</code>, <code>SQLException</code></li> </ul>"},{"location":"en/module-04/exceptions/#1914-unchecked-exceptions-runtimeexception","title":"19.1.4 Unchecked Exceptions (<code>RuntimeException</code>)","text":"<ul> <li>Subclasses of <code>RuntimeException</code></li> <li>Not required to be declared or caught</li> <li>Usually represent programming errors</li> <li>Examples: <code>NullPointerException</code>, <code>IllegalArgumentException</code></li> </ul>"},{"location":"en/module-04/exceptions/#192-declaring-and-throwing-exceptions","title":"19.2 Declaring and throwing exceptions","text":""},{"location":"en/module-04/exceptions/#1921-declaring-exceptions-with-throws","title":"19.2.1 Declaring exceptions with throws","text":"<p>A method declares checked exceptions using the <code>throws</code> clause. This is part of the method\u2019s API contract.</p> <pre><code>void readFile(Path p) throws IOException {\n    Files.readString(p);\n}\n</code></pre> <p>Note</p> <p>Only checked exceptions must be declared. Unchecked exceptions may be declared, but are usually omitted.</p> <p></p>"},{"location":"en/module-04/exceptions/#1922-throwing-exceptions","title":"19.2.2 Throwing exceptions","text":"<p>Exceptions are created with <code>new</code> and thrown explicitly using <code>throw</code>.</p> <pre><code>if (value &lt; 0) {\n    throw new IllegalArgumentException(\"value must be &gt;= 0\");\n}\n</code></pre> <ul> <li><code>throw</code> throws exactly one exception instance</li> <li><code>throws</code> declares possible exceptions in the method signature</li> </ul> <p></p>"},{"location":"en/module-04/exceptions/#193-overriding-methods-and-exception-rules","title":"19.3 Overriding methods and exception rules","text":"<p>When overriding a method, exception rules are strictly enforced.</p> <ul> <li>An overriding method may throw fewer or narrower checked exceptions</li> <li>It may throw any unchecked exceptions</li> <li>It may throw no new or broader checked exceptions</li> </ul> <pre><code>class Parent {\n    void work() throws IOException {}\n}\n\nclass Child extends Parent {\n    @Override\n    void work() throws FileNotFoundException {} // OK (subclass)\n}\n</code></pre> <p>Note</p> <p>Changing only the unchecked exceptions never breaks the override contract.</p> <p></p>"},{"location":"en/module-04/exceptions/#194-handling-exceptions-try-catch-finally","title":"19.4 Handling exceptions: try, catch, finally","text":""},{"location":"en/module-04/exceptions/#1941-basic-try-catch-syntax","title":"19.4.1 Basic try-catch syntax","text":"<pre><code>try {\n    riskyOperation();\n} catch (IOException e) {\n    handle(e);\n}\n</code></pre> <ul> <li>A <code>try</code> block must be followed by at least one <code>catch</code> or a <code>finally</code></li> <li>Catches are checked top-down</li> </ul>"},{"location":"en/module-04/exceptions/#1942-multiple-catch-blocks","title":"19.4.2 Multiple catch blocks","text":"<p>Multiple catch blocks allow different handling for different exception types.</p> <pre><code>try {\n    process();\n} catch (FileNotFoundException e) {\n    recover();\n} catch (IOException e) {\n    log();\n}\n</code></pre> <p>Note</p> <p>More specific exceptions must come before more general ones, otherwise compilation fails. If you place a catch for a superclass (e.g. <code>IOException</code>) before a catch for a subclass (e.g. <code>FileNotFoundException</code>), the subclass catch becomes unreachable.</p> <p></p>"},{"location":"en/module-04/exceptions/#1943-multi-catch-java-7","title":"19.4.3 Multi-catch (Java 7+)","text":"<pre><code>try {\n    process();\n} catch (IOException | SQLException e) {\n    log(e);\n}\n</code></pre> <ul> <li>Exception types must be unrelated (no parent/child)</li> <li>The caught variable is implicitly <code>final</code></li> </ul>"},{"location":"en/module-04/exceptions/#1944-finally-block","title":"19.4.4 finally block","text":"<p>The <code>finally</code> block executes regardless of whether an exception is thrown, except in extreme JVM termination cases.</p> <pre><code>try {\n    open();\n} finally {\n    close();\n}\n</code></pre> <ul> <li>Used for cleanup logic</li> <li>Executes even if <code>return</code> is used in try and/or catch block</li> </ul> <p>Note</p> <p>A <code>finally</code> block can override a return value or swallow an exception. This is generally discouraged because it makes the control flow harder to reason about.</p> <p></p>"},{"location":"en/module-04/exceptions/#195-automatic-resource-management-try-with-resources","title":"19.5 Automatic Resource Management (try-with-resources)","text":"<p>Try-with-resources provides automatic closing of resources that implement <code>AutoCloseable</code>. </p> <p>It eliminates the need for explicit <code>finally</code> cleanup in most cases.</p> <p></p>"},{"location":"en/module-04/exceptions/#1951-basic-syntax","title":"19.5.1 Basic syntax","text":"<pre><code>try (BufferedReader br = Files.newBufferedReader(path)) {\n    return br.readLine();\n}\n</code></pre> <ul> <li>Resources are closed automatically</li> <li>Closure happens even if an exception is thrown</li> <li>Resources are closed before any catch or finally block executes.</li> </ul> <pre><code>try (Resource a = new Resource()) {\n    a.read();\n} finally {\n    a.close();  // \u274c Compile-time error: a is out of scope here\n}\n</code></pre>"},{"location":"en/module-04/exceptions/#1952-declaring-multiple-resources","title":"19.5.2 Declaring multiple resources","text":"<pre><code>try (InputStream in = Files.newInputStream(p);\n        OutputStream out = Files.newOutputStream(q)) {\n    in.transferTo(out);\n}\n</code></pre> <ul> <li>Resources are closed in reverse order of declaration</li> </ul>"},{"location":"en/module-04/exceptions/#1953-scope-of-resources","title":"19.5.3 Scope of resources","text":"<ul> <li>Resources are in scope only inside the <code>try</code> block</li> <li>They are implicitly <code>final</code></li> <li>Since Java 9, you can declare resources ahead of time, outside the <code>try-with-resources</code>, provided they are declared as <code>final</code> or are effectively final.</li> </ul> <pre><code>final var firstWriter = Files.newBufferedWriter(filePath);\n\ntry (firstWriter; var secondWriter = Files.newBufferedWriter(filePath)) {\n    // CODE\n}\n</code></pre> <p>Note</p> <p>Attempting to reassign a resource variable causes a compilation error.</p> <pre><code>Resource a = new Resource();\ntry(a){ // since Java 9\n  ...\n}finally{\n   a.close(); // this code will compile but the resource referred to by the reference 'a', has been closed.\n}\n</code></pre> <p></p>"},{"location":"en/module-04/exceptions/#196-suppressed-exceptions","title":"19.6 Suppressed exceptions","text":"<p>When both the <code>try</code> block and the resource\u2019s <code>close()</code> method throw exceptions, Java preserves the primary exception and suppresses the others.</p> <pre><code>try (BadResource r = new BadResource()) {\n    throw new RuntimeException(\"main\");\n}\n</code></pre> <p>If <code>close()</code> also throws an exception, it becomes suppressed.</p> <pre><code>catch (Exception e) {\n    for (Throwable t : e.getSuppressed()) {\n        System.out.println(t);\n    }\n}\n</code></pre> <ul> <li>Primary exception is thrown</li> <li>Secondary exceptions are accessible via <code>getSuppressed()</code></li> </ul> <p></p>"},{"location":"en/module-04/exceptions/#197-exceptions-summary","title":"19.7 Exceptions summary","text":"<ul> <li>Checked exceptions must be caught or declared</li> <li>Overriding methods may not widen checked exceptions</li> <li>Use multi-catch for shared handling logic</li> <li>Prefer try-with-resources over finally cleanup</li> <li>Resources close in reverse order</li> <li>Suppressed exceptions preserve full failure context</li> </ul>"},{"location":"en/module-04/generics/","title":"18. Generics in Java","text":""},{"location":"en/module-04/generics/#table-of-contents","title":"Table of Contents","text":"<ul> <li>18.1 Generic Type Basics</li> <li>18.2 Why Generics Exist</li> <li>18.3 Generic Methods</li> <li>18.4 Type Erasure<ul> <li>18.4.1 How Type Erasure Works</li> <li>18.4.2 Erasure of Unbounded Type Parameters</li> <li>18.4.3 Erasure of Bounded Type Parameters</li> <li>18.4.4 Multiple Bounds The First Bound Determines Erasure</li> <li>18.4.5 Why Only the First Bound Becomes the Runtime Type</li> <li>18.4.6 A More Complex Example</li> <li>18.4.7 Overriding and Generics<ul> <li>18.4.7.1 How the Compiler Validates an Override</li> <li>18.4.7.2 Generic Parameters and Overriding</li> <li>18.4.7.3 Valid Override - Erasing Generic Specificity</li> <li>18.4.7.4 Invalid Override - Adding Generic Specificity</li> <li>18.4.7.5 Valid Override - Matching Parameterization</li> <li>18.4.7.6 Invalid Override - Changing Generic Argument</li> <li>18.4.7.7 Why This Rule Exists</li> <li>18.4.7.8 Mental Model</li> <li>18.4.7.9 Summary Rules</li> </ul> </li> <li>18.4.8 Overloading a Generic Method Why Some Overloads Are Impossible</li> <li>18.4.9 Overloading a Generic Method Inherited from a Parent Class</li> <li>18.4.10 Returning Generic Types Rules and Restrictions</li> <li>18.4.11 Summary of Erasure Rules</li> </ul> </li> <li>18.5 Bounds on Type Parameters<ul> <li>18.5.1 Upper Bounds extends</li> <li>18.5.2 Multiple Bounds</li> <li>18.5.3 Wildcards: ?, ? extends, ? super<ul> <li>18.5.3.1 Unbounded Wildcard</li> <li>18.5.3.2 Upper-Bounded Wildcard extends</li> <li>18.5.3.3 Lower-Bounded Wildcard super</li> </ul> </li> </ul> </li> <li>18.6 Generics and Inheritance</li> <li>18.7 Type Inference Diamond Operator</li> <li>18.8 Raw Types Legacy Compatibility</li> <li>18.9 Generic Arrays Not Allowed</li> <li>18.10 Bounded Type Inference</li> <li>18.11 Wildcards vs Type Parameters</li> <li>18.12 PECS Rule Producer Extends Consumer Super</li> <li>18.13 Common Pitfalls</li> <li>18.14 Summary Table of Wildcards</li> <li>18.15 Summary of Concepts</li> <li>18.16 Complete Example</li> </ul> <p>Java <code>Generics</code> allow you to create classes, interfaces, and methods that work with user-specified types, ensuring that only objects of the correct type are used.</p> <p>All type checks are performed by the compiler at compile time.</p> <p>During compilation, the compiler verifies type correctness and then removes the generic type information, replacing it with concrete types (a process known as type erasure) or with Object when necessary.</p> <p>The resulting bytecode does not contain generics: it only contains concrete types and, when needed, casts automatically inserted by the compiler.</p> <p>In this way, type errors are caught before execution, making the code safer, more readable, and more reusable.</p> <p>Generics apply to: - <code>Classes</code> - <code>Interfaces</code> - <code>Methods</code> (generic methods) - <code>Constructors</code> </p> <p></p>"},{"location":"en/module-04/generics/#181-generic-type-basics","title":"18.1 Generic Type Basics","text":"<p>A generic class or interface introduces one or more type parameters, enclosed in angle brackets.</p> <pre><code>class Box&lt;T&gt; {\n    private T value;\n    void set(T v) { value = v; }\n    T get()       { return value; }\n}\n\nBox&lt;String&gt; b = new Box&lt;&gt;();\nb.set(\"hello\");\nString x = b.get(); // no cast needed\n</code></pre> <p>Multiple type parameters are allowed:</p> <pre><code>class Pair&lt;K, V&gt; {\n    K key;\n    V value;\n}\n</code></pre> <p></p>"},{"location":"en/module-04/generics/#182-why-generics-exist","title":"18.2 Why Generics Exist","text":"<pre><code>List list = new ArrayList();          // pre-generics\nlist.add(\"hi\");\nInteger x = (Integer) list.get(0);    // ClassCastException at runtime\n</code></pre> <p>With generics:</p> <pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"hi\");\nString x = list.get(0);               // type-safe, no cast\n</code></pre> <p></p>"},{"location":"en/module-04/generics/#183-generic-methods","title":"18.3 Generic Methods","text":"<p>A generic method introduces its own type parameter(s), independent of the class.</p> <pre><code>class Util {\n    static &lt;T&gt; T pick(T a, T b) { return a; }\n}\n\nString s = Util.&lt;String&gt;pick(\"A\", \"B\"); // explicit\nString t = Util.pick(\"A\", \"B\");         // inference works\n</code></pre> <p></p>"},{"location":"en/module-04/generics/#184-type-erasure","title":"18.4 Type Erasure","text":"<p><code>Type erasure</code> is the process by which the Java compiler removes all generic type information before generating bytecode. </p> <p>This ensures backward compatibility with pre-Java-5 JVMs.</p> <p>At compile time, generics are fully checked: type bounds, variance, method overloading with generics, etc. However, at runtime, all generic information disappears.</p> <p></p>"},{"location":"en/module-04/generics/#1841-how-type-erasure-works","title":"18.4.1 How Type Erasure Works","text":"<ul> <li>Replace all type variables (like <code>T</code>) with their erasure.</li> <li>Insert casts where needed.</li> <li>Remove all generic type arguments (e.g., <code>List&lt;String&gt;</code> \u2192 <code>List</code>).</li> </ul>"},{"location":"en/module-04/generics/#1842-erasure-of-unbounded-type-parameters","title":"18.4.2 Erasure of Unbounded Type Parameters","text":"<p>If a type variable has no bound:</p> <pre><code>class Box&lt;T&gt; {\n    T value;\n    T get() { return value; }\n}\n</code></pre> <p>The erasure of <code>T</code> is <code>Object</code>.</p> <pre><code>class Box {\n    Object value;\n    Object get() { return value; }\n}\n</code></pre> <p></p>"},{"location":"en/module-04/generics/#1843-erasure-of-bounded-type-parameters","title":"18.4.3 Erasure of Bounded Type Parameters","text":"<p>If the type parameter has bounds:</p> <pre><code>class TaskRunner&lt;T extends Runnable&gt; {\n    void run(T task) { task.run(); }\n}\n</code></pre> <p>Then the erasure of <code>T</code> is the first bound: <code>Runnable</code>.</p> <pre><code>class TaskRunner {\n    void run(Runnable task) { task.run(); }\n}\n</code></pre> <p></p>"},{"location":"en/module-04/generics/#1844-multiple-bounds-the-first-bound-determines-erasure","title":"18.4.4 Multiple Bounds: The First Bound Determines Erasure","text":"<p>Java allows multiple bounds:</p> <pre><code>&lt;T extends Runnable &amp; Serializable &amp; Cloneable&gt;\n</code></pre> <p>The critical rule:</p> <p>Important</p> <p>The erasure of <code>T</code> is always the first bound, which must be a class or interface.</p> <p>Because <code>Runnable</code> is the first bound, the compiler erases <code>T</code> to <code>Runnable</code>.</p> <p>-Example with Multiple Bounds (Fully Expanded)</p> <pre><code>public static &lt;T extends Runnable &amp; Serializable &amp; Cloneable&gt;\nvoid runAll(List&lt;T&gt; list) {\n    for (T t : list) {\n        t.run();\n    }\n}\n</code></pre> <p>Erased Version</p> <pre><code>public static void runAll(List list) {\n    for (Object obj : list) {\n        Runnable t = (Runnable) obj;   // cast set by the compiler\n        t.run();\n    }\n}\n</code></pre> <p>What happens to the other bounds (Serializable, Cloneable)?</p> <ul> <li>They are enforced only at compile time.</li> <li>They do NOT appear in bytecode.</li> <li>No additional interfaces are attached to the erased type.</li> </ul> <p></p>"},{"location":"en/module-04/generics/#1845-why-only-the-first-bound-becomes-the-runtime-type","title":"18.4.5 Why Only the First Bound Becomes the Runtime Type?","text":"<p>Because the JVM must operate using a single, concrete reference type for each variable or parameter.</p> <p>Runtime bytecode instructions like <code>invokevirtual</code> require a single class or interface, not a composite type such as \u201cRunnable &amp; Serializable &amp; Cloneable\u201d.</p> <p>Thus:</p> <p>Note</p> <p>Java selects the first bound as the runtime type, and uses the remaining bounds for compile-time validation only.</p> <p></p>"},{"location":"en/module-04/generics/#1846-a-more-complex-example","title":"18.4.6 A More Complex Example","text":"<pre><code>interface A { void a(); }\ninterface B { void b(); }\n\nclass C implements A, B {\n    public void a() {}\n    public void b() {}\n}\n\nclass Demo&lt;T extends A &amp; B&gt; {\n    void test(T value) {\n        value.a();\n        value.b();\n    }\n}\n</code></pre> <p>Erased Version</p> <pre><code>class Demo {\n    void test(A value) {\n        value.a();\n        // value.b();   // \u274c not available after erasure: type is A, not B\n    }\n}\n</code></pre> <p>Note</p> <p>The compiler may insert additional casts or bridge methods in more complex inheritance scenarios, but erasure always uses only the first bound (A in this case).</p> <p></p>"},{"location":"en/module-04/generics/#1847-overriding-and-generics","title":"18.4.7 Overriding and Generics","text":"<p>When generics interact with inheritance, two fundamental rules must be clearly understood:</p> <p>Important</p> <p>Override is checked after type erasure. Type compatibility is checked before type erasure.</p> <p>These two steps explain why some methods override correctly while others produce compile-time errors.</p> <p></p>"},{"location":"en/module-04/generics/#18471-how-the-compiler-validates-an-override","title":"18.4.7.1 How the Compiler Validates an Override","text":"<p>When a subclass declares a method that might override a superclass method, the compiler performs two checks:</p> <ol> <li>Before erasure    The method must be type-compatible with the parent method.</li> <li>Same method name</li> <li>Same parameter types (including generic arguments)</li> <li> <p>Compatible return type (covariant allowed)</p> </li> <li> <p>After erasure    The erased signatures must match exactly.</p> </li> </ol> <p>Both conditions must be satisfied.</p> <p></p>"},{"location":"en/module-04/generics/#18472-generic-parameters-and-overriding","title":"18.4.7.2 Generic Parameters and Overriding","text":"<p>Generic type arguments are part of the method signature at compile time, but disappear after erasure.</p> <p>Because of this:</p> <ul> <li>You are allowed to erase generic information in the overriding method</li> <li>You are NOT allowed to introduce new generic specificity</li> <li>If both methods declare parameterized types, they must match exactly</li> </ul> <p></p>"},{"location":"en/module-04/generics/#18473-valid-override-erasing-generic-specificity","title":"18.4.7.3 Valid Override - Erasing Generic Specificity","text":"<pre><code>class Parent {\n    void process(Set&lt;Integer&gt; data) {}\n}\n\nclass Child extends Parent {\n    @Override\n    void process(Set data) {}   // \u2714 allowed (raw type)\n}\n</code></pre> <p>Explanation:</p> <ul> <li>Before erasure: <code>Set</code> is assignment-compatible with <code>Set&lt;Integer&gt;</code></li> <li>After erasure: both become <code>Set</code></li> </ul> <p>\u2714 Valid override.</p> <p></p>"},{"location":"en/module-04/generics/#18474-invalid-override-adding-generic-specificity","title":"18.4.7.4 Invalid Override - Adding Generic Specificity","text":"<pre><code>class Parent {\n    void process(Set data) {}\n}\n\nclass Child extends Parent {\n    void process(Set&lt;Integer&gt; data) {}   // \u274c compile error\n}\n</code></pre> <p>Explanation:</p> <ul> <li>Before erasure: <code>Set&lt;Integer&gt;</code> is NOT assignment-compatible with <code>Set</code></li> <li>The compiler rejects it before even considering erasure</li> </ul> <p></p>"},{"location":"en/module-04/generics/#18475-valid-override-matching-parameterization","title":"18.4.7.5 Valid Override - Matching Parameterization","text":"<pre><code>class Parent {\n    void process(Set&lt;Integer&gt; data) {}\n}\n\nclass Child extends Parent {\n    @Override\n    void process(Set&lt;Integer&gt; data) {}   // \u2714 exact match\n}\n</code></pre> <p>Both checks pass: - Compatible before erasure - Identical after erasure</p> <p></p>"},{"location":"en/module-04/generics/#18476-invalid-override-changing-generic-argument","title":"18.4.7.6 Invalid Override - Changing Generic Argument","text":"<pre><code>class Parent {\n    void process(Set&lt;Integer&gt; data) {}\n}\n\nclass Child extends Parent {\n    void process(Set&lt;String&gt; data) {}   // \u274c compile error\n}\n</code></pre> <p>Explanation:</p> <ul> <li>Before erasure: <code>Set&lt;String&gt;</code> is not compatible with <code>Set&lt;Integer&gt;</code></li> <li>After erasure: both would become <code>Set</code></li> <li>Collision + incompatibility \u2192 compile error</li> </ul> <p></p>"},{"location":"en/module-04/generics/#18477-why-this-rule-exists","title":"18.4.7.7 Why This Rule Exists","text":"<p>Java must guarantee:</p> <ul> <li>Compile-time type safety</li> <li>Runtime polymorphism after erasure</li> </ul> <p>Since generics disappear at runtime, the JVM sees only erased signatures. The compiler must therefore ensure compatibility before erasure, and consistency after erasure.</p> <p></p>"},{"location":"en/module-04/generics/#18478-mental-model","title":"18.4.7.8 Mental Model","text":"<p>Think of overriding with generics as a two-phase check:</p> <pre><code>Phase 1 \u2192 Are the source-level types compatible?\nPhase 2 \u2192 Do the erased signatures match?\n</code></pre> <p>If either phase fails \u2192 compilation error.</p> <p></p>"},{"location":"en/module-04/generics/#18479-summary-rules","title":"18.4.7.9 Summary Rules","text":"<ul> <li>Override is validated after erasure</li> <li>Compatibility is validated before erasure</li> <li>You may erase generic information in the subclass</li> <li>You may NOT introduce new generic specificity</li> <li>If both methods are parameterized, arguments must match exactly</li> <li>After erasure, signatures must be identical</li> </ul> <p>This explains why some methods that look like overloads are rejected: after erasure they collide, and if they are not valid overrides, the compiler blocks them.</p> <p></p>"},{"location":"en/module-04/generics/#1848-overloading-a-generic-method-why-some-overloads-are-impossible","title":"18.4.8 Overloading a Generic Method \u2014 Why Some Overloads Are Impossible","text":"<p>When Java compiles generic code, it applies type erasure: type parameters such as T are removed, and the compiler substitutes them with their erased type (usually Object or the first bound).</p> <p>Because of this, two methods that look different at the source level may become identical after erasure.</p> <p>If the erased signatures are the same, Java cannot distinguish between them, therefore the code does not compile.</p> <ul> <li>Example: Two Methods That Collapse to the Same Signature</li> </ul> <pre><code>public class Demo {\n    public void testInput(List&lt;Object&gt; inputParam) {}\n\n    // public void testInput(List&lt;String&gt; inputParam) {}   // \u274c Compile error: after erasure, both become testInput(List)\n}\n</code></pre> <p>Explanation</p> <pre><code>List&lt;Object&gt; and List&lt;String&gt; are both erased to List.\n</code></pre> <p>At runtime both methods would appear as:</p> <pre><code>void testInput(List inputParam)\n</code></pre> <p>Java does not allow two methods with identical signatures in the same class, so the overload is rejected at compile time.</p> <p></p>"},{"location":"en/module-04/generics/#1849-overloading-a-generic-method-inherited-from-a-parent-class","title":"18.4.9 Overloading a Generic Method Inherited from a Parent Class","text":"<p>The same rule applies when a subclass tries to introduce a method that erases to the same signature as one in its superclass.</p> <pre><code>public class SubDemo extends Demo {\n    public void testInput(List&lt;Integer&gt; inputParam) {} \n    // \u274c Compile error: erases to testInput(List), same as parent\n}\n</code></pre> <p>Again, the compiler rejects the overload because the erased signatures collide.</p> <p>When Overloading Does Work</p> <p>Erasure only removes type parameters, not the actual class used in the method parameter.</p> <p>Therefore, if two method parameters differ in their raw (non-generic) type, the overload is legal, even if one is a generic parameterized type.</p> <pre><code>public class Demo {\n    public void testInput(List&lt;Object&gt; inputParam) {}\n    public void testInput(ArrayList&lt;String&gt; inputParam) {}  // \u2714 Compiles\n}\n</code></pre> <p>Why this works</p> <p>Even though <code>ArrayList&lt;String&gt;</code> erases to <code>ArrayList</code>, and <code>List&lt;Object&gt;</code> erases to <code>List</code>, these are different classes (ArrayList vs. List), so the signatures remain distinct:</p> <pre><code>void testInput(List inputParam)\nvoid testInput(ArrayList inputParam)\n</code></pre> <p>No collision \u2192 legal overloading.</p> <p></p>"},{"location":"en/module-04/generics/#18410-returning-generic-types-rules-and-restrictions","title":"18.4.10 Returning Generic Types \u2014 Rules and Restrictions","text":"<p>When returning a value from a method, Java follows a strict rule:</p> <p>The return type of an overriding method must be a subtype of the parent's return type, and any generic arguments must remain type-compatible (even though they are erased at runtime).</p> <p>This often confuses developers, because generics on return types cause similar erasure-based conflicts as parameter types.</p> <p>Key Points: - Return type covariance applies only to the raw type, not the generic arguments. - Generic arguments must remain compatible after erasure (they must match). - Two methods cannot differ only by generic parameter on the return type.</p> <ul> <li>Example: Illegal Return Type Change Due to Generic Mismatch</li> </ul> <pre><code>class A {\n    List&lt;String&gt; getData() { return null; }\n}\n\nclass B extends A {\n    // List&lt;Integer&gt; is not a covariant return type of List&lt;String&gt;\n    // \u274c Compile error\n    List&lt;Integer&gt; getData() { return null; }\n}\n</code></pre> <p>Explanation:</p> <p>Even though generics are erased, Java still enforces source-level type safety:</p> <p><code>List&lt;Integer&gt;</code> is not a subtype of <code>List&lt;String&gt;</code>.</p> <p>Both erase to <code>List</code>, but Java rejects overriding that breaks type compatibility.</p> <ul> <li>Example: Legal Covariant Return Type</li> </ul> <pre><code>class A {\n    Collection&lt;String&gt; getData() { return null; }\n}\n\nclass B extends A {\n    List&lt;String&gt; getData() { return null; }  // \u2714 List is a subtype of Collection\n}\n</code></pre> <p>This is allowed because: - The raw types are covariant (List extends Collection). - The generic arguments match (String vs. String).</p> <ul> <li>Example: Illegal Overload on Return Type Alone</li> </ul> <p>Two methods differing only by the generic argument in the return type cannot coexist:</p> <pre><code>class Demo {\n    List&lt;String&gt; getList() { return null; }\n\n    // List&lt;Integer&gt; getList() { return null; }  \n    // \u274c Compile error: return type alone does not distinguish methods\n}\n</code></pre> <p>Java does not use the return type when distinguishing overloaded methods.</p> <p></p>"},{"location":"en/module-04/generics/#18411-summary-of-erasure-rules","title":"18.4.11 Summary of Erasure Rules","text":"<ul> <li><code>Unbounded T</code> \u2192 erased to Object.</li> <li><code>T extends X</code> \u2192 erased to X.</li> <li><code>T extends X &amp; Y &amp; Z</code> \u2192 erased to X.</li> <li>All generic parameters are erased in method signatures.</li> <li>Casts are inserted to preserve compile-time typing.</li> <li>Bridge methods may be generated to preserve polymorphism.</li> </ul>"},{"location":"en/module-04/generics/#185-bounds-on-type-parameters","title":"18.5 Bounds on Type Parameters","text":""},{"location":"en/module-04/generics/#1851-upper-bounds-extends","title":"18.5.1 Upper Bounds: extends","text":"<p><code>&lt;T extends Number&gt;</code> means T must be Number or a subclass.</p> <pre><code>class Stats&lt;T extends Number&gt; {\n    T num;\n    Stats(T num) { this.num = num; }\n}\n</code></pre> <p></p>"},{"location":"en/module-04/generics/#1852-multiple-bounds","title":"18.5.2 Multiple Bounds","text":"<p>Syntax: <code>T extends Class &amp; Interface1 &amp; Interface2 ...</code> </p> <p>The class must come first.</p> <pre><code>class C&lt;T extends Number &amp; Comparable&lt;T&gt;&gt; { }\n</code></pre> <p></p>"},{"location":"en/module-04/generics/#1853-wildcards-extends-super","title":"18.5.3 Wildcards: <code>?</code>, <code>? extends</code>, <code>? super</code>","text":""},{"location":"en/module-04/generics/#18531-unbounded-wildcard","title":"18.5.3.1 Unbounded Wildcard <code>?</code>","text":"<p>Use when you want to accept a list of unknown type:</p> <pre><code>void printAll(List&lt;?&gt; list) { ... }\n</code></pre> <p></p>"},{"location":"en/module-04/generics/#18532-upper-bounded-wildcard-extends","title":"18.5.3.2 Upper-Bounded Wildcard <code>? extends</code>","text":"<pre><code>List&lt;? extends Number&gt; nums = List.of(1, 2, 3);\nNumber n = nums.get(0);   // OK\n// nums.add(5);           // \u274c cannot add: type safety\n</code></pre> <p>You cannot add elements (except null) to ? extends because you don\u2019t know the exact subtype.</p> <p></p>"},{"location":"en/module-04/generics/#18533-lower-bounded-wildcard-super","title":"18.5.3.3 Lower-Bounded Wildcard <code>? super</code>","text":"<p><code>&lt;? super Integer&gt;</code> means the type must be Integer or a superclass of Integer.</p> <pre><code>List&lt;? super Integer&gt; list = new ArrayList&lt;Number&gt;();\nlist.add(10);    // OK\nObject o = list.get(0); // returns Object (lowest common supertype)\n</code></pre> <p>IMPORTANT</p> <ul> <li> <p><code>Super</code> accepts insertion</p> </li> <li> <p><code>extends</code> accepts extraction.</p> </li> </ul> <p></p>"},{"location":"en/module-04/generics/#186-generics-and-inheritance","title":"18.6 Generics and Inheritance","text":"<p>Generics do NOT participate in inheritance. </p> <p>A <code>List&lt;String&gt;</code> is not a subtype of <code>List&lt;Object&gt;</code>; parameterized types are invariant.</p> <pre><code>List&lt;String&gt; ls = new ArrayList&lt;&gt;();\nList&lt;Object&gt; lo = ls;      // \u274c compile error\n</code></pre> <p>Instead:</p> <pre><code>List&lt;? extends Object&gt; ok = ls;   // works\n</code></pre> <p></p>"},{"location":"en/module-04/generics/#187-type-inference-diamond-operator","title":"18.7 Type Inference (Diamond Operator)","text":"<pre><code>Map&lt;String, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();\n</code></pre> <p>The compiler infers generic arguments from the assignment.</p> <p></p>"},{"location":"en/module-04/generics/#188-raw-types-legacy-compatibility","title":"18.8 Raw Types (Legacy Compatibility)","text":"<p>A raw type disables generics, re-introducing unsafe behavior.</p> <pre><code>List raw = new ArrayList();\nraw.add(\"x\");\nraw.add(10);   // allowed, but unsafe\n</code></pre> <p>Raw types should be avoided.</p> <p></p>"},{"location":"en/module-04/generics/#189-generic-arrays-not-allowed","title":"18.9 Generic Arrays (Not Allowed)","text":"<p>You cannot create arrays of parameterized types:</p> <pre><code>List&lt;String&gt;[] arr = new List&lt;String&gt;[10];   // \u274c compile error\n</code></pre> <p>Because arrays enforce runtime type safety while generics rely on compile-time checks only.</p> <p></p>"},{"location":"en/module-04/generics/#1810-bounded-type-inference","title":"18.10 Bounded Type Inference","text":"<pre><code>static &lt;T extends Number&gt; T identity(T x) { return x; }\n\nint v = identity(10);   // OK\n// String s = identity(\"x\"); // \u274c not a Number\n</code></pre>"},{"location":"en/module-04/generics/#1811-wildcards-vs-type-parameters","title":"18.11 Wildcards vs. Type Parameters","text":"<p>Use wildcards when you need flexibility in parameters. Use type parameters when the method must return or maintain type information.</p> <p>Example \u2014 wildcard too weak:</p> <pre><code>List&lt;?&gt; copy(List&lt;?&gt; list) {\n   return list;  // loses type information\n}\n</code></pre> <p>Better:</p> <pre><code>&lt;T&gt; List&lt;T&gt; copy(List&lt;T&gt; list) {\n    return list;\n}\n</code></pre> <p></p>"},{"location":"en/module-04/generics/#1812-pecs-rule-producer-extends-consumer-super","title":"18.12 PECS Rule (Producer Extends, Consumer Super)","text":"<p>Use ? extends when the parameter produces values. Use ? super when the parameter consumes values.</p> <pre><code>List&lt;? extends Number&gt; listExtends = List.of(1, 2, 3);\nList&lt;? super Integer&gt; listSuper = new ArrayList&lt;Number&gt;();\n\n// ? extends \u2192 safe read\nNumber n = listExtends.get(0);\n\n// ? super \u2192 safe write\nlistSuper.add(10);\n</code></pre> <p></p>"},{"location":"en/module-04/generics/#1813-common-pitfalls","title":"18.13 Common Pitfalls","text":"<ul> <li>Sorting lists with wildcards: <code>List&lt;? extends Number&gt;</code> cannot accept insertions.</li> <li>Misunderstanding that <code>List&lt;Object&gt;</code> is NOT a supertype of <code>List&lt;String&gt;</code>.</li> <li>Forgetting generic arrays are illegal.</li> <li>Thinking generic types are preserved at runtime (they are erased).</li> <li>Trying to overload methods using only different type parameters.</li> </ul>"},{"location":"en/module-04/generics/#1814-summary-table-of-wildcards","title":"18.14 Summary Table of Wildcards","text":"Syntax Meaning <code>?</code> unknown type (read-only except Object methods) <code>? extends T</code> read T safely, cannot add (except null) <code>? super T</code> can add T, retrieving gives Object"},{"location":"en/module-04/generics/#1815-summary-of-concepts","title":"18.15 Summary of Concepts","text":"<pre><code>Generics = compile-time type safety\nBounds = restrict legal types\nWildcards = flexibility in parameters\nType Inference = compiler deduces types\nType Erasure = generics disappear at runtime\nBridge Methods = maintain polymorphism\n</code></pre>"},{"location":"en/module-04/generics/#1816-complete-example","title":"18.16 Complete Example","text":"<pre><code>class Repository&lt;T extends Number&gt; {\n    private final List&lt;T&gt; store = new ArrayList&lt;&gt;();\n\n    void add(T value) { store.add(value); }\n\n    T first() { return store.isEmpty() ? null : store.get(0); }\n\n    // generic method with wildcard\n    static double sum(List&lt;? extends Number&gt; list) {\n        double total = 0;\n        for (Number n : list) total += n.doubleValue();\n        return total;\n    }\n}\n</code></pre>"},{"location":"en/module-04/inheritance/","title":"16. Inheritance in Java","text":""},{"location":"en/module-04/inheritance/#table-of-contents","title":"Table of Contents","text":"<ul> <li>16.1 General Definition of Inheritance</li> <li>16.2 Single Inheritance and java.lang.Object</li> <li>16.3 Transitive Inheritance</li> <li>16.4 What Gets Inherited Short Reminder</li> <li>16.5 Class Modifiers Affecting Inheritance</li> <li>16.6 this and super References<ul> <li>16.6.1 The this Reference</li> <li>16.6.2 The super Reference</li> </ul> </li> <li>16.7 Declaring Constructors in an Inheritance Chain</li> <li>16.8 Default no-arg Constructor</li> <li>16.9 Using this and Constructor Overloading</li> <li>16.10 Calling the Parent Constructor Using super</li> <li>16.11 Default Constructor Tips and Traps</li> <li>16.12 super Always Refers to the Most Direct Parent</li> <li>16.13 Inheriting Members<ul> <li>16.13.1 Method Overriding<ul> <li>16.13.1.1 Definition and Role in Inheritance</li> <li>16.13.1.2 Using super to Call the Parent Implementation</li> <li>16.13.1.3 Overriding Rules Instance Methods</li> <li>16.13.1.4 Hiding Static Methods Method Hiding</li> </ul> </li> <li>16.13.2 Abstract Classes<ul> <li>16.13.2.1 Definition and Purpose</li> <li>16.13.2.2 Rules for Abstract Classes</li> </ul> </li> <li>16.13.3 Creating Immutable Objects<ul> <li>16.13.3.1 What Is an Immutable Object</li> <li>16.13.3.2 Guidelines for Designing Immutable Classes</li> </ul> </li> </ul> </li> </ul> <p><code>Inheritance</code> is one of the core pillars of Object-Oriented Programming. </p> <p>It allows a class (the subclass) to acquire the state and behavior of another class (the superclass), creating hierarchical relationships that promote code reuse, specialization, and polymorphism.</p> <p></p>"},{"location":"en/module-04/inheritance/#161-general-definition-of-inheritance","title":"16.1 General Definition of Inheritance","text":"<p>Inheritance enables a class to extend another class, automatically gaining its accessible fields and methods.</p> <p>The extending class may add new features or override existing behaviors, creating more specialized versions of its parent.</p> <p>Note</p> <p>Inheritance expresses an \u201cis-a\u201d relationship: a Dog is a Animal.</p> <p></p>"},{"location":"en/module-04/inheritance/#162-single-inheritance-and-javalangobject","title":"16.2 Single Inheritance and java.lang.Object","text":"<p>Java supports single inheritance, meaning every class may extend only one direct superclass.</p> <p>All classes ultimately inherit from <code>java.lang.Object</code>, which sits at the top of the hierarchy. </p> <p>This ensures all Java objects share a minimal common behavior (e.g., <code>toString()</code>, <code>equals()</code>, <code>hashCode()</code>).</p> <pre><code>class Animal { }\nclass Dog extends Animal { }\n\n// All classes implicitly extend Object\nSystem.out.println(new Dog() instanceof Object); // true\n</code></pre> <p></p>"},{"location":"en/module-04/inheritance/#163-transitive-inheritance","title":"16.3 Transitive Inheritance","text":"<p><code>Inheritance</code> is transitive. </p> <p>If class <code>C</code> extends <code>B</code> and <code>B</code> extends <code>A</code>, then <code>C</code> effectively inherits accessible members from both <code>B</code> and <code>A</code>.</p> <pre><code>class A { }\nclass B extends A { }\nclass C extends B { } // C inherits from both A and B\n</code></pre> <p></p>"},{"location":"en/module-04/inheritance/#164-what-gets-inherited-short-reminder","title":"16.4 What Gets Inherited? (Short Reminder)","text":"<p>A subclass inherits all accessible members of the superclass.</p> <p>However, this depends on <code>access modifiers</code>.</p> <ul> <li>public \u2192 always inherited</li> <li>protected \u2192 inherited if accessible through package or subclass rules</li> <li>default (package-private) \u2192 inherited only within the same package</li> <li>private \u2192 NOT inherited</li> </ul> <p>Note</p> <p>( Please refer to Paragraph \"Access Modifiers\" in Chapter: 2. Basic Language Java Building Blocks )</p> <p></p>"},{"location":"en/module-04/inheritance/#165-class-modifiers-affecting-inheritance","title":"16.5 Class Modifiers Affecting Inheritance","text":"<p>Some class-level modifiers affect whether a class may be extended.</p> Modifier Meaning Effect on Inheritance <code>final</code> Class cannot be extended Inheritance STOP <code>abstract</code> Class cannot be instantiated Must be extended <code>sealed</code> Only allows a fixed list of subclasses Restricts inheritance <code>non-sealed</code> Subclass of sealed class that reopens inheritance Inheritance allowed <code>static</code> Applies only to nested classes Behaves like a top-level class inside its enclosing class <p>Note</p> <p>A <code>static</code> class in Java can exist only as a static nested class.</p> <p></p>"},{"location":"en/module-04/inheritance/#166-this-and-super-references","title":"16.6 <code>this</code> and <code>super</code> References","text":""},{"location":"en/module-04/inheritance/#1661-the-this-reference","title":"16.6.1 The <code>this</code> Reference","text":"<p>The <code>this</code> reference refers to the current object instance and helps in disambiguing access to current and inherited members. </p> <p>Java uses a granular scope rule: - If a method/local variable has the same name as an instance field, the local one \u201cshadows\u201d the field. - <code>this.fieldName</code> is required to access the instance attribute.</p> <pre><code>public class Person {\n    String name;\n\n    public Person(String name) {\n        // Without \"this\", we would reassign the parameter to itself\n        this.name = name;\n    }\n}\n</code></pre> <p>If names differ, <code>this</code> is optional:</p> <pre><code>public class Person {\n    String name;\n\n    public Person(String n) {\n        name = n; // fine, the names of the variables differ: there is no ambiguity, no shadowing\n    }\n}\n</code></pre> <p>Warning</p> <p><code>this</code> cannot be used inside static methods because, in that context, no instance exists.</p> <p></p>"},{"location":"en/module-04/inheritance/#1662-the-super-reference","title":"16.6.2 The <code>super</code> Reference","text":"<p>The <code>super</code> reference gives access to members of the direct parent class.  </p> <p>Useful when: - The parent and child define a field/method with the same name:  See below: Inheriting Members  - Parent and child define a field with the same name \u2192 variable hiding (two copies) - Parent and child define a method with the same signature \u2192 method overriding - You want to explicitly call the inherited implementation</p> <pre><code>class Parent { int value = 10; }\n\nclass Child extends Parent {\n    int value = 20;\n\n    void printBoth() {\n        System.out.println(value);      // child value\n        System.out.println(super.value); // parent value\n    }\n}\n</code></pre> <p>Note</p> <p><code>super</code> cannot be used inside static contexts.</p> <p></p>"},{"location":"en/module-04/inheritance/#167-declaring-constructors-in-an-inheritance-chain","title":"16.7 Declaring Constructors in an Inheritance Chain","text":"<p>A <code>constructor</code> initializes a newly created object. </p> <p>Constructors are never inherited, but each subclass constructor must ensure that the superclass is initialized.</p> <p><code>Constructors</code> are special methods with a name that matches the name of the class and that does not declare any return type.</p> <p>A class may define multiple constructors (constructor overloading), each with a unique <code>signature</code>.</p> <p>You can explicitly declare a <code>no-arg</code> or a specific constructor or, if you don't, Java will  implicitly create a <code>default no-arg constructor</code>.</p> <p>If you explicitly declare a constructor, the Java compiler will not include any <code>default no-arg constructor</code>: this rule applies independently to every class in the hierarchy.</p> <p>A parent class still gets its own default constructor unless it also defines one.</p> <p></p>"},{"location":"en/module-04/inheritance/#168-default-no-arg-constructor","title":"16.8 Default <code>no-arg</code> Constructor","text":"<p>If a class does not declare any constructor, Java automatically inserts a default no-argument constructor. </p> <p>This constructor calls <code>super()</code> implicitly: the Java compiler implicitly insert a call to the no-arg constructor super(). </p> <pre><code>class Parent { }\n\nclass Child extends Parent {\n    // Compiler inserts:\n    // Child() { super(); }\n}\n</code></pre> <p></p>"},{"location":"en/module-04/inheritance/#169-using-this-and-constructor-overloading","title":"16.9 Using <code>this()</code> and Constructor Overloading","text":"<p>this() calls another constructor in the same class. </p> <p>Rules:</p> <ul> <li>Must be the first statement in the constructor</li> <li>Cannot be combined with <code>super()</code></li> <li>Only one call to this() is allowed in a constructor</li> <li>Used to centralize initialization</li> </ul> <pre><code>class Car {\n    int year;\n    String model;\n\n    Car() {\n        this(2020, \"Unknown\");\n    }\n\n    Car(int year, String model) {\n        this.year = year;\n        this.model = model;\n    }\n}\n</code></pre> <p></p>"},{"location":"en/module-04/inheritance/#1610-calling-the-parent-constructor-using-super","title":"16.10 Calling the Parent Constructor Using <code>super()</code>","text":"<p>Every constructor must call a superclass constructor, either explicitly or implicitly.</p> <p><code>super()</code> must appear as the first line in the constructor (unless replaced by <code>this()</code>).</p> <pre><code>class Parent {\n    Parent() { System.out.println(\"Parent constructor\"); }\n}\n\nclass Child extends Parent {\n    Child() {\n        super(); // optional, compiler would insert it\n        System.out.println(\"Child constructor\");\n    }\n}\n</code></pre> <p></p>"},{"location":"en/module-04/inheritance/#1611-default-constructor-tips-and-traps","title":"16.11 Default Constructor \u2014 Tips and Traps","text":"<ul> <li>If the superclass does not have a no-arg constructor, the subclass MUST call <code>super(args)</code> explicitly.</li> <li>If the subclass defines any constructor, Java does NOT create a default constructor automatically for that subclass.</li> <li>If you forget to call an existing parent constructor explicitly, the compiler inserts <code>super()</code> \u2014 which may not exist.</li> </ul> <pre><code>class Parent {\n    Parent(int x) { }\n}\n\nclass Child extends Parent {\n    // ERROR \u2192 compiler inserts super(), but Parent() does not exist\n    Child() { }\n}\n</code></pre>"},{"location":"en/module-04/inheritance/#1612-super-always-refers-to-the-most-direct-parent","title":"16.12 <code>super()</code> Always Refers to the Most Direct Parent","text":"<p>Even in long inheritance chains, <code>super()</code> always calls the constructor of the immediate superclass, not any higher ancestor.</p> <pre><code>class A { \n    A() { System.out.println(\"A\"); } \n}\nclass B extends A { \n    B() { System.out.println(\"B\"); } \n}\nclass C extends B {\n    C() {\n        super(); // Calls B(), not A()\n        System.out.println(\"C\");\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>A\nB\nC\n</code></pre> <p></p>"},{"location":"en/module-04/inheritance/#1613-inheriting-members","title":"16.13 Inheriting Members","text":"<p>In Java, field access and static method calls are resolved at compile time, while instance method calls are resolved at runtime.</p> <p>The key distinction is:</p> <ul> <li>The <code>variable</code> or <code>static method</code> that is used depends on the declared type of the reference.</li> <li>The <code>instance method</code> that is executed depends on the actual runtime type of the object.</li> </ul> <p>Example: <code>Field Access</code> (Not Polymorphic)</p> <p>Fields are resolved based on the declared type of the reference, not the actual object.</p> <pre><code>class Parent {\n    String name = \"Parent\";\n}\n\nclass Child extends Parent {\n    String name = \"Child\";\n}\n\nParent p = new Child();\nSystem.out.println(p.name);   // Output: Parent\n</code></pre> <p>Explanation:</p> <ul> <li>The reference <code>p</code> is declared as type <code>Parent</code>.</li> <li>Field access is determined at compile time.</li> <li>Therefore, <code>Parent.name</code> is used, even though the object is a <code>Child</code>.</li> </ul> <p>Fields are not polymorphic.</p> <p>Example: <code>Static Methods</code> (Not Polymorphic)</p> <p>Static methods are also resolved using the declared type of the reference.</p> <pre><code>class Parent {\n    static void print() {\n        System.out.println(\"Parent static\");\n    }\n}\n\nclass Child extends Parent {\n    static void print() {\n        System.out.println(\"Child static\");\n    }\n}\n\nParent p = new Child();\np.print();   // Output: Parent static\n</code></pre> <p>Explanation:</p> <ul> <li>Static methods are bound at compile time.</li> <li>The method chosen depends on the reference type (<code>Parent</code>), not the object type.</li> </ul> <p>This is called method hiding, not overriding.</p> <p>Example: <code>Instance Methods</code> (Polymorphic)</p> <p>Instance methods are resolved at runtime based on the actual object type.</p> <pre><code>class Parent {\n    void print() {\n        System.out.println(\"Parent instance\");\n    }\n}\n\nclass Child extends Parent {\n    @Override\n    void print() {\n        System.out.println(\"Child instance\");\n    }\n}\n\nParent p = new Child();\np.print();   // Output: Child instance\n</code></pre> <p>Explanation:</p> <ul> <li>The reference type is <code>Parent</code>.</li> <li>The actual object is <code>Child</code>.</li> <li>Java uses dynamic dispatch.</li> <li>Therefore, <code>Child.print()</code> is executed.</li> </ul> <p>Instance methods are polymorphic.</p> <p></p>"},{"location":"en/module-04/inheritance/#16131-method-overriding","title":"16.13.1 Method Overriding","text":"<p>Method overriding is a core concept of inheritance: it allows a subclass to provide a new implementation for a method that is already defined in its superclass.</p> <p>At runtime, the version of the method that is executed depends on the actual object type, not on the reference type.</p> <p>This is called dynamic dispatch and it is what enables polymorphism in Java.</p> <p></p>"},{"location":"en/module-04/inheritance/#161311-definition-and-role-in-inheritance","title":"16.13.1.1 Definition and Role in Inheritance","text":"<p>A method in a subclass overrides a method in its superclass if:</p> <ul> <li>the superclass method is <code>instance</code> (non static);</li> <li>the subclass method has the same name, the same parameter list and a return type which is the same type or a subtype of the return type in the inherited method;</li> <li>both methods are accessible (not private) and the subclass method is NOT less visible than the superclass one.</li> <li>The overriding method cannot declare new or broader checked exceptions. </li> </ul> <p>Overriding is used to specialize behavior: a subclass can adapt or refine what the parent class does while still being used through a reference of the parent type.</p> <pre><code>class Animal {\n    void speak() {\n        System.out.println(\"Some generic animal sound\");\n    }\n}\n\nclass Dog extends Animal {\n\n    @Override\n    void speak() {\n        System.out.println(\"Woof!\");\n    }\n}\n\npublic class TestOverride {\n    public static void main(String[] args) {\n        Animal a = new Dog(); // reference type = Animal, object type = Dog\n        a.speak(); // prints \"Woof!\" (Dog implementation)\n    }\n}\n</code></pre> <p></p>"},{"location":"en/module-04/inheritance/#161312-using-super-to-call-the-parent-implementation","title":"16.13.1.2 Using <code>super</code> to Call the Parent Implementation","text":"<p>When a subclass overrides a method, it can still access the superclass implementation via the <code>super</code> reference. </p> <p>This is useful if you want to reuse or extend the behavior defined in the parent class.</p> <pre><code>class Person {\n    void introduce() {\n        System.out.println(\"I am a person.\");\n    }\n}\n\nclass Student extends Person {\n    @Override\n    void introduce() {\n        super.introduce(); // calls Person.introduce()\n        System.out.println(\"I am also a student.\");\n    }\n}\n</code></pre> <p>If both parent and child declare a member (field or method) with the same name, The child can access both:</p> <ul> <li>the overridden version (default)</li> <li>the parent version via <code>super</code></li> </ul> <pre><code>class Base {\n    int value = 10;\n\n    void show() {\n        System.out.println(\"Base value = \" + value);\n    }\n}\n\nclass Derived extends Base {\n    int value = 20; // hides Base.value\n\n    @Override\n    void show() {\n        System.out.println(\"Derived value = \" + value);          // 20\n        System.out.println(\"Base value via super = \" + super.value); // 10\n    }\n}\n</code></pre> <p></p>"},{"location":"en/module-04/inheritance/#161313-overriding-rules-instance-methods","title":"16.13.1.3 Overriding Rules (Instance Methods)","text":"<ul> <li>Same signature: same method name, same parameter types and order.</li> <li>Covariant return type: the overriding method can return the same type as the parent, or a subtype of the parent return type.</li> <li>Accessibility: the overriding method cannot be less accessible than the overridden one (for example, cannot change from public to protected or private). It can keep the same visibility or increase it.</li> <li>Checked exceptions: the overriding method cannot declare new or broader checked exceptions than the parent method; it may declare fewer or more specific checked exceptions, or remove them entirely.</li> <li>Unchecked exceptions: can be added or removed without restriction.</li> <li>final methods: cannot be overridden.</li> </ul> <pre><code>class Parent {\n    Number getValue() throws Exception {\n        return 42;\n    }\n}\n\nclass Child extends Parent {\n@Override\n    // Covariant return type: Integer is a subclass of Number\n    Integer getValue() throws RuntimeException {\n        return 100;\n    }\n}\n</code></pre>"},{"location":"en/module-04/inheritance/#161314-hiding-static-methods-method-hiding","title":"16.13.1.4 Hiding Static Methods (Method Hiding)","text":"<p>Static methods are not overridden; they are hidden. </p> <p>If a subclass defines a static method with the same signature as a static method in the parent, the subclass method hides the parent method. </p> <p>If one of the methods is marked as <code>static</code> and the other is not, the code will NOT compile.</p> <p>Method selection for static methods happens at compile time, based on the reference type, not the object type.</p> <pre><code>class A {\n    static void show() {\n        System.out.println(\"A.show()\");\n    }\n}\n\nclass B extends A {\n    static void show() {\n        System.out.println(\"B.show()\");\n    }\n}\n\npublic class TestStatic {\n    public static void main(String[] args) {\n        A a = new B();\n        B b = new B();\n\n        a.show(); // A.show()  (reference type A)\n        b.show(); // B.show()  (reference type B)\n    }\n}\n</code></pre> <p>Important</p> <ul> <li>final static methods cannot be hidden, and instance methods declared final cannot be overridden.</li> <li>If you try to redefine them in a subclass, the code will not compile.</li> </ul> <p></p>"},{"location":"en/module-04/inheritance/#16132-abstract-classes","title":"16.13.2 Abstract Classes","text":""},{"location":"en/module-04/inheritance/#161321-definition-and-purpose","title":"16.13.2.1 Definition and Purpose","text":"<p>An abstract class is a class that cannot be instantiated directly and is intended to be extended. </p> <p>It may contain:</p> <ul> <li>abstract methods (declared without a body);</li> <li>concrete methods (with implementation);</li> <li>fields, constructors, static members, and even static initializers.</li> </ul> <p>Abstract classes are used when you want to define a common base behavior and contract, but leave some details to be implemented by concrete subclasses.</p> <p></p>"},{"location":"en/module-04/inheritance/#161322-rules-for-abstract-classes","title":"16.13.2.2 Rules for Abstract Classes","text":"<ul> <li>A class with at least one abstract method must be declared abstract.</li> <li>An abstract class cannot be instantiated directly.</li> <li>Abstract methods have no body and end with a semicolon.</li> <li>Abstract methods cannot be <code>final</code>, <code>static</code>, or <code>private</code>, because they must be overridable.</li> <li>The first concrete (non-abstract) subclass in the hierarchy must implement all inherited abstract methods, otherwise it must itself be declared abstract.</li> </ul> <pre><code>abstract class Shape {\n\n    abstract double area(); // must be implemented by concrete subclasses\n\n    void describe() {\n        System.out.println(\"I am a shape.\");\n    }\n\n    Shape() {\n        System.out.println(\"Shape constructor\");\n    }\n}\n\nclass Circle extends Shape {\n    private final double radius;\n\n    Circle(double radius) {\n        this.radius = radius;\n    }\n\n    @Override\n    double area() {\n        return Math.PI * radius * radius;\n    }\n}\n</code></pre> <p>Note</p> <ul> <li>Although an abstract class cannot be instantiated, its constructors are still called when creating instances of concrete subclasses.</li> <li>The chain always starts from the top of the hierarchy and moves down.</li> </ul> <p></p>"},{"location":"en/module-04/inheritance/#16133-creating-immutable-objects","title":"16.13.3 Creating Immutable Objects","text":""},{"location":"en/module-04/inheritance/#161331-what-is-an-immutable-object","title":"16.13.3.1 What Is an Immutable Object?","text":"<p>An object is immutable if, after it has been created, its state cannot change. </p> <p>All fields that represent the state remain constant for the lifetime of that object. </p> <p>Immutable objects are simpler to reason about, inherently thread safe (if properly designed), and widely used in the Java Standard Library (for example, <code>String</code>, wrapper classes like <code>Integer</code>, and many classes in <code>java.time</code>).</p> <p></p>"},{"location":"en/module-04/inheritance/#161332-guidelines-for-designing-immutable-classes","title":"16.13.3.2 Guidelines for Designing Immutable Classes","text":"<ul> <li>Declare the class final so it cannot be subclassed (or make all constructors private and provide controlled factory methods).</li> <li>Make all fields that represent state private and final.</li> <li>Do not provide any mutator (setter) methods.</li> <li>Initialize all fields in constructors (or factory methods) and never expose them in a mutable way.</li> <li>If a field refers to a mutable object, make defensive copies on construction and when returning it via getters.</li> </ul> <pre><code>import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic final class Person {\n    private final String name; // String is immutable\n    private final int age;\n    private final List&lt;String&gt; hobbies; // List is mutable, we must protect it\n\n    public Person(String name, int age, List&lt;String&gt; hobbies) {\n        this.name = name;\n        this.age = age;\n        // Defensive copy on input\n        this.hobbies = new ArrayList&lt;&gt;(hobbies);\n    }\n\n    public String getName() {\n        return name; // safe (String is immutable)\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public List&lt;String&gt; getHobbies() {\n        // Defensive copy or unmodifiable view on output\n        return Collections.unmodifiableList(hobbies);\n    }\n}\n</code></pre> <p>In this example:</p> <ul> <li><code>Person</code> is final: it cannot be subclassed and its behavior cannot be altered through inheritance.</li> <li>All fields are <code>private</code> and <code>final</code>, set only once in the constructor.</li> <li>The list of hobbies is defensively copied on construction and wrapped as unmodifiable in the getter, so external code cannot modify the internal state.</li> </ul> <p>Designing immutable objects is especially important in multithread contexts and when passing objects across layers of an application. </p>"},{"location":"en/module-04/methods-attributes/","title":"14. Methods, Attributes and Variables","text":""},{"location":"en/module-04/methods-attributes/#table-of-contents","title":"Table of Contents","text":"<ul> <li>14.1 Methods<ul> <li>14.1.1 Mandatory Components of a Method<ul> <li>14.1.1.1 Access Modifiers</li> <li>14.1.1.2 Return Type</li> <li>14.1.1.3 Method Name</li> <li>14.1.1.4 Method Signature</li> <li>14.1.1.5 Method Body</li> </ul> </li> <li>14.1.2 Optional Modifiers</li> <li>14.1.3 Declaring Methods</li> </ul> </li> <li>14.2 Java Is a Pass-by-Value Language</li> <li>14.3 Overloading Methods<ul> <li>14.3.1 Calling overloaded methods<ul> <li>14.3.1.1 Exact match wins</li> <li>14.3.1.2 If no exact match exists Java picks the most specific compatible type</li> <li>14.3.1.3 Primitive widening beats boxing</li> <li>14.3.1.4 Boxing beats varargs</li> <li>14.3.1.5 For references Java picks the most specific reference type</li> <li>14.3.1.6 When there is no unambiguous most specific the-call-is-a-compile-error</li> <li>14.3.1.7 Mixed primitive + wrapper overloads</li> <li>14.3.1.8 When primitives mix with reference types</li> <li>14.3.1.9 When Object wins</li> <li>14.3.1.10 Summary Table Overload Resolution</li> </ul> </li> </ul> </li> <li>14.4 Local and Instance Variables<ul> <li>14.4.1 Instance Variables</li> <li>14.4.2 Local Variables<ul> <li>14.4.2.1 Effectively Final Local Variables</li> <li>14.4.2.2 Parameters as Effectively Final</li> </ul> </li> </ul> </li> <li>14.5 Varargs Variable-Length Argument Lists</li> <li>14.6 Static Methods Static Variables and Static Initializers<ul> <li>14.6.1 Static Variables Class Variables</li> <li>14.6.2 Static Methods</li> <li>14.6.3 Static Initializer Blocks</li> <li>14.6.4 Initialization Order Static vs Instance</li> <li>14.6.5 Accessing Static Members<ul> <li>14.6.5.1 Recommended use class name</li> <li>14.6.5.2 Also legal via instance reference</li> </ul> </li> <li>14.6.6 Static and Inheritance</li> <li>14.6.7 Common Pitfalls</li> </ul> </li> </ul> <p>This chapter introduces fundamental Object-Oriented Programming (OOP) concepts in Java, starting with methods, parameter passing, overloading, local vs. instance variables, and varargs.  </p> <p></p>"},{"location":"en/module-04/methods-attributes/#141-methods","title":"14.1 Methods","text":"<p><code>Methods</code> represent the operations/behaviors that can be performed by a particular data type (a class).</p> <p>They describe what the object can do and how it interacts with its internal state and the outside world.</p> <p>A <code>method declaration</code> is composed of mandatory and optional components.</p> <p></p>"},{"location":"en/module-04/methods-attributes/#1411-mandatory-components-of-a-method","title":"14.1.1 Mandatory Components of a Method","text":""},{"location":"en/module-04/methods-attributes/#14111-access-modifiers","title":"14.1.1.1  Access Modifiers","text":"<p><code>Access Modifiers</code> control visibility, not behavior.</p> <p>( Please refer to Paragraph \"Access Modifiers\" in Chapter: 2. Basic Language Java Building Blocks ) </p> <p></p>"},{"location":"en/module-04/methods-attributes/#14112-return-type","title":"14.1.1.2 Return Type","text":"<p>Appears immediately before the method name.</p> <ul> <li>If the method returns a value \u2192 the return type specifies the value\u2019s type.</li> <li>If the method does not return a value \u2192 the keyword <code>void</code> must be used.</li> <li>A method with a non-void return type must contain at least one <code>return value;</code> statement.</li> <li>A <code>void</code> method may:</li> <li>omit a return statement</li> <li>include <code>return;</code> (with no value)</li> </ul> <p></p>"},{"location":"en/module-04/methods-attributes/#14113-method-name","title":"14.1.1.3 Method Name","text":"<p>Follows the same rules as identifiers ( Please refer to Chapter: 3. Java Naming Rules ).</p> <p></p>"},{"location":"en/module-04/methods-attributes/#14114-method-signature","title":"14.1.1.4 Method Signature","text":"<p>The method signature in Java includes:</p> <ul> <li>the method name</li> <li>the parameter type list (types + order)</li> </ul> <p>Note</p> <p>Parameter names do NOT belong to the signature, only types and order matter.</p> <ul> <li>Example of distinct signatures:</li> </ul> <pre><code>void process(int x)\nvoid process(int x, int y)\nvoid process(int x, String y)\n</code></pre> <ul> <li>Example of same signature (illegal overloading):</li> </ul> <pre><code>// \u274c same signature: only parameter names differ\nvoid m(int a)\nvoid m(int b)\n</code></pre> <p></p>"},{"location":"en/module-04/methods-attributes/#14115-method-body","title":"14.1.1.5 Method Body","text":"<p>A block <code>{ }</code> containing zero or more statements.</p> <p>If the method is <code>abstract</code>, the body must be omitted.</p> <p></p>"},{"location":"en/module-04/methods-attributes/#1412-optional-modifiers","title":"14.1.2 Optional Modifiers","text":"<p>Optional method modifiers include:</p> <ul> <li><code>static</code></li> <li><code>abstract</code></li> <li><code>final</code></li> <li><code>default</code> (interface methods)</li> <li><code>synchronized</code></li> <li><code>native</code></li> <li><code>strictfp</code></li> </ul> <p>Rules:</p> <ul> <li>Optional modifiers may appear in any order.</li> <li> <p>All modifiers must appear before the return type.</p> </li> <li> <p>Example:</p> </li> </ul> <pre><code>public static final int compute() {\n    return 10;\n}\n</code></pre> <p></p>"},{"location":"en/module-04/methods-attributes/#1413-declaring-methods","title":"14.1.3 Declaring Methods","text":"<pre><code>public final synchronized String formatValue(int x, double y) throws IOException {\n    return \"Result: \" + x + \", \" + y;\n}\n</code></pre> <p>Breakdown:</p> Part Meaning <code>public</code> access modifier <code>final</code> cannot be overridden <code>synchronized</code> thread control modifier <code>String</code> return type <code>formatValue</code> method name <code>(int x, double y)</code> parameter list <code>throws IOException</code> exception list method body implementation <p></p>"},{"location":"en/module-04/methods-attributes/#142-java-is-a-pass-by-value-language","title":"14.2 Java Is a \u201cPass-by-Value\u201d Language","text":"<p>Java uses only pass-by-value, no exceptions.</p> <p>This means:</p> <ul> <li>For primitive types \u2192 the method receives a copy of the value.</li> <li>For reference types \u2192 the method receives a copy of the reference, meaning:</li> <li>the reference itself cannot be changed by the method</li> <li> <p>the object can be modified through that reference</p> </li> <li> <p>Example:</p> </li> </ul> <pre><code>void modify(int a, StringBuilder b) {\n    a = 50;           // modifying the *copy* \u2192 no effect outside\n    b.append(\"!\");    // modifying the *object* \u2192 visible outside\n}\n</code></pre> <pre><code>public static void main(String[] args) {\n\n    int num1 = 11;\n    methodTryModif(num1);\n    System.out.println(num1);\n\n}\n\npublic static void methodTryModif(int num1){    \n    num1 = 10;  // this new assignement affects only the method parameter which, accidentally, has the same name as the external variable.\n}\n</code></pre> <p></p>"},{"location":"en/module-04/methods-attributes/#143-overloading-methods","title":"14.3 Overloading Methods","text":"<p>Method overloading means same method name, different signature.</p> <p>Two methods are considered overloaded if they differ in:</p> <ul> <li>number of parameters  </li> <li>parameter types  </li> <li>parameter order  </li> </ul> <p>Overloading does NOT depend on:</p> <ul> <li>return type  </li> <li>access modifier  </li> <li> <p>exceptions  </p> </li> <li> <p>Example:</p> </li> </ul> <pre><code>void print(int x)\nvoid print(double x)\nvoid print(int x, int y)\n</code></pre> <p>Illegal overloaded method:</p> <pre><code>// \u274c Return type does not count in overloading\nint compute(int x)\ndouble compute(int x)\n</code></pre> <p></p>"},{"location":"en/module-04/methods-attributes/#1431-calling-overloaded-methods","title":"14.3.1 Calling overloaded methods","text":"<p>When multiple overloaded methods are available, Java applies overload resolution to decide which method to call.</p> <p>The compiler selects the method whose parameter types are the most specific and compatible with the provided arguments.</p> <p>Overload resolution happens at compile time (unlike overriding, which is run-time based).</p> <p>Java follows these rules:</p> <p></p>"},{"location":"en/module-04/methods-attributes/#14311-exact-match-wins","title":"14.3.1.1 Exact match wins","text":"<p>If an argument matches a method parameter exactly, that method is chosen.</p> <pre><code>void call(int x)    { System.out.println(\"int\"); }\nvoid call(long x)   { System.out.println(\"long\"); }\n\ncall(5); // prints: int (exact match for int)\n</code></pre> <p></p>"},{"location":"en/module-04/methods-attributes/#14312-if-no-exact-match-exists-java-picks-the-most-specific-compatible-type","title":"14.3.1.2 \u2014 If no exact match exists, Java picks the most specific compatible type","text":"<p>Java prefers:</p> <ol> <li>widening over autoboxing  </li> <li>autoboxing over varargs  </li> <li> <p>wider reference only if more specific type is not available  </p> </li> <li> <p>Example with numeric primitives:</p> </li> </ol> <pre><code>void test(long x)   { System.out.println(\"long\"); }\nvoid test(float x)  { System.out.println(\"float\"); }\n\ntest(5);  // int literal: can widen to long or float\n          // but long is more specific than float for integer types\n          // Output: long\n</code></pre> <p></p>"},{"location":"en/module-04/methods-attributes/#14313-primitive-widening-beats-boxing","title":"14.3.1.3 \u2014 Primitive widening beats boxing","text":"<p>If a primitive argument can either widen or autobox, Java chooses widening.</p> <pre><code>void m(int x)       { System.out.println(\"int\"); }\nvoid m(Integer x)   { System.out.println(\"Integer\"); }\n\nbyte b = 10;\nm(b);               // byte \u2192 int (widening) wins\n                    // Output: int\n</code></pre> <p></p>"},{"location":"en/module-04/methods-attributes/#14314-boxing-beats-varargs","title":"14.3.1.4 \u2014 Boxing beats varargs","text":"<pre><code>void show(Integer x)    { System.out.println(\"Integer\"); }\nvoid show(int... x)     { System.out.println(\"varargs\"); }\n\nshow(5);                // int \u2192 Integer (boxing) preferred\n                        // Output: Integer\n</code></pre>"},{"location":"en/module-04/methods-attributes/#14315-for-references-java-picks-the-most-specific-reference-type","title":"14.3.1.5 \u2014 For references, Java picks the most specific reference type","text":"<pre><code>void ref(Object o)      { System.out.println(\"Object\"); }\nvoid ref(String s)      { System.out.println(\"String\"); }\n\nref(\"abc\");             // \"abc\" is a String \u2192 more specific than Object\n                        // Output: String\n</code></pre> <p>More specific means lower in the inheritance hierarchy.</p> <p></p>"},{"location":"en/module-04/methods-attributes/#14316-when-there-is-no-unambiguous-most-specific-the-call-is-a-compile-error","title":"14.3.1.6 \u2014 When there is no unambiguous \u201cmost specific\u201d, the call is a compile error","text":"<p>Example with sibling classes:</p> <pre><code>void check(Number n)      { System.out.println(\"Number\"); }\nvoid check(String s)      { System.out.println(\"String\"); }\n\ncheck(null);    // Both String and Number can accept null\n                // String is more specific because it is a concrete class\n                // Output: String\n</code></pre> <p>But if two unrelated classes compete:</p> <pre><code>void run(String s)   { }\nvoid run(Integer i)  { }\n\nrun(null);  // \u274c Compile-time error: ambiguous method call\n</code></pre> <p></p>"},{"location":"en/module-04/methods-attributes/#14317-mixed-primitive-wrapper-overloads","title":"14.3.1.7 \u2014 Mixed primitive + wrapper overloads","text":"<p>Java evaluates widening, boxing, and varargs in this order:</p> <p><code>widening \u2192 boxing \u2192 varargs</code></p> <p>Example:</p> <pre><code>void mix(long x)        { System.out.println(\"long\"); }\nvoid mix(Integer x)     { System.out.println(\"Integer\"); }\nvoid mix(int... x)      { System.out.println(\"varargs\"); }\n\nshort s = 5;\nmix(s);   // short \u2192 int \u2192 long  (widening)\n          // Boxing and varargs ignored\n          // Output: long\n</code></pre> <p></p>"},{"location":"en/module-04/methods-attributes/#14318-when-primitives-mix-with-reference-types","title":"14.3.1.8 \u2014 When primitives mix with reference types","text":"<pre><code>void fun(Object o)     { System.out.println(\"Object\"); }\nvoid fun(int x)        { System.out.println(\"int\"); }\n\nfun(10);                // exact primitive match wins\n                        // Output: int\n\nInteger i = 10;\nfun(i);                 // reference accepted \u2192 Object\n                        // Output: Object\n</code></pre>"},{"location":"en/module-04/methods-attributes/#14319-when-object-wins","title":"14.3.1.9 \u2014 When Object wins","text":"<pre><code>void fun(List&lt;String&gt; o)    { System.out.println(\"O\"); }\nvoid fun(CharSequence x)    { System.out.println(\"X\"); }\nvoid fun(Object y)          { System.out.println(\"Y\"); }\n\nfun(LocalDate.now());       // Output: Y\n</code></pre>"},{"location":"en/module-04/methods-attributes/#143110-summary-table-overload-resolution","title":"14.3.1.10 Summary Table (Overload Resolution)","text":"Situation Rule Exact match Always chosen Primitive widening vs boxing Widening wins Boxing vs varargs Boxing wins Most specific reference type Wins Unrelated reference types Ambiguous \u2192 compile error Mixed primitive + wrapper Widening \u2192 boxing \u2192 varargs"},{"location":"en/module-04/methods-attributes/#144-local-and-instance-variables","title":"14.4 Local and Instance Variables","text":""},{"location":"en/module-04/methods-attributes/#1441-instance-variables","title":"14.4.1 Instance Variables","text":"<p>Instance variables are:</p> <ul> <li>declared as members of a class</li> <li>created when an object is instantiated</li> <li>accessible by all methods of the instance</li> </ul> <p>Possible modifiers for instance variables:</p> <ul> <li>access modifiers (<code>public</code>, <code>protected</code>, <code>private</code>)</li> <li><code>final</code></li> <li><code>volatile</code></li> <li> <p><code>transient</code></p> </li> <li> <p>Example:</p> </li> </ul> <pre><code>public class Person {\n    private String name;         // instance variable\n    protected final int age = 0; // final means cannot be reassigned\n}\n</code></pre> <p></p>"},{"location":"en/module-04/methods-attributes/#1442-local-variables","title":"14.4.2 Local Variables","text":"<p>Local variables:</p> <ul> <li>are declared inside a method, constructor, or block</li> <li>have no default values \u2192 must be explicitly initialized before use</li> <li> <p>only modifier allowed: final</p> </li> <li> <p>Example:</p> </li> </ul> <pre><code>void calculate() {\n    int x;        // declared\n    x = 10;       // must be initialized before use\n\n    final int y = 5;  // legal\n}\n</code></pre> <p>Two special cases:</p> <p></p>"},{"location":"en/module-04/methods-attributes/#14421-effectively-final-local-variables","title":"14.4.2.1 Effectively Final Local Variables","text":"<p>A local variable is effectively final if it is assigned once, even without <code>final</code>.</p> <p>Effectively final variables can be used in:</p> <ul> <li>lambda expressions</li> <li>local/anonymous classes</li> </ul> <p></p>"},{"location":"en/module-04/methods-attributes/#14422-parameters-as-effectively-final","title":"14.4.2.2 Parameters as Effectively Final","text":"<p>Method parameters behave as local variables and follow the same rules.</p> <p></p>"},{"location":"en/module-04/methods-attributes/#145-varargs-variable-length-argument-lists","title":"14.5 Varargs (Variable-Length Argument Lists)","text":"<p>Varargs allow a method to accept zero or more parameters of the same type.</p> <p>Syntax:</p> <pre><code>void printNames(String... names)\n</code></pre> <p>Rules:</p> <ul> <li>A method may have only one varargs parameter.</li> <li>It must be the last parameter in the list.</li> <li> <p>Varargs are treated as an array inside the method.</p> </li> <li> <p>Example:</p> </li> </ul> <pre><code>void show(int x, String... values) {\n    System.out.println(values.length);\n}\n\nshow(10);                     // length = 0\nshow(10, \"A\");                // length = 1\nshow(10, \"A\", \"B\", \"C\");      // length = 3\n</code></pre> <p>Important</p> <p>Varargs and arrays participate in method overloading. Overload resolution may become ambiguous.</p> <p></p>"},{"location":"en/module-04/methods-attributes/#146-static-methods-static-variables-and-static-initializers","title":"14.6 Static Methods, Static Variables, and Static Initializers","text":"<p>In Java, the keyword <code>static</code> marks elements that belong to the class itself, not to individual instances. This means:</p> <ul> <li>They are loaded once into memory when the class is first loaded by the JVM.</li> <li>They are shared among all instances.</li> <li>They can be accessed without creating an object of the class.</li> </ul> <p>Static members are stored in the JVM method area (class-level memory), while instance members live in the heap.</p> <p></p>"},{"location":"en/module-04/methods-attributes/#1461-static-variables-class-variables","title":"14.6.1 Static Variables (Class Variables)","text":"<p>A static variable is a variable defined at class level and shared by all instances.</p> <p>Characteristics:</p> <ul> <li>Created when the class is loaded.</li> <li>Exists even if no instance of the class is created.</li> <li>All objects see the same value.</li> <li> <p>May be marked <code>final</code>, <code>volatile</code>, or <code>transient</code>.</p> </li> <li> <p>Example:</p> </li> </ul> <pre><code>public class Counter {\n    static int count = 0;    // shared by all instances\n    int id;                  // instance variable\n\n    public Counter() {\n        count++;\n        id = count;          // each instance gets a unique id\n    }\n}\n</code></pre> <p></p>"},{"location":"en/module-04/methods-attributes/#1462-static-methods","title":"14.6.2 Static Methods","text":"<p>A static method belongs to the class, not to any object instance.</p> <p>Rules:</p> <ul> <li>They can be called using the class name: <code>ClassName.method()</code>.</li> <li>They cannot access instance variables or instance methods directly, but only through an instance of the class.</li> <li>They cannot use <code>this</code> or <code>super</code>.</li> <li>They are commonly used for:</li> <li>utility methods (e.g., <code>Math.sqrt()</code>)</li> <li>factory methods</li> <li> <p>global behaviors that do not depend on instance state</p> </li> <li> <p>Example:</p> </li> </ul> <pre><code>public class MathUtil {\n\n    static int square(int x) {        // static method\n        return x * x;\n    }\n\n    void instanceMethod() {\n        // System.out.println(count);   // OK: accessing static variable\n        // square(5);                   // OK: static method accessible\n    }\n}\n</code></pre> <p>Common errors:</p> <pre><code>// \u274c Compile error: instance method cannot be accessed directly in static context\nstatic void go() {\n    run();        // run() is instance method!\n}\n\nvoid run() { }\n</code></pre> <p></p>"},{"location":"en/module-04/methods-attributes/#1463-static-initializer-blocks","title":"14.6.3 Static Initializer Blocks","text":"<p>Static initializer blocks allow executing code once, when the class is loaded.</p> <p>Syntax:</p> <pre><code>static {\n    // initialization logic\n}\n</code></pre> <p>Usage:</p> <ul> <li>initializing complex static variables  </li> <li>performing class-level setup  </li> <li> <p>running code that must execute exactly once  </p> </li> <li> <p>Example:</p> </li> </ul> <pre><code>public class Config {\n\n    static final Map&lt;String, String&gt; settings = new HashMap&lt;&gt;();\n\n    static {\n        settings.put(\"mode\", \"production\");\n        settings.put(\"version\", \"1.0\");\n        System.out.println(\"Static initializer executed\");\n    }\n}\n</code></pre> <p>Important</p> <p>Static initializer blocks run once, in the order they appear, before <code>main()</code> and before any static method is called.</p> <p></p>"},{"location":"en/module-04/methods-attributes/#1464-initialization-order-static-vs-instance","title":"14.6.4 Initialization Order (Static vs. Instance)","text":"<p>( Please refer to Chapter: 15. Class Loading, Initialization, and Object Construction ) </p> <p></p>"},{"location":"en/module-04/methods-attributes/#1465-accessing-static-members","title":"14.6.5 Accessing Static Members","text":""},{"location":"en/module-04/methods-attributes/#14651-recommended-use-class-name","title":"14.6.5.1 Recommended: use class name","text":"<pre><code>Math.sqrt(16);\nMyClass.staticMethod();\n</code></pre>"},{"location":"en/module-04/methods-attributes/#14652-also-legal-via-instance-reference","title":"14.6.5.2 Also legal: via instance reference","text":"<pre><code>MyClass obj = new MyClass();\nobj.staticMethod();   \n</code></pre>"},{"location":"en/module-04/methods-attributes/#1466-static-and-inheritance","title":"14.6.6 Static and Inheritance","text":"<p>Static methods:</p> <ul> <li>can be hidden, not overridden  </li> <li>binding is compile-time, not runtime  </li> <li> <p>accessed based on reference type, not object type</p> </li> <li> <p>Example:</p> </li> </ul> <pre><code>class A {\n    static void test() { System.out.println(\"A\"); }\n}\n\nclass B extends A {\n    static void test() { System.out.println(\"B\"); }\n}\n\nA ref = new B();\nref.test();   // prints \"A\" \u2014 static binding!\n</code></pre> <p>Note</p> <p>Key rule: static methods use reference type, not object type.</p> <p></p>"},{"location":"en/module-04/methods-attributes/#1467-common-pitfalls","title":"14.6.7 Common  Pitfalls","text":"<ul> <li>Attempting to reference an instance variable/method from a static context.</li> <li>Assuming static methods are overridden \u2192 they are hidden.</li> <li>Calling a static method from an instance reference (legal but confusing).</li> <li>Confusing initialization order of static elements vs. instance elements.</li> <li>Forgetting that static variables are shared across all objects.</li> <li>Not knowing that static initializers run once, in declaration order.</li> </ul>"},{"location":"en/module-05/functional/","title":"20. Functional Programming in Java","text":""},{"location":"en/module-05/functional/#table-of-contents","title":"Table of Contents","text":"<ul> <li>20.1 Functional Interfaces<ul> <li>20.1.1 Rules for Functional Interfaces</li> <li>20.1.2 Common Functional Interfaces (java.util.function)</li> <li>20.1.3 Convenience Methods on Functional Interfaces</li> <li>20.1.4 Primitive Functional Interfaces</li> <li>20.1.5 Summary</li> </ul> </li> <li>20.2 Lambda Expressions<ul> <li>20.2.1 Syntax of Lambda Expressions</li> <li>20.2.2 Examples of Lambda Syntax</li> <li>20.2.3 Rules for Lambda Expressions</li> <li>20.2.4 Type Inference</li> <li>20.2.5 Restrictions in Lambda Bodies</li> <li>20.2.6 Return Type Rules</li> <li>20.2.7 Lambdas vs Anonymous Classes</li> <li>20.2.8 Common Lambda Errors Certification Traps</li> </ul> </li> <li>20.3 Method References<ul> <li>20.3.1 Reference to a Static Method</li> <li>20.3.2 Reference to an Instance Method of a Particular Object</li> <li>20.3.3 Reference to an Instance Method of an Arbitrary Object of a Given Type</li> <li>20.3.4 Reference to a Constructor</li> <li>20.3.5 Summary Table of Method Reference Types</li> <li>20.3.6 Common Pitfalls</li> </ul> </li> </ul> <p><code>Functional programming</code> is a programming paradigm that focuses on describing what should be done rather than how it should be done.</p> <p>Starting from Java 8, the language added several features that enable functional-style programming: <code>lambda expressions</code>, <code>functional interfaces</code>, and <code>method references</code>.</p> <p>These features allow developers to write more expressive, concise, and reusable code, especially when working with collections, concurrency APIs, and event-driven systems.</p> <p></p>"},{"location":"en/module-05/functional/#201-functional-interfaces","title":"20.1 Functional Interfaces","text":"<p>In Java, a functional interface is an interface that contains exactly one abstract method.</p> <p>Functional interfaces enable Lambda Expressions and Method References, forming the core of Java\u2019s functional programming model.</p> <p>Note</p> <p>Java automatically treats any interface with a single abstract method as a functional interface. The <code>@FunctionalInterface</code> annotation is optional but recommended.</p> <p></p>"},{"location":"en/module-05/functional/#2011-rules-for-functional-interfaces","title":"20.1.1 Rules for Functional Interfaces","text":"<ul> <li>Exactly one abstract method (SAM = Single Abstract Method).</li> <li>Interfaces may declare any number of default, static or private methods.</li> <li>They may override <code>Object</code> methods (<code>toString()</code>, <code>equals(Object)</code>, <code>hashCode()</code>) without affecting SAM count.</li> <li>The functional method may come from a superinterface.</li> </ul> <p>Example:</p> <pre><code>@FunctionalInterface\ninterface Adder {\n    int add(int a, int b);   // single abstract method\n    static void info() {}\n    default void log() {}\n}\n</code></pre> <p></p>"},{"location":"en/module-05/functional/#2012-common-functional-interfaces-javautilfunction","title":"20.1.2 Common Functional Interfaces (java.util.function)","text":"<p>Below is a summary of the most important functional interfaces.</p> Functional Interface Returns Method Parameters <code>Supplier&lt;T&gt;</code> T get() 0 <code>Consumer&lt;T&gt;</code> void accept(T) 1 <code>BiConsumer&lt;T,U&gt;</code> void accept(T,U) 2 <code>Function&lt;T,R&gt;</code> R apply(T) 1 <code>BiFunction&lt;T,U,R&gt;</code> R apply(T,U) 2 <code>UnaryOperator&lt;T&gt;</code> T apply(T) 1 (same types) <code>BinaryOperator&lt;T&gt;</code> T apply(T,T) 2 (same types) <code>Predicate&lt;T&gt;</code> boolean test(T) 1 <code>BiPredicate&lt;T,U&gt;</code> boolean test(T,U) 2 <ul> <li>Examples</li> </ul> <pre><code>Supplier&lt;String&gt; sup = () -&gt; \"Hello!\";\n\nConsumer&lt;String&gt; printer = s -&gt; System.out.println(s);\n\nFunction&lt;String, Integer&gt; length = s -&gt; s.length();\n\nUnaryOperator&lt;Integer&gt; square = x -&gt; x * x;\n\nPredicate&lt;Integer&gt; positive = x -&gt; x &gt; 0;\n</code></pre> <p></p>"},{"location":"en/module-05/functional/#2013-convenience-methods-on-functional-interfaces","title":"20.1.3 Convenience Methods on Functional Interfaces","text":"<p>Many functional interfaces come with helper methods that allow chaining and composition.</p> Interface Method Description Function andThen() applies this, then another Function compose() applies another, then this Function identity() returns a function x -&gt; x Predicate and() logical AND Predicate or() logical OR Predicate negate() logical NOT Consumer andThen() chains consumers BinaryOperator minBy() comparator-based minimum BinaryOperator maxBy() comparator-based maximum <ul> <li>Examples</li> </ul> <pre><code>Function&lt;Integer, Integer&gt; times2 = x -&gt; x * 2;\nFunction&lt;Integer, Integer&gt; plus3  = x -&gt; x + 3;\n\nvar result1 = times2.andThen(plus3).apply(5);   // (5*2)+3 = 13\nvar result2 = times2.compose(plus3).apply(5);   // (5+3)*2 = 16\n\nPredicate&lt;String&gt; longString = s -&gt; s.length() &gt; 5;\nPredicate&lt;String&gt; startsWithA = s -&gt; s.startsWith(\"A\");\n\nboolean ok = longString.and(startsWithA).test(\"Amazing\");  // true\n</code></pre> <p></p>"},{"location":"en/module-05/functional/#2014-primitive-functional-interfaces","title":"20.1.4 Primitive Functional Interfaces","text":"<p>Java provides specialized versions of functional interfaces for primitives to avoid boxing/unboxing overhead.</p> Functional Interface Return Type Single Abstract Method # Parameters IntSupplier int getAsInt() 0 LongSupplier long getAsLong() 0 DoubleSupplier double getAsDouble() 0 BooleanSupplier boolean getAsBoolean() 0 IntConsumer void accept(int) 1 (int) LongConsumer void accept(long) 1 (long) DoubleConsumer void accept(double) 1 (double) IntPredicate boolean test(int) 1 (int) LongPredicate boolean test(long) 1 (long) DoublePredicate boolean test(double) 1 (double) IntUnaryOperator int applyAsInt(int) 1 (int) LongUnaryOperator long applyAsLong(long) 1 (long) DoubleUnaryOperator double applyAsDouble(double) 1 (double) IntBinaryOperator int applyAsInt(int, int) 2 (int,int) LongBinaryOperator long applyAsLong(long, long) 2 (long,long) DoubleBinaryOperator double applyAsDouble(double,double) 2 IntFunction R apply(int) 1 (int) LongFunction R apply(long) 1 (long) DoubleFunction R apply(double) 1 (double) ToIntFunction int applyAsInt(T) 1 (T) ToLongFunction long applyAsLong(T) 1 (T) ToDoubleFunction double applyAsDouble(T) 1 (T) ToIntBiFunction int applyAsInt(T,U) 2 (T,U) ToLongBiFunction long applyAsLong(T,U) 2 (T,U) ToDoubleBiFunction double applyAsDouble(T,U) 2 (T,U) ObjIntConsumer void accept(T,int) 2 (T,int) ObjLongConsumer void accept(T,long) 2 (T,long) ObjDoubleConsumer void accept(T,double) 2 (T,double) DoubleToIntFunction int applyAsInt(double) 1 DoubleToLongFunction long applyAsLong(double) 1 IntToDoubleFunction double applyAsDouble(int) 1 IntToLongFunction long applyAsLong(int) 1 LongToDoubleFunction double applyAsDouble(long) 1 LongToIntFunction int applyAsInt(long) 1 <ul> <li>Example</li> </ul> <pre><code>IntSupplier dice = () -&gt; (int)(Math.random() * 6) + 1;\n\nIntPredicate even = x -&gt; x % 2 == 0;\n\nIntUnaryOperator doubleIt = x -&gt; x * 2;\n</code></pre> <p></p>"},{"location":"en/module-05/functional/#2015-summary","title":"20.1.5 Summary","text":"<ul> <li>Functional interfaces contain exactly one abstract method (SAM).</li> <li>They power Lambdas and Method References.</li> <li>Java offers many built-in FIs in java.util.function.</li> <li>Primitive variants improve performance by removing boxing.</li> </ul>"},{"location":"en/module-05/functional/#202-lambda-expressions","title":"20.2 Lambda Expressions","text":"<p>A lambda expression is a compact way of writing a function.</p> <p>Lambda expressions provide a concise way to define implementations of functional interfaces.</p> <p>A lambda is essentially a short block of code that takes parameters and returns a value, without requiring a full method declaration.</p> <p>They represent behavior as data and are a key element of Java\u2019s functional programming model.</p> <p></p>"},{"location":"en/module-05/functional/#2021-syntax-of-lambda-expressions","title":"20.2.1 Syntax of Lambda Expressions","text":"<p>The general syntax is:</p> <p><code>(parameters) -&gt; expression</code> or <code>(parameters) -&gt; { statements }</code></p> <p></p>"},{"location":"en/module-05/functional/#2022-examples-of-lambda-syntax","title":"20.2.2 Examples of Lambda Syntax","text":"<p>Zero parameters <pre><code>Runnable r = () -&gt; System.out.println(\"Hello\");\n</code></pre></p> <p>One parameter (parentheses optional) <pre><code>Consumer&lt;String&gt; c = s -&gt; System.out.println(s);\n</code></pre></p> <p>Multiple parameters <pre><code>BinaryOperator&lt;Integer&gt; add = (a, b) -&gt; a + b;\n</code></pre></p> <p>With a block body <pre><code>Function&lt;Integer, String&gt; f = (x) -&gt; {\n    int doubled = x * 2;\n    return \"Value: \" + doubled;\n};\n</code></pre></p> <p></p>"},{"location":"en/module-05/functional/#2023-rules-for-lambda-expressions","title":"20.2.3 Rules for Lambda Expressions","text":"<ul> <li>Parameter types may be omitted (type inference).</li> <li>If a parameter has a type, all parameters must specify the type.</li> <li>A single parameter does not require parentheses.</li> <li>Multiple parameters require parentheses.</li> <li>If the body is a single expression (no <code>{ }</code>), <code>return</code> is not allowed; the expression itself is the return value.</li> <li>If the body uses <code>{ }</code> (a block), <code>return</code> must appear if a value is returned.</li> <li>Lambda expressions can only be assigned to functional interfaces (SAM types).</li> </ul>"},{"location":"en/module-05/functional/#2024-type-inference","title":"20.2.4 Type Inference","text":"<p>The compiler infers the lambda's type from the target functional interface context.</p> <pre><code>Predicate&lt;String&gt; p = s -&gt; s.isEmpty();  // s inferred as String\n</code></pre> <p>If the compiler cannot infer the type, you must specify it explicitly.</p> <pre><code>BiFunction&lt;Integer, Integer, Integer&gt; f = (Integer a, Integer b) -&gt; a * b;\n</code></pre> <p></p>"},{"location":"en/module-05/functional/#2025-restrictions-in-lambda-bodies","title":"20.2.5 Restrictions in Lambda Bodies","text":"<p>Lambdas can only capture local variables that are final or effectively final (not reassigned).</p> <pre><code>int x = 10;\nRunnable r = () -&gt; {\n    // x++;   // \u274c compile error \u2014 x must be effectively final\n    System.out.println(x);\n};\n</code></pre> <p>They CAN modify object state (only references must be effectively final).</p> <pre><code>var list = new ArrayList&lt;&gt;();\nRunnable r2 = () -&gt; list.add(\"OK\");  // allowed\n</code></pre> <p></p>"},{"location":"en/module-05/functional/#2026-return-type-rules","title":"20.2.6 Return Type Rules","text":"<p>If the body is an expression: the expression is the return value.</p> <pre><code>Function&lt;Integer, Integer&gt; f = x -&gt; x * 2;\n</code></pre> <p>If the body is a block: you must include <code>return</code>.</p> <pre><code>Function&lt;Integer, Integer&gt; g = x -&gt; {\n    return x * 2;\n};\n</code></pre> <p></p>"},{"location":"en/module-05/functional/#2027-lambdas-vs-anonymous-classes","title":"20.2.7 Lambdas vs Anonymous Classes","text":"<ul> <li>Lambdas do NOT create a new scope \u2014 they share the enclosing scope.</li> <li><code>this</code> inside a lambda refers to the enclosing object, not the lambda.</li> </ul> <pre><code>class Test {\n    void run() {\n        Runnable r = () -&gt; System.out.println(this.toString());\n    }\n}\n</code></pre> <p>In anonymous classes, <code>this</code> refers to the anonymous class instance.</p> <p></p>"},{"location":"en/module-05/functional/#2028-common-lambda-errors-certification-traps","title":"20.2.8 Common Lambda Errors (Certification Traps)","text":"<p>Inconsistent return types <pre><code>x -&gt; { if (x &gt; 0) return 1; }  // \u274c missing return for negative case\n</code></pre></p> <p>Mixing typed and untyped parameters <pre><code>(a, int b) -&gt; a + b   // \u274c illegal\n</code></pre></p> <p>Returning a value from a void-target lambda <pre><code>Runnable r = () -&gt; 5;  // \u274c Runnable.run() returns void\n</code></pre></p> <p>Ambiguous overload resolution</p> <pre><code>void m(IntFunction&lt;Integer&gt; f) {}\nvoid m(Function&lt;Integer, Integer&gt; f) {}\n\nm(x -&gt; x + 1);  // \u274c ambiguous\n</code></pre> <p></p>"},{"location":"en/module-05/functional/#203-method-references","title":"20.3 Method References","text":"<p>Method references provide a shorthand syntax for using an existing method as a functional interface implementation. </p> <p>They are equivalent to lambda expressions, but more concise, readable, and often preferred when the target method already exists.</p> <p>There are four categories of method references in Java:</p> <ul> <li> <ol> <li>Reference to a static method (<code>ClassName::staticMethod</code>)</li> </ol> </li> <li> <ol> <li>Reference to an instance method of a particular object (<code>instance::method</code>)</li> </ol> </li> <li> <ol> <li>Reference to an instance method of an arbitrary object of a given type (<code>ClassName::instanceMethod</code>)</li> </ol> </li> <li> <ol> <li>Reference to a constructor (<code>ClassName::new</code>)</li> </ol> </li> </ul> <p></p>"},{"location":"en/module-05/functional/#2031-reference-to-a-static-method","title":"20.3.1 Reference to a Static Method","text":"<p>A static method reference replaces a lambda that calls a static method.</p> <pre><code>class Utils {\n    static int square(int x) { return x * x; }\n}\n\nFunction&lt;Integer, Integer&gt; f1 = x -&gt; Utils.square(x);\nFunction&lt;Integer, Integer&gt; f2 = Utils::square;  // method reference\n</code></pre> <p>Both <code>f1</code> and <code>f2</code> behave identically.</p> <p></p>"},{"location":"en/module-05/functional/#2032-reference-to-an-instance-method-of-a-particular-object","title":"20.3.2 Reference to an Instance Method of a Particular Object","text":"<p>Used when you already have an object instance, and want to refer to one of its methods.</p> <pre><code>String prefix = \"Hello, \";\n\nUnaryOperator&lt;String&gt; op1 = s -&gt; prefix.concat(s);\nUnaryOperator&lt;String&gt; op2 = prefix::concat;   // method reference\n\nSystem.out.println(op2.apply(\"World\"));\n</code></pre> <p>The reference <code>prefix::concat</code> binds <code>concat</code> to that specific object.</p> <p></p>"},{"location":"en/module-05/functional/#2033-reference-to-an-instance-method-of-an-arbitrary-object-of-a-given-type","title":"20.3.3 Reference to an Instance Method of an Arbitrary Object of a Given Type","text":"<p>This is the trickiest form.</p> <p>The functional interface\u2019s first parameter becomes the method\u2019s receiver (<code>this</code>).</p> <pre><code>BiPredicate&lt;String, String&gt; p1 = (s1, s2) -&gt; s1.equals(s2);\nBiPredicate&lt;String, String&gt; p2 = String::equals;   // method reference\n\nSystem.out.println(p2.test(\"abc\", \"abc\"));  // true\n</code></pre> <p>Note</p> <p>This form applies the method to the first argument of the lambda.</p> <p></p>"},{"location":"en/module-05/functional/#2034-reference-to-a-constructor","title":"20.3.4 Reference to a Constructor","text":"<p>Constructor references replace lambdas that call <code>new</code>.</p> <pre><code>Supplier&lt;ArrayList&lt;String&gt;&gt; sup1 = () -&gt; new ArrayList&lt;&gt;();\nSupplier&lt;ArrayList&lt;String&gt;&gt; sup2 = ArrayList::new; // method reference\n\nFunction&lt;Integer, ArrayList&lt;String&gt;&gt; sup3 = ArrayList::new;\n// calls the constructor ArrayList(int capacity)\n</code></pre> <p></p>"},{"location":"en/module-05/functional/#2035-summary-table-of-method-reference-types","title":"20.3.5 Summary Table of Method Reference Types","text":"<p>The table below summarizes all method reference categories.</p> Type Syntax Example Equivalent Lambda Static method Class::staticMethod x -&gt; Class.staticMethod(x) Instance method of specific object instance::method x -&gt; instance.method(x) Instance method of arbitrary object Class::method (obj, x) -&gt; obj.method(x) Constructor Class::new () -&gt; new Class() <p></p>"},{"location":"en/module-05/functional/#2036-common-pitfalls","title":"20.3.6 Common Pitfalls","text":"<ul> <li>A method reference must match exactly the functional interface signature.</li> <li>Method overloads can make method references ambiguous.</li> <li>Instance-method reference (<code>Class::method</code>) shifts the receiver to parameter 1.</li> <li>Constructor reference fails if there is no matching constructor.</li> </ul> <pre><code>// \u274c Ambiguous: which println()? (println(int), println(String)...)\nConsumer&lt;String&gt; c = System.out::println; // OK only because FI parameter is String\n\n// \u274c No matching constructor: wrong functional interface\nSupplier&lt;Integer&gt; s = Integer::new;          // \u2714 OK: calls Integer()\nFunction&lt;String, Long&gt; f = Integer::new;     // \u274c ERROR: constructor returns Integer, not Long\n</code></pre> <p>When in doubt, rewrite the method reference as a lambda \u2014 if the lambda works but the method reference does not, the problem is usually signature matching.</p>"},{"location":"en/module-05/streams/","title":"21. Java Optionals and Streams","text":""},{"location":"en/module-05/streams/#table-of-contents","title":"Table of Contents","text":"<ul> <li>21.1 Optionals Optional OptionalInt OptionalLong OptionalDouble<ul> <li>21.1.1 Creating Optionals</li> <li>21.1.2 Reading values safely</li> <li>21.1.3 Transforming Optionals</li> <li>21.1.4 Optionals and Streams</li> <li>21.1.5 Primitive Optionals</li> <li>21.1.6 Common pitfalls</li> </ul> </li> <li>21.2 What Is a Stream And What It Is Not</li> <li>21.3 Stream Pipeline Architecture<ul> <li>21.3.1 Stream Sources</li> <li>21.3.2 Intermediate Operations<ul> <li>21.3.2.1 Table of Common intermediate operations</li> </ul> </li> <li>21.3.3 Terminal Operations<ul> <li>21.3.3.1 Table of terminal operations</li> </ul> </li> </ul> </li> <li>21.4 Lazy Evaluation and Short-Circuiting</li> <li>21.5 Stateless vs Stateful Operations<ul> <li>21.5.1 Stateless Operations</li> <li>21.5.2 Stateful Operations</li> </ul> </li> <li>21.6 Stream Ordering and Determinism</li> <li>21.7 Parallel Streams</li> <li>21.8 Reduction Operations<ul> <li>21.8.1 reduce combining a stream into a single object<ul> <li>21.8.1.1 Correct mental model</li> </ul> </li> <li>21.8.2 collect</li> <li>21.8.3 Why collect is different from reduce</li> </ul> </li> <li>21.9 Common Streams Pitfalls</li> <li>21.10 Primitive Streams<ul> <li>21.10.1 Why primitive streams matter</li> <li>21.10.2 Common creation methods</li> <li>21.10.3 Primitive-specialized mapping methods</li> <li>21.10.4 Mapping table among StreamT and primitive streams</li> <li>21.10.5 Terminal operations and their result types</li> <li>21.10.6 Common pitfalls and gotchas</li> </ul> </li> <li>21.11 Collectors collect Collector and the Collectors Factory Methods<ul> <li>21.11.1 collect vs Collector</li> <li>21.11.2 Core collectors quick-reference</li> <li>21.11.3 Grouping collectors</li> <li>21.11.4 partitioningBy</li> <li>21.11.5 toMap and merge rules</li> <li>21.11.6 collectingAndThen</li> <li>21.11.7 How collectors relate to parallel streams</li> </ul> </li> </ul>"},{"location":"en/module-05/streams/#211-optionals-optional-optionalint-optionallong-optionaldouble","title":"21.1 Optionals (Optional, OptionalInt, OptionalLong, OptionalDouble)","text":"<p><code>Optional&lt;T&gt;</code> is a container object that may or may not hold a non-null value. </p> <p>It is designed to make \u201cabsence of a value\u201d explicit and to reduce <code>NullPointerException</code> risk by forcing callers to handle the empty case.</p> <p>Note</p> <ul> <li><code>Optional</code> is intended primarily for return types.</li> <li>It is generally discouraged for fields, method parameters, and serialization boundaries (unless a specific API contract requires it).</li> </ul> <p></p>"},{"location":"en/module-05/streams/#2111-creating-optionals","title":"21.1.1 Creating Optionals","text":"<p>There are three core factory methods. </p> <ul> <li><code>Optional.of(value)</code> \u2192 value must be non-null; otherwise <code>NullPointerException</code> is thrown</li> <li><code>Optional.ofNullable(value)</code> \u2192 returns empty if value is null</li> <li><code>Optional.empty()</code> \u2192 an explicitly empty Optional</li> </ul> <pre><code>Optional&lt;String&gt; a = Optional.of(\"x\");\nOptional&lt;String&gt; b = Optional.ofNullable(null); // Optional.empty\nOptional&lt;String&gt; c = Optional.empty();\n</code></pre> <p></p>"},{"location":"en/module-05/streams/#2112-reading-values-safely","title":"21.1.2 Reading values safely","text":"<p>Optionals provide multiple ways to access the wrapped value.</p> <ul> <li><code>isPresent()</code> / <code>isEmpty()</code> \u2192 test presence</li> <li><code>get()</code> \u2192 returns the value or throws <code>NoSuchElementException</code> if empty (discouraged)</li> <li><code>orElse(defaultValue)</code> \u2192 returns value or default (default evaluated immediately)</li> <li><code>orElseGet(supplier)</code> \u2192 returns value or supplier result (supplier evaluated lazily)</li> <li><code>orElseThrow()</code> \u2192 returns value or throws <code>NoSuchElementException</code></li> <li><code>orElseThrow(exceptionSupplier)</code> \u2192 returns value or throws custom exception</li> </ul> <pre><code>Optional&lt;String&gt; opt = Optional.of(\"java\");\n\nString v1 = opt.orElse(\"default\");\nString v2 = opt.orElseGet(() -&gt; \"computed\");\nString v3 = opt.orElseThrow(); // ok because opt is present\n</code></pre> <p>Note</p> <ul> <li>A common trap: <code>orElse(...)</code> evaluates its argument even if the Optional is present.</li> <li>Use <code>orElseGet(...)</code> when the default is expensive to compute.</li> </ul> <p></p>"},{"location":"en/module-05/streams/#2113-transforming-optionals","title":"21.1.3 Transforming Optionals","text":"<p>Optionals support functional transformations similar to streams, but with \u201c0 or 1 element\u201d semantics.</p> <ul> <li><code>map(fn)</code> \u2192 transforms the value if present</li> <li><code>flatMap(fn)</code> \u2192 transforms to an Optional without nesting</li> <li><code>filter(predicate)</code> \u2192 keeps value only if predicate is true</li> </ul> <pre><code>Optional&lt;String&gt; name = Optional.of(\"Alice\");\n\nOptional&lt;Integer&gt; len =\n    name.map(String::length); // Optional[5]\n\nOptional&lt;String&gt; filtered =\n    name.filter(n -&gt; n.startsWith(\"A\")); // Optional[Alice]\n\nSystem.out.println(len.orElse(0));\nSystem.out.println(filtered.orElseGet(() -&gt; \"11\"));\n</code></pre> <p>Output:</p> <pre><code>5\nAlice\n</code></pre> <p>Note</p> <ul> <li><code>map</code> wraps the result in an Optional.</li> <li>If your mapping function already returns an Optional, use <code>flatMap</code> to avoid <code>Optional&lt;Optional&lt;T&gt;&gt;</code> nesting.</li> </ul> <p></p>"},{"location":"en/module-05/streams/#2114-optionals-and-streams","title":"21.1.4 Optionals and Streams","text":"<p>A very common pipeline pattern is to map to an Optional and then remove empties. </p> <p>Since Java 9, <code>Optional</code> provides <code>stream()</code> to convert \u201cpresent \u2192 one element\u201d and \u201cempty \u2192 zero elements\u201d.</p> <pre><code>        Stream&lt;String&gt; words = Stream.of(\"a\", \"bb\", \"ccc\");\n\n        words.map(w -&gt; w.length() &gt; 1 ? Optional.of(w.length()) : Optional.&lt;Integer&gt;empty()).flatMap(Optional::stream) // rimuove gli elementi vuoti\n                .forEach(System.out::println); \n</code></pre> <p>Output:</p> <pre><code>2\n3\n</code></pre> <p>Note</p> <p>Before Java 9, this pattern required <code>filter(Optional::isPresent)</code> plus <code>map(Optional::get)</code>.</p> <p></p>"},{"location":"en/module-05/streams/#2115-primitive-optionals","title":"21.1.5 Primitive Optionals","text":"<p>Primitive streams use primitive optionals to avoid boxing: <code>OptionalInt</code>, <code>OptionalLong</code>, <code>OptionalDouble</code>. </p> <p>They mirror the main Optional API with primitive getters such as <code>getAsInt()</code>.</p> <ul> <li><code>OptionalInt.getAsInt()</code> / <code>OptionalLong.getAsLong()</code> / <code>OptionalDouble.getAsDouble()</code></li> <li><code>orElse(...)</code> / <code>orElseGet(...)</code> / <code>orElseThrow(...)</code></li> </ul> <pre><code>OptionalInt m = IntStream.of(3, 1, 2).min(); // OptionalInt[1]\nint value = m.orElse(0); // 1\n</code></pre> <p></p>"},{"location":"en/module-05/streams/#2116-common-pitfalls","title":"21.1.6 Common pitfalls","text":"<ul> <li>Do not call <code>get()</code> without checking presence; prefer <code>orElseThrow</code> or transformations</li> <li>Avoid returning <code>null</code> instead of <code>Optional.empty()</code>; an Optional reference itself should not be null</li> <li>Remember: <code>average()</code> on primitive streams always returns <code>OptionalDouble</code> (even for <code>IntStream</code> and <code>LongStream</code>)</li> <li>Use <code>orElseGet</code> when computing the default is expensive</li> </ul>"},{"location":"en/module-05/streams/#212-what-is-a-stream-and-what-it-is-not","title":"21.2 What Is a Stream (And What It Is Not)","text":"<p>A <code>Java Stream</code> represents a sequence of elements supporting functional-style operations. </p> <p>Streams are designed for data processing, not data storage.</p> <p>Key characteristics:</p> <ul> <li>A stream does not store data</li> <li>A stream is lazy \u2014 nothing happens until a terminal operation is invoked</li> <li>A stream can be consumed only once</li> <li>Streams encourage side-effect-free operations</li> </ul> <p>Note</p> <p>Streams are conceptually similar to database queries: they describe what to compute, not how to iterate.</p> <p></p>"},{"location":"en/module-05/streams/#213-stream-pipeline-architecture","title":"21.3 Stream Pipeline Architecture","text":"<p>Every stream pipeline consists of three distinct phases:</p> <ul> <li>1\ufe0f Source</li> <li>2\ufe0f Zero or more Intermediate Operations</li> <li>3\ufe0f Exactly one Terminal Operation</li> </ul> <p></p>"},{"location":"en/module-05/streams/#2131-stream-sources","title":"21.3.1 Stream Sources","text":"<p>Common stream sources include:</p> <ul> <li>Collections: <code>collection.stream()</code></li> <li>Arrays: <code>Arrays.stream(array)</code></li> <li>I/O channels and files</li> <li>Infinite streams: <code>Stream.iterate</code>, <code>Stream.generate</code></li> </ul> <pre><code>List&lt;String&gt; names = List.of(\"Ana\", \"Bob\", \"Carla\");\nStream&lt;String&gt; s = names.stream();  \n</code></pre> <p></p>"},{"location":"en/module-05/streams/#2132-intermediate-operations","title":"21.3.2 Intermediate Operations","text":"<p>Intermediate operations:</p> <ul> <li>Return a new stream</li> <li>Are lazy</li> <li>Do not trigger execution</li> </ul> <p></p>"},{"location":"en/module-05/streams/#21321-table-of-common-intermediate-operations","title":"21.3.2.1 Table of Common intermediate operations:","text":"Method Common input Params Return value Desctiption <code>filter</code> Predicate <code>Stream&lt;T&gt;</code> filter the stream according to a predicate match <code>map</code> Function <code>Stream&lt;R&gt;</code> transform a stream through a one to one mapping input/output <code>flatMap</code> Function <code>Stream&lt;R&gt;</code> flatten nested streams into a single stream <code>sorted</code> (none) or Comparator <code>Stream&lt;T&gt;</code> sort by natural order or by the provided Comparator <code>distinct</code> (none) <code>Stream&lt;T&gt;</code> remove duplicate elements <code>limit</code> / <code>skip</code> long <code>Stream&lt;T&gt;</code> limit size or skip elements <code>peek</code> Consumer <code>Stream&lt;T&gt;</code> run side-effect action for each element (debugging) <ul> <li>Example:</li> </ul> <pre><code>        List&lt;String&gt; names = List.of(\"Ana\", \"Bob\", \"Carla\", \"Mario\");\n\n        names.stream().filter(n -&gt; n.length() &gt; 3).map(String::toUpperCase).forEach(System.out::println);\n</code></pre> <p>Output:</p> <pre><code>CARLA\nMARIO\n</code></pre> <p>Note</p> <p>Intermediate operations only describe the computation. No element is processed yet.</p> <p></p>"},{"location":"en/module-05/streams/#2133-terminal-operations","title":"21.3.3 Terminal Operations","text":"<p>Terminal operations:</p> <ul> <li>Trigger execution</li> <li>Consume the stream</li> <li>Produce a result or side effect</li> </ul> <p></p>"},{"location":"en/module-05/streams/#21331-table-of-terminal-operations","title":"21.3.3.1 Table of terminal operations:","text":"Method Return value behaviour for infinite streams <code>forEach</code> void does not terminate <code>collect</code> varies does not terminate <code>reduce</code> varies does not terminate <code>findFirst</code> / <code>findAny</code> <code>Optional&lt;T&gt;</code> terminates <code>anyMatch</code> / <code>allMatch</code> / <code>noneMatch</code> boolean may terminate early (short-circuit) <code>min</code> / <code>max</code> <code>Optional&lt;T&gt;</code> does not terminate <code>count</code> long does not terminate"},{"location":"en/module-05/streams/#214-lazy-evaluation-and-short-circuiting","title":"21.4 Lazy Evaluation and Short-Circuiting","text":"<pre><code>var newNames = new ArrayList&lt;String&gt;();\n\nnewNames.add(\"Bob\");\nnewNames.add(\"Dan\");\n\n// Streams are lazily evaluated: this does not traverse the data yet,\n// it only creates a pipeline description bound to the source.\nvar stream = newNames.stream();\n\nnewNames.add(\"Erin\");\n\n// Terminal operation triggers evaluation. The stream sees the updated source,\n// so the count includes \"Erin\".\nstream.count(); // 3\n</code></pre> <p>Important note : A stream is bound to its source (<code>newNames</code>), and the pipeline is not executed until a terminal operation is invoked. For this reason, if you modify the collection before the terminal operation, the terminal operation \u201csees\u201d the new elements (here, <code>Erin</code>). In general, however, modifying the source while a stream pipeline is in use is bad practice and can lead to non-deterministic behavior (or <code>ConcurrentModificationException</code> with some sources/operations).  The practical rule is: build the source, then create and execute the stream without mutating it.</p> <p>Streams process elements one at a time, flowing \u201cvertically\u201d through the pipeline rather than stage-by-stage.</p> <p>Below we modify the example to use a short-circuiting terminal operation: <code>findFirst()</code>.</p> <pre><code>Stream.of(\"a\", \"bb\", \"ccc\")\n    .filter(s -&gt; {\n        System.out.println(\"filter \" + s);\n        return s.length() &gt; 1;\n    })\n    .map(s -&gt; {\n        System.out.println(\"map \" + s);\n        return s.toUpperCase();\n    })\n    .findFirst()\n    .ifPresent(System.out::println);\n</code></pre> <p>Execution order:</p> <p>Note</p> <p>Only the minimum number of elements required by the terminal operation are processed.</p> <pre><code>filter a\nfilter bb\nmap bb\nBB\n</code></pre> <p><code>findFirst()</code> is satisfied as soon as it finds the first element that successfully passes through the pipeline (here <code>\"bb\"</code>), therefore: - <code>\"ccc\"</code> is never processed (neither <code>filter</code> nor <code>map</code>); - lazy evaluation avoids unnecessary work compared to a terminal operation that consumes all elements (such as <code>forEach</code> or <code>count</code>).</p> <p></p>"},{"location":"en/module-05/streams/#215-stateless-vs-stateful-operations","title":"21.5 Stateless vs Stateful Operations","text":""},{"location":"en/module-05/streams/#2151-stateless-operations","title":"21.5.1 Stateless Operations","text":"<p>Operations like <code>map</code> and <code>filter</code> process each element independently.</p> <p></p>"},{"location":"en/module-05/streams/#2152-stateful-operations","title":"21.5.2 Stateful Operations","text":"<p>Operations like <code>distinct</code>, <code>sorted</code>, and <code>limit</code> require maintaining internal state.</p> <p>Note</p> <p>Stateful operations can severely impact parallel stream performance.</p> <p></p>"},{"location":"en/module-05/streams/#216-stream-ordering-and-determinism","title":"21.6 Stream Ordering and Determinism","text":"<p>Streams may be:</p> <ul> <li>Ordered (e.g., <code>List.stream()</code>)</li> <li>Unordered (e.g., <code>HashSet.stream()</code>)</li> </ul> <p>Some operations respect encounter order:</p> <ul> <li><code>forEachOrdered</code></li> <li><code>findFirst</code></li> </ul> <p>Note</p> <p>In parallel streams, <code>forEach</code> does not guarantee order.</p> <p></p>"},{"location":"en/module-05/streams/#217-parallel-streams","title":"21.7 Parallel Streams","text":"<p>Parallel streams divide work across threads using the ForkJoinPool.commonPool().</p> <pre><code>int sum =\nIntStream.range(1, 1_000_000)\n    .parallel()\n        .sum();\n</code></pre> <p>Rules for safe parallel streams:</p> <ul> <li>No side effects</li> <li>No mutable shared state</li> <li>Associative operations only</li> </ul> <p>Note</p> <p>Parallel streams can be slower for small workloads.</p> <p></p>"},{"location":"en/module-05/streams/#218-reduction-operations","title":"21.8 Reduction Operations","text":""},{"location":"en/module-05/streams/#2181-reduce-combining-a-stream-into-a-single-object","title":"21.8.1 <code>reduce()</code>: combining a stream into a single object","text":"<p>There are three method signatures for this operation:</p> <ul> <li>public <code>Optional&lt;T&gt;</code> reduce(<code>BinaryOperator&lt;T&gt; accumulator</code>);</li> <li>public <code>T</code> reduce(<code>T identity</code>, <code>BinaryOperator&lt;T&gt; accumulator</code>);</li> <li>public <code>&lt;U&gt; U</code> reduce(<code>U identity</code>, <code>BiFunction&lt;U, ? super T, U&gt; accumulator</code>, <code>BinaryOperator&lt;U&gt; combiner</code>)</li> </ul> <pre><code>int sum = Stream.of(1, 2, 3)\n    .reduce(0, Integer::sum);\n</code></pre> <p>Reduction requires:</p> <ul> <li>Identity: Initial value for each partial reduction; must be a neutral element; Example: 0 for sum, 1 for multiplication, empty collection for collecting;</li> <li>Accumulator: Incorporates one stream element into a partial result;</li> <li>(Optional) Combiner: Merges two partial results; Used only when the stream is parallel; Ignored for sequential streams</li> </ul> <p>Note</p> <p>The accumulator must be associative and stateless.</p> <p></p>"},{"location":"en/module-05/streams/#21811-correct-mental-model","title":"21.8.1.1 Correct mental model","text":"<ul> <li>Accumulator: result + element</li> <li>Combiner: result + result</li> </ul> <p>Example 1: Correct use (sum of lengths)</p> <pre><code>int totalLength =\n    Stream.of(\"a\", \"bb\", \"ccc\")\n          .parallel()\n          .reduce(\n              0,                       // identity\n              (sum, s) -&gt; sum + s.length(), // accumulator\n              (left, right) -&gt; left + right // combiner\n          );\n</code></pre> <p>What happens in parallel</p> <p>Suppose the stream is split:</p> <ul> <li>Thread 1: \"a\", \"bb\" \u2192 0 + 1 + 2 = 3</li> <li>Thread 2: \"ccc\" \u2192 0 + 3 = 3</li> </ul> <p>Then the combiner merges the partial results:</p> <pre><code>3 + 3 = 6\n</code></pre> <p>Example 2: Combiner ignored in sequential streams</p> <pre><code>int result =\n    Stream.of(\"a\", \"bb\", \"ccc\")\n          .reduce(\n              0,\n              (sum, s) -&gt; sum + s.length(),\n              (x, y) -&gt; {\n                  throw new RuntimeException(\"Never called\");\n              }\n          );\n</code></pre> <p>Example 3: Incorrect combiner</p> <pre><code>int result =\n    Stream.of(1, 2, 3, 4)\n          .parallel()\n          .reduce(\n              0,\n              (a, b) -&gt; a - b,   // accumulator\n              (x, y) -&gt; x - y    // combiner\n          );\n</code></pre> <p>Why this is wrong</p> <p>Subtraction is not associative.</p> <p>Possible execution:</p> <ul> <li>Thread 1: 0 - 1 - 2 = -3</li> <li>Thread 2: 0 - 3 - 4 = -7</li> </ul> <p>Combiner:</p> <pre><code>-3 - (-7) = 4\n</code></pre> <p>Sequential result would be:</p> <pre><code>(((0 - 1) - 2) - 3) - 4 = -10\n</code></pre> <p>Warning</p> <p>\u274c Parallel and sequential results differ \u2192 illegal reduction</p> <p></p>"},{"location":"en/module-05/streams/#2182-collect","title":"21.8.2 <code>collect()</code>","text":"<p><code>collect</code> is a mutable reduction optimized for grouping and aggregation. </p> <p>It is the Stream API\u2019s standard tool for \u201cmutable reduction\u201d: you accumulate elements into a mutable container (like a List, Set, Map, StringBuilder, custom result object),  and then optionally merge partial containers when running in parallel.</p> <p>The general form is:</p> <ul> <li><code>public &lt;R&gt; R **collect**(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? super T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner)</code>;</li> </ul> <p>And a common version used is:</p> <ul> <li><code>public &lt;R, A&gt; R **collect**(Collector&lt;? super T, A, R&gt; collector)</code></li> </ul> <p>where Collectors.* provides prebuilt collectors (grouping, mapping, joining, counting, etc.).</p> <p>Meaning:</p> <ul> <li>supplier: creates a new empty result container (e.g. new <code>ArrayList&lt;&gt;()</code>)</li> <li>accumulator: adds one element into that container (e.g. <code>list::add</code>)</li> <li>combiner: merges two containers (e.g. <code>list1.addAll(list2)</code>)</li> </ul> <p></p>"},{"location":"en/module-05/streams/#2183-why-collect-is-different-from-reduce","title":"21.8.3 Why <code>collect()</code> is different from <code>reduce()</code>","text":"<ul> <li>Intent: mutation vs immutability<ul> <li><code>reduce()</code> is designed for immutable-style reduction: combine values into a new value (e.g. sum, min, max).</li> <li><code>collect()</code> is designed for mutable containers: build up a List, Map, StringBuilder, etc.</li> </ul> </li> <li>Correctness in parallel<ul> <li><code>reduce()</code> requires the operation to be:<ul> <li>associative</li> <li>stateless</li> <li>compatible with identity/combiner rules</li> </ul> </li> <li><code>collect()</code> is built to support parallelism safely by:<ul> <li>creating one container per thread (supplier)</li> <li>accumulating locally (accumulator)</li> <li>merging at the end (combiner)</li> </ul> </li> </ul> </li> <li> <p>Performance</p> <ul> <li><code>collect()</code> can be optimized because the stream runtime knows you are building containers:<ul> <li>it can avoid unnecessary copying</li> <li>it can pre-size or use specialized implementations (depending on collector)</li> <li>it\u2019s the idiomatic and expected approach</li> <li>using reduce() to build a collection often creates extra objects or forces unsafe mutation.</li> </ul> </li> </ul> </li> <li> <p>Example: \u201ccollect into a List\u201d the right way</p> </li> </ul> <pre><code>List&lt;String&gt; longNames =\n    names.stream()\n         .filter(s -&gt; s.length() &gt; 3)\n            .collect(Collectors.toList());\n</code></pre> <ul> <li>Example: groupingBy with explanation</li> </ul> <pre><code>Map&lt;Integer, List&lt;String&gt;&gt; byLength =\n    names.stream()\n         .collect(Collectors.groupingBy(String::length));\n</code></pre> <p>What happens conceptually:</p> <ul> <li>The collector creates an empty <code>Map&lt;Integer, List&lt;String&gt;&gt;</code></li> <li>For each name:<ul> <li>compute the key (String::length)</li> <li>put it in the correct bucket list</li> </ul> </li> <li>In parallel:<ul> <li>each thread builds its own partial maps</li> <li>the combiner merges maps by merging lists per key</li> </ul> </li> </ul> <p></p>"},{"location":"en/module-05/streams/#219-common-streams-pitfalls","title":"21.9 Common Streams Pitfalls","text":"<ul> <li>Reusing a consumed stream \u2192 <code>IllegalStateException</code></li> <li>Modifying external variables inside lambdas</li> <li>Assuming execution order in parallel streams</li> <li>Using <code>peek</code> for logic instead of debugging</li> </ul>"},{"location":"en/module-05/streams/#2110-primitive-streams","title":"21.10 Primitive Streams","text":"<p>Java provides three specialized stream types to avoid boxing overhead and to enable numeric-focused operations:</p> <ul> <li><code>IntStream</code> for <code>int</code></li> <li><code>LongStream</code> for <code>long</code></li> <li><code>DoubleStream</code> for <code>double</code></li> </ul> <p>Primitive streams are still streams (lazy pipelines, intermediate + terminal operations, single-use), but they are not generic and they use primitive-specialized functional interfaces (e.g., <code>IntPredicate</code>, <code>LongUnaryOperator</code>, <code>DoubleConsumer</code>).</p> <p>Note</p> <p>Use primitive streams when the data is naturally numeric or when performance matters: they avoid boxing/unboxing overhead and provide additional numeric terminal operations.</p> <p></p>"},{"location":"en/module-05/streams/#21101-why-primitive-streams-matter","title":"21.10.1 Why primitive streams matter","text":"<ul> <li>Performance: avoid allocating wrapper objects and repeated boxing/unboxing in large pipelines</li> <li>Convenience: built-in numeric reductions such as <code>sum()</code>, <code>average()</code>, <code>summaryStatistics()</code></li> <li>Common traps: understanding when results are primitives vs <code>OptionalInt</code>/<code>OptionalLong</code>/<code>OptionalDouble</code></li> </ul>"},{"location":"en/module-05/streams/#21102-common-creation-methods","title":"21.10.2 Common creation methods","text":"<p>The following are the most frequently used ways to create primitive streams. Many certification questions start by identifying the stream type created by a factory method.</p> Sources IntStream.of(int...) IntStream.range(int startInclusive, int endExclusive) IntStream.rangeClosed(int startInclusive, int endInclusive) IntStream.iterate(int seed, IntUnaryOperator f) // infinite unless limited IntStream.iterate(int seed, IntPredicate hasNext, IntUnaryOperator f) IntStream.generate(IntSupplier s) // infinite unless limited LongStream.of(long...) LongStream.range(long startInclusive, long endExclusive) LongStream.rangeClosed(long startInclusive, long endInclusive) LongStream.iterate(long seed, LongUnaryOperator f) LongStream.iterate(long seed, LongPredicate hasNext, LongUnaryOperator f) LongStream.generate(LongSupplier s) DoubleStream.of(double...) DoubleStream.iterate(double seed, DoubleUnaryOperator f) DoubleStream.iterate(double seed, DoublePredicate hasNext, DoubleUnaryOperator f) DoubleStream.generate(DoubleSupplier s) <p>Important</p> <ul> <li>Only <code>IntStream</code> and <code>LongStream</code> provide <code>range()</code> and <code>rangeClosed()</code>.</li> <li>There is no <code>DoubleStream.range</code> because counting with doubles has rounding issues.</li> </ul> <p></p>"},{"location":"en/module-05/streams/#21103-primitive-specialized-mapping-methods","title":"21.10.3 Primitive-specialized mapping methods","text":"<p>Primitive streams provide primitive-only mapping operations that avoid boxing:</p> <ul> <li><code>IntStream.map(IntUnaryOperator)</code> \u2192 <code>IntStream</code></li> <li><code>IntStream.mapToLong(IntToLongFunction)</code> \u2192 <code>LongStream</code></li> <li> <p><code>IntStream.mapToDouble(IntToDoubleFunction)</code> \u2192 <code>DoubleStream</code></p> </li> <li> <p><code>LongStream.map(LongUnaryOperator)</code> \u2192 <code>LongStream</code></p> </li> <li><code>LongStream.mapToInt(LongToIntFunction)</code> \u2192 <code>IntStream</code></li> <li> <p><code>LongStream.mapToDouble(LongToDoubleFunction)</code> \u2192 <code>DoubleStream</code></p> </li> <li> <p><code>DoubleStream.map(DoubleUnaryOperator)</code> \u2192 <code>DoubleStream</code></p> </li> <li><code>DoubleStream.mapToInt(DoubleToIntFunction)</code> \u2192 <code>IntStream</code></li> <li><code>DoubleStream.mapToLong(DoubleToLongFunction)</code> \u2192 <code>LongStream</code></li> </ul> <p></p>"},{"location":"en/module-05/streams/#21104-mapping-table-among-streamt-and-primitive-streams","title":"21.10.4 Mapping table among <code>Stream&lt;T&gt;</code> and primitive streams","text":"<p>This table summarizes the main conversions among object streams and primitive streams. </p> <p>The \u201cFrom\u201d column tells you which methods are available and the resulting target stream type.</p> From (source) To (target) Primary method(s) <code>Stream&lt;T&gt;</code> <code>Stream&lt;R&gt;</code> <code>map(Function&lt;? super T, ? extends R&gt;)</code> <code>Stream&lt;T&gt;</code> <code>Stream&lt;R&gt; (flatten)</code> <code>flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt;)</code> <code>Stream&lt;T&gt;</code> <code>IntStream</code> <code>mapToInt(ToIntFunction&lt;? super T&gt;)</code> <code>Stream&lt;T&gt;</code> <code>LongStream</code> <code>mapToLong(ToLongFunction&lt;? super T&gt;)</code> <code>Stream&lt;T&gt;</code> <code>DoubleStream</code> <code>mapToDouble(ToDoubleFunction&lt;? super T&gt;)</code> <code>Stream&lt;T&gt;</code> <code>IntStream (flatten)</code> <code>flatMapToInt(Function&lt;? super T, ? extends IntStream&gt;)</code> <code>Stream&lt;T&gt;</code> <code>LongStream (flatten)</code> <code>flatMapToLong(Function&lt;? super T, ? extends LongStream&gt;)</code> <code>Stream&lt;T&gt;</code> <code>DoubleStream (flatten)</code> <code>flatMapToDouble(Function&lt;? super T, ? extends DoubleStream&gt;)</code> <code>IntStream</code> <code>Stream&lt;Integer&gt;</code> <code>boxed()</code> <code>LongStream</code> <code>Stream&lt;Long&gt;</code> <code>boxed()</code> <code>DoubleStream</code> <code>Stream&lt;Double&gt;</code> <code>boxed()</code> <code>IntStream</code> <code>Stream&lt;U&gt;</code> <code>mapToObj(IntFunction&lt;? extends U&gt;)</code> <code>LongStream</code> <code>Stream&lt;U&gt;</code> <code>mapToObj(LongFunction&lt;? extends U&gt;)</code> <code>DoubleStream</code> <code>Stream&lt;U&gt;</code> <code>mapToObj(DoubleFunction&lt;? extends U&gt;)</code> <code>IntStream</code> <code>LongStream</code> <code>asLongStream()</code> <code>IntStream</code> <code>DoubleStream</code> <code>asDoubleStream()</code> <code>LongStream</code> <code>DoubleStream</code> <code>asDoubleStream()</code> <p>Important</p> <ul> <li>There is no <code>unboxed()</code> operation.</li> <li>To go from wrappers to primitives you must start from <code>Stream&lt;T&gt;</code> and use <code>mapToInt</code> / <code>mapToLong</code> / <code>mapToDouble</code>.</li> </ul> <p></p>"},{"location":"en/module-05/streams/#21105-terminal-operations-and-their-result-types","title":"21.10.5 Terminal operations and their result types","text":"<p>Primitive streams have several terminal operations that are either unique or have primitive-specific return types.</p> Terminal operation IntStream returns LongStream returns DoubleStream returns <code>count()</code> long long long <code>sum()</code> int long double <code>min()</code> / max() OptionalInt OptionalLong OptionalDouble <code>average()</code> OptionalDouble OptionalDouble OptionalDouble <code>findFirst()</code> / findAny() OptionalInt OptionalLong OptionalDouble <code>reduce(op)</code> OptionalInt OptionalLong OptionalDouble <code>reduce(identity, op)</code> int long double <code>summaryStatistics()</code> IntSummaryStatistics LongSummaryStatistics DoubleSummaryStatistics <p>Warning</p> <ul> <li>Even for <code>IntStream</code> and <code>LongStream</code>, <code>average()</code> returns <code>OptionalDouble</code> (not <code>OptionalInt</code> or <code>OptionalLong</code>).</li> </ul> <ul> <li>Example 1: <code>Stream&lt;String&gt;</code> \u2192 <code>IntStream</code> \u2192 primitive terminal operations.</li> </ul> <pre><code>List&lt;String&gt; words = List.of(\"a\", \"bb\", \"ccc\");\n\nint totalLength = words.stream()\n    .mapToInt(String::length) // IntStream\n        .sum(); // int\n\n// totalLength = 1 + 2 + 3 = 6\n</code></pre> <ul> <li>Example 2: <code>IntStream</code> \u2192 boxed <code>Stream&lt;Integer&gt;</code> (boxing introduced).</li> </ul> <pre><code>Stream&lt;Integer&gt; boxed = IntStream.rangeClosed(1, 3) // 1,2,3\n    .boxed(); // Stream&lt;Integer&gt;\n</code></pre> <ul> <li>Example 3: primitive stream \u2192 object stream via <code>mapToObj</code>.</li> </ul> <pre><code>Stream&lt;String&gt; labels = IntStream.range(1, 4) // 1,2,3\n    .mapToObj(i -&gt; \"N=\" + i); // Stream&lt;String&gt;\n</code></pre> <p></p>"},{"location":"en/module-05/streams/#21106-common-pitfalls-and-gotchas","title":"21.10.6 Common pitfalls and gotchas","text":"<ul> <li>Do not confuse <code>Stream&lt;Integer&gt;</code> with <code>IntStream</code>: their mapping methods and functional interfaces differ</li> <li><code>IntStream.sum()</code> returns <code>int</code> but <code>IntStream.count()</code> returns <code>long</code></li> <li><code>average()</code> always returns <code>OptionalDouble</code> for all primitive stream types</li> <li>Using <code>boxed()</code> reintroduces boxing; only do it if the downstream API requires objects (e.g., collecting to <code>List&lt;Integer&gt;</code>)</li> <li>Be careful with narrowing conversions: <code>LongStream.mapToInt</code> and <code>DoubleStream.mapToInt</code> may truncate values</li> </ul>"},{"location":"en/module-05/streams/#2111-collectors-collect-collector-and-the-collectors-factory-methods","title":"21.11 Collectors (collect(), Collector, and the Collectors Factory Methods)","text":"<p>A <code>Collector</code> describes how to accumulate stream elements into a final result. </p> <p>The <code>collect(...)</code> terminal operation executes this recipe. </p> <p>The <code>Collectors</code> utility class provides ready-made collectors for common aggregation tasks.</p> <p></p>"},{"location":"en/module-05/streams/#21111-collect-vs-collector","title":"21.11.1 collect() vs Collector","text":"<p>There are two main ways to collect:</p> <ul> <li><code>collect(Collector)</code> \u2192 the common form using <code>Collectors.*</code></li> <li><code>collect(supplier, accumulator, combiner)</code> \u2192 explicit mutable reduction (lower-level)</li> </ul> <pre><code>List&lt;String&gt; list =\nStream.of(\"a\", \"b\")\n    .collect(Collectors.toList());\n\nStringBuilder sb =\nStream.of(\"a\", \"b\")\n    .collect(StringBuilder::new, StringBuilder::append, StringBuilder::append);\n</code></pre> <p>Note</p> <p>Use <code>collect(supplier, accumulator, combiner)</code> when you need a custom mutable container and do not want to implement a full <code>Collector</code>.</p> <p></p>"},{"location":"en/module-05/streams/#21112-core-collectors-quick-reference","title":"21.11.2 Core collectors (quick reference)","text":"<p>These are the most frequently used collectors and the ones most likely to appear in exam questions.</p> <ul> <li><code>toList()</code> \u2192 <code>List&lt;T&gt;</code> (no guarantees about mutability/implementation)</li> <li><code>toSet()</code> \u2192 <code>Set&lt;T&gt;</code></li> <li><code>toCollection(supplier)</code> \u2192 specific collection type (e.g., <code>TreeSet</code>)</li> <li><code>joining(delim, prefix, suffix)</code> \u2192 <code>String</code> from <code>CharSequence</code> elements</li> <li><code>counting()</code> \u2192 <code>Long</code> count</li> <li><code>summingInt</code> / <code>summingLong</code> / <code>summingDouble</code> \u2192 numeric sums</li> <li><code>averagingInt</code> / <code>averagingLong</code> / <code>averagingDouble</code> \u2192 numeric averages</li> <li><code>minBy(comparator)</code> / <code>maxBy(comparator)</code> \u2192 <code>Optional&lt;T&gt;</code></li> <li><code>mapping(mapper, downstream)</code> \u2192 transform then collect with downstream</li> <li><code>filtering(predicate, downstream)</code> \u2192 filter inside collector (Java 9+)</li> </ul> <p></p>"},{"location":"en/module-05/streams/#21113-grouping-collectors","title":"21.11.3 Grouping collectors","text":"<p><code>groupingBy</code> classifies elements into buckets keyed by a classifier function. </p> <p>It produces a <code>Map&lt;K, V&gt;</code> where <code>V</code> depends on the downstream collector.</p> <pre><code>Map&lt;Integer, List&lt;String&gt;&gt; byLen =\nStream.of(\"a\", \"bb\", \"ccc\", \"dd\")\n    .collect(Collectors.groupingBy(String::length));\nSystem.out.println(\"byLen: \" + byLen.toString());\n</code></pre> <p>Output:</p> <pre><code>byLen: {1=[a], 2=[bb, dd], 3=[ccc]}\n</code></pre> <p>With a downstream collector you control what each bucket contains:</p> <pre><code>Map&lt;Integer, Long&gt; countByLen =\nStream.of(\"a\", \"bb\", \"ccc\", \"dd\")\n    .collect(Collectors.groupingBy(String::length, Collectors.counting()));\nSystem.out.println(\"countByLen: \" + countByLen.toString());\n\nMap&lt;Integer, Set&lt;String&gt;&gt; setByLen =\nStream.of(\"a\", \"bb\", \"ccc\", \"dd\")\n    .collect(Collectors.groupingBy(String::length, Collectors.toSet()));\nSystem.out.println(\"setByLen: \" + setByLen.toString());\n</code></pre> <p>Output:</p> <pre><code>countByLen: {1=1, 2=2, 3=1}\nsetByLen: {1=[a], 2=[bb, dd], 3=[ccc]}\n</code></pre> <p>Warning</p> <p>Pay attention to the resulting map value type. Example: <code>groupingBy(..., counting())</code> yields <code>Map&lt;K, Long&gt;</code> (not <code>int</code>).</p> <p></p>"},{"location":"en/module-05/streams/#21114-partitioningby","title":"21.11.4 partitioningBy","text":"<p><code>partitioningBy</code> splits the stream into exactly two groups using a boolean predicate. It always returns a map with keys <code>true</code> and <code>false</code>.</p> <pre><code>Map&lt;Boolean, List&lt;String&gt;&gt; parts =\nStream.of(\"a\", \"bb\", \"ccc\")\n.collect(Collectors.partitioningBy(s -&gt; s.length() &gt; 1));\nSystem.out.println(\"parts: \" + parts.toString());\n</code></pre> <p>Output:</p> <pre><code>parts: {false=[a], true=[bb, ccc]}\n</code></pre> <p>Note</p> <p><code>partitioningBy</code> always creates two buckets, while <code>groupingBy</code> can create many. Both support downstream collectors.</p> <p></p>"},{"location":"en/module-05/streams/#21115-tomap-and-merge-rules","title":"21.11.5 toMap and merge rules","text":"<p><code>toMap</code> throws an exception on duplicate keys unless you provide a merge function.</p> <pre><code>Map&lt;Integer, String&gt; m1 =\nStream.of(\"aa\", \"bb\")\n    .collect(Collectors.toMap(String::length, s -&gt; s)); // \u274c Exception in thread \"main\" java.lang.IllegalStateException: Duplicate key 2 (attempted merging values aa and bb)\n\nMap&lt;Integer, String&gt; m2 =\nStream.of(\"aa\", \"bb\", \"cc\")\n    .collect(Collectors.toMap(String::length, s -&gt; s, (oldV, newV) -&gt; oldV + \",\" + newV)); // key=2 merges values\n</code></pre> <p>Output:</p> <pre><code>m2: {2=aa,bb,cc}\n</code></pre> <p></p>"},{"location":"en/module-05/streams/#21116-collectingandthen","title":"21.11.6 collectingAndThen","text":"<p><code>collectingAndThen(downstream, finisher)</code> lets you apply a final transformation after collecting (e.g., make the list unmodifiable).</p> <pre><code>List&lt;String&gt; unmodifiable =\nStream.of(\"a\", \"b\", \"c\")\n    .collect(Collectors.collectingAndThen(Collectors.toList(), List::copyOf));\n</code></pre> <p></p>"},{"location":"en/module-05/streams/#21117-how-collectors-relate-to-parallel-streams","title":"21.11.7 How collectors relate to parallel streams","text":"<p>Collectors are designed to work with parallel streams by using supplier/accumulator/combiner internally. In parallel, each worker builds a partial result container and then merges containers.</p> <ul> <li>The accumulator mutates a per-thread container (no shared mutable state)</li> <li>The combiner merges containers (required for parallel execution)</li> <li>Some collectors are \u201cconcurrent\u201d or have characteristics that affect performance and ordering</li> </ul> <p>Note</p> <p>prefer <code>collect(Collectors.toList())</code> over using <code>reduce</code> to build collections. <code>reduce</code> is for immutable-style reductions; <code>collect</code> is for mutable containers.</p>"},{"location":"en/module-06/collections/","title":"22. Introduction to the Collections Framework","text":""},{"location":"en/module-06/collections/#table-of-contents","title":"Table of Contents","text":"<ul> <li>22.1 What Is the Collections Framework</li> <li>22.2 The Core Interfaces<ul> <li>22.2.1 Main Collection Interfaces</li> <li>22.2.2 Map Hierarchy</li> </ul> </li> <li>22.3 Sequenced Collections Java-21</li> <li>22.4 Why the Collections Framework Exists</li> <li>22.5 The Two Sides of the Framework Collections-vs-Maps</li> <li>22.6 Generic Types in the Collections Framework</li> <li>22.7 Mutability vs Immutability</li> <li>22.8 Big-O Performance Expectations</li> <li>22.9 Summary</li> </ul> <p>The <code>Java Collections Framework (JCF)</code> is a set of interfaces, classes, and algorithms designed to store, manipulate, and process groups of data efficiently.</p> <p>It provides a unified architecture for handling collections, allowing developers to write reusable, interoperable code with predictable behaviors and performance characteristics.</p> <p>This chapter introduces the foundational concepts needed before studying Lists, Sets, Queues, Maps, and Sequenced Collections, explored in detail in subsequent chapters.</p> <p></p>"},{"location":"en/module-06/collections/#221-what-is-the-collections-framework","title":"22.1 What Is the Collections Framework?","text":"<p>The Collections Framework provides:</p> <ul> <li>A set of interfaces (Collection, List, Set, Queue, Deque, Map\u2026)</li> <li>A set of implementations (ArrayList, HashSet, TreeSet, LinkedList\u2026)</li> <li>A set of utility algorithms (sorting, searching, copying, reversing\u2026) in java.util.Collections and java.util.Arrays.</li> <li>A common language for performance expectations (Big-O complexity).</li> </ul> <p>All major collection structures share a consistent design so that code working with one implementation can often be reused with another.</p> <p></p>"},{"location":"en/module-06/collections/#222-the-core-interfaces","title":"22.2 The Core Interfaces","text":"<p>At the heart of the Java Collections Framework is a small set of root interfaces that define generic data-handling behaviors.</p> <ul> <li>List: an <code>ordered</code> collection of elements that allows <code>duplicates</code>;</li> <li>Set: a collection that does not allow <code>duplicates</code>;</li> <li>Queue: a collection designed for holding elements prior to processing, typically FIFO (first-in-first-out), with variants like priority queues and deques.</li> <li>Map: a structure that maps keys to values, where duplicate keys are not allowed; each key can map to at most one value.</li> </ul> <p></p>"},{"location":"en/module-06/collections/#2221-main-collection-interfaces","title":"22.2.1 Main Collection Interfaces","text":"<p>Below is the conceptual hierarchy.</p> <pre><code>java.util\n\u251c\u2500 Collection&lt;E&gt;\n\u2502 \u251c\u2500 SequencedCollection&lt;E&gt; (Java 21+)\n\u2502 \u2502 \u251c\u2500 List&lt;E&gt;\n\u2502 \u2502 \u2502   \u251c\u2500 ArrayList&lt;E&gt;\n\u2502 \u2502 \u2502   \u2514\u2500 LinkedList&lt;E&gt; (also implements Deque&lt;E&gt;)\n\u2502 \u2502 \u2514\u2500 Deque&lt;E&gt; (also extends Queue&lt;E&gt;)\n\u2502 \u2502     \u251c\u2500 ArrayDeque&lt;E&gt;\n\u2502 \u2502     \u2514\u2500 LinkedList&lt;E&gt;\n\u2502 \u251c\u2500 Set&lt;E&gt;\n\u2502 \u2502     \u251c\u2500 SequencedSet&lt;E&gt; (Java 21+)\n\u2502 \u2502     \u2502       \u2514\u2500 LinkedHashSet&lt;E&gt;\n\u2502 \u2502     \u251c\u2500 SortedSet&lt;E&gt;\n\u2502 \u2502     \u2502       \u2514\u2500 NavigableSet&lt;E&gt;\n\u2502 \u2502     \u2502           \u2514\u2500 TreeSet&lt;E&gt;\n\u2502 \u2502     \u251c\u2500 HashSet&lt;E&gt;\n\u2502 \u2502     \u2514\u2500 (other Set implementations)\n\u2502 \u251c\u2500 Queue&lt;E&gt;\n\u2502 \u2502     \u251c\u2500 Deque&lt;E&gt; (already under SequencedCollection&lt;E&gt;)\n\u2502 \u2502     \u251c\u2500 PriorityQueue&lt;E&gt;\n\u2502 \u2502     \u2514\u2500 (other Queue implementations)\n\u2502 \u2514\u2500 (other Collection implementations)\n\u2502\n\u2514\u2500 Map&lt;K,V&gt; (not a Collection)\n    \u251c\u2500 SequencedMap&lt;K,V&gt; (Java 21+)\n    \u2502   \u2514\u2500 LinkedHashMap&lt;K,V&gt;\n    \u251c\u2500 SortedMap&lt;K,V&gt;\n    \u2502   \u2514\u2500 NavigableMap&lt;K,V&gt;\n    \u2502   \u2514\u2500 TreeMap&lt;K,V&gt;\n    \u251c\u2500 HashMap&lt;K,V&gt;\n    \u251c\u2500 Hashtable&lt;K,V&gt;\n    \u2514\u2500 (other Map/ConcurrentMap implementations)\n</code></pre> <p>The Map interface does not extend Collection because a map stores key/value pairs rather than single values.</p> <p></p>"},{"location":"en/module-06/collections/#2222-map-hierarchy","title":"22.2.2 Map Hierarchy","text":"<pre><code>java.util\n\u2514\u2500 Map&lt;K,V&gt;\n    \u251c\u2500 SequencedMap&lt;K,V&gt; (Java 21+)\n    \u2502   \u2514\u2500 LinkedHashMap&lt;K,V&gt;\n    \u251c\u2500 SortedMap&lt;K,V&gt;\n    \u2502   \u2514\u2500 NavigableMap&lt;K,V&gt;\n    \u2502       \u2514\u2500 TreeMap&lt;K,V&gt;\n    \u251c\u2500 HashMap&lt;K,V&gt;\n    \u251c\u2500 Hashtable&lt;K,V&gt;\n    \u2514\u2500 ConcurrentMap&lt;K,V&gt; (java.util.concurrent)\n        \u2514\u2500 ConcurrentHashMap&lt;K,V&gt;\n</code></pre>"},{"location":"en/module-06/collections/#223-sequenced-collections-java-21","title":"22.3 Sequenced Collections (Java 21+)","text":"<p>Java 21 introduces the new interface <code>SequencedCollection</code>, which formalizes the idea that a collection maintains a defined encounter order. This was already true for List, LinkedHashSet, LinkedHashMap, Deque, etc., but now the behavior is standardized.</p> <ul> <li><code>SequencedCollection</code> defines methods like <code>getFirst()</code>, <code>getLast()</code>, <code>addFirst()</code>, <code>addLast()</code>, <code>removeFirst()</code>, <code>removeLast()</code>, and <code>reversed()</code>.</li> <li>SequencedSet, SequencedMap extend the idea for sets and maps.</li> </ul> <p>This drastically simplifies the specification of ordering behaviors and will be used throughout the following chapters.</p> <p></p>"},{"location":"en/module-06/collections/#224-why-the-collections-framework-exists","title":"22.4 Why the Collections Framework Exists","text":"<ul> <li>Avoid reinventing data structures</li> <li>Provide well-tested, high-performance algorithms</li> <li>Improve interoperability through shared interfaces</li> <li>Support generic types for type-safe collections</li> </ul> <p>Before Java 1.2, data structures were ad-hoc, inconsistent, and untyped. </p> <p>The Collections Framework unified all of this into a consistent API.</p> <p></p>"},{"location":"en/module-06/collections/#225-the-two-sides-of-the-framework-collections-vs-maps","title":"22.5 The Two Sides of the Framework: Collections vs. Maps","text":"<p>\u201cDoes Map extend Collection?\u201d No. A Map stores pairs, while a Collection stores single elements.</p> <ul> <li>Collection = List, Set, Queue, Deque, SequencedCollection</li> <li>Map = Dictionary-like key/value store</li> </ul> <p></p>"},{"location":"en/module-06/collections/#226-generic-types-in-the-collections-framework","title":"22.6 Generic Types in the Collections Framework","text":"<p>Collections are almost always used with generics. Using raw types is discouraged.</p> <pre><code>List&lt;String&gt; names = new ArrayList&lt;&gt;();\nMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();\n</code></pre> <p>Note</p> <p>Generics in collections work through <code>type erasure</code>: Please check the Paragraph \"18.4 Type Erasure\" in Chapter: 18. Generics in Java.</p> <p></p>"},{"location":"en/module-06/collections/#227-mutability-vs-immutability","title":"22.7 Mutability vs. Immutability","text":"<p>Many methods in the Collections API return unmodifiable collections:</p> <pre><code>List&lt;String&gt; immutable = List.of(\"a\", \"b\");\nimmutable.add(\"c\"); // \u274c UnsupportedOperationException\n</code></pre> <p>Java provides several ways to create immutable collections:</p> <ul> <li><code>List.of()</code>, <code>Set.of()</code>, <code>Map.of()</code></li> <li><code>List.copyOf(collection)</code></li> <li><code>Collections.unmodifiableList(...)</code> wrappers</li> <li><code>Records</code> used as immutable value containers</li> </ul> <p>Note</p> <p>The method <code>Arrays.asList(varargs)</code>, which is backed by an array, behaves differently: see examples below.</p> <pre><code>String[] vargs = new String[] {\"u\", \"v\", \"z\"};\nList&lt;String&gt; fromAsList = Arrays.asList(vargs);\n\nList&lt;String&gt; immutable1 = List.of(vargs);\nimmutable1.add(\"c\"); // \u274c UnsupportedOperationException\n\nList&lt;String&gt; immutable2 = List.copyOf(fromAsList);\nimmutable2.set(0, \"k\"); // \u274c UnsupportedOperationException\n\n\n// We can't ADD or REMOVE elements from \"fromAsList\" but we can replace them,\n// either by modifying the underlying array \"vargs\" or by mutating the list itself:\n\n\nfromAsList.set(0, \"k\");  // the update will be reflected on the backing array as well.\n</code></pre> <p>Note</p> <p><code>Arrays.asList(...)</code> returns a fixed-size, but mutable, List view backed by the original array. You cannot add/remove elements, but you can replace existing ones.</p> <p></p>"},{"location":"en/module-06/collections/#228-big-o-performance-expectations","title":"22.8 Big-O Performance Expectations","text":"<p>Understanding complexity is essential. Here are common examples:</p> Type Methods Complexity ArrayList <code>get()</code>, <code>add()</code>, <code>remove()</code> <code>O(1)</code>, <code>amortized O(1)</code>, <code>O(n)</code> LinkedList <code>get()</code>, <code>add/remove first/last</code> <code>O(n)</code>,  <code>O(1)</code> HashSet <code>add()</code>, <code>contains()</code>, <code>remove()</code> ~ <code>O(1)</code> TreeSet <code>add()</code>, <code>contains()</code>, <code>remove()</code> <code>O(log n)</code> HashMap <code>get()/put()</code> ~ <code>O(1) on average</code> TreeMap <code>get()/put()</code> <code>O(log n)</code> Deque <code>add/remove first/last</code> <code>O(1)</code> <p>Note</p> <p>These values are averages; worst-case may be different (especially for hash-based structures).</p> <p></p>"},{"location":"en/module-06/collections/#229-summary","title":"22.9 Summary","text":"<ul> <li>The Collection Framework is built on a small set of core interfaces.</li> <li>Java 21 adds Sequenced Collections to unify ordering behavior.</li> <li>Maps are not Collections \u2014 they form a parallel hierarchy.</li> <li>Collections rely heavily on generics.</li> <li>Mutability matters \u2014 factory methods often return immutable collections.</li> <li>Performance characteristics are predictable.</li> </ul>"},{"location":"en/module-06/comparing/","title":"24. Comparable, Comparator &amp; Sorting in Java","text":""},{"location":"en/module-06/comparing/#table-of-contents","title":"Table of Contents","text":"<ul> <li>24.1 Comparable \u2014 Natural Ordering<ul> <li>24.1.1 Comparable Method Contract</li> <li>24.1.2 Example Class Implementing Comparable</li> <li>24.1.3 Common Comparable Pitfalls</li> </ul> </li> <li>24.2 Comparator \u2014 Custom Ordering<ul> <li>24.2.1 Comparator Core Methods<ul> <li>24.2.1.1 Comparator Helper Static Methods</li> <li>24.2.1.2 Instance Methods on Comparator</li> </ul> </li> <li>24.2.2 Comparator Example</li> </ul> </li> <li>24.3 Comparable vs Comparator</li> <li>24.4 Sorting Arrays and Collections<ul> <li>24.4.1 Arrays sort</li> <li>24.4.2 Collections sort</li> </ul> </li> <li>24.5 Multi-Level Sorting thenComparing</li> <li>24.6 Comparing Primitives Efficiently</li> <li>24.7 Common Traps</li> <li>24.8 Full Example</li> <li>24.9 Summary</li> </ul> <p>Java provides two main strategies for sorting and comparing: <code>Comparable</code> (natural ordering) and <code>Comparator</code> (custom ordering).</p> <p>Understanding their rules, constraints, and interactions with <code>generics</code> is essential.</p> <ul> <li>For numeric types, sorting follows natural numerical order, meaning smaller values come before larger ones.</li> <li>Sorting strings follows lexicographical (Unicode code point) order: character-by-character comparison; digits come before uppercase, uppercase before lowercase.</li> </ul> <p>This ordering is based on each character\u2019s Unicode code point, not alphabetical intuition.</p> <p>A Unicode code point is a unique numerical value assigned to a character in the Unicode standard.</p> <p>More precisely: a <code>Unicode code point</code> is an integer (written in hexadecimal as U+XXXX) that represents a specific character, symbol, or control mark\u2014independent of font, language, or platform.</p> <ul> <li>Examples:<ul> <li>U+0041 \u2192 A</li> <li>U+0061 \u2192 a</li> <li>U+0030 \u2192 0</li> <li>U+1F600 \u2192 \ud83d\ude00</li> </ul> </li> </ul> <p>A code point is not a byte sequence. It\u2019s an abstract number.</p> <p>How a code point is stored in memory depends on the encoding (UTF-8, UTF-16, UTF-32).</p> <p>Unicode defines code points from U+0000 to U+10FFFF.</p> <p>In short: Unicode code points define what the character is; encodings define how it is represented in bytes.</p> <ul> <li>Example natural ordering</li> </ul> <pre><code>List&lt;String&gt; items = List.of(\"10\", \"2\", \"A\", \"Z\", \"a\", \"b\");\n\nList&lt;String&gt; sorted = new ArrayList&lt;&gt;(items);\nCollections.sort(sorted);\n\nSystem.out.println(sorted);\n</code></pre> <p>Output:</p> <pre><code>[10, 2, A, Z, a, b]\n</code></pre> <p>Note</p> <p>Natural ordering is only defined for types that implement Comparable.</p> <p></p>"},{"location":"en/module-06/comparing/#241-comparable-natural-ordering","title":"24.1 Comparable \u2014 Natural Ordering","text":"<p>The interface <code>Comparable&lt;T&gt;</code> defines the natural order of a type.</p> <p>A class implements it when it wants to define its default sorting rule.</p> <p></p>"},{"location":"en/module-06/comparing/#2411-comparable-method-contract","title":"24.1.1 Comparable Method Contract","text":"<pre><code>public interface Comparable&lt;T&gt; {\n    int compareTo(T other);\n}\n</code></pre> <p>Rules and expectations:</p> <ul> <li>Return negative \u2192 <code>this</code> &lt; <code>other</code></li> <li>Return zero \u2192 <code>this</code> == <code>other</code></li> <li>Return positive \u2192 <code>this</code> &gt; <code>other</code></li> </ul> <p>Important</p> <ul> <li>Natural ordering must be consistent with <code>equals()</code>, unless explicitly documented otherwise:</li> <li><code>compareTo()</code> is consistent with <code>equals()</code> if, and only if, <code>a.compareTo(b) == 0</code> and <code>a.equals(b) is true</code>.</li> </ul> <p>Warning</p> <p>compareTo may throw ClassCastException if given a non-comparable type \u2014 but this usually appears only with raw types.</p> <p></p>"},{"location":"en/module-06/comparing/#2412-example-class-implementing-comparable","title":"24.1.2 Example: Class Implementing Comparable","text":"<pre><code>public class Person implements Comparable&lt;Person&gt; {\n\n    private String name;\n    private int age;\n\n    public Person(String n, int a) {\n        this.name = n;\n        this.age = a;\n    }\n\n    @Override\n    public int compareTo(Person other) {\n        return Integer.compare(this.age, other.age);\n    }\n\n\n}\n\nvar list = List.of(new Person(\"Bob\", 40), new Person(\"Alice\", 30));\n\nlist.stream().sorted().forEach(p -&gt; System.out.println(p.getAge()));\n</code></pre> <p>The list sorts by age, because that is the natural numbering order.</p> <p></p>"},{"location":"en/module-06/comparing/#2413-common-comparable-pitfalls","title":"24.1.3 Common Comparable Pitfalls","text":"<ul> <li>Compare all relevant fields \u2192 inconsistent results if not</li> <li>Violating transitivity \u2192 leads to undefined behavior</li> <li>Throwing exceptions inside compareTo() breaks sorting</li> <li>Failing to implement the same logic as equals() \u2192 common trap</li> </ul>"},{"location":"en/module-06/comparing/#242-comparator-custom-ordering","title":"24.2 Comparator \u2014 Custom Ordering","text":"<p>The interface <code>Comparator&lt;T&gt;</code> allows defining multiple sorting strategies without modifying the class itself.</p> <p></p>"},{"location":"en/module-06/comparing/#2421-comparator-core-methods","title":"24.2.1 Comparator Core Methods","text":"<pre><code>int compare(T a, T b);\n</code></pre> <p>Additional helper methods:</p> <p></p>"},{"location":"en/module-06/comparing/#24211-comparator-helper-static-methods","title":"24.2.1.1 Comparator Helper Static Methods","text":"Method Static / Instance Return Type Parameters Description <code>Comparator.comparing(keyExtractor)</code> static Comparator Function&lt;? super T, ? extends U&gt; Builds a comparator comparing extracted keys using natural ordering. <code>Comparator.comparing(keyExtractor, keyComparator)</code> static Comparator Function, Comparator Builds comparator comparing extracted keys using a custom comparator. <code>Comparator.comparingInt(keyExtractor)</code> static Comparator ToIntFunction Optimized comparator for int keys (avoids boxing). <code>Comparator.comparingLong(keyExtractor)</code> static Comparator ToLongFunction Optimized comparator for long keys. <code>Comparator.comparingDouble(keyExtractor)</code> static Comparator ToDoubleFunction Optimized comparator for double keys. <code>Comparator.naturalOrder()</code> static Comparator none Comparator using natural ordering (Comparable). <code>Comparator.reverseOrder()</code> static Comparator none Reverse natural ordering. <code>Comparator.nullsFirst(comparator)</code> static Comparator Comparator Wraps comparator so nulls compare before non-nulls. <code>Comparator.nullsLast(comparator)</code> static Comparator Comparator Wraps comparator so nulls compare after non-nulls."},{"location":"en/module-06/comparing/#24212-instance-methods-on-comparator","title":"24.2.1.2 Instance Methods on Comparator","text":"Method Static / Instance Return Type Parameters Description <code>thenComparing(otherComparator)</code> instance Comparator Comparator Adds a secondary comparator when the primary compares equal. <code>thenComparing(keyExtractor)</code> instance Comparator Function Secondary comparison using natural ordering of extracted key. <code>thenComparing(keyExtractor, keyComparator)</code> instance Comparator Function, Comparator Secondary comparison with custom comparator. <code>thenComparingInt(keyExtractor)</code> instance Comparator ToIntFunction Secondary numeric comparison (optimized). <code>thenComparingLong(keyExtractor)</code> instance Comparator ToLongFunction Secondary numeric comparison. <code>thenComparingDouble(keyExtractor)</code> instance Comparator ToDoubleFunction Secondary numeric comparison. <code>reversed()</code> instance Comparator none Returns a reversed comparator for the same comparison logic."},{"location":"en/module-06/comparing/#2422-comparator-example","title":"24.2.2 Comparator Example","text":"<pre><code>var people = List.of(new Person(\"Bob\",40), new Person(\"Ann\",30));\n\nComparator&lt;Person&gt; byName = Comparator.comparing(Person::getName);\n\nComparator&lt;Person&gt; byAgeDesc = Comparator.comparingInt(Person::getAge).reversed();\n\nvar sorted = people.stream().sorted(byName.thenComparing(byAgeDesc)).toList();\n</code></pre>"},{"location":"en/module-06/comparing/#243-comparable-vs-comparator","title":"24.3 Comparable vs Comparator","text":"Feature Comparable Comparator Package java.lang java.util Method compareTo(T) compare(T,T) Sorting Type Natural (default) Custom (multiple strategies) Modifies Source Class YES NO Useful For Default ordering External or alternate ordering Allows Multiple Orders NO YES Used By Collections.sort YES YES Used By Arrays.sort YES YES"},{"location":"en/module-06/comparing/#244-sorting-arrays-and-collections","title":"24.4 Sorting Arrays and Collections","text":""},{"location":"en/module-06/comparing/#2441-arrays-sort","title":"24.4.1 Arrays sort()","text":"<pre><code>int[] nums = {3,1,2};\nArrays.sort(nums); // natural order\n\nPerson[] arr = {...};\nArrays.sort(arr); // Person must implement Comparable\nArrays.sort(arr, byName); // using Comparator\n</code></pre>"},{"location":"en/module-06/comparing/#2442-collections-sort","title":"24.4.2 Collections sort()","text":"<pre><code>Collections.sort(list); // natural order\nCollections.sort(list, byName); // comparator\n</code></pre> <p>Note</p> <p>Collections.sort(list) delegates to list.sort(comparator) since Java 8.</p> <p></p>"},{"location":"en/module-06/comparing/#245-multi-level-sorting-thencomparing","title":"24.5 Multi-Level Sorting (thenComparing)","text":"<pre><code>var cmp = Comparator\n    .comparing(Person::getLastName)\n        .thenComparing(Person::getFirstName)\n            .thenComparingInt(Person::getAge);\n</code></pre>"},{"location":"en/module-06/comparing/#246-comparing-primitives-efficiently","title":"24.6 Comparing Primitives Efficiently","text":"<pre><code>Comparator.comparingInt(Person::getAge)\nComparator.comparingLong(...)\nComparator.comparingDouble(...)\n</code></pre> <p>Note</p> <p>These avoid boxing and are preferred in performance-sensitive code.</p> <p></p>"},{"location":"en/module-06/comparing/#247-common-traps","title":"24.7 Common Traps","text":"<ul> <li>Sorting a list of Objects without Comparable \u2192 runtime ClassCastException</li> <li>compareTo inconsistent with equals \u2192 unpredictable behavior</li> <li>Comparator that breaks transitivity \u2192 sorting becomes undefined</li> <li>Null elements \u2192 unless Comparator handles them, sorting throws NPE</li> <li>Comparator comparing fields of mixed types \u2192 ClassCastException</li> <li>Using subtraction to compare ints can overflow \u2192 always use <code>Integer.compare()</code></li> <li>Sorting a list with null elements and natural order \u2192 NPE</li> <li>compareTo must never return inconsistent negative/zero/positive on same two objects (no randomness)</li> </ul>"},{"location":"en/module-06/comparing/#248-full-example","title":"24.8 Full Example","text":"<pre><code>record Book(String title, double price, int year) {}\n\nvar books = List.of(\nnew Book(\"Java 17\", 40.0, 2021),\nnew Book(\"Algorithms\", 55.0, 2019),\nnew Book(\"Java 21\", 42.0, 2023)\n);\n\nComparator&lt;Book&gt; cmp =\nComparator\n    .comparingDouble(Book::price)\n        .thenComparing(Book::year)\n            .reversed();\n\nbooks.stream().sorted(cmp)\n    .forEach(System.out::println);\n</code></pre> <p>Note</p> <p><code>reversed()</code> applies to the entire composed comparator, not just the first comparison key.</p> <p></p>"},{"location":"en/module-06/comparing/#249-summary","title":"24.9 Summary","text":"<ul> <li>Use <code>Comparable</code> for natural ordering (1 default order).</li> <li>Use <code>Comparator</code> for flexible or multiple sorting strategies.</li> <li>Comparators can compose (reversed, thenComparing).</li> <li>Sorting requires consistent comparison logic.</li> <li>Arrays.sort and Collections.sort use both Comparable and Comparator.</li> </ul>"},{"location":"en/module-06/list-api/","title":"25. The List API","text":""},{"location":"en/module-06/list-api/#table-of-contents","title":"Table of Contents","text":"<ul> <li>25.1 Characteristics of Lists</li> <li>25.2 Creating Lists Constructors<ul> <li>25.2.1 ArrayList Constructors</li> <li>25.2.2 LinkedList Constructors</li> </ul> </li> <li>25.3 Factory Methods<ul> <li>25.3.1 List of immutable</li> <li>25.3.2 List copyOf immutable-copy</li> <li>25.3.3 Arrays asList fixed-size-list</li> </ul> </li> <li>25.4 Core List Operations<ul> <li>25.4.1 Adding Elements</li> <li>25.4.2 Accessing Elements</li> <li>25.4.3 Removing Elements</li> <li>25.4.4 Important Behaviors and Characteristics</li> </ul> </li> <li>25.5 contains, equals and hashCode<ul> <li>25.5.1 contains</li> <li>25.5.2 Equality of Lists</li> <li>25.5.3 hashCode</li> </ul> </li> <li>25.6 Iterating Through a List<ul> <li>25.6.1 Classic For Loop</li> <li>25.6.2 Enhanced For Loop</li> <li>25.6.3 Iterator--ListIterator</li> </ul> </li> <li>25.7 The subList Method<ul> <li>25.7.1 Syntax</li> <li>25.7.2 Rules</li> <li>25.7.3 Examples</li> <li>25.7.4 Modifying the parent list invalidates the view</li> <li>25.7.5 Modifying the subList modifies the parent</li> <li>25.7.6 Clearing the subList clears part of the parent list</li> <li>25.7.7 Common Pitfalls</li> </ul> </li> <li>25.8 Summary Table of Important Operations</li> </ul> <p>In the <code>Collections Framework</code>, a List represents an ordered, index-based, duplicate-allowing collection.</p> <p>The List interface extends <code>Collection</code> and is implemented by:</p> <pre><code>List\n\u251c\u2500\u2500 ArrayList (Resizable array \u2014 fast random access, slower inserts/removals in the middle)\n\u251c\u2500\u2500 LinkedList (Doubly-linked list \u2014 fast inserts/removals, slower random access)\n\u2514\u2500\u2500 Vector (Legacy synchronized list \u2014 rarely used today)\n</code></pre> <p>Note</p> <p>Vector is legacy and synchronized \u2014 avoid unless explicitly required.</p> <p></p>"},{"location":"en/module-06/list-api/#251-characteristics-of-lists","title":"25.1 Characteristics of Lists","text":"<ul> <li>Ordered \u2014 elements preserve insertion order.</li> <li>Indexed \u2014 accessible via <code>get(int)</code> and <code>set(int,E)</code>.</li> <li>Allow duplicates \u2014 <code>List</code> does not enforce uniqueness.</li> <li>Can contain <code>null</code> \u2014 unless using special implementations.</li> </ul>"},{"location":"en/module-06/list-api/#252-creating-lists-constructors","title":"25.2 Creating Lists (Constructors)","text":""},{"location":"en/module-06/list-api/#2521-arraylist-constructors","title":"25.2.1 ArrayList Constructors","text":"<pre><code>List&lt;String&gt; a1 = new ArrayList&lt;&gt;();\nList&lt;String&gt; a2 = new ArrayList&lt;&gt;(50); // initial capacity\nList&lt;String&gt; a3 = new ArrayList&lt;&gt;(List.of(\"A\", \"B\"));\n</code></pre> <p>Note</p> <p>Initial capacity is not a size. It just decides how many elements the internal array can hold before resizing.</p> <p></p>"},{"location":"en/module-06/list-api/#2522-linkedlist-constructors","title":"25.2.2 LinkedList Constructors","text":"<pre><code>List&lt;String&gt; l1 = new LinkedList&lt;&gt;();\nList&lt;String&gt; l2 = new LinkedList&lt;&gt;(List.of(\"A\", \"B\"));\n</code></pre> <p>Note</p> <p><code>LinkedList</code> also implements <code>Deque</code>.</p> <p></p>"},{"location":"en/module-06/list-api/#253-factory-methods","title":"25.3 Factory Methods","text":""},{"location":"en/module-06/list-api/#2531-listof-immutable","title":"25.3.1 <code>List.of()</code> (immutable)","text":"<pre><code>List&lt;String&gt; list1 = List.of(\"A\", \"B\", \"C\");\nlist1.add(\"X\"); // \u274c UnsupportedOperationException\nlist1.set(0, \"Z\"); // \u274c UnsupportedOperationException\n</code></pre> <p>Note</p> <p>All <code>List.of()</code> lists: - reject <code>nulls</code> - are immutable - throw <code>UOE</code> on structural modification</p> <p></p>"},{"location":"en/module-06/list-api/#2532-listcopyof-immutable-copy","title":"25.3.2 <code>List.copyOf()</code> (immutable copy)","text":"<pre><code>List&lt;String&gt; src = new ArrayList&lt;&gt;();\nsrc.add(\"Hello\");\n\nList&lt;String&gt; copy = List.copyOf(src); // immutable snapshot\n</code></pre>"},{"location":"en/module-06/list-api/#2533-arraysaslist-fixed-size-list","title":"25.3.3 Arrays.asList() (fixed-size list)","text":"<pre><code>String[] arr = {\"A\", \"B\"};\nList&lt;String&gt; list = Arrays.asList(arr);\n\nlist.set(0, \"Z\"); // OK\nlist.add(\"X\"); // \u274c UOE \u2014 size is fixed\n</code></pre> <p>Note</p> <p>The list is backed by the array: modifying one affects the other.</p> <p></p>"},{"location":"en/module-06/list-api/#254-core-list-operations","title":"25.4 Core List Operations","text":""},{"location":"en/module-06/list-api/#2541-adding-elements","title":"25.4.1 Adding Elements","text":"<pre><code>list.add(\"A\");\nlist.add(1, \"B\"); // insert at index\nlist.addAll(otherList);\nlist.addAll(2, otherList);\n</code></pre>"},{"location":"en/module-06/list-api/#2542-accessing-elements","title":"25.4.2 Accessing Elements","text":"<pre><code>String x = list.get(0);\nlist.set(1, \"NewValue\");\n</code></pre> <p>Note</p> <p><code>get()</code> throws <code>IndexOutOfBoundsException</code> for invalid indices.</p> <p>If you try to <code>update</code> an element in an empty List, even at index 0, you get an <code>IndexOutOfBoundsException</code></p> <pre><code>List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\nlist.add(3);\nlist.add(5);\nSystem.out.println(list.toString());\nlist.clear();\nlist.set(0, 2);\n</code></pre> <p>Output</p> <pre><code>[3, 5]\nException in thread \"main\" java.lang.IndexOutOfBoundsException: Index 0 out of bounds for length 0\n</code></pre> <p>Warning</p> <p>Calling get/set with an invalid index throws IndexOutOfBoundsException</p> <p></p>"},{"location":"en/module-06/list-api/#2543-removing-elements","title":"25.4.3 Removing Elements","text":"<pre><code>list.remove(0); // remove(int index) \u2014 removes by index;  remove(Object) \u2014 removes first equal element\nlist.remove(\"A\"); // removes first occurrence\nlist.removeIf(s -&gt; s.startsWith(\"X\"));\nlist.clear();\n</code></pre>"},{"location":"en/module-06/list-api/#2544-important-behaviors-and-characteristics","title":"25.4.4 Important Behaviors and Characteristics","text":"Operation Behavior Exception(s) <code>add(E)</code> always appends \u2014 <code>add(int,E)</code> shifts elements right IndexOutOfBoundsException <code>get(int)</code> constant-time for ArrayList, linear for LinkedList IndexOutOfBoundsException <code>set(int,E)</code> replaces element IndexOutOfBoundsException <code>remove(int)</code> shifts elements left IndexOutOfBoundsException <code>remove(Object)</code> removes first equal element \u2014"},{"location":"en/module-06/list-api/#255-contains-equals-and-hashcode","title":"25.5 <code>contains()</code>, <code>equals()</code>, and <code>hashCode()</code>","text":""},{"location":"en/module-06/list-api/#2551-contains","title":"25.5.1 <code>contains()</code>","text":"<p>Method <code>contains()</code> uses <code>.equals()</code> on elements.</p> <p></p>"},{"location":"en/module-06/list-api/#2552-equality-of-lists","title":"25.5.2 Equality of Lists","text":"<p><code>List.equals()</code> performs element-wise comparison in order.</p> <pre><code>List&lt;String&gt; a = List.of(\"A\", \"B\");\nList&lt;String&gt; b = List.of(\"A\", \"B\");\n\nSystem.out.println(a.equals(b)); // true\n</code></pre> <p>Note</p> <ul> <li>Order matters.</li> <li>Type of list does NOT matter.</li> </ul> <p></p>"},{"location":"en/module-06/list-api/#2553-hashcode","title":"25.5.3 <code>hashCode()</code>","text":"<p>Computed based on the contents.</p> <p></p>"},{"location":"en/module-06/list-api/#256-iterating-through-a-list","title":"25.6 Iterating Through a List","text":""},{"location":"en/module-06/list-api/#2561-classic-for-loop","title":"25.6.1 Classic For Loop","text":"<pre><code>for (int i = 0; i &lt; list.size(); i++) {\n    System.out.println(list.get(i));\n}\n</code></pre>"},{"location":"en/module-06/list-api/#2562-enhanced-for-loop","title":"25.6.2 Enhanced For Loop","text":"<pre><code>for (String s : list) {\n    System.out.println(s);\n}\n</code></pre>"},{"location":"en/module-06/list-api/#2563-iterator-listiterator","title":"25.6.3 Iterator &amp; ListIterator","text":"<pre><code>Iterator&lt;String&gt; it = list.iterator();\nwhile (it.hasNext()) { System.out.println(it.next()); }\n\nListIterator&lt;String&gt; lit = list.listIterator();\nwhile (lit.hasNext()) {\n    if (lit.next().equals(\"A\")) lit.set(\"Z\");\n}\n</code></pre> <p>Warning</p> <p>All standard List iterators are fail-fast: structural modification outside iterator causes ConcurrentModificationException.</p> <p>Note</p> <p>Only <code>ListIterator</code> supports bidirectional traversal and modification.</p> <p></p>"},{"location":"en/module-06/list-api/#257-the-sublist-method","title":"25.7 The <code>subList()</code> Method","text":"<p><code>subList()</code> creates a view of a portion of the list, not a copy. Modifying either list can modify the other.</p> <p></p>"},{"location":"en/module-06/list-api/#2571-syntax","title":"25.7.1 Syntax","text":"<pre><code>List&lt;E&gt; subList(int fromIndex, int toIndex);\n</code></pre>"},{"location":"en/module-06/list-api/#2572-rules","title":"25.7.2 Rules","text":"Rule Explanation fromIndex inclusive element at fromIndex is included toIndex exclusive element at toIndex is NOT included The view is backed by original list modifying one modifies the other Structural modification of parent invalidates the subList \u2192 ConcurrentModificationException"},{"location":"en/module-06/list-api/#2573-examples","title":"25.7.3 Examples","text":"<pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;(List.of(\"A\", \"B\", \"C\", \"D\"));\nList&lt;String&gt; view = list.subList(1, 3);\n// view = [\"B\", \"C\"]\n\nview.set(0, \"X\");\n// list = [\"A\", \"X\", \"C\", \"D\"]\n// view = [\"X\", \"C\"]\n</code></pre>"},{"location":"en/module-06/list-api/#2574-modifying-the-parent-list-invalidates-the-view","title":"25.7.4 Modifying the parent list invalidates the view","text":"<pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;(List.of(\"A\",\"B\",\"C\",\"D\"));\nList&lt;String&gt; view = list.subList(1, 3);\n\nlist.add(\"E\"); // structural change to parent list\n\nview.get(0); // \u274c ConcurrentModificationException\n</code></pre>"},{"location":"en/module-06/list-api/#2575-modifying-the-sublist-modifies-the-parent","title":"25.7.5 Modifying the subList modifies the parent","text":"<pre><code>view.remove(1);\n// removes \"C\" from both view and parent list\n</code></pre>"},{"location":"en/module-06/list-api/#2576-clearing-the-sublist-clears-part-of-the-parent-list","title":"25.7.6 Clearing the subList clears part of the parent list","text":"<pre><code>view.clear();\n// removes indices 1 and 2 from the parent\n</code></pre>"},{"location":"en/module-06/list-api/#2577-common-pitfalls","title":"25.7.7 Common Pitfalls","text":"<ul> <li>Assuming subList is independent:  it is a view, not a copy</li> <li>Assuming subList allows resizing: works only on modifiable parent lists.</li> <li>Forgetting that parent modifications invalidate results in ConcurrentModificationException</li> <li>Incorrect index expectations: End index is exclusive</li> </ul>"},{"location":"en/module-06/list-api/#258-summary-table-of-important-operations","title":"25.8 Summary Table of Important Operations","text":"Operation ArrayList LinkedList Immutable Lists <code>add(E)</code> fast fast \u274c unsupported <code>add(index,E)</code> slow (shift) fast \u274c <code>get(index)</code> fast slow fast <code>remove(index)</code> slow slow (unless removing first/last) \u274c <code>remove(Object)</code> slower slower \u274c <code>set(index,E)</code> fast slow \u274c <code>iterator()</code> fast fast fast <code>listIterator()</code> fast fast fast <code>contains(Object)</code> O(n) O(n) O(n)"},{"location":"en/module-06/map-api/","title":"28. Map API","text":""},{"location":"en/module-06/map-api/#table-of-contents","title":"Table of Contents","text":"<ul> <li>28.1 Core Map Characteristics</li> <li>28.2 Main Map Implementations</li> <li>28.3 Creating Maps</li> <li>28.4 Basic Map Operations</li> <li>28.5 Iterating Over a Map</li> <li>28.6 Determining Equality in Maps</li> <li>28.7 Special Behavior of TreeMap</li> <li>28.8 Null Handling</li> <li>28.9 Common Pitfalls</li> <li>28.10 Summary</li> </ul> <p>The <code>Map</code> interface represents a collection of key\u2013value pairs, where each key maps to at most one value.</p> <p>Unlike other collection types, <code>Map</code> does not extend <code>Collection</code> and therefore has its own hierarchy and rules.</p> <p></p>"},{"location":"en/module-06/map-api/#281-core-map-characteristics","title":"28.1 Core Map Characteristics","text":"<ul> <li>Each key is unique; duplicate keys overwrite the previous value</li> <li>Values may be duplicated</li> <li>Maps do not support positional (index-based) access</li> <li>Iteration is performed over <code>keySet()</code>, <code>values()</code>, or <code>entrySet()</code></li> </ul> <p>Note</p> <p>A <code>Map</code> is not a <code>Collection</code>, but its views (keySet, values, entrySet) are collections.</p> <p></p>"},{"location":"en/module-06/map-api/#282-main-map-implementations","title":"28.2 Main Map Implementations","text":"Implementation Ordering Null Keys Null Values Thread-Safe Notes <code>HashMap</code> No ordering 1 Many No Fast, most common <code>LinkedHashMap</code> Insertion order 1 Many No Predictable iteration <code>TreeMap</code> Sorted by key No Many No Keys must be comparable <code>Hashtable</code> No ordering No No Yes Legacy <code>ConcurrentHashMap</code> No ordering No No Yes Concurrent-friendly <p>Note</p> <p><code>TreeMap</code> ordering is determined either by <code>Comparable</code> or by a <code>Comparator</code> provided at construction.</p> <p></p>"},{"location":"en/module-06/map-api/#283-creating-maps","title":"28.3 Creating Maps","text":"<p><code>Maps</code> can be created using constructors or factory methods.</p> <pre><code>Map&lt;String, Integer&gt; map1 = new HashMap&lt;&gt;();\nMap&lt;String, Integer&gt; map2 = new LinkedHashMap&lt;&gt;();\nMap&lt;String, Integer&gt; map3 = new TreeMap&lt;&gt;();\n\nMap&lt;String, Integer&gt; map4 = Map.of(\"A\", 1, \"B\", 2);\nMap&lt;String, Integer&gt; map5 = Map.ofEntries(\n    Map.entry(\"X\", 10),\n    Map.entry(\"Y\", 20)\n);\n</code></pre> <p>Note</p> <p>Maps created with <code>Map.of(...)</code> and <code>Map.ofEntries(...)</code> are immutable. Any modification attempt throws <code>UnsupportedOperationException</code>.</p> <p></p>"},{"location":"en/module-06/map-api/#284-basic-map-operations","title":"28.4 Basic Map Operations","text":"Method Description Return <code>put(k, v)</code> Adds or replaces a mapping Return prev. value or null <code>putIfAbsent(k,v)</code> Adds only if key not present Returns existing or null <code>get(k)</code> Returns value or null Return specific value or null <code>getOrDefault(k, default)</code> Returns value or default Return specific value or default <code>remove(k)</code> Removes mapping Remove and return specific value or null <code>containsKey(k)</code> Checks key presence boolean <code>containsValue(v)</code> Checks value presence boolean <code>size()</code> Number of entries int <code>isEmpty()</code> Empty check boolean <code>clear()</code> Removes all entries void <code>V merge(k, v, BiFunction(V, V, V))</code> merge(k, v, remappingFunction) if key absent \u2192 sets value; if key present \u2192 function(oldValue, newValue); if function returns null \u2192 mapping removed <pre><code>Map&lt;String, String&gt; map = new HashMap&lt;&gt;();\nmap.put(\"A\", \"Apple\");\nmap.put(\"B\", \"Banana\");\n\nmap.put(\"A\", \"Avocado\"); // overwrites value\n\nString v = map.get(\"B\"); // Banana\n</code></pre>"},{"location":"en/module-06/map-api/#285-iterating-over-a-map","title":"28.5 Iterating Over a Map","text":"<p>Maps are iterated via views:</p> <ul> <li><code>keySet()</code> \u2192 Set of keys</li> <li><code>values()</code> \u2192 Collection of values</li> <li><code>entrySet()</code> \u2192 Set of Map.Entry</li> </ul> <pre><code>for (String key : map.keySet()) {\n    System.out.println(key);\n}\n\nfor (String value : map.values()) {\n    System.out.println(value);\n}\n\nfor (Map.Entry&lt;String, String&gt; e : map.entrySet()) {\n    System.out.println(e.getKey() + \" = \" + e.getValue());\n}\n</code></pre> <p>Note</p> <p>Modifying the map while iterating over these views may throw <code>ConcurrentModificationException</code> (except for concurrent maps).</p> <p></p>"},{"location":"en/module-06/map-api/#286-determining-equality-in-maps","title":"28.6 Determining Equality in Maps","text":"<p>Map equality is defined as follows:</p> <ul> <li>Two maps are equal if they contain the same key\u2013value mappings</li> <li>Key comparison uses <code>equals()</code></li> <li>Value comparison uses <code>equals()</code></li> </ul> <pre><code>Map&lt;String, Integer&gt; m1 = Map.of(\"A\", 1, \"B\", 2);\nMap&lt;String, Integer&gt; m2 = Map.of(\"B\", 2, \"A\", 1);\n\nSystem.out.println(m1.equals(m2)); // true\n</code></pre> <p>Note</p> <p>Iteration order does not affect map equality.</p> <p></p>"},{"location":"en/module-06/map-api/#287-special-behavior-of-treemap","title":"28.7 Special Behavior of TreeMap","text":"<p>TreeMap maintains entries in sorted order based on keys.</p> <pre><code>Map&lt;Integer, String&gt; tm = new TreeMap&lt;&gt;();\ntm.put(3, \"C\");\ntm.put(1, \"A\");\ntm.put(2, \"B\");\n\nSystem.out.println(tm); // {1=A, 2=B, 3=C}\n</code></pre> <p>Warning</p> <p>All keys in a <code>TreeMap</code> must be mutually comparable. Mixing incompatible types causes <code>ClassCastException</code> at runtime.</p> <p></p>"},{"location":"en/module-06/map-api/#288-null-handling","title":"28.8 Null Handling","text":"Implementation Null Key Null Value HashMap Yes (1) Yes LinkedHashMap Yes (1) Yes TreeMap No Yes Hashtable No No ConcurrentHashMap No No <p>Note</p> <p>TreeMap accepts null values only when they do not participate in key comparison. In practice this is rare, because null keys are banned and comparators may reject nulls.</p> <p>HashMap/LinkedHashMap allow only ONE null key \u2014 inserting another replaces the existing one.</p> <p></p>"},{"location":"en/module-06/map-api/#289-common-pitfalls","title":"28.9 Common Pitfalls","text":"<ul> <li>Assuming Map is a Collection</li> <li>Forgetting that duplicate keys overwrite values</li> <li>Using null keys in TreeMap or ConcurrentHashMap</li> <li>Confusing iteration order with equality</li> <li>Trying to modify immutable maps created via Map.of</li> </ul>"},{"location":"en/module-06/map-api/#2810-summary","title":"28.10 Summary","text":"<ul> <li>Maps store unique keys mapped to values</li> <li>Ordering depends on implementation</li> <li>Equality is based on key\u2013value pairs</li> <li>TreeMap requires comparable keys</li> <li>Immutable maps throw exceptions on modification</li> </ul>"},{"location":"en/module-06/queue-api/","title":"27. Queue &amp; Deque API","text":""},{"location":"en/module-06/queue-api/#table-of-contents","title":"Table of Contents","text":"<ul> <li>27.1 Queue \u2014 Overview<ul> <li>27.1.1 Queue Core Methods</li> <li>27.1.2 Queue Implementations</li> </ul> </li> <li>27.2 Deque \u2014 Overview<ul> <li>27.2.1 Deque Core Methods</li> <li>27.2.2 Deque Implementations</li> </ul> </li> <li>27.3 Using a Queue</li> <li>27.4 Using a Deque as-Queue and as-Stack<ul> <li>27.4.1 FIFO Example Queue-Behavior</li> <li>27.4.2 LIFO Example Stack-Behavior</li> </ul> </li> <li>27.5 PriorityQueue \u2014 Special Queue</li> <li>27.6 Blocking Queues Basics</li> <li>27.7 Common Pitfalls</li> <li>27.8 Summary Table</li> </ul> <p>Java\u2019s <code>Queue</code> and <code>Deque</code> interfaces model ordered collections designed for processing elements in a particular sequence.</p> <p>A Queue typically models a FIFO (First-In, First-Out) structure. A Deque (<code>double-ended queue</code>) allows insertion and removal from both ends, enabling FIFO and LIFO behavior in a single API.</p> <p></p>"},{"location":"en/module-06/queue-api/#271-queue-overview","title":"27.1 Queue \u2014 Overview","text":"<p>The <code>Queue</code> interface extends <code>Collection</code> and is commonly used in asynchronous programming, work distribution, algorithms, and buffering.</p> <p>Two families of methods exist: ones that throw exceptions and ones that return special values (usually <code>null</code>).</p> <p></p>"},{"location":"en/module-06/queue-api/#2711-queue-core-methods","title":"27.1.1 Queue Core Methods","text":"Operation Throws Exception Returns Special Value Description Insert <code>add(e)</code> <code>offer(e)</code> Adds an element; offer preferred for bounded queues Remove <code>E remove()</code> <code>E poll()</code> Removes and returns head. <code>remove()</code> throws NoSuchElementException if queue is empty, <code>poll()</code> returns null Read <code>E element()</code> <code>E peek()</code> Returns head without removing. <code>element()</code> throws NoSuchElementException if queue is empty, <code>peek()</code> returns null"},{"location":"en/module-06/queue-api/#2712-queue-implementations","title":"27.1.2 Queue Implementations","text":"<p>Common classes implementing <code>Queue</code>:</p> <ul> <li><code>LinkedList</code> \u2014 unbounded, also implements <code>Deque</code> and <code>List</code>.</li> <li><code>ArrayDeque</code> \u2014 fast, resizable array-based queue; cannot store <code>null</code>.</li> <li><code>PriorityQueue</code> \u2014 orders elements by natural order or comparator; not FIFO.</li> <li><code>ConcurrentLinkedQueue</code> \u2014 thread-safe, lock-free.</li> </ul> <p>Note</p> <p><code>PriorityQueue</code> does not guarantee traversal order matching priority sorting.</p> <p>Warning</p> <p>Most Queue implementations reject <code>null</code> because <code>null</code> is used as a return value for \u201cempty\u201d.</p> <p></p>"},{"location":"en/module-06/queue-api/#272-deque-overview","title":"27.2 Deque \u2014 Overview","text":"<p><code>Deque</code> (double-ended queue) supports insertion, removal, and inspection from both the head and the tail.</p> <p>It is more versatile than a Queue: - FIFO (queue-like) - LIFO (stack-like) - Bidirectional algorithms</p> <p></p>"},{"location":"en/module-06/queue-api/#2721-deque-core-methods","title":"27.2.1 Deque Core Methods","text":"Operation Front End Insert addFirst(e), offerFirst(e) addLast(e), offerLast(e) Remove removeFirst(), pollFirst() removeLast(), pollLast() Examine getFirst(), peekFirst() getLast(), peekLast()"},{"location":"en/module-06/queue-api/#2722-deque-implementations","title":"27.2.2 Deque Implementations","text":"<ul> <li><code>ArrayDeque</code> \u2014 recommended general-purpose implementation (fast, no capacity limit).</li> <li><code>LinkedList</code> \u2014 full-featured but slower due to node-based structure.</li> <li><code>ConcurrentLinkedDeque</code> \u2014 non-blocking concurrent deque.</li> </ul> <p>Note</p> <p><code>Stack</code> is legacy; use <code>Deque</code> for stack behavior (push/pop). ArrayDeque, LinkedList queue operations (add/remove/peek) are O(1) amortized</p> <p></p>"},{"location":"en/module-06/queue-api/#273-using-a-queue","title":"27.3 Using a Queue","text":"<pre><code>Queue&lt;String&gt; q = new LinkedList&lt;&gt;();\n\nq.offer(\"A\");\nq.offer(\"B\");\nq.offer(\"C\");\n\nSystem.out.println(q.peek());   // A\nSystem.out.println(q.poll());   // A\nSystem.out.println(q.poll());   // B\nSystem.out.println(q.poll());   // C\nSystem.out.println(q.poll());   // null (empty queue)\n</code></pre>"},{"location":"en/module-06/queue-api/#274-using-a-deque-as-queue-and-as-stack","title":"27.4 Using a Deque (as Queue and as Stack)","text":""},{"location":"en/module-06/queue-api/#2741-fifo-example-queue-behavior","title":"27.4.1 FIFO Example (Queue Behavior)","text":"<pre><code>Deque&lt;String&gt; dq = new ArrayDeque&lt;&gt;();\n\ndq.offerLast(\"A\"); // enqueue\ndq.offerLast(\"B\");\ndq.offerLast(\"C\");\n\nSystem.out.println(dq.pollFirst()); // A\nSystem.out.println(dq.pollFirst()); // B\nSystem.out.println(dq.pollFirst()); // C\n</code></pre>"},{"location":"en/module-06/queue-api/#2742-lifo-example-stack-behavior","title":"27.4.2 LIFO Example (Stack Behavior)","text":"<pre><code>Deque&lt;String&gt; stack = new ArrayDeque&lt;&gt;();\n\nstack.push(\"A\");\nstack.push(\"B\");\nstack.push(\"C\");\n\nSystem.out.println(stack.pop()); // C\nSystem.out.println(stack.pop()); // B\nSystem.out.println(stack.pop()); // A\n</code></pre>"},{"location":"en/module-06/queue-api/#275-priorityqueue-special-queue","title":"27.5 PriorityQueue \u2014 Special Queue","text":"<p><code>PriorityQueue</code> orders elements by natural order or by a provided <code>Comparator</code>.</p> <p>Important characteristics:</p> <ul> <li>Not FIFO \u2014 head is the \u201csmallest\u201d element.</li> <li>Order is only guaranteed during removal, not iteration.</li> <li>Null elements not permitted.</li> </ul> <pre><code>PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;();\n\npq.offer(50);\npq.offer(10);\npq.offer(30);\n\nSystem.out.println(pq.poll()); // 10\nSystem.out.println(pq.poll()); // 30\nSystem.out.println(pq.poll()); // 50\n</code></pre> <p></p>"},{"location":"en/module-06/queue-api/#276-blocking-queues-basics","title":"27.6 Blocking Queues (Basics)","text":"<p>In concurrent environments, the <code>java.util.concurrent</code> package provides blocking queue types.</p> <ul> <li><code>ArrayBlockingQueue</code> \u2014 fixed-size backing array.</li> <li><code>LinkedBlockingQueue</code> \u2014 optionally bounded.</li> <li><code>PriorityBlockingQueue</code> \u2014 thread-safe priority queue.</li> <li><code>DelayQueue</code> \u2014 elements released after delays.</li> </ul> <p>Note</p> <p>BlockingQueue never allows <code>null</code>. put(e) \u2014 blocks until space available take() \u2014 blocks until element available BlockingQueue also supports timed operations: offer(e, timeout), poll(timeout)</p> <p></p>"},{"location":"en/module-06/queue-api/#277-common-pitfalls","title":"27.7 Common Pitfalls","text":"<ul> <li><code>Queue</code> and <code>Deque</code> methods come in \u201cexception\u201d and \u201cspecial-value\u201d variants \u2014 memorize which is which.</li> <li><code>ArrayDeque</code> cannot store <code>null</code> \u2014 <code>null</code> is used internally.</li> <li><code>PriorityQueue</code> iteration order is NOT sorted.</li> <li>Using <code>Stack</code> is discouraged; use <code>Deque</code> instead.</li> <li>Deque enables both FIFO and LIFO and has the most complete API.</li> </ul>"},{"location":"en/module-06/queue-api/#278-summary-table","title":"27.8 Summary Table","text":"Interface Typical Behavior Null Allowed? Common Implementations Notes Queue FIFO Depends LinkedList, ArrayDeque, PriorityQueue PriorityQueue not FIFO Deque FIFO + LIFO No (ArrayDeque) ArrayDeque, LinkedList Full double-ended operations PriorityQueue Ordered by priority No PriorityQueue Removes smallest element first BlockingQueue Thread-safe FIFO No ArrayBlockingQueue, LinkedBlockingQueue add/offer vs put differences ConcurrentLinkedQueue Lock-free FIFO No ConcurrentLinkedQueue Very fast for multi-threading"},{"location":"en/module-06/sequenced/","title":"29. Sequenced Collections &amp; Sequenced Maps","text":""},{"location":"en/module-06/sequenced/#table-of-contents","title":"Table of Contents","text":"<ul> <li>29.1 Motivation and Background</li> <li>29.2 SequencedCollection Interface<ul> <li>29.2.1 Core Methods of SequencedCollection</li> <li>29.2.2 Implementations of SequencedCollection</li> <li>29.2.3 Reversed Views</li> </ul> </li> <li>29.3 SequencedMap Interface<ul> <li>29.3.1 Core Methods of SequencedMap</li> <li>29.3.2 Implementations of SequencedMap</li> <li>29.3.3 Reversed Maps</li> </ul> </li> <li>29.4 Relationship with Existing APIs<ul> <li>29.4.1 Which Built-in Types Are Sequenced</li> </ul> </li> <li>29.5 Common Pitfalls</li> <li>29.6 Summary</li> </ul> <p>Java 21 introduces <code>Sequenced Collections</code> and <code>Sequenced Maps</code> to unify and formalize access to elements based on their encounter order.</p> <p>This addition solves long-standing inconsistencies between lists, sets, queues, deques, and maps, providing a common API to work with the first and last elements, as well as reversed views.</p> <p></p>"},{"location":"en/module-06/sequenced/#291-motivation-and-background","title":"29.1 Motivation and Background","text":"<p>Before Java 21, ordered collections (such as List, LinkedHashSet, Deque, or LinkedHashMap) exposed ordering operations through different methods or not at all.</p> <p>Developers had to rely on implementation-specific APIs or indirect workarounds.</p> <p>Sequenced interfaces introduce a consistent contract for all ordered collections and maps, making order-based operations explicit, safe, and uniform.</p> <p></p>"},{"location":"en/module-06/sequenced/#292-sequencedcollection-interface","title":"29.2 SequencedCollection Interface","text":"<p><code>SequencedCollection&lt;E&gt;</code> is a new interface that extends Collection and represents collections with a well-defined encounter order. <p>Implemented by <code>List</code>, <code>Deque</code>, and <code>LinkedHashSet</code> (TreeSet is ordered but does not implement SequencedCollection directly).</p> <p></p>"},{"location":"en/module-06/sequenced/#2921-core-methods-of-sequencedcollection","title":"29.2.1 Core Methods of SequencedCollection","text":"<p>The interface defines methods to access and manipulate elements at both ends of the collection.</p> Method Description <code>E getFirst()</code> Returns the first element <code>E getLast()</code> Returns the last element <code>void addFirst(E e)</code> Inserts element at the beginning <code>void addLast(E e)</code> Inserts element at the end <code>E removeFirst()</code> Removes and returns the first element <code>E removeLast()</code> Removes and returns the last element <code>SequencedCollection&lt;E&gt; reversed()</code> Returns a reversed view <p></p>"},{"location":"en/module-06/sequenced/#2922-implementations-of-sequencedcollection","title":"29.2.2 Implementations of SequencedCollection","text":"<p>The following standard types implement SequencedCollection:</p> Type Notes List Ordered by index Deque Double-ended queue LinkedHashSet Maintains insertion order <p></p>"},{"location":"en/module-06/sequenced/#2923-reversed-views","title":"29.2.3 Reversed Views","text":"<p>Calling reversed() does not create a copy.</p> <p>It returns a live view of the same collection with inverted order.</p> <pre><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;(List.of(1, 2, 3));\nSequencedCollection&lt;Integer&gt; rev = list.reversed();\n\nrev.removeFirst(); // removes 3\nSystem.out.println(list); // [1, 2]\n</code></pre> <p>Note</p> <p>Reversed views share the same backing collection. Structural changes in either view affect the other: modifying either the original collection or the reversed view affects the other.</p> <p></p>"},{"location":"en/module-06/sequenced/#293-sequencedmap-interface","title":"29.3 SequencedMap Interface","text":"<p><code>SequencedMap&lt;K,V&gt;</code> extends <code>Map&lt;K,V&gt;</code> and represents maps with a defined encounter order of entries.</p> <p>It standardizes operations that previously existed only in specific implementations such as <code>LinkedHashMap</code>.</p> <p></p>"},{"location":"en/module-06/sequenced/#2931-core-methods-of-sequencedmap","title":"29.3.1 Core Methods of SequencedMap","text":"Method Description <code>Entry&lt;K,V&gt; firstEntry()</code> First map entry <code>Entry&lt;K,V&gt; lastEntry()</code> Last map entry <code>Entry&lt;K,V&gt; pollFirstEntry()</code> Removes and returns the first entry, or null if empty <code>Entry&lt;K,V&gt; pollLastEntry()</code> Removes and returns last entry, or null if empty <code>SequencedMap&lt;K,V&gt; reversed()</code> Reversed view of the map"},{"location":"en/module-06/sequenced/#2932-implementations-of-sequencedmap","title":"29.3.2 Implementations of SequencedMap","text":"<p>Currently, the primary standard implementation is:</p> Type Ordering LinkedHashMap Insertion order (or access order if configured) <p>Note</p> <p>LinkedHashMap can reorder entries on read if constructed with accessOrder=true.</p> <p>In that case, \u201cfirst\u201d and \u201clast\u201d reflect most-recent-access order.</p> <p></p>"},{"location":"en/module-06/sequenced/#2933-reversed-maps","title":"29.3.3 Reversed Maps","text":"<p>As with collections, reversed() on a sequenced map returns a view, not a copy.</p> <pre><code>SequencedMap&lt;String, Integer&gt; map =\nnew LinkedHashMap&lt;&gt;(Map.of(\"A\", 1, \"B\", 2, \"C\", 3));\n\nSequencedMap&lt;String, Integer&gt; rev = map.reversed();\n\nrev.pollFirstEntry(); // removes C=3\nSystem.out.println(map); // {A=1, B=2}\n</code></pre> <p>Note</p> <p>Like SequencedCollection, <code>reversed()</code> returns a live view \u2014 mutations apply to both maps.</p> <p></p>"},{"location":"en/module-06/sequenced/#294-relationship-with-existing-apis","title":"29.4 Relationship with Existing APIs","text":"<p>Sequenced interfaces do not replace existing collection types.</p> <p>They sit above them in the hierarchy and unify common behaviors.</p> <p>All existing ordered collections automatically benefit from these APIs without breaking backward compatibility.</p> <p></p>"},{"location":"en/module-06/sequenced/#2941-which-built-in-types-are-sequenced","title":"29.4.1 Which Built-in Types Are Sequenced?","text":"<p>The following table summarizes whether standard collection types are ordered, and whether they implement the new Sequenced interfaces.</p> Type Ordered? SequencedCollection? SequencedMap? <code>List</code> \u2714 Yes \u2714 Yes \u2718 No <code>Deque</code> \u2714 Yes \u2714 Yes \u2718 No <code>LinkedHashSet</code> \u2714 Yes \u2714 Yes \u2718 No <code>TreeSet</code> \u2714 Yes (sorted) \u2718 No* \u2718 No <code>HashSet</code> \u2718 No \u2718 No \u2718 No <code>LinkedHashMap</code> \u2714 Yes \u2718 No \u2714 Yes <code>HashMap</code> \u2718 No \u2718 No \u2718 No <code>TreeMap</code> \u2714 Yes (sorted) \u2718 No \u2718 No <p>Note</p> <p><code>TreeSet</code> is ordered, but implements <code>SortedSet</code>/<code>NavigableSet</code>, not <code>SequencedCollection</code>.</p> <p></p>"},{"location":"en/module-06/sequenced/#295-common-pitfalls","title":"29.5 Common Pitfalls","text":"<ul> <li>Sequenced interfaces define views, not copies</li> <li><code>reversed()</code> reflects changes bidirectionally</li> <li>Not all Set or Map implementations are sequenced</li> <li>HashSet and HashMap do not implement sequenced interfaces</li> <li>Order is guaranteed only when explicitly defined</li> <li>Removing elements via iterator on reversed view impacts original order immediately.</li> </ul>"},{"location":"en/module-06/sequenced/#296-summary","title":"29.6 Summary","text":"<ul> <li>Sequenced interfaces formalize encounter order</li> <li>They provide first/last access and reversal</li> <li>They work via live views, not copies</li> <li>They unify APIs across lists, deques, sets, and maps</li> </ul>"},{"location":"en/module-06/set-api/","title":"26. Set API","text":""},{"location":"en/module-06/set-api/#table-of-contents","title":"Table of Contents","text":"<ul> <li>26.1 Set Hierarchy Java-Collections-Framework</li> <li>26.2 Characteristics of Each Set Implementation<ul> <li>26.2.1 HashSet</li> <li>26.2.2 LinkedHashSet</li> <li>26.2.3 TreeSet</li> </ul> </li> <li>26.3 Equality Rules in Sets<ul> <li>26.3.1 HashSet--LinkedHashSet</li> <li>26.3.2 TreeSet</li> </ul> </li> <li>26.4 Creating Set Instances<ul> <li>26.4.1 Using Constructors</li> <li>26.4.2 Copy Constructors</li> <li>26.4.3 Factory Methods</li> </ul> </li> <li>26.5 Main Operations on Sets<ul> <li>26.5.1 Adding Elements</li> <li>26.5.2 Checking Membership</li> <li>26.5.3 Removing Elements</li> <li>26.5.4 Bulk Operations</li> </ul> </li> <li>26.6 Common Pitfalls</li> <li>26.7 Summary Table</li> </ul> <p>A Set in Java represents a collection that contains no duplicate elements.  </p> <p>It models the mathematical concept of a <code>set</code>: unordered (unless using an ordered implementation) and composed of unique values.</p> <p>All Set implementations rely on equality semantics (either <code>equals()</code> or <code>comparator</code> logic.</p> <p></p>"},{"location":"en/module-06/set-api/#261-set-hierarchy-java-collections-framework","title":"26.1 Set Hierarchy (Java Collections Framework)","text":"<pre><code>Set&lt;E&gt;\n \u251c\u2500\u2500 SequencedSet&lt;E&gt; (Java 21+)\n \u2502    \u2514\u2500\u2500 LinkedHashSet&lt;E&gt;   (ordered)\n \u251c\u2500\u2500 HashSet&lt;E&gt;              (unordered)\n \u2514\u2500\u2500 SortedSet&lt;E&gt;\n      \u2514\u2500\u2500 NavigableSet&lt;E&gt;\n           \u2514\u2500\u2500 TreeSet&lt;E&gt;    (sorted)\n</code></pre> <p>All <code>Set</code> implementations require: - uniqueness of elements - predictable equality and hashing (depending on implementation)</p> <p>Note</p> <p><code>LinkedHashSet</code> is now formally a <code>SequencedSet</code> since Java 21.</p> <p></p>"},{"location":"en/module-06/set-api/#262-characteristics-of-each-set-implementation","title":"26.2 Characteristics of Each Set Implementation","text":""},{"location":"en/module-06/set-api/#2621-hashset","title":"26.2.1 HashSet","text":"<ul> <li>Fastest general-purpose Set  </li> <li>Unordered (no iteration order guarantee)  </li> <li>Uses <code>hashCode()</code> and <code>equals()</code> </li> <li>Allows one <code>null</code> element  </li> </ul> <pre><code>Set&lt;String&gt; set = new HashSet&lt;&gt;();\nset.add(\"A\");\nset.add(\"B\");\nset.add(\"A\");   // duplicate ignored\nSystem.out.println(set); // order not guaranteed\n</code></pre>"},{"location":"en/module-06/set-api/#2622-linkedhashset","title":"26.2.2 LinkedHashSet","text":"<ul> <li>Maintains insertion order </li> <li>Slightly slower than HashSet  </li> <li>Useful when predictable iteration order is required</li> </ul> <pre><code>Set&lt;String&gt; set = new LinkedHashSet&lt;&gt;();\nset.add(\"A\");\nset.add(\"C\");\nset.add(\"B\");\nSystem.out.println(set);  // [A, C, B]\n</code></pre>"},{"location":"en/module-06/set-api/#2623-treeset","title":"26.2.3 TreeSet","text":"<p>A sorted Set whose order is determined by: 1. Natural ordering (<code>Comparable</code>) 2. A provided <code>Comparator</code> </p> <p>TreeSet: - No <code>null</code> elements allowed (NullPointerException at runtime) - Guarantees sorted iteration - Supports range views: <code>headSet()</code>, <code>tailSet()</code>, <code>subSet()</code> </p> <pre><code>TreeSet&lt;Integer&gt; tree = new TreeSet&lt;&gt;();\ntree.add(10);\ntree.add(1);\ntree.add(5);\n\nSystem.out.println(tree); // [1, 5, 10]\n</code></pre> <p>Note</p> <p><code>TreeSet</code> requires all elements to be mutually comparable \u2014 mixing non-comparable types produces <code>ClassCastException</code>. Operations (add, remove, contains) are O(log n).</p> <p></p>"},{"location":"en/module-06/set-api/#263-equality-rules-in-sets","title":"26.3 Equality Rules in Sets","text":"<p>The rules differ depending on implementation.</p> <p></p>"},{"location":"en/module-06/set-api/#2631-hashset-linkedhashset","title":"26.3.1 HashSet &amp; LinkedHashSet","text":"<p><code>Uniqueness</code> is determined by two methods: - <code>hashCode()</code> - <code>equals()</code> </p> <p>Two objects are considered the same element if:</p> <ol> <li>Their hash codes match  </li> <li>Their <code>equals()</code> method returns <code>true</code> </li> </ol> <p>Warning</p> <p>If you mutate an object after adding it to a HashSet or LinkedHashSet, its hashCode may change and the set may lose track of it.</p> <p></p>"},{"location":"en/module-06/set-api/#2632-treeset","title":"26.3.2 TreeSet","text":"<p>Uniqueness is based on <code>compareTo()</code> or the provided <code>Comparator</code>.  </p> <p>If <code>compare(a, b) == 0</code> then the objects are considered duplicates, even if <code>equals()</code> is false.</p> <pre><code>Comparator&lt;String&gt; comp = (a, b) -&gt; a.length() - b.length();\nSet&lt;String&gt; set = new TreeSet&lt;&gt;(comp);\n\nset.add(\"Hi\");\nset.add(\"Yo\"); // same length \u2192 treated as duplicate\n\nSystem.out.println(set);  // [\"Hi\"]\n</code></pre> <p></p>"},{"location":"en/module-06/set-api/#264-creating-set-instances","title":"26.4 Creating Set Instances","text":""},{"location":"en/module-06/set-api/#2641-using-constructors","title":"26.4.1 Using Constructors","text":"<pre><code>Set&lt;String&gt; s1 = new HashSet&lt;&gt;();\nSet&lt;String&gt; s2 = new LinkedHashSet&lt;&gt;();\nSet&lt;String&gt; s3 = new TreeSet&lt;&gt;();\n</code></pre>"},{"location":"en/module-06/set-api/#2642-copy-constructors","title":"26.4.2 Copy Constructors","text":"<pre><code>List&lt;String&gt; list = List.of(\"A\", \"B\", \"C\");\n\nSet&lt;String&gt; copy = new HashSet&lt;&gt;(list); // order lost\nSystem.out.println(copy);\n\nSet&lt;String&gt; ordered = new LinkedHashSet&lt;&gt;(list); // maintains the order from the list\nSystem.out.println(ordered);\n</code></pre>"},{"location":"en/module-06/set-api/#2643-factory-methods","title":"26.4.3 Factory Methods","text":"<pre><code>Set&lt;String&gt; s1 = Set.of(\"A\", \"B\", \"C\");   // immutable\nSet&lt;String&gt; empty = Set.of();             // empty immutable set\n</code></pre> <p>Note</p> <p>Factory-created sets are immutable: adding or removing elements throws <code>UnsupportedOperationException</code>. <code>Set.of(...)</code> rejects duplicates at creation time \u2192 IllegalArgumentException and rejects null \u2192 NullPointerException</p> <p></p>"},{"location":"en/module-06/set-api/#265-main-operations-on-sets","title":"26.5 Main Operations on Sets","text":""},{"location":"en/module-06/set-api/#2651-adding-elements","title":"26.5.1 Adding Elements","text":"<pre><code>set.add(\"A\");          // returns true if added\nset.add(\"A\");          // returns false if duplicate\n</code></pre>"},{"location":"en/module-06/set-api/#2652-checking-membership","title":"26.5.2 Checking Membership","text":"<pre><code>set.contains(\"A\");\n</code></pre>"},{"location":"en/module-06/set-api/#2653-removing-elements","title":"26.5.3 Removing Elements","text":"<pre><code>set.remove(\"A\");\nset.clear();\n</code></pre>"},{"location":"en/module-06/set-api/#2654-bulk-operations","title":"26.5.4 Bulk Operations","text":"<pre><code>set.addAll(otherSet);\nset.removeAll(otherSet);\nset.retainAll(otherSet); // intersection\n</code></pre>"},{"location":"en/module-06/set-api/#266-common-pitfalls","title":"26.6 Common Pitfalls","text":"<ul> <li>Using TreeSet with non-comparable objects \u2192 <code>ClassCastException</code></li> <li>TreeSet does not use <code>equals()</code> at all: only comparator/compareTo decides uniqueness.</li> <li>Using mutable objects as Set keys \u2192 breaks hashing rules</li> <li>Factory Set.of() is immutable \u2014 modification fails</li> <li>HashSet does not guarantee iteration order</li> <li>TreeSet treats objects with compare()==0 as duplicates even if not equal</li> </ul>"},{"location":"en/module-06/set-api/#267-summary-table","title":"26.7 Summary Table","text":"Implementation Keeps Order? Allows Null? Sorted? Underlying Logic HashSet No Yes (1 null) No hashCode + equals LinkedHashSet Yes (insertion order) Yes (1 null) No hash table + linked list TreeSet Yes (sorted) No Yes (natural/comparator) compareTo / Comparator"},{"location":"en/module-06/shared-operations/","title":"23. Shared Collection Operations &amp; Equality","text":""},{"location":"en/module-06/shared-operations/#table-of-contents","title":"Table of Contents","text":"<ul> <li>23.1 Core Collection Methods Available to Most Collections<ul> <li>23.1.1 Mutating Operations</li> <li>23.1.2 Query Operations</li> </ul> </li> <li>23.2 Equality</li> <li>23.3 Fail-Fast Behavior</li> <li>23.4 Bulk Operations</li> <li>23.5 Common Return Types and Exceptions</li> <li>23.6 Summary Table \u2014 Shared Operations</li> </ul> <p>This chapter covers the fundamental operations shared across the Java Collections API, including how equality is determined inside collections. </p> <p>These concepts apply to all main collection families based on Collection (List, Set, Queue, Deque and their Sequenced variants). <p>Map shares several conceptual behaviors (iteration, equality) but does not inherit Collection.</p> <p>Mastering these operations is essential, as they explain how collections behave when adding, searching, removing, comparing, iterating, and sorting elements.</p> <p></p>"},{"location":"en/module-06/shared-operations/#231-core-collection-methods-available-to-most-collections","title":"23.1 Core Collection Methods (Available to Most Collections)","text":"<p>The following methods come from the <code>Collection&lt;E&gt;</code> interface and are inherited by all major collections except <code>Map</code> (which has its own family of operations).</p> <p>Note</p> <p><code>Map</code> does not implement <code>Collection</code>, but its <code>keySet()</code>, <code>values()</code>, and <code>entrySet()</code> views do, and therefore expose these shared operations.</p> <p></p>"},{"location":"en/module-06/shared-operations/#2311-mutating-operations","title":"23.1.1 Mutating Operations","text":"<ul> <li><code>boolean add(E e)</code> \u2014 Adds an element (allowed to add duplicates in lists).</li> <li><code>boolean remove(Object o)</code> \u2014 Removes the first matching element.</li> <li><code>void clear()</code> \u2014 Removes all elements.</li> <li><code>boolean addAll(Collection&lt;? extends E&gt; c)</code> \u2014 Bulk insertion. </li> <li><code>boolean removeAll(Collection&lt;?&gt; c)</code> \u2014 Removes all elements contained in the given collection.</li> <li><code>boolean retainAll(Collection&lt;?&gt; c)</code> \u2014 Keeps only matching elements.</li> </ul>"},{"location":"en/module-06/shared-operations/#2312-query-operations","title":"23.1.2 Query Operations","text":"<ul> <li><code>int size()</code> \u2014 Number of elements.</li> <li><code>boolean isEmpty()</code> \u2014 Whether collection contains zero elements.</li> <li><code>boolean contains(Object o)</code> \u2014 Relies on element equality rules.</li> <li><code>Iterator&lt;E&gt; iterator()</code> \u2014 Returns an iterator (fail-fast).</li> <li><code>Object[] toArray()</code> and <code>&lt;T&gt; T[] toArray(T[] a)</code> \u2014 Copy into an array.</li> </ul>"},{"location":"en/module-06/shared-operations/#232-equality","title":"23.2 Equality","text":"<p>A custom implementation of the method <code>equals()</code> allows us to compare the type and content of two collections.</p> <p>The implementation will differ depending if we are dealing with Lists or Sets.</p> <ul> <li>Example</li> </ul> <pre><code>List&lt;Integer&gt; firstList = List.of(10, 11, 22);\nList&lt;Integer&gt; secondList = List.of(10, 11, 22);\nList&lt;Integer&gt; thirdList = List.of(22, 11, 10);\n\nSystem.out.println(\"firstList.equals(secondList): \" + firstList.equals(secondList));\nSystem.out.println(\"secondList.equals(thirdList): \" + secondList.equals(thirdList));\n\nSet&lt;Integer&gt; firstSet = Set.of(10, 11, 22);\nSet&lt;Integer&gt; secondSet = Set.of(10, 11, 22);\nSet&lt;Integer&gt; thirdSet = Set.of(22, 11, 10);\n\nSystem.out.println(\"firstSet.equals(secondSet): \" + firstSet.equals(secondSet));\nSystem.out.println(\"secondSet.equals(thirdSet): \" + secondSet.equals(thirdSet));\n</code></pre> <p>Output</p> <pre><code>firstList.equals(secondList): true\nsecondList.equals(thirdList): false\nfirstSet.equals(secondSet): true\nsecondSet.equals(thirdSet): true\n</code></pre> <p>Note</p> <ul> <li>Lists compare size, order, and element equality one-by-one.</li> <li>Sets compare size and membership only \u2014 encounter order is irrelevant.</li> <li>Two sets with the same logical elements are equal even if they maintain different iteration order internally.</li> </ul> <p></p>"},{"location":"en/module-06/shared-operations/#233-fail-fast-behavior","title":"23.3 Fail-Fast Behavior","text":"<p>Most collection iterators (except concurrent collections) are <code>fail-fast</code>: modifying a collection structurally while iterating triggers a <code>ConcurrentModificationException</code>.</p> <pre><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;(List.of(1,2,3));\nfor (Integer i : list) {\n    list.add(99); // \u274c ConcurrentModificationException\n}\n</code></pre> <p>Note</p> <p>Use <code>Iterator.remove()</code> when you must remove elements during iteration. Fail-fast behavior is not guaranteed \u2014 the exception is thrown on a best-effort basis. You must not rely on catching it for program correctness.</p> <p></p>"},{"location":"en/module-06/shared-operations/#234-bulk-operations","title":"23.4 Bulk Operations","text":"<ul> <li><code>removeIf(Predicate&lt;? super E&gt; filter)</code> \u2014 Removes all matching items.</li> <li><code>replaceAll(UnaryOperator&lt;E&gt; op)</code> \u2014 Replaces every element.</li> <li><code>forEach(Consumer&lt;? super E&gt; action)</code> \u2014 Applies action to each element.</li> <li><code>stream()</code> \u2014 Returns a stream for pipeline operations.</li> </ul>"},{"location":"en/module-06/shared-operations/#235-common-return-types-and-exceptions","title":"23.5 Common Return Types and Exceptions","text":"<ul> <li><code>add(E)</code> returns boolean \u2014 always <code>true</code> for <code>ArrayList</code>, may be <code>false</code> for <code>Set</code> if no change occurs.</li> <li><code>remove(Object)</code> returns boolean (not the removed element!).</li> <li><code>get(int)</code> throws <code>IndexOutOfBoundsException</code>.</li> <li><code>iterator().remove()</code> throws <code>IllegalStateException</code> if called twice without next().</li> <li><code>toArray()</code> always returns a <code>Object[]</code> \u2014 not <code>T[]</code>.</li> </ul>"},{"location":"en/module-06/shared-operations/#236-summary-table-shared-operations","title":"23.6 Summary Table \u2014 Shared Operations","text":"Operation Applies To Notes <code>add(e)</code> All collections except Map Lists allow duplicates <code>remove(o)</code> All collections except Map Removes first occurrence <code>contains(o)</code> All collections except Map Uses equals() <code>size(), isEmpty()</code> All collections Constant-time for most <code>iterator()</code> All collections Fail-fast <code>clear()</code> All collections Removes all elements <code>stream()</code> All collections Returns sequential stream <code>removeIf(), replaceAll()</code> Lists only (most Sets do not support replaceAll) Bulk operations <code>toArray()</code> All collections Returns Object[]"},{"location":"en/module-07/concurrency/","title":"31. Java Concurrency APIs","text":""},{"location":"en/module-07/concurrency/#table-of-contents","title":"Table of Contents","text":"<ul> <li>31.1 Goals and Scope of the Concurrency API</li> <li>31.2 Fundamental Threading Problems<ul> <li>31.2.1 Race Conditions</li> <li>31.2.2 Deadlock</li> <li>31.2.3 Starvation</li> <li>31.2.4 Livelock</li> </ul> </li> <li>31.3 From Threads to Tasks</li> <li>31.4 Executor Framework<ul> <li>31.4.1 Submitting Tasks and Futures</li> <li>31.4.2 Callable vs Runnable</li> </ul> </li> <li>31.5 Thread Pools and Scheduling</li> <li>31.6 Executor Lifecycle and Termination</li> <li>31.7 Thread Safety Strategies<ul> <li>31.7.1 Synchronization</li> <li>31.7.2 Atomic Variables<ul> <li>31.7.2.1 Atomic classes</li> <li>31.7.2.2 Atomic methods</li> </ul> </li> <li>31.7.3 Lock Framework<ul> <li>31.7.3.1 Lock implementations</li> <li>31.7.3.2 Common Lock methods</li> </ul> </li> <li>31.7.4 Coordination Utilities</li> </ul> </li> <li>31.8 Concurrent Collections</li> <li>31.9 Parallel Streams</li> <li>31.10 Relation to Virtual Threads</li> <li>31.11 Summary</li> </ul> <p>This chapter introduces the Java Concurrency API, which provides high-level abstractions for managing concurrent execution safely, efficiently, and scalably.</p> <p>Unlike low-level thread manipulation, the Concurrency API focuses on tasks, executors, and coordination mechanisms, allowing developers to reason about what should be done rather than how threads are scheduled.</p> <p></p>"},{"location":"en/module-07/concurrency/#311-goals-and-scope-of-the-concurrency-api","title":"31.1 Goals and Scope of the Concurrency API","text":"<p>The <code>Java Concurrency API</code>, primarily located in the <code>java.util.concurrent</code> package, was introduced to address fundamental problems inherent in manual thread management.</p> <ul> <li>Decouple task submission from thread management.</li> <li>Reduce error-prone low-level synchronization.</li> <li>Improve scalability and performance on multi-core systems.</li> <li>Provide structured mechanisms for coordination, cancellation, and shutdown.</li> </ul> <p>The API does not eliminate concurrency problems but provides disciplined tools to manage them safely and predictably. </p> <p>Instead of explicitly creating and controlling threads, developers submit tasks and let the framework manage thread allocation, reuse, and synchronization.</p> <pre><code>ExecutorService executor = Executors.newSingleThreadExecutor();\nexecutor.execute(() -&gt; System.out.println(\"Task executed\"));\nexecutor.shutdown();\n</code></pre> <p></p>"},{"location":"en/module-07/concurrency/#312-fundamental-threading-problems","title":"31.2 Fundamental Threading Problems","text":"<p>Before understanding the <code>Concurrency API</code>, it is essential to understand the concurrency problems it is designed to mitigate. </p> <p>These problems arise from <code>shared mutable state</code>, <code>scheduling unpredictability</code>, and <code>improper coordination</code>.</p> <p></p>"},{"location":"en/module-07/concurrency/#3121-race-conditions","title":"31.2.1 Race Conditions","text":"<p>A race condition occurs when multiple threads access shared mutable state and the program\u2019s correctness depends on the timing or interleaving of their execution.</p> <ul> <li>Caused by unsynchronized access to shared data.</li> <li>Leads to inconsistent or incorrect program state.</li> </ul> <pre><code>class Counter {\n    int count = 0;\n    void increment() {\n       count++;\n    }\n}\n</code></pre> <p>If multiple threads invoke <code>increment()</code> concurrently, increments may be lost because the operation is not atomic.</p> <p></p>"},{"location":"en/module-07/concurrency/#3122-deadlock","title":"31.2.2 Deadlock","text":"<p>A deadlock occurs when two or more threads are permanently blocked, each waiting for a resource held by another thread.</p> <ul> <li>Typically caused by circular lock dependencies.</li> <li>No thread involved can make progress.</li> </ul> <pre><code>synchronized (lockA) {\n    synchronized (lockB) {\n    }\n}\n</code></pre> <p>If another thread acquires <code>lockB</code> first and then waits for <code>lockA</code>, a deadlock may occur.</p> <p>Note</p> <p>Real-world deadlocks typically involve multiple locks and order inversion.</p> <p></p>"},{"location":"en/module-07/concurrency/#3123-starvation","title":"31.2.3 Starvation","text":"<p>Starvation happens when a thread is indefinitely denied access to resources, even though those resources are available.</p> <ul> <li>Often caused by unfair locking or scheduling policies.</li> <li>Thread remains runnable but never executes.</li> </ul> <pre><code>ReentrantLock lock = new ReentrantLock(false); // unfair lock\n</code></pre> <p>Threads may repeatedly acquire the lock while others wait indefinitely.</p> <p></p>"},{"location":"en/module-07/concurrency/#3124-livelock","title":"31.2.4 Livelock","text":"<p>In a livelock, threads are not blocked but continuously react to each other in a way that prevents progress.</p> <ul> <li>Threads remain active but ineffective.</li> <li>Often caused by aggressive retry or avoidance logic.</li> </ul> <pre><code>while (!tryLock()) {\n    Thread.sleep(10);\n}\n</code></pre> <p>Both threads may repeatedly retry, preventing forward progress.</p> <p></p>"},{"location":"en/module-07/concurrency/#313-from-threads-to-tasks","title":"31.3 From Threads to Tasks","text":"<p>The Concurrency API shifts the programming model from managing threads directly to submitting tasks. </p> <p>A task represents a logical unit of work independent of the thread that executes it.</p> <ul> <li>Runnable: Represents a task that does not return a result.</li> <li>Callable: Represents a task that returns a result and may throw checked exceptions.</li> </ul> <pre><code>Runnable task = () -&gt; System.out.println(\"Runnable task\");\nCallable&lt;Integer&gt; callable = () -&gt; 42;\n</code></pre> <p>This abstraction allows tasks to be reused, scheduled flexibly, and executed by different execution strategies.</p> <p></p>"},{"location":"en/module-07/concurrency/#314-executor-framework","title":"31.4 Executor Framework","text":"<p>The Executor Framework is the core of the Concurrency API. </p> <p>It manages thread creation, reuse, and task execution behind a simple interface.</p> <ul> <li>Executor: Basic interface for executing tasks.</li> <li>ExecutorService: Extends Executor with lifecycle control and result handling.</li> <li>ScheduledExecutorService: Supports delayed and periodic task execution.</li> </ul> <pre><code>ExecutorService executor = Executors.newFixedThreadPool(2);\nexecutor.execute(() -&gt; System.out.println(\"Task 1\"));\nexecutor.execute(() -&gt; System.out.println(\"Task 2\"));\nexecutor.shutdown();\n</code></pre> <p></p>"},{"location":"en/module-07/concurrency/#3141-submitting-tasks-and-futures","title":"31.4.1 Submitting Tasks and Futures","text":"<p>Tasks submitted using <code>execute()</code> return `void: it is a \"fire-and-forget\" method which does not give back any information about the result of the task.</p> <p>Tasks submitted using <code>submit()</code> return a Future, which represents the result of an asynchronous computation.</p> <p>Both methods are used to submit work for asynchronous execution.</p> <pre><code>Future&lt;Integer&gt; future = executor.submit(() -&gt; 10 + 20);\nInteger result = future.get();\n</code></pre> Method Description void execute(Runnable task) Executes a task asynchronously with no return value and no <code>Future</code>. Future&lt;?&gt; submit(Runnable task) Executes a task asynchronously; no result is produced (<code>Future.get()</code> returns <code>null</code>).  Future submit(Callable task) Executes a task asynchronously and returns a result of type <code>T</code>.  List&gt; invokeAll(Collection&lt;? extends Callable&gt; tasks) Executes all tasks and returns a <code>Future</code> for each, after all complete.  T invokeAny(Collection&lt;? extends Callable&gt; tasks) Executes tasks and returns the result of one that completes successfully; others are cancelled. Method Description boolean isDone() Returns <code>true</code> if the task has completed (normally, exceptionally, or via cancellation). boolean isCancelled() Returns <code>true</code> if the task was cancelled before normal completion. boolean cancel(boolean mayInterruptIfRunning) Attempts to cancel execution. If <code>true</code>, interrupts the running thread if possible. T get() Blocks until completion and returns the result, or throws an exception if failed or cancelled. T get(long timeout, TimeUnit unit) Blocks up to the given timeout and returns the result, or throws <code>TimeoutException</code> if not completed. <p>Warning</p> <p><code>execute()</code> will drop exceptions silently unless handled inside the task.</p> <p></p>"},{"location":"en/module-07/concurrency/#3142-callable-vs-runnable","title":"31.4.2 Callable vs Runnable","text":"<p>Both interfaces represent tasks, but with different capabilities.</p> <ul> <li><code>Runnable</code>: No return value, cannot throw checked exceptions.</li> <li><code>Callable</code>: Returns a value and supports checked exceptions.</li> </ul> <pre><code>Callable&lt;String&gt; c = () -&gt; \"done\";\nRunnable r = () -&gt; System.out.println(\"done\");\n</code></pre> <p>For result-oriented asynchronous computation, <code>Callable</code> is generally preferred.</p> <p></p>"},{"location":"en/module-07/concurrency/#315-thread-pools-and-scheduling","title":"31.5 Thread Pools and Scheduling","text":"<p>Executors manage thread pools, which reuse a fixed or dynamic number of threads to execute tasks efficiently.</p> <ul> <li>Fixed thread pool: Limits concurrency to a fixed number of threads.</li> <li>Cached thread pool: Dynamically grows and shrinks based on demand: creates new threads as needed but reuses available threads.</li> <li>Single-thread executor: Ensures sequential task execution.</li> <li>Scheduled executor: Supports delayed and periodic tasks.</li> </ul> Factory Method Return Type Description <code>Executors.newFixedThreadPool(int nThreads)</code> ExecutorService Creates a thread pool with a fixed number of threads. <code>Executors.newFixedThreadPool(int nThreads, ThreadFactory threadFactory)</code> ExecutorService Same as newFixedThreadPool but with a custom ThreadFactory. <code>Executors.newSingleThreadExecutor()</code> ExecutorService Creates a single-worker thread pool that executes tasks sequentially. <code>Executors.newSingleThreadExecutor(ThreadFactory threadFactory)</code> ExecutorService Single-thread executor with a custom ThreadFactory. <code>Executors.newCachedThreadPool()</code> ExecutorService Creates a thread pool that creates new threads as needed and reuses idle ones. <code>Executors.newCachedThreadPool(ThreadFactory threadFactory)</code> ExecutorService Cached thread pool with a custom ThreadFactory. <code>Executors.newSingleThreadScheduledExecutor()</code> ScheduledExecutorService Creates a single-thread scheduled executor. <code>Executors.newSingleThreadScheduledExecutor(ThreadFactory threadFactory)</code> ScheduledExecutorService Single-thread scheduled executor with a custom ThreadFactory. <code>Executors.newScheduledThreadPool(int corePoolSize)</code> ScheduledExecutorService Creates a scheduled thread pool with the given core size. <code>Executors.newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory)</code> ScheduledExecutorService Scheduled thread pool with a custom ThreadFactory. <code>Executors.newWorkStealingPool()</code> ExecutorService Creates a work-stealing pool using available processors as parallelism level. <code>Executors.newWorkStealingPool(int parallelism)</code> ExecutorService Creates a work-stealing pool with the specified parallelism level. <code>Executors.newThreadPerTaskExecutor(ThreadFactory threadFactory)</code> ExecutorService Creates an executor that starts a new thread for each task. <code>Executors.newVirtualThreadPerTaskExecutor()</code> ExecutorService Creates an executor that starts a new virtual thread for each task. <p><code>Task scheduling</code>: tasks submitted to an executor are enqueued and picked by pool threads; the execution order depends on the executor implementation, queue policy, and thread availability.  For scheduled executors, tasks are ordered by trigger time; periodic tasks are re-queued after each run.</p> <pre><code>ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\n\nscheduler.schedule(\n    () -&gt; System.out.println(\"Delayed\"),\n    2, TimeUnit.SECONDS);\n</code></pre> Method Description ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit) Schedules a one-shot action that becomes enabled after the given delay.  ScheduledFuture schedule(Callable callable, long delay, TimeUnit unit) Schedules a one-shot task that returns a value after the given delay. ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) Schedules periodic execution at a fixed rate: each execution is scheduled relative to the initial start time; if a run is delayed, subsequent runs may attempt to \"catch up\". ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) Schedules periodic execution with fixed delay: each execution is scheduled relative to the completion time of the previous run; no catch-up behavior. <p>Important</p> <p>Never create threads manually in a loop: use pools or virtual threads instead.</p> <p></p>"},{"location":"en/module-07/concurrency/#316-executor-lifecycle-and-termination","title":"31.6 Executor Lifecycle and Termination","text":"<p>Executors must be shut down explicitly to release resources and allow JVM termination.</p> <ul> <li>shutdown(): Initiates orderly shutdown: completes waiting tasks but doesn't accept additionals ones.</li> <li>close(): (Java 19+) calls shutdown() and waits for tasks to finish, behaving like try-with-resources support for ExecutorService.</li> <li>shutdownNow(): Attempts immediate shutdown and interrupts running tasks.</li> <li>awaitTermination(): Waits for completion or timeout.</li> </ul> <pre><code>executor.shutdown();\nexecutor.awaitTermination(5, TimeUnit.SECONDS);\n</code></pre> <p></p>"},{"location":"en/module-07/concurrency/#317-thread-safety-strategies","title":"31.7 Thread Safety Strategies","text":"<p>The Concurrency API provides multiple complementary strategies for achieving thread safety.</p> <p></p>"},{"location":"en/module-07/concurrency/#3171-synchronization","title":"31.7.1 Synchronization","text":"<p>Synchronization enforces mutual exclusion and memory visibility by using an intrinsic lock (monitor) associated with an object or a class.</p> <pre><code>synchronized void increment() {\n    count++;\n}\n</code></pre> <p>When a thread enters a synchronized method:</p> <ul> <li>It acquires the intrinsic lock of the target object (<code>this</code> for instance methods).</li> <li>Only one thread at a time can hold the same lock, preventing concurrent execution.</li> <li>When the method exits, the lock is released automatically.</li> </ul> <p>Synchronization establishes a happens-before relationship in the Java Memory Model:</p> <ul> <li>All writes made inside the synchronized region are flushed to main memory when the lock is released.</li> <li>A thread acquiring the same lock later is guaranteed to see those updates.</li> </ul> <p>The synchronized keyword can be applied to:</p> <ul> <li>Instance methods (lock on <code>this</code>)</li> <li>Static methods (lock on the <code>Class</code> object)</li> <li>Blocks (lock on a specific object, allowing finer-grained control)</li> </ul> <p>Important</p> <p>Synchronization is simple but may hurt scalability under contention.</p> <p></p>"},{"location":"en/module-07/concurrency/#3172-atomic-variables","title":"31.7.2 Atomic Variables","text":"<p>Atomic classes provide lock-free, thread-safe operations implemented using low-level CPU primitives such as Compare-And-Swap (CAS).</p> <pre><code>AtomicInteger count = new AtomicInteger();\ncount.incrementAndGet();\n</code></pre> <p></p>"},{"location":"en/module-07/concurrency/#31721-atomic-classes","title":"31.7.2.1 Atomic classes","text":"Atomic Class Description AtomicBoolean Atomically updates and reads a <code>boolean</code> value. AtomicInteger Atomically updates and reads an <code>int</code> value. AtomicLong Atomically updates and reads a <code>long</code> value. AtomicReference Atomically updates and reads an object reference. AtomicIntegerArray Provides atomic operations on elements of an <code>int</code> array. AtomicLongArray Provides atomic operations on elements of a <code>long</code> array. AtomicReferenceArray Provides atomic operations on elements of a reference array. AtomicStampedReference Atomically updates a reference with an integer stamp to avoid ABA problems. AtomicMarkableReference Atomically updates a reference with a boolean mark."},{"location":"en/module-07/concurrency/#31722-atomic-methods","title":"31.7.2.2 Atomic methods","text":"Method Description get() Returns the current value with volatile-read semantics. set(value) Sets the value with volatile-write semantics. lazySet(value) Eventually sets the value with weaker ordering guarantees. compareAndSet(expect, update) Atomically sets the value if the current value equals the expected value. getAndSet(value) Atomically sets the value and returns the previous value. incrementAndGet() Atomically increments the value and returns the updated result. getAndIncrement() Atomically increments the value and returns the previous result. decrementAndGet() Atomically decrements the value and returns the updated result. getAndDecrement() Atomically decrements the value and returns the previous result. addAndGet(delta) Atomically adds the given delta and returns the updated result. getAndAdd(delta) Atomically adds the given delta and returns the previous result. <p>Atomic variables:</p> <ul> <li>Perform single operations atomically</li> <li>Provide memory visibility guarantees similar to <code>volatile</code></li> <li>Avoid thread blocking, making them highly scalable under contention</li> </ul> <p>However, atomic variables only guarantee atomicity for individual operations.</p> <p>Composing multiple operations still requires external synchronization.</p> <p>Atomic variables are typically used for:</p> <ul> <li>Counters and sequence generators</li> <li>Flags and state indicators</li> <li>High-throughput, low-latency updates</li> </ul> <p></p>"},{"location":"en/module-07/concurrency/#3173-lock-framework","title":"31.7.3 Lock Framework","text":"<p>The <code>java.util.concurrent.locks</code> package provides explicit locking mechanisms that offer greater flexibility and control than synchronized.</p> <pre><code>ReentrantLock lock = new ReentrantLock();\nlock.lock();\ntry {\n    // critical section\n} finally {\n    lock.unlock();\n}\n</code></pre> <p>Key characteristics of the Lock framework:</p> <ul> <li>Locks must be explicitly acquired and released</li> <li>Lock acquisition can be interruptible or time-bounded</li> <li>Locks may be configured with fairness policies (parameter) when ordering is required (when you need to control the order in which threads run)</li> <li>Multiple Condition objects can be associated with a single lock</li> </ul> <p></p>"},{"location":"en/module-07/concurrency/#31731-lock-implementations","title":"31.7.3.1 Lock implementations","text":"Lock Implementation Description Lock Core interface defining explicit lock operations. ReentrantLock Reentrant mutual exclusion lock with optional fairness policy. ReadWriteLock Interface defining separate read and write locks. ReentrantReadWriteLock Provides separate reentrant read and write locks to improve read scalability. StampedLock Lock supporting optimistic, read, and write locking modes (non-reentrant). <p>Warning</p> <p>Unlike other locks, StampedLock is not reentrant \u2014 re-acquiring it from the same thread causes deadlock.</p> <p></p>"},{"location":"en/module-07/concurrency/#31732-common-lock-methods","title":"31.7.3.2 Common Lock methods","text":"Method Description lock() Acquires the lock, blocking indefinitely until available. unlock() Releases the lock; must be called by the owning thread. tryLock() Attempts to acquire the lock immediately without blocking: returns boolean indicating if lock has been succesfully acquired tryLock(long, TimeUnit) Attempts to acquire the lock within the given timeout. lockInterruptibly() Acquires the lock unless the thread is interrupted. newCondition() Creates a <code>Condition</code> instance for fine-grained thread coordination. <p>Unlike synchronized, locks do not release automatically, making proper try/finally usage essential to avoid deadlocks.</p> <p></p>"},{"location":"en/module-07/concurrency/#3174-coordination-utilities","title":"31.7.4 Coordination Utilities","text":"<p>Coordination utilities allow threads to coordinate execution phases without protecting shared data via mutual exclusion.</p> <p>Other coordination primitives include: - <code>CountDownLatch</code> - <code>Semaphore</code> - <code>Phaser</code></p> <pre><code>import java.util.concurrent.CyclicBarrier;\n\npublic class BarrierExample {\n\n    private static final int THREAD_COUNT = 3;\n\n    public static void main(String[] args) {\n\n        CyclicBarrier barrier = new CyclicBarrier(\n            THREAD_COUNT,\n            () -&gt; System.out.println(\"All threads reached the barrier. Proceeding...\")\n        );\n\n        Runnable task = () -&gt; {\n            String name = Thread.currentThread().getName();\n            try {\n                System.out.println(name + \" performing initial work\");\n                Thread.sleep((long) (Math.random() * 2000));\n\n                // Wait for other threads\n                System.out.println(name + \" waiting at barrier\");\n                barrier.await();\n\n                // Executed only after all threads reach the barrier\n                System.out.println(name + \" performing next phase\");\n\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        };\n\n        for (int i = 1; i &lt;= THREAD_COUNT; i++) {\n            new Thread(task, \"Worker-\" + i).start();\n        }\n    }\n}\n</code></pre> <p>Sample Output:</p> <pre><code>Worker-1 performing initial work\nWorker-2 performing initial work\nWorker-3 performing initial work\nWorker-3 waiting at barrier\nWorker-1 waiting at barrier\nWorker-2 waiting at barrier\nAll threads reached the barrier. Proceeding...\nWorker-3 performing next phase\nWorker-1 performing next phase\nWorker-2 performing next phase\n</code></pre> <p>A <code>CyclicBarrier</code>:</p> <ul> <li>Blocks threads until a predefined number of threads reach the barrier</li> <li>Releases all waiting threads simultaneously once the barrier is tripped</li> <li>Can be reused for multiple coordination cycles</li> </ul> <p>These utilities focus on execution ordering and synchronization, not data protection.</p> <p></p>"},{"location":"en/module-07/concurrency/#318-concurrent-collections","title":"31.8 Concurrent Collections","text":"<p>Concurrent collections are thread-safe data structures designed to support high levels of concurrency without requiring external synchronization.</p> <p>Unlike synchronized wrappers (e.g. <code>Collections.synchronizedMap</code>), concurrent collections: - Use fine-grained locking or lock-free techniques - Allow multiple threads to access and modify the collection simultaneously - Scale better under contention</p> <p>Common examples include:</p> <ul> <li> <p>ConcurrentHashMap   A high-performance concurrent map that allows concurrent reads and updates by partitioning internal state and minimizing lock contention.</p> </li> <li> <p>CopyOnWriteArrayList   A thread-safe list optimized for scenarios with many reads and few writes. Write operations create a new internal array, allowing reads to proceed without locking.</p> </li> <li> <p>BlockingQueue   A queue designed for producer-consumer patterns, where threads can block while waiting for elements or available capacity.</p> </li> </ul> <pre><code>BlockingQueue&lt;String&gt; queue = new LinkedBlockingQueue&lt;&gt;();\nqueue.put(\"item\");   // blocks if the queue is full\nqueue.take();        // blocks if the queue is empty\n</code></pre> <p>Blocking queues handle synchronization internally, simplifying coordination between producer and consumer threads.</p> <p>Caution</p> <p>CopyOnWrite collections are memory-expensive; avoid in write-heavy workloads.</p> <p></p>"},{"location":"en/module-07/concurrency/#319-parallel-streams","title":"31.9 Parallel Streams","text":"<p><code>Parallel streams</code> provide declarative data parallelism, allowing stream operations to be executed concurrently across multiple threads with minimal code changes.</p> <p>Key characteristics: - Activated via <code>parallelStream()</code> or <code>stream().parallel()</code> - Internally executed using the common ForkJoinPool - Automatically splits data into chunks processed in parallel</p> <p>Parallel streams work best when: - Operations are CPU-bound - Functions are stateless and non-blocking - The data source is large enough to amortize parallelization overhead</p> <pre><code>list.parallelStream()\n    .map(x -&gt; x * x)\n    .forEach(System.out::println);\n</code></pre> <p>Because execution order is not guaranteed, parallel streams should avoid: - Shared mutable state - Blocking I/O - Order-dependent side effects</p> <p>Note</p> <p>Use <code>forEachOrdered()</code> if deterministic output is required.</p> <p></p>"},{"location":"en/module-07/concurrency/#3110-relation-to-virtual-threads","title":"31.10 Relation to Virtual Threads","text":"<p>In Java 21, the <code>Executor framework</code> integrates seamlessly with virtual threads, enabling massive concurrency with minimal resource usage.</p> <pre><code>ExecutorService executor =\nExecutors.newVirtualThreadPerTaskExecutor();\n\nexecutor.submit(() -&gt; blockingIO());\nexecutor.close();\n</code></pre> <p>This allows blocking code to scale efficiently without redesigning APIs.</p> <p></p>"},{"location":"en/module-07/concurrency/#3111-summary","title":"31.11 Summary","text":"<ul> <li>The <code>Java Concurrency API</code> provides a robust, scalable, and safer alternative to manual thread management. </li> <li>By abstracting execution, coordinating tasks, and offering thread-safe utilities, it enables developers to build concurrent systems that are both performant and maintainable.</li> <li>Choose the right tool: synchronized \u2192 locks \u2192 atomics \u2192 executors \u2192 virtual threads.</li> </ul>"},{"location":"en/module-07/threads/","title":"30. Java Threads \u2013 Fundamentals and Execution Model","text":""},{"location":"en/module-07/threads/#table-of-contents","title":"Table of Contents","text":"<ul> <li>30.1 Threads Processes and the Operating System</li> <li>30.2 Memory Model Stack and Heap</li> <li>30.3 Context and Context Switching</li> <li>30.4 Concurrency vs Parallelism</li> <li>30.5 Threads in Java Conceptual Model</li> <li>30.6 Thread Categories in Java 21</li> <li>30.7 Creating Threads in Java</li> <li>30.8 Thread Lifecycle and Execution</li> <li>30.9 Starting vs Running a Thread Synchronous-or-Asynchronous</li> <li>30.10 Thread Priority and Scheduling</li> <li>30.11 Thread Deferring and Yielding</li> <li>30.12 Thread Interruption and Cooperative Cancellation<ul> <li>30.12.1 What Interrupting a Thread Means</li> <li>30.12.2 Interrupting Blocking Operations</li> <li>30.12.3 Checking the Interruption Status</li> <li>30.12.4 Example Interrupting-a-Sleeping-Thread</li> <li>30.12.5 Key Observations</li> </ul> </li> <li>30.13 Threads and the Main Thread</li> <li>30.14 Thread Concurrency and Shared State</li> <li>30.15 Summary</li> </ul> <p>This chapter introduces threads from first principles and explains how they are modeled and used in Java 21. </p> <p>It builds the conceptual foundation required for understanding <code>concurrency</code>, <code>synchronization</code>, and the <code>Java Concurrency API</code> covered in the next chapter.</p> <p></p>"},{"location":"en/module-07/threads/#301-threads-processes-and-the-operating-system","title":"30.1 Threads, Processes, and the Operating System","text":"<p>To understand threads, we must start from the operating system execution model. Modern operating systems execute programs using processes and threads.</p> <ul> <li>Process: An executing program instance managed by the operating system. A process owns its own virtual memory space, system resources (files, sockets), and at least one thread.</li> <li>Thread: A lightweight execution unit within a process. Threads share the process memory and resources but execute independently.</li> <li>Task: A logical unit of work to be executed. A task may be executed by a thread but is not itself a thread.</li> <li>CPU Core: A physical or logical execution unit capable of running one thread at a time. Multiple cores allow true parallel execution.</li> </ul> <p>A single process can contain many threads, all operating within the same shared environment. This shared environment is both the source of concurrency power and concurrency risk.</p> <p></p>"},{"location":"en/module-07/threads/#302-memory-model-stack-and-heap","title":"30.2 Memory Model: Stack and Heap","text":"<p>Threads interact with memory in two fundamentally different ways.</p> <ul> <li>Thread Stack: Private memory area for each thread. It stores method call frames, local variables, and execution state. Each thread has exactly one stack.</li> <li>Heap: Shared memory area used for objects and class instances. All threads within the same process can access the heap.</li> </ul> <p>Because <code>stacks are isolated</code> and the <code>heap is shared</code>, concurrency problems arise when multiple threads access the same heap objects without proper coordination.</p> <p></p>"},{"location":"en/module-07/threads/#303-context-and-context-switching","title":"30.3 Context and Context Switching","text":"<p>The operating system schedules threads onto CPU cores. </p> <p>Since the number of runnable threads often exceeds the number of available cores, the OS performs context switching.</p> <ul> <li>Context: The complete execution state of a thread, including registers, program counter, and stack pointer.</li> <li>Context Switch: The act of suspending one thread and resuming another by saving and restoring their contexts.</li> </ul> <p>Context switching enables concurrency but has a cost: CPU cycles are consumed without executing application logic. </p> <p>Java developers must design systems that balance concurrency and efficiency.</p> <p></p>"},{"location":"en/module-07/threads/#304-concurrency-vs-parallelism","title":"30.4 Concurrency vs Parallelism","text":"<p>These two terms are often confused but describe different concepts.</p> <ul> <li>Concurrency: Multiple threads are in progress during the same time interval, possibly interleaved on a single CPU core.</li> <li>Parallelism: Multiple threads execute simultaneously on different CPU cores.</li> </ul> <p>Java supports concurrency independently of hardware parallelism. </p> <p>Even on a single-core system, Java threads can be concurrent through time slicing.</p> <p></p>"},{"location":"en/module-07/threads/#305-threads-in-java-conceptual-model","title":"30.5 Threads in Java: Conceptual Model","text":"<p>In Java, a thread represents an independent path of execution within a single JVM process. All Java threads run within the same heap and class loader context unless explicitly isolated by advanced mechanisms.</p> <ul> <li>Java Thread: An object of type <code>java.lang.Thread</code> that maps to an underlying execution unit.</li> <li>Runnable: A functional interface representing a task whose <code>run()</code> method contains executable logic.</li> </ul> <p>A thread executes code by invoking its <code>run()</code> method, either directly or indirectly through the JVM thread scheduler: please see Starting vs Running a Thread</p> <p></p>"},{"location":"en/module-07/threads/#306-thread-categories-in-java-21","title":"30.6 Thread Categories in Java 21","text":"<p>Java 21 defines multiple kinds of threads, differing in lifecycle, scheduling, and intended use.</p> <ul> <li>Platform Thread: A traditional Java thread mapped one-to-one to an operating system thread.</li> <li>Virtual Thread: A lightweight thread managed by the JVM and scheduled onto carrier threads. Introduced to enable massive concurrency with minimal overhead.</li> <li>Carrier Thread: A platform thread used internally by the JVM to execute virtual threads.</li> <li>Daemon Thread: A background thread that does not prevent JVM termination. When only daemon threads remain, the JVM exits.</li> <li>User Thread: Any non-daemon thread. The JVM waits for all user threads to complete before exiting.</li> <li>System Thread: Threads created internally by the JVM for garbage collection, JIT compilation, and other runtime services.</li> </ul> <p>Note</p> <p><code>Virtual threads</code> are lightweight user threads; they are not daemon by default.</p> <p></p>"},{"location":"en/module-07/threads/#307-creating-threads-in-java","title":"30.7 Creating Threads in Java","text":"<p>Threads can be created in multiple ways, all conceptually centered around providing executable logic.</p> <ul> <li>Extending <code>Thread</code> and overriding <code>run()</code>.</li> <li>Passing a <code>Runnable</code> to a <code>Thread</code> constructor.</li> <li>Using thread factories and executors (covered in the Concurrency API section).</li> </ul> <pre><code>Runnable runnable = ...\n\n  // Create a platform thread through constructor\n  Thread thread = new Thread(runnable);\n  thread.start();\n\n  // Start a daemon thread to run a task\n  Thread thread = Thread.ofPlatform().daemon().start(runnable);\n\n  // Create an unstarted thread with name \"duke\", its start() method\n  // must be invoked to schedule it to execute.\n  Thread thread = Thread.ofPlatform().name(\"duke\").unstarted(runnable);\n\n  // A ThreadFactory that creates daemon threads named \"worker-0\", \"worker-1\", ...\n  ThreadFactory factory = Thread.ofPlatform().daemon().name(\"worker-\", 0).factory();\n\n  // Start a virtual thread to run a task\n  Thread thread = Thread.ofVirtual().start(runnable);\n\n  // A ThreadFactory that creates virtual threads\n  ThreadFactory factory = Thread.ofVirtual().factory();\n</code></pre> <p>Warning</p> <ul> <li>Thread creation alone does not start execution.</li> <li>Execution begins only when the JVM scheduler is engaged.</li> </ul> <p></p>"},{"location":"en/module-07/threads/#308-thread-lifecycle-and-execution","title":"30.8 Thread Lifecycle and Execution","text":"<p>A Java thread progresses through well-defined states during its lifetime.</p> <ul> <li>New: Thread object created but not yet started.</li> <li>Runnable: Eligible for execution by the scheduler.</li> <li>Running: Actively executing on a CPU core.</li> <li>Blocked / Waiting: Temporarily unable to proceed due to synchronization or coordination.</li> <li>Terminated: Execution completed or aborted.</li> </ul> <p>The JVM and operating system cooperate to move threads between these states.</p> <p>Threads in <code>BLOCKED</code>, <code>WAITING</code> or <code>TIMED_WAITING</code> state are not using any CPU resources</p> <p></p>"},{"location":"en/module-07/threads/#309-starting-vs-running-a-thread-synchronous-or-asynchronous","title":"30.9 Starting vs Running a Thread: Synchronous or Asynchronous","text":"<p>A critical conceptual distinction exists between invoking <code>run()</code> and invoking <code>start()</code>.</p> <ul> <li>Calling <code>run()</code> directly executes the method synchronously in the current thread, like a normal method call.</li> <li>Calling <code>start()</code> requests the JVM to create a new call stack and execute <code>run()</code> asynchronously in a separate thread.</li> </ul> <p>Therefore, code such as <code>new Thread(r).run();</code> does NOT create concurrency. The execution remains synchronous and blocks the calling thread until completion.</p> <p>Note</p> <p><code>Asynchronous execution</code> means the caller continues immediately while the new thread progresses independently, subject to scheduling.</p> <p><code>Synchronous execution</code> means the caller waits for the operation to complete.</p> <p>Important</p> <p>Concurrency starts only when <code>start()</code> is invoked.</p> <p></p>"},{"location":"en/module-07/threads/#3010-thread-priority-and-scheduling","title":"30.10 Thread Priority and Scheduling","text":"<p>Java threads have an associated priority hint that influences scheduling.</p> <ul> <li><code>Thread Priority</code>: An integer value indicating relative importance, ranging from minimum to maximum.</li> <li><code>Scheduling</code>: The JVM delegates scheduling decisions to the operating system, which may or may not honor priorities strictly.</li> </ul> <p>Thread priority affects scheduling probability but never guarantees execution order. Portable Java code must never rely on priorities for correctness.</p> <p>You can set priority on <code>platform threads</code>; for <code>virtual threads</code> the priority is always set to 5 (Thread.NORM_PRIORITY) and trying to change it has no effect.</p> <p></p>"},{"location":"en/module-07/threads/#3011-thread-deferring-and-yielding","title":"30.11 Thread Deferring and Yielding","text":"<p>Threads can voluntarily influence scheduling behavior.</p> <p>Calling Thread.yield() signals willingness to pause execution.</p> <ul> <li><code>Yielding</code>: A thread hints that it is willing to pause execution to allow other runnable threads to proceed.</li> <li><code>Sleeping</code>: A thread suspends execution for a fixed duration, entering a timed waiting state.</li> </ul> <p>These mechanisms do not guarantee immediate execution of other threads; they merely provide scheduling hints.</p> <p></p>"},{"location":"en/module-07/threads/#3012-thread-interruption-and-cooperative-cancellation","title":"30.12 Thread Interruption and Cooperative Cancellation","text":"<p>Java threads cannot be stopped forcibly from the outside. </p> <p>Instead, Java provides a cooperative mechanism called thread interruption, which allows one thread to request that another thread stop what it is doing. </p> <p>The target thread decides how and when to respond.</p> <p></p>"},{"location":"en/module-07/threads/#30121-what-interrupting-a-thread-means","title":"30.12.1 What Interrupting a Thread Means","text":"<p>Interrupting a thread does not terminate it. Calling <code>interrupt()</code> sets an internal interruption flag on the target thread. It is the responsibility of the running thread to observe this flag and react appropriately.</p> <ul> <li><code>Interrupt Request</code>: A signal sent to a thread indicating that it should stop or change its current activity.</li> <li><code>Interruption Flag</code>: A boolean status associated with each thread, set when <code>interrupt()</code> is invoked.</li> <li><code>Cooperative Cancellation</code>: A design pattern where threads periodically check for interruption and terminate themselves cleanly.</li> </ul> <p></p>"},{"location":"en/module-07/threads/#30122-interrupting-blocking-operations","title":"30.12.2 Interrupting Blocking Operations","text":"<p>Some blocking methods in Java respond immediately to interruption by throwing <code>InterruptedException</code> and clearing the interruption flag. These methods include <code>sleep()</code>, <code>wait()</code>, and <code>join()</code>.</p> <p>When a thread is blocked in one of these methods and another thread interrupts it, the blocked thread is awakened and an exception is thrown. This provides a safe escape point from blocking operations.</p> <p></p>"},{"location":"en/module-07/threads/#30123-checking-the-interruption-status","title":"30.12.3 Checking the Interruption Status","text":"<p>Threads that are not blocked must explicitly check whether they have been interrupted. Java provides two ways to do this.</p> <ul> <li><code>Thread.currentThread().isInterrupted()</code>: Returns the interruption status without clearing it.</li> <li><code>Thread.interrupted()</code>: Returns the interruption status and clears it. This is subtle: the next call will return false.</li> </ul> <p>Failing to check the interruption status may cause threads to ignore cancellation requests and run indefinitely.</p> <p></p>"},{"location":"en/module-07/threads/#30124-example-interrupting-a-sleeping-thread","title":"30.12.4 Example: Interrupting a Sleeping Thread","text":"<p>The following example demonstrates cooperative cancellation using interruption. </p> <p>A worker thread repeatedly sleeps while performing work. The main thread interrupts it, causing a clean shutdown.</p> <pre><code>class Main {\n\n    static class Task implements Runnable {\n        public void run() {\n            try {\n                while (true) {\n                    System.out.println(\"Working...\");\n                    Thread.sleep(1000);\n                }\n            } catch (InterruptedException e) {\n                System.out.println(\"Task interrupted, shutting down\");\n            }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread worker = new Thread(new Task());\n        worker.start();\n        System.out.println(\"main before sleep...\");\n        Thread.sleep(3000);\n        System.out.println(\"main after sleep...\");\n        worker.interrupt();\n        System.out.println(\"main reached END\");\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>main before sleep...\nWorking...\nWorking...\nWorking...\nmain after sleep...\nmain reached END\nTask interrupted, shutting down\n</code></pre> <p>Note</p> <p>Output order may vary slightly due to scheduling.</p> <p></p>"},{"location":"en/module-07/threads/#30125-key-observations","title":"30.12.5 Key Observations","text":"<ul> <li>Calling <code>interrupt()</code> does not stop the thread directly.</li> <li>The interruption is detected because <code>sleep()</code> throws <code>InterruptedException</code>.</li> <li>The worker thread terminates itself in a controlled manner.</li> <li>Proper interruption handling allows threads to release resources and maintain program correctness.</li> </ul> <p>Note</p> <p>Swallowing <code>InterruptedException</code> without terminating or restoring the interruption status is considered bad practice and may lead to unresponsive threads.</p> <p></p>"},{"location":"en/module-07/threads/#3013-threads-and-the-main-thread","title":"30.13 Threads and the Main Thread","text":"<p>Every Java application starts with a main thread. This thread executes the <code>main(String[])</code> method.</p> <ul> <li>The main thread is a user thread.</li> <li>The JVM remains alive as long as at least one user thread is running.</li> <li>If the main thread terminates but other user threads exist, the JVM continues execution waiting for the user threads to be done.</li> <li>Daemon threads do not keep JVM alive.</li> </ul> <p>Understanding the role of the main thread is essential for reasoning about program termination and background processing.</p> <p></p>"},{"location":"en/module-07/threads/#3014-thread-concurrency-and-shared-state","title":"30.14 Thread Concurrency and Shared State","text":"<p><code>Concurrency</code> arises when multiple threads access shared mutable state.</p> <ul> <li><code>Shared State</code>: Any heap-based data accessible by more than one thread.</li> <li><code>Race Condition</code>: A correctness error caused by unsynchronized access to shared state.</li> <li><code>Visibility Problem</code>: A thread observes stale data due to lack of proper memory synchronization.</li> </ul> <p>Java solves these with synchronization, volatile, locks, atomics, and high-level frameworks (Executors, futures).</p> <p>Synchronization, volatile variables, and higher-level concurrency utilities will be studied in subsequent sections.</p> <p></p>"},{"location":"en/module-07/threads/#3015-summary","title":"30.15 Summary","text":"<ul> <li><code>Threads</code> are the fundamental building block of concurrent execution in Java. </li> <li>They exist within processes, share memory, and are scheduled by the JVM in cooperation with the operating system.</li> <li>Correct thread management avoids leaks, deadlocks, and wasted CPU.</li> </ul>"},{"location":"en/module-08/files-path-api/","title":"33. Files and Paths APIs","text":""},{"location":"en/module-08/files-path-api/#table-of-contents","title":"Table of Contents","text":"<ul> <li>33.1 Legacy File and NIO Path Creation-and-Conversion<ul> <li>33.1.1 Creating a File Legacy</li> <li>33.1.2 Creating a Path NIO-v2</li> <li>33.1.3 Absolute vs Relative What Relative Means</li> <li>33.1.4 Joining--Building-Paths<ul> <li>33.1.4.1 resolve</li> <li>33.1.4.2 relativize</li> </ul> </li> <li>33.1.5 Converting Between File and Path</li> <li>33.1.6 URI Conversion When-Needed</li> <li>33.1.7 Canonical vs Absolute vs Normalized Core-Differences<ul> <li>33.1.7.1 normalize</li> </ul> </li> <li>33.1.8 Quick Comparison Table Creation--Conversion</li> </ul> </li> <li>33.2 Managing Files and Directories Create-Copy-Move-Replace-Compare-Delete<ul> <li>33.2.1 Mental Model Path-Locator-vs-Operations</li> <li>33.2.2 Creating Files and Directories<ul> <li>33.2.2.1 Create a File</li> <li>33.2.2.2 Create Directories</li> </ul> </li> <li>33.2.3 Copying Files and Directories<ul> <li>33.2.3.1 Copy a File NIO</li> <li>33.2.3.2 Manual Copy Legacy-Stream-Based</li> </ul> </li> <li>33.2.4 Moving--Renaming-and-Replacing<ul> <li>33.2.4.1 Legacy Rename Common-Pitfall</li> <li>33.2.4.2 NIO Move Preferred</li> </ul> </li> <li>33.2.5 Comparing Paths and Files<ul> <li>33.2.5.1 Equality-vs-Same-File</li> </ul> </li> <li>33.2.6 Deleting Files and Directories<ul> <li>33.2.6.1 Legacy Delete</li> <li>33.2.6.2 NIO Delete and Delete-If-Exists</li> </ul> </li> <li>33.2.7 Recursively Copying--Deleting-Directory-Trees NIO-Pattern</li> <li>33.2.8 Summary Checklist</li> </ul> </li> </ul> <p>This section focuses on how to create filesystem locators using the legacy <code>java.io.File</code> API and the modern <code>java.nio.file.Path</code> API: how to convert between them and understanding overloads, defaults, and common pitfalls.</p> <p></p>"},{"location":"en/module-08/files-path-api/#331-legacy-file-and-nio-path-creation-and-conversion","title":"33.1 Legacy <code>File</code> and NIO <code>Path</code>: Creation and Conversion","text":""},{"location":"en/module-08/files-path-api/#3311-creating-a-file-legacy","title":"33.1.1 Creating a <code>File</code> (Legacy)","text":"<p>A <code>File</code> instance represents a filesystem pathname (absolute or relative). </p> <p>Creating one does not access the filesystem and does not throw <code>IOException</code>.</p> <p>Core constructors (most common):</p> <ul> <li><code>new File(String pathname)</code> </li> <li><code>new File(String parent, String child)</code> </li> <li><code>new File(File parent, String child)</code> </li> <li><code>new File(URI uri)</code> (typically <code>file:...</code>)</li> </ul> <pre><code>import java.io.File;\nimport java.net.URI;\n\nFile f1 = new File(\"data.txt\"); // relative\nFile f2 = new File(\"/tmp\", \"data.txt\"); // parent + child\nFile f3 = new File(new File(\"/tmp\"), \"data.txt\");\n\nFile f4 = new File(URI.create(\"file:///tmp/data.txt\"));\n</code></pre> <p>Note</p> <ul> <li><code>new File(...)</code> never opens the file.</li> <li>Existence/permissions are checked only when you call methods like <code>exists()</code>, <code>length()</code>, or when you open a stream/channel.</li> </ul> <p></p>"},{"location":"en/module-08/files-path-api/#3312-creating-a-path-nio-v2","title":"33.1.2 Creating a <code>Path</code> (NIO v.2)","text":"<p>A <code>Path</code> is also just a locator. </p> <p>Like <code>File</code>, creating a <code>Path</code> does not access the filesystem.</p> <p>Core factories:</p> <ul> <li><code>Path.of(String first, String... more)</code> (Java 11+)</li> <li><code>Paths.get(String first, String... more)</code> (older style; still valid)</li> <li><code>Path.of(URI uri)</code> (e.g., <code>file:///...</code>)</li> </ul> <pre><code>import java.net.URI;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\nPath p1 = Path.of(\"data.txt\"); // relative\nPath p2 = Path.of(\"/tmp\", \"data.txt\"); // parent + child\n\nPath p3 = Paths.get(\"data.txt\"); // legacy factory style\nPath p4 = Path.of(URI.create(\"file:///tmp/data.txt\"));\n</code></pre> <p>Note</p> <ul> <li><code>Path.of(...)</code> and <code>Paths.get(...)</code> are equivalent for the default filesystem.</li> <li>Prefer <code>Path.of</code> in modern code.</li> </ul> <p></p>"},{"location":"en/module-08/files-path-api/#3313-absolute-vs-relative-what-relative-means","title":"33.1.3 Absolute vs Relative: What \u201cRelative\u201d Means","text":"<p>Both <code>File</code> and <code>Path</code> can be created as relative paths. </p> <p>Relative paths are resolved against the process working directory (typically <code>System.getProperty(\"user.dir\")</code>).</p> <pre><code>import java.io.File;\nimport java.nio.file.Path;\n\nFile rf = new File(\"data.txt\");\nPath rp = Path.of(\"data.txt\");\n\nSystem.out.println(rf.isAbsolute()); // false\nSystem.out.println(rp.isAbsolute()); // false\n\nSystem.out.println(rf.getAbsolutePath());\nSystem.out.println(rp.toAbsolutePath());\n</code></pre> <p>Note</p> <p>Relative paths are a common source of \u201cworks on my machine\u201d bugs because <code>user.dir</code> depends on how/where the JVM was launched.</p> <p></p>"},{"location":"en/module-08/files-path-api/#3314-joining-building-paths","title":"33.1.4 Joining / Building Paths","text":"<ul> <li>Legacy <code>File</code> uses constructors (parent + child). </li> <li>NIO uses <code>resolve</code> and related methods.</li> </ul> Task Legacy (File) NIO (Path) Join parent + child <code>new File(parent, child)</code> <code>parent.resolve(child)</code> Join many segments Repeated constructors <code>Path.of(a, b, c)</code> or chained <code>resolve()</code> <pre><code>import java.io.File;\nimport java.nio.file.Path;\n\nFile f = new File(\"/tmp\", \"a.txt\");\n\nPath base = Path.of(\"/tmp\");\nPath p = base.resolve(\"a.txt\"); // /tmp/a.txt\nPath p2 = base.resolve(\"dir\").resolve(\"a.txt\"); // /tmp/dir/a.txt\n</code></pre>"},{"location":"en/module-08/files-path-api/#33141-resolve","title":"33.1.4.1 <code>resolve()</code>","text":"<p>Combines paths in a filesystem-aware way.</p> <ul> <li>Relative paths are appended</li> <li>Absolute argument replaces base path</li> </ul> <p>Note</p> <p><code>Path.resolve(...)</code> has a rule: if the argument is absolute, it returns the argument and discards the base (you cannot combine two absolute paths using <code>resolve</code>).</p> <p></p>"},{"location":"en/module-08/files-path-api/#33142-relativize","title":"33.1.4.2 <code>relativize()</code>","text":"<p><code>Path.relativize</code> computes a relative path from one path to another. The resulting path, when <code>resolved</code> against the source path, yields the target path.</p> <p>In other words:</p> <ul> <li>It answers the question: \u201cHow do I go from path A to path B?\u201d</li> <li>The result is always a relative path</li> <li>No filesystem access occurs</li> </ul> <p>Fundamental Rules</p> <p><code>relativize</code> has strict preconditions. Violating them throws an exception.</p> Rule Explanation Both paths must be absolute or both relative Both paths must belong to the same filesystem same provider Root components must match same root (on Windows, same drive) Result is never absolute always relative <p>Note</p> <p>If one path is absolute and the other relative, <code>IllegalArgumentException</code> is thrown.</p> <p>Simple Relative Example:</p> <p>Both paths are relative, so relativization is allowed.</p> <pre><code>Path p1 = Path.of(\"docs/manual\");\nPath p2 = Path.of(\"docs/images/logo.png\");\n\nPath relative = p1.relativize(p2);\nSystem.out.println(relative);\n</code></pre> <pre><code>../images/logo.png\n</code></pre> <p>Interpretation: from <code>docs/manual</code>, go up one level, then into <code>images/logo.png</code>.</p> <p>Absolute Paths Example:</p> <p>Absolute paths work exactly the same way.</p> <pre><code>Path base = Path.of(\"/home/user/projects\");\nPath target = Path.of(\"/home/user/docs/readme.txt\");\n\nPath relative = base.relativize(target);\nSystem.out.println(relative);\n</code></pre> <pre><code>../docs/readme.txt\n</code></pre> <p>Using <code>resolve</code> to Verify the Result</p> <p>A key property of <code>relativize</code> is this identity:</p> <pre><code>base.resolve(base.relativize(target)).equals(target)\n</code></pre> <pre><code>Path base = Path.of(\"/a/b/c\");\nPath target = Path.of(\"/a/d/e\");\n\nPath r = base.relativize(target);\nSystem.out.println(r); // ../../d/e\nSystem.out.println(base.resolve(r)); // /a/d/e\n</code></pre> <p>Example: Mixing Absolute and Relative Paths (ERROR CASE)</p> <p>This is one of the most common mistakes.</p> <pre><code>Path abs = Path.of(\"/a/b\");\nPath rel = Path.of(\"c/d\");\n\nabs.relativize(rel); // throws exception\n</code></pre> <pre><code>Exception in thread \"main\" java.lang.IllegalArgumentException\n</code></pre> <p>Note</p> <p><code>relativize</code> does NOT attempt to convert paths to absolute automatically.</p> <p>Example: Different Roots (Windows-Specific Trap)</p> <p>On Windows, paths with different drive letters cannot be relativized.</p> <pre><code>Path p1 = Path.of(\"C:\\\\data\\\\a\");\nPath p2 = Path.of(\"D:\\\\data\\\\b\");\n\np1.relativize(p2); // IllegalArgumentException\n</code></pre> <p>Note</p> <p>On Unix-like systems, the root is always <code>/</code>, so this issue does not occur.</p> <p></p>"},{"location":"en/module-08/files-path-api/#3315-converting-between-file-and-path","title":"33.1.5 Converting Between <code>File</code> and <code>Path</code>","text":"<p>Conversion is straightforward and lossless for normal local filesystem paths.</p> Conversion How File \u2192 Path <code>file.toPath()</code> Path \u2192 File <code>path.toFile()</code> <pre><code>import java.io.File;\nimport java.nio.file.Path;\n\nFile f = new File(\"data.txt\");\nPath p = f.toPath();\n\nFile back = p.toFile();\n</code></pre> <p>Note</p> <p>Conversion does not validate existence. It only converts representations.</p> <p></p>"},{"location":"en/module-08/files-path-api/#3316-uri-conversion-when-needed","title":"33.1.6 URI Conversion (When Needed)","text":"<p><code>URIs</code> are useful when paths must be represented in a standard, absolute form (e.g., interoperating with networked resources or configuration). </p> <p>Both APIs support URI conversion.</p> Direction Legacy (File) NIO (Path) From URI <code>new File(uri)</code> <code>Path.of(uri)</code> To URI <code>file.toURI()</code> <code>path.toUri()</code> <pre><code>import java.io.File;\nimport java.net.URI;\nimport java.nio.file.Path;\n\nFile f = new File(\"/tmp/data.txt\");\nURI u1 = f.toURI();\n\nPath p = Path.of(\"/tmp/data.txt\");\nURI u2 = p.toUri();\n\nPath pFromUri = Path.of(u2);\nFile fFromUri = new File(u1);\n</code></pre> <p>Note</p> <p><code>new File(URI)</code> requires a <code>file:</code> URI and throws <code>IllegalArgumentException</code> if the URI is not hierarchical or not a file URI.</p> <p></p>"},{"location":"en/module-08/files-path-api/#3317-canonical-vs-absolute-vs-normalized-core-differences","title":"33.1.7 Canonical vs Absolute vs Normalized (Core Differences)","text":"<p>These terms are often mixed up. They are not the same.</p> Concept Legacy (File) NIO (Path) Touches filesystem Absolute <code>getAbsoluteFile()</code> <code>toAbsolutePath()</code> No Normalized (no pure normalize, use canonical)* <code>normalize()</code> <code>normalize()</code>: No Canonical / Real <code>getCanonicalFile()</code> <code>toRealPath()</code> Yes <p>Note</p> <p><code>File.getCanonicalFile()</code> and <code>Path.toRealPath()</code> may resolve symlinks and require the path to exist, so they can throw <code>IOException</code>.</p> <p>File does not provide a method for purely syntactic normalization: historically many developers used getCanonicalFile(), but this accesses the filesystem and can fail.</p> <pre><code>import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Path;\n\nFile f = new File(\"a/../data.txt\");\nSystem.out.println(f.getAbsolutePath()); // absolute, may still contain \"..\"\n\ntry {\n    System.out.println(f.getCanonicalPath()); // resolves \"..\", may touch filesystem\n} catch (IOException e) {\n    System.out.println(\"Canonical failed: \" + e.getMessage());\n}\n\nPath p = Path.of(\"a/../data.txt\");\nSystem.out.println(p.toAbsolutePath()); // absolute, may still contain \"..\"\nSystem.out.println(p.normalize()); // purely syntactic\n\ntry {\n    System.out.println(p.toRealPath()); // resolves symlinks, requires existence\n} catch (IOException e) {\n    System.out.println(\"RealPath failed: \" + e.getMessage());\n}\n</code></pre> <p></p>"},{"location":"en/module-08/files-path-api/#33171-normalize","title":"33.1.7.1 <code>normalize()</code>","text":"<p>Removes redundant name elements like <code>.</code> and <code>..</code>.</p> <ul> <li>Purely syntactic</li> <li>Does not check if path exists</li> </ul> <p>Note</p> <p><code>normalize()</code> is purely syntactic, does not check existence, and can produce invalid paths if misused.</p> <p></p>"},{"location":"en/module-08/files-path-api/#3318-quick-comparison-table-creation-conversion","title":"33.1.8 Quick Comparison Table (Creation + Conversion)","text":"Need Legacy (File) NIO (Path) Preferred today Create from string <code>new File(\"x\")</code> <code>Path.of(\"x\")</code> Path Parent + child <code>new File(p, c)</code> <code>Path.of(p, c)</code> or <code>resolve()</code> Path Convert between APIs <code>toPath()</code> <code>toFile()</code> Path-centric Normalize <code>getCanonicalFile()</code> (filesystem-based) <code>normalize()</code> (syntactic only) Path Resolve symlinks Canonical <code>toRealPath()</code> Path"},{"location":"en/module-08/files-path-api/#332-managing-files-and-directories-create-copy-move-replace-compare-delete-legacy-vs-nio","title":"33.2 Managing Files and Directories: Create, Copy, Move, Replace, Compare, Delete (Legacy vs NIO)","text":"<p>This section covers the operations you perform on filesystem entries (files/directories): creating, copying, moving/renaming, replacing, comparing, and deleting. </p> <p>It contrasts legacy <code>java.io.File</code> (and related legacy helpers) with modern <code>java.nio.file</code> (NIO.2).</p> <p></p>"},{"location":"en/module-08/files-path-api/#3321-mental-model-pathlocator-vs-operations","title":"33.2.1 Mental Model: \u201cPath/Locator\u201d vs \u201cOperations\u201d","text":"<p>Both APIs use objects that represent a path, but operations differ:</p> <ul> <li>Legacy: <code>File</code> is both a path wrapper and an operations API (mixed responsibility)</li> <li>NIO: <code>Path</code> is the path; <code>Files</code> performs operations (separation of concerns)</li> </ul> Responsibility Legacy NIO Path representation <code>File</code> <code>Path</code> Filesystem operations <code>File</code> <code>Files</code> Rich error reporting Weak (booleans) Strong (exceptions) <p>Note</p> <p>legacy methods often return <code>boolean</code> (silent failure), while NIO throws <code>IOException</code> with cause.</p> <p></p>"},{"location":"en/module-08/files-path-api/#3322-creating-files-and-directories","title":"33.2.2 Creating Files and Directories","text":"<p>Creating is where the old API is most awkward and the NIO API is most expressive.</p> Task Legacy approach NIO approach Notes Create empty file open+close stream <code>Files.createFile</code> NIO fails if exists Create one directory <code>mkdir</code> <code>Files.createDirectory</code> Parent must exist Create directories recursively <code>mkdirs</code> <code>Files.createDirectories</code> Creates parents <p></p>"},{"location":"en/module-08/files-path-api/#33221-create-a-file","title":"33.2.2.1 Create a File","text":"<p>Legacy has no \u201ccreate empty file\u201d method, so you typically create a file by opening an output stream (side effect).</p> <pre><code>import java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\nFile f = new File(\"created-legacy.txt\");\ntry (FileOutputStream out = new FileOutputStream(f)) {\n    // file is created (or truncated) as a side effect\n}\n</code></pre> <p>NIO provides an explicit creation method.</p> <pre><code>import java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.io.IOException;\n\nPath p = Path.of(\"created-nio.txt\");\nFiles.createFile(p);\n</code></pre> <p>Note</p> <p><code>Files.createFile</code> throws <code>FileAlreadyExistsException</code> if the entry exists.</p> <p></p>"},{"location":"en/module-08/files-path-api/#33222-create-directories","title":"33.2.2.2 Create Directories","text":"<pre><code>import java.io.File;\n\nFile dir1 = new File(\"a/b\");\nboolean ok1 = dir1.mkdir(); // fails if parent \"a\" does not exist\nboolean ok2 = dir1.mkdirs(); // creates parents\n</code></pre> <pre><code>import java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.io.IOException;\n\nPath d = Path.of(\"a/b\");\nFiles.createDirectory(d); // parent must exist\nFiles.createDirectories(d); // creates parents, ok if already exists\n</code></pre> <p>Note</p> <p>Legacy <code>mkdir()/mkdirs()</code> return <code>false</code> on failure without telling why. NIO throws <code>IOException</code>.</p> <p></p>"},{"location":"en/module-08/files-path-api/#3323-copying-files-and-directories","title":"33.2.3 Copying Files and Directories","text":"<p>Legacy copy is usually manual stream-copy (or external libs). NIO has a single, explicit operation.</p> Capability Legacy NIO Copy file contents Manual streams <code>Files.copy</code> Copy into existing target Manual <code>REPLACE_EXISTING</code> option Copy directory tree Manual recursion Manual recursion (but better tools: <code>Files.walk</code> + <code>Files.copy</code>) <p></p>"},{"location":"en/module-08/files-path-api/#33231-copy-a-file-nio","title":"33.2.3.1 Copy a File (NIO)","text":"<pre><code>import java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\nimport java.io.IOException;\n\nPath src = Path.of(\"src.txt\");\nPath dst = Path.of(\"dst.txt\");\n\nFiles.copy(src, dst); // fails if dst exists\nFiles.copy(src, dst, StandardCopyOption.REPLACE_EXISTING);\n</code></pre> <p>Note</p> <p><code>Files.copy</code> throws <code>FileAlreadyExistsException</code> if the target exists and you did not use <code>REPLACE_EXISTING</code>.</p> <p></p>"},{"location":"en/module-08/files-path-api/#33232-manual-copy-legacy-stream-based","title":"33.2.3.2 Manual Copy (Legacy, Stream-Based)","text":"<pre><code>import java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\ntry (FileInputStream in = new FileInputStream(\"src.bin\");\nFileOutputStream out = new FileOutputStream(\"dst.bin\")) {\n\n    byte[] buf = new byte[8192];\n    int n;\n    while ((n = in.read(buf)) != -1) {\n        out.write(buf, 0, n);\n    }\n}\n</code></pre> <p>Note</p> <p>Remember <code>read(byte[])</code> returns the number of bytes read; you must write only that count, not the full buffer.</p> <p></p>"},{"location":"en/module-08/files-path-api/#3324-moving-renaming-and-replacing","title":"33.2.4 Moving / Renaming and Replacing","text":"<p>In both APIs, rename/move is \u201cmetadata-level\u201d when possible, but can behave like copy+delete across filesystems. NIO makes this explicit via options.</p> Operation Legacy NIO Rename/move <code>File.renameTo</code> <code>Files.move</code> Replace existing Unreliable <code>REPLACE_EXISTING</code> Atomic move Not supported <code>ATOMIC_MOVE</code> (if supported) <p></p>"},{"location":"en/module-08/files-path-api/#33241-legacy-rename-common-pitfall","title":"33.2.4.1 Legacy Rename (Common Pitfall)","text":"<pre><code>import java.io.File;\n\nFile from = new File(\"old.txt\");\nFile to = new File(\"new.txt\");\n\nboolean ok = from.renameTo(to); // may fail silently\nSystem.out.println(ok);\n</code></pre> <p>Note</p> <ul> <li><code>renameTo</code> is notoriously platform-dependent and returns only <code>boolean</code>.</li> <li>It may fail because target exists, file is open, permissions, or cross-filesystem move.</li> </ul> <p></p>"},{"location":"en/module-08/files-path-api/#33242-nio-move-preferred","title":"33.2.4.2 NIO Move (Preferred)","text":"<pre><code>import java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\nimport java.io.IOException;\n\nPath from = Path.of(\"old.txt\");\nPath to = Path.of(\"new.txt\");\n\nFiles.move(from, to); // fails if target exists\nFiles.move(from, to, StandardCopyOption.REPLACE_EXISTING);\n</code></pre> <p>Note</p> <p><code>Files.move</code> throws <code>FileAlreadyExistsException</code> when the target exists and <code>REPLACE_EXISTING</code> is not specified.</p> <p></p>"},{"location":"en/module-08/files-path-api/#3325-comparing-paths-and-files","title":"33.2.5 Comparing Paths and Files","text":"<p>Comparing locators can mean: string/path equality, normalized/canonical equality, or \u201csame file on disk\u201d. </p> <p>The APIs differ here significantly.</p> Comparison goal Legacy NIO Same path text <code>File.equals</code> <code>Path.equals</code> Normalize path <code>getCanonicalFile</code> <code>normalize</code> Same file/resource on disk weak (canonical heuristic) <code>Files.isSameFile</code> <p></p>"},{"location":"en/module-08/files-path-api/#33251-equality-vs-same-file","title":"33.2.5.1 Equality vs Same File","text":"<p>Two different path strings can refer to the same file.</p> <pre><code>import java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.io.IOException;\n\nPath p1 = Path.of(\"a/../data.txt\");\nPath p2 = Path.of(\"data.txt\");\n\nSystem.out.println(p1.equals(p2)); // false (different path text)\nSystem.out.println(p1.normalize().equals(p2.normalize())); // might still be false if relative\n\ntry {\n    System.out.println(Files.isSameFile(p1, p2)); // may be true, may throw if not accessible\n} catch (IOException e) {\n    System.out.println(\"isSameFile failed: \" + e.getMessage());\n}\n</code></pre> <p>Note</p> <p><code>Files.isSameFile</code> may access the filesystem and can throw <code>IOException</code> (permission issues, missing files, etc.).</p> <p></p>"},{"location":"en/module-08/files-path-api/#3326-deleting-files-and-directories","title":"33.2.6 Deleting Files and Directories","text":"<p>Deletion is simple in concept but has important edge cases: non-empty directories, missing targets, and error reporting differences.</p> Task Legacy NIO Behavior if missing Delete file/dir <code>File.delete</code> <code>Files.delete</code> Legacy false, NIO exception Delete if exists No direct (check+delete) <code>Files.deleteIfExists</code> returns boolean Delete non-empty dir Manual recursion Manual recursion (walk) Both require recursion <p></p>"},{"location":"en/module-08/files-path-api/#33261-legacy-delete","title":"33.2.6.1 Legacy Delete","text":"<pre><code>import java.io.File;\n\nFile f = new File(\"x.txt\");\nboolean ok = f.delete(); // false if not deleted\nSystem.out.println(ok);\n</code></pre> <p>Note</p> <p>Legacy <code>delete()</code> fails (returns false) for a non-empty directory and often provides no reason.</p> <p></p>"},{"location":"en/module-08/files-path-api/#33262-nio-delete-and-delete-if-exists","title":"33.2.6.2 NIO Delete and Delete-If-Exists","text":"<pre><code>import java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.NoSuchFileException;\nimport java.nio.file.DirectoryNotEmptyException;\nimport java.io.IOException;\n\nPath p = Path.of(\"x.txt\");\n\ntry {\n    Files.delete(p);\n} catch (NoSuchFileException e) {\n    System.out.println(\"Missing: \" + e.getFile());\n} catch (DirectoryNotEmptyException e) {\n    System.out.println(\"Directory not empty: \" + e.getFile());\n} catch (IOException e) {\n    System.out.println(\"Delete failed: \" + e.getMessage());\n}\n\nboolean deleted = Files.deleteIfExists(p);\nSystem.out.println(deleted);\n</code></pre> <p>Note</p> <p>Certification tip: <code>Files.delete</code> throws <code>NoSuchFileException</code> if missing, while <code>deleteIfExists</code> returns <code>false</code>.</p> <p></p>"},{"location":"en/module-08/files-path-api/#3327-recursively-copying-deleting-directory-trees-nio-pattern","title":"33.2.7 Recursively Copying / Deleting Directory Trees (NIO Pattern)","text":"<p>NIO doesn\u2019t provide a single \u201ccopyTree/deleteTree\u201d method, but the standard approach uses <code>Files.walk</code> or <code>Files.walkFileTree</code>. </p> <pre><code>import java.io.IOException;\nimport java.nio.file.*;\nimport java.nio.file.attribute.BasicFileAttributes;\n\nPath root = Path.of(\"dirToDelete\");\n\nFiles.walkFileTree(root, new SimpleFileVisitor&lt;Path&gt;() {\n    @Override\n    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n        Files.delete(file);\n        return FileVisitResult.CONTINUE;\n    }\n\n    @Override\n    public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n        if (exc != null) throw exc;\n        Files.delete(dir);\n        return FileVisitResult.CONTINUE;\n    }\n});\n</code></pre> <p>Note</p> <p>Deleting a directory tree requires deleting files first, then directories (post-order). This is a common reasoning question.</p> <p></p>"},{"location":"en/module-08/files-path-api/#3328-summary-checklist","title":"33.2.8 Summary Checklist","text":"<ul> <li>Prefer <code>Files.createFile/createDirectory/createDirectories</code> over legacy workarounds</li> <li><code>File.renameTo</code> is unreliable; prefer <code>Files.move</code> with options</li> <li><code>Files.copy/move</code> throw <code>FileAlreadyExistsException</code> unless <code>REPLACE_EXISTING</code> is used</li> <li><code>Files.delete</code> throws; <code>Files.deleteIfExists</code> returns boolean</li> <li><code>Files.isSameFile</code> can throw <code>IOException</code> and may touch the filesystem</li> <li>Non-empty directory deletion requires recursion (both APIs)</li> </ul>"},{"location":"en/module-08/files-path/","title":"32. Files and Paths Fundamentals","text":""},{"location":"en/module-08/files-path/#table-of-contents","title":"Table of Contents","text":"<ul> <li>32.1 Conceptual Model Filesystem, Files, Directories, Links and IO-Targets</li> <li>32.2 Filesystem \u2013 The Global Abstraction</li> <li>32.3 Path \u2013 Locating an Entry in a Filesystem</li> <li>32.4 Files \u2013 Persistent Data Containers</li> <li>32.5 Directories \u2013 Structural Containers</li> <li>32.6 Links \u2013 Indirection Mechanisms<ul> <li>32.6.1 Hard Links</li> <li>32.6.2 Symbolic Soft Links</li> </ul> </li> <li>32.7 Other Filesystem Entry Types</li> <li>32.8 How Java IO Interacts with These Concepts</li> <li>32.9 Core Conceptual Pitfalls</li> <li>32.10 Why Path and Files Exist IO-Context</li> <li>32.11 Is File legacy-apis both a path and a file-operations api<ul> <li>32.11.1 What File Really Is</li> <li>32.11.2 Path-like Responsibilities</li> <li>32.11.3 Filesystem Operation Responsibilities</li> <li>32.11.4 What File Is NOT</li> <li>32.11.5 The Old dual role</li> <li>32.11.6 How NIO Fixed This</li> <li>32.11.7 Summary</li> </ul> </li> <li>32.12 Path Is a Description Not a Resource</li> <li>32.13 Absolute vs Relative Paths<ul> <li>32.13.1 Absolute Paths</li> <li>32.13.2 Relative Paths</li> </ul> </li> <li>32.14 Filesystem Awareness and Separators<ul> <li>32.14.1 FileSystem</li> <li>32.14.2 Path Separators</li> </ul> </li> <li>32.15 What Files Actually Do and What They Don\u2019t<ul> <li>32.15.1 Files DO</li> <li>32.15.2 Files DO NOT</li> </ul> </li> <li>32.16 Error Handling Philosophy Old-vs-NIO</li> <li>32.17 Common Misconceptions</li> </ul> <p>This section focuses on <code>Path</code>, <code>File</code>, <code>Files</code>, and related classes, explaining why they exist, what problems they solve, and which are the differences between  legacy <code>java.io APIs</code> and <code>NIO v.2</code> (new I/O APIs), with special attention to filesystem semantics, path resolution, and common misconceptions.</p> <p></p>"},{"location":"en/module-08/files-path/#321-conceptual-model-filesystem-files-directories-links-and-io-targets","title":"32.1 Conceptual Model: Filesystem, Files, Directories, Links, and I/O Targets","text":"<p>Before understanding Java I/O APIs, it is essential to understand what they interact with. </p> <p>Java I/O does not operate in a vacuum: it interacts with filesystem abstractions provided by the operating system. </p> <p>This section defines those concepts independently of Java, then explains how Java I/O maps onto them and what problems are being solved.</p> <p></p>"},{"location":"en/module-08/files-path/#322-filesystem-the-global-abstraction","title":"32.2 Filesystem \u2013 The Global Abstraction","text":"<p>A <code>filesystem</code> is a structured mechanism provided by an operating system to organize, store, retrieve, and manage data on persistent storage devices.</p> <p>At a conceptual level, a filesystem solves several fundamental problems:</p> <ul> <li>Persistent storage beyond program execution</li> <li>Hierarchical organization of data</li> <li>Naming and locating data</li> <li>Access control and permissions</li> <li>Concurrency and consistency guarantees</li> </ul> <p>In Java NIO, a filesystem is represented by the <code>FileSystem</code> abstraction, typically obtained via <code>FileSystems.getDefault()</code> for the OS filesystem.</p> Aspect Meaning Persistence Data survives JVM termination Scope OS-managed, not JVM-managed Multiplicity Multiple filesystems may exist Examples Disk FS, ZIP FS, in-memory FS <p>Note</p> <p>Java does not implement filesystems; it adapts to filesystem implementations provided by the OS or custom providers.</p> <p></p>"},{"location":"en/module-08/files-path/#323-path-locating-an-entry-in-a-filesystem","title":"32.3 Path \u2013 Locating an Entry in a Filesystem","text":"<p>A <code>path</code> is a logical locator, not a resource. </p> <p>It describes where something would be in a filesystem, not what it is or whether it exists.</p> <p>A <code>path</code> solves the problem of <code>addressing</code>:</p> <ul> <li>Identifies a location</li> <li>Is interpreted within a specific filesystem</li> <li>May or may not correspond to an existing entry</li> </ul> Property Path Existence-aware No Type-aware No Immutable Yes OS resource No <p>Note</p> <p>In Java, <code>Path</code> represents potential filesystem entries, not actual ones.</p> <p></p>"},{"location":"en/module-08/files-path/#324-files-persistent-data-containers","title":"32.4 Files \u2013 Persistent Data Containers","text":"<p>A <code>file</code> is a filesystem entry whose primary role is to store data. </p> <p>The filesystem treats files as opaque byte sequences.</p> <p>Problems solved by files:</p> <ul> <li>Durable storage of information</li> <li>Sequential and random access to data</li> <li>Sharing data between processes</li> </ul> <p>From the filesystem perspective, a file has:</p> <ul> <li>Content (bytes)</li> <li>Metadata (size, timestamps, permissions)</li> <li>A location (path)</li> </ul> Aspect Description Content Byte-oriented Interpretation Application-defined Lifetime Independent of processes Java access Streams, channels, Files methods <p>Note</p> <p><code>Text</code> vs <code>binary</code> is not a filesystem concept; it is an application-level interpretation.</p> <p></p>"},{"location":"en/module-08/files-path/#325-directories-structural-containers","title":"32.5 Directories \u2013 Structural Containers","text":"<p>A <code>directory (or folder)</code> is a filesystem entry whose purpose is to organize other entries.</p> <p><code>Directories</code> solve the problem of scalability and organization:</p> <ul> <li>Group related entries</li> <li>Enable hierarchical naming</li> <li>Support efficient lookup</li> </ul> Aspect Directory Stores data No (stores references) Contains Files, directories, links Read/write Structural, not content-based Java access Files.list, Files.walk <p>Note</p> <p>A directory is not a file with content, even if both share common metadata.</p> <p></p>"},{"location":"en/module-08/files-path/#326-links-indirection-mechanisms","title":"32.6 Links \u2013 Indirection Mechanisms","text":"<p>A <code>link</code> is a filesystem entry that refers to another entry. </p> <p>Links solve the problem of indirection and reuse.</p> <p></p>"},{"location":"en/module-08/files-path/#3261-hard-links","title":"32.6.1 Hard Links","text":"<p>A <code>hard link</code> is an additional name for the same underlying data.</p> <ul> <li>Multiple paths point to the same file data</li> <li>Deletion occurs only when all links are removed</li> </ul> <p></p>"},{"location":"en/module-08/files-path/#3262-symbolic-soft-links","title":"32.6.2 Symbolic (Soft) Links","text":"<p>A <code>symbolic link</code> is a special file containing a path to another entry:</p> <ul> <li>May point to non-existing targets</li> <li>Resolved at access time</li> </ul> Link Type Refers To Can Dangle Java Handling Hard Data No Transparent Symbolic Path Yes Explicit control <p>Note</p> <p>Java NIO exposes link behavior explicitly via <code>LinkOption</code>.</p> <p>In many common filesystems, Java code cannot create hard links in a fully portable way, while symbolic links are directly supported via <code>Files.createSymbolicLink(...)</code> (where permitted by the OS / permissions).</p> <p></p>"},{"location":"en/module-08/files-path/#327-other-filesystem-entry-types","title":"32.7 Other Filesystem Entry Types","text":"<p>Some filesystem entries are not data containers but interaction endpoints.</p> Type Purpose Device file Interface to hardware FIFO / Pipe Inter-process communication Socket file Network communication <p>Note</p> <p>Java I/O may interact with these entries, but behavior is platform-dependent.</p> <p></p>"},{"location":"en/module-08/files-path/#328-how-java-io-interacts-with-these-concepts","title":"32.8 How Java I/O Interacts with These Concepts","text":"<p>Java I/O APIs operate at different abstraction layers:</p> <ul> <li><code>Path</code> / <code>File</code> (legacy API) \u2192 describes a filesystem entry</li> <li><code>File</code> (legacy API) / <code>Files</code> \u2192 queries or modifies filesystem state</li> <li><code>Streams</code> / <code>Channels</code> \u2192 move bytes or characters</li> </ul> Java API Role <code>Path</code> Addressing <code>File</code> (legacy APIs) Addressing / filesystem operations <code>Files</code> Filesystem operations <code>InputStream</code> / <code>Reader</code> Reading data <code>OutputStream</code> / <code>Writer</code> Writing data <code>Channel</code> / <code>SeekableByteChannel</code> Advanced / random access <p>Note</p> <p>No Java API \u201cis\u201d a file; APIs mediate access to filesystem-managed resources.</p> <p></p>"},{"location":"en/module-08/files-path/#329-core-conceptual-pitfalls","title":"32.9 Core Conceptual Pitfalls","text":"<ul> <li>Confusing paths with files</li> <li>Assuming paths imply existence</li> <li>Assuming directories store file data</li> <li>Assuming links are always resolved automatically</li> </ul> <p>Note</p> <p>Always separate location, structure, and data flow when reasoning about I/O.</p> <p></p>"},{"location":"en/module-08/files-path/#3210-why-path-and-files-exist-io-context","title":"32.10 Why Path and Files Exist (I/O Context)","text":"<p>Classic <code>java.io</code> mixed three different concerns into poorly separated APIs:</p> <ul> <li>Path representation (where is the resource?)</li> <li>Filesystem interaction (does it exist? what type?)</li> <li>Data access (reading/writing bytes or characters)</li> </ul> <p>The NIO.2 design (Java 7+) deliberately separates these concerns:</p> <ul> <li><code>Path</code> \u2192 describes a location</li> <li><code>Files</code> \u2192 performs filesystem operations</li> <li><code>Streams / Channels</code> \u2192 move data</li> </ul> <p>Note</p> <p>A <code>Path</code> never opens a file and never touches the disk by itself.</p> <p></p>"},{"location":"en/module-08/files-path/#3211-is-file-legacy-apis-both-a-path-and-a-file-operations-api","title":"32.11 Is <code>File</code> (legacy APIs) both a <code>path</code> and a <code>file-operations</code> API?","text":"<p>Yes \u2014 in the old I/O API, <code>java.io.File</code> confusingly plays two roles at the same time, and this design is exactly one of the reasons <code>java.nio.file</code> was introduced.</p> <p>Short Answer</p> <ul> <li><code>File</code> represents a filesystem path</li> <li><code>File</code> also exposes filesystem operations</li> <li>It does not represent an open file, nor file contents</li> </ul> <p>Note</p> <p>This mixing of responsibilities is considered a design flaw in hindsight.</p> <p></p>"},{"location":"en/module-08/files-path/#32111-what-file-really-is","title":"32.11.1 What <code>File</code> Really Is","text":"<p>Conceptually, <code>File</code> is closer to what we now call a <code>Path</code>, but with added operational methods.</p> Aspect java.io.File Represents a location Yes Opens a file No Reads / writes data No Queries filesystem Yes Modifies filesystem Yes Holds OS handle No <p>Note</p> <p>A <code>File</code> object can exist even if the file does not.</p> <p></p>"},{"location":"en/module-08/files-path/#32112-path-like-responsibilities","title":"32.11.2 Path-like Responsibilities","text":"<p><code>File</code> behaves like a path abstraction because it:</p> <ul> <li>Encapsulates a filesystem pathname (absolute or relative)</li> <li>Can be resolved against the working directory</li> <li>Can be converted to absolute or canonical form</li> </ul> <p>Examples:</p> <pre><code>File f = new File(\"data.txt\"); // relative path\nFile abs = f.getAbsoluteFile(); // absolute path\nFile canon = f.getCanonicalFile(); // normalized + resolved\n</code></pre> <p></p>"},{"location":"en/module-08/files-path/#32113-filesystem-operation-responsibilities","title":"32.11.3 Filesystem Operation Responsibilities","text":"<p>At the same time, <code>File</code> exposes methods that touch the filesystem:</p> <ul> <li>exists()</li> <li>isFile(), isDirectory()</li> <li>length()</li> <li>delete()</li> <li>mkdir(), mkdirs()</li> <li>list(), listFiles()</li> </ul> <p>Note</p> <p>Most of these methods return <code>boolean</code> instead of throwing <code>IOException</code>, which hides failure causes.</p> <p></p>"},{"location":"en/module-08/files-path/#32114-what-file-is-not","title":"32.11.4 What <code>File</code> Is NOT","text":"<ul> <li>Not an open file descriptor</li> <li>Not a stream</li> <li>Not a channel</li> <li>Not a container of file data</li> </ul> <p>You must still use streams or readers/writers to access contents.</p> <p></p>"},{"location":"en/module-08/files-path/#32115-the-old-dual-role","title":"32.11.5 The Old dual role","text":"<p>The dual role of <code>File</code> caused several issues:</p> <ul> <li>Mixed concerns (path + operations)</li> <li>Poor error handling (boolean instead of exceptions)</li> <li>Weak support for links and multiple filesystems</li> <li>Platform-dependent behavior</li> </ul> <p></p>"},{"location":"en/module-08/files-path/#32116-how-nio-fixed-this","title":"32.11.6 How NIO Fixed This","text":"<p>NIO.2 explicitly separates responsibilities:</p> Responsibility Old API NIO API <code>Path representation</code> <code>File</code> <code>Path</code> <code>Filesystem operations</code> <code>File</code> <code>Files</code> <code>Data access</code> Streams Streams / Channels <p>Note</p> <p>This separation is one of the most important conceptual improvements in Java I/O.</p> <p></p>"},{"location":"en/module-08/files-path/#32117-summary","title":"32.11.7 Summary","text":"<ul> <li><code>File</code> represents a path AND performs filesystem operations</li> <li>It never reads or writes file contents</li> <li>It never opens a file</li> <li><code>Path</code> + <code>Files</code> is the modern replacement</li> </ul>"},{"location":"en/module-08/files-path/#3212-path-is-a-description-not-a-resource","title":"32.12 Path Is a Description, Not a Resource","text":"<p>A <code>Path</code> is a pure abstraction representing a sequence of name elements in a filesystem.</p> <ul> <li>It does NOT imply existence</li> <li>It does NOT imply accessibility</li> <li>It does NOT hold a file descriptor</li> </ul> <p>This is fundamentally different from streams or channels.</p> Concept Path Stream / Channel <code>Opens resource</code> No Yes <code>Touches disk</code> No Yes <code>Holds OS handle</code> No Yes <code>Immutable</code> Yes No <p>Note</p> <p>Creating a Path cannot throw <code>IOException</code> because no I/O happens.</p> <p></p>"},{"location":"en/module-08/files-path/#3213-absolute-vs-relative-paths","title":"32.13 Absolute vs Relative Paths","text":"<p>Understanding path resolution is essential.</p> <p></p>"},{"location":"en/module-08/files-path/#32131-absolute-paths","title":"32.13.1 Absolute Paths","text":"<p>An absolute path fully identifies a location from the filesystem root.</p> <ul> <li>Platform-dependent root</li> <li>Independent of JVM working directory</li> </ul> Platform Example Absolute Path Unix <code>/home/user/file.txt</code> Windows <code>C:\\Users\\User\\file.txt</code> <p>Important</p> <ul> <li>A path starting with a forward slash <code>(/)</code> (Unix-like) or with a drive letter such as <code>C:</code> (Windows) is typically considered an absolute path.</li> <li>The symbol <code>.</code> is a reference to the current directory while <code>..</code> is a reference to its parent directory. On Windows, a path like <code>\\dir\\file.txt</code> (without drive letter) is rooted on the current drive, not fully qualified with drive + path.</li> </ul> <p>Example:</p> <pre><code>/dirA/dirB/../dirC/./content.txt\n\nis equivalent to:\n\n/dirA/dirC/content.txt\n\n// in this example the symbols were redundant and unnecessary\n</code></pre> <p></p>"},{"location":"en/module-08/files-path/#32132-relative-paths","title":"32.13.2 Relative Paths","text":"<p>A relative path is resolved against the JVM current working directory.</p> <ul> <li>Depends on where JVM was launched</li> <li>Common source of bugs</li> </ul> <p>Note</p> <p>The working directory is typically available via <code>System.getProperty(\"user.dir\")</code>.</p> <p>Example:</p> <pre><code>dirB/dirC/content.txt\n</code></pre> <p></p>"},{"location":"en/module-08/files-path/#3214-filesystem-awareness-and-separators","title":"32.14 Filesystem Awareness and Separators","text":"<p>NIO introduces filesystem abstraction, which was mostly absent in java.io.</p> <p></p>"},{"location":"en/module-08/files-path/#32141-filesystem","title":"32.14.1 FileSystem","text":"<p>A <code>FileSystem</code> represents a concrete filesystem implementation.</p> <ul> <li>Default filesystem corresponds to OS filesystem</li> <li>Other filesystems possible (ZIP, memory, network)</li> </ul> <p>Note</p> <p>Paths are always associated with exactly ONE FileSystem.</p> <p></p>"},{"location":"en/module-08/files-path/#32142-path-separators","title":"32.14.2 Path Separators","text":"<p>Separators differ across platforms, but <code>Path</code> abstracts them.</p> Aspect java.io.File java.nio.file.Path Separator String-based Filesystem-aware Portability Manual handling Automatic Comparison Error-prone Safer <p>Note</p> <p>Hardcoding <code>\"/\"</code> or <code>\"\\\\\"</code> is discouraged; <code>Path</code> handles this automatically.</p> <p></p>"},{"location":"en/module-08/files-path/#3215-what-files-actually-do-and-what-they-dont","title":"32.15 What Files Actually Do (and What They Don\u2019t)","text":"<p>The <code>Files</code> class performs real I/O operations.</p> <p></p>"},{"location":"en/module-08/files-path/#32151-files-do","title":"32.15.1 Files DO","text":"<ul> <li>Open files indirectly (via streams / channels returned by its methods)</li> <li>Create and delete filesystem entries</li> <li>Throw checked exceptions on failure</li> <li>Respect filesystem permissions</li> </ul>"},{"location":"en/module-08/files-path/#32152-files-do-not","title":"32.15.2 Files DO NOT","text":"<ul> <li>Maintain open resources after method returns (except streams)</li> <li>Store file contents internally</li> <li>Guarantee atomicity unless specified</li> <li>Maintain a persistent handle to open files (streams/channels own the handle instead)</li> </ul> <p>Note</p> <p>Methods returning streams (e.g. <code>Files.lines()</code>) DO keep the file open until the stream is closed.</p> <p></p>"},{"location":"en/module-08/files-path/#3216-error-handling-philosophy-old-vs-nio","title":"32.16 Error Handling Philosophy: Old vs NIO","text":"<p>A major conceptual difference lies in error reporting.</p> Aspect <code>java.io.File</code> <code>java.nio.file.Files</code> Error signaling boolean / <code>null</code> <code>IOException</code> Diagnostics Poor Rich Race awareness Weak Improved Preference Discouraged Preferred <p></p>"},{"location":"en/module-08/files-path/#3217-common-misconceptions","title":"32.17 Common Misconceptions","text":"<ul> <li>\u201cPath represents a file\u201d \u2192 false</li> <li>\u201cnormalize checks existence\u201d \u2192 false</li> <li>\u201cFiles.readAllLines streams data\u201d \u2192 false</li> <li>\u201cRelative paths are portable\u201d \u2192 false</li> <li>\u201cCreating a Path may fail due to permissions\u201d \u2192 false</li> </ul> <p>Note</p> <p>Many NIO methods that sound \u201csafe\u201d are purely syntactic (like <code>normalize</code> or <code>resolve</code>): they do not touch the filesystem and cannot detect missing files.</p>"},{"location":"en/module-08/io-streams-api/","title":"35. Java I/O APIs (Legacy and NIO)","text":""},{"location":"en/module-08/io-streams-api/#table-of-contents","title":"Table of Contents","text":"<ul> <li>35.1 Legacy java.io \u2014 Design, Behavior, and Subtleties<ul> <li>35.1.1 The Stream Abstraction</li> <li>35.1.2 Stream Chaining and the Decorator Pattern</li> <li>35.1.3 Blocking I/O: What It Means</li> <li>35.1.4 Resource Management: close(), flush(), and Why They Exist</li> <li>35.1.5 finalize(): Why It Exists and Why It Fails</li> <li>35.1.6 available(): Purpose and Misuse</li> <li>35.1.7 mark() and reset(): Controlled Backtracking</li> <li>35.1.8 Readers, Writers, and Character Encoding</li> <li>35.1.9 File vs FileDescriptor</li> </ul> </li> <li>35.2 java.nio \u2014 Buffers, Channels, and Non-Blocking IO<ul> <li>35.2.1 From Streams to Buffers: A Conceptual Shift</li> <li>35.2.2 Buffers: Purpose and Structure</li> <li>35.2.3 Buffer Lifecycle: Write \u2192 Flip \u2192 Read</li> <li>35.2.4 clear() vs compact()</li> <li>35.2.5 Heap Buffers vs Direct Buffers</li> <li>35.2.6 Channels: What They Are</li> <li>35.2.7 Blocking vs Non-Blocking Channels</li> <li>35.2.8 Scatter/Gather I/O</li> <li>35.2.9 Selectors: Multiplexing Non-Blocking I/O</li> <li>35.2.10 When to Use java.nio</li> </ul> </li> <li>35.3 java.nio.file (NIO.2) \u2014 File and Directory Operations (Legacy vs Modern)<ul> <li>35.3.1 Existence and Accessibility Checks</li> <li>35.3.2 Creating Files and Directories</li> <li>35.3.3 Deleting Files and Directories</li> <li>35.3.4 Copying Files and Directories</li> <li>35.3.5 Moving and Renaming</li> <li>35.3.6 Reading and Writing Text and Bytes (Files Enhancements)</li> <li>35.3.7 newInputStream/newOutputStream and newBufferedReader/newBufferedWriter</li> <li>35.3.8 Listing Directories and Traversing Trees</li> <li>35.3.9 Searching and Filtering</li> <li>35.3.10 Attributes: Reading, Writing, and Views</li> <li>35.3.11 Symbolic Links and Link Following</li> <li>35.3.12 Summary: Why Files Is an Enhancement</li> </ul> </li> <li>35.4 Serialization \u2014 Object Streams, Compatibility, and Traps<ul> <li>35.4.1 What Serialization Does (and What It Does Not)</li> <li>35.4.2 The Two Main Marker Interfaces</li> <li>35.4.3 Basic Example: Writing and Reading an Object</li> <li>35.4.4 Object Graphs, References, and Identity</li> <li>35.4.5 serialVersionUID: The Versioning Key</li> <li>35.4.6 transient and static Fields</li> <li>35.4.7 Non-Serializable Fields and NotSerializableException</li> <li>35.4.8 Constructors and Serialization</li> <li>35.4.9 Custom Serialization Hooks: writeObject and readObject</li> <li>35.4.10 Example Use Case: Restoring a transient Derived Field</li> <li>35.4.11 Externalizable: Full Control (and Full Responsibility)</li> <li>35.4.12 readObject() Security Considerations</li> <li>35.4.13 Common Traps and Practical Tips</li> <li>35.4.14 When to Use (or Avoid) Java Serialization</li> </ul> </li> </ul>"},{"location":"en/module-08/io-streams-api/#351-legacy-javaio-design-behavior-and-subtleties","title":"35.1 Legacy java.io \u2014 Design, Behavior, and Subtleties","text":"<p>The legacy <code>java.io</code> API is the original I/O abstraction introduced in Java 1.0.</p> <p>It is stream-oriented, blocking, and closely mapped to operating system I/O concepts.</p> <p>Although newer APIs exist, <code>java.io</code> remains fundamental: many higher-level APIs build on it, and it is still heavily used.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#3511-the-stream-abstraction","title":"35.1.1 The Stream Abstraction","text":"<p>A <code>stream</code> represents a continuous flow of data between a source and a destination.</p> <p>In <code>java.io</code>, streams are unidirectional: they are either input or output.</p> Stream Direction Data unit Category <code>InputStream</code> Input Bytes (8-bit) Byte stream <code>OutputStream</code> Output Bytes (8-bit) Byte stream <code>Reader</code> Input Characters Character stream <code>Writer</code> Output Characters Character stream <p><code>Streams</code> hide the concrete origin of data (file, network, memory) and expose a uniform read/write interface.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#3512-stream-chaining-and-the-decorator-pattern","title":"35.1.2 Stream Chaining and the Decorator Pattern","text":"<p>Most java.io streams are designed to be combined.</p> <p>Each wrapper adds behavior without changing the underlying data source.</p> <pre><code>InputStream in =\n    new BufferedInputStream(\n        new FileInputStream(\"data.bin\"));\n</code></pre> <p>In this example: - <code>FileInputStream</code> performs the actual file access - <code>BufferedInputStream</code> adds an in-memory buffer</p> <p>Note</p> <p>This design is known as the Decorator Pattern.</p> <p>It allows features to be layered dynamically.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#3513-blocking-io-what-it-means","title":"35.1.3 Blocking I/O: What It Means","text":"<p>All legacy <code>java.io</code> streams are blocking.</p> <p>This means a thread performing I/O may be suspended by the operating system.</p> <p>For example, when calling <code>read()</code>: - If data is available, it is returned immediately - If no data is available, the thread waits - If end-of-stream is reached, -1 is returned</p> <p>Note</p> <p>Blocking behavior simplifies programming but limits scalability.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#3514-resource-management-close-flush-and-why-they-exist","title":"35.1.4 Resource Management: <code>close()</code>, <code>flush()</code>, and Why They Exist","text":"<p>Streams often encapsulate native operating system resources such as <code>file descriptors</code> or <code>socket handles</code>.</p> <p>These resources are limited and must be released explicitly.</p> Method Purpose <code>flush()</code> Writes buffered data to the destination <code>close()</code> Flushes and releases the resource <pre><code>try (OutputStream out = new FileOutputStream(\"file.bin\")) {\n    out.write(42);\n} // close() called automatically\n</code></pre> <p>Note</p> <p>Failing to close streams may cause data loss or resource exhaustion.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#3515-finalize-why-it-exists-and-why-it-fails","title":"35.1.5 <code>finalize()</code>: Why It Exists and Why It Fails","text":"<p>Early Java attempted to automate resource cleanup using finalization.</p> <p>The <code>finalize()</code> method was called by the garbage collector before reclaiming memory.</p> <p>However, garbage collection timing is unpredictable.</p> Aspect finalize() Execution time Unspecified Reliability Low Current status Deprecated <p>Note</p> <p><code>finalize()</code> must never be used for I/O cleanup; it is deprecated and unsafe.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#3516-available-purpose-and-misuse","title":"35.1.6 <code>available()</code>: Purpose and Misuse","text":"<p>The <code>available()</code> method estimates how many bytes can be read without blocking.</p> <p>It does not report total remaining data.</p> <p>Typical use cases include: - Avoiding blocking in UI or protocol parsing - Sizing temporary buffers</p> <pre><code>if (in.available() &gt; 0) {\n    in.read(buffer);\n}\n</code></pre> <p>Note</p> <p><code>available()</code> must not be used to detect end-of-file. Only <code>read()</code> returning -1 signals EOF.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#3517-mark-and-reset-controlled-backtracking","title":"35.1.7 <code>mark()</code> and <code>reset()</code>: Controlled Backtracking","text":"<p>Some input streams allow marking a position and returning to it later.</p> <pre><code>BufferedInputStream in = new BufferedInputStream(...);\nin.mark(1024);\n// read ahead\nin.reset();\n</code></pre> Stream markSupported() <code>FileInputStream</code> No <code>BufferedInputStream</code> Yes <code>ByteArrayInputStream</code> Yes <p></p>"},{"location":"en/module-08/io-streams-api/#3518-readers-writers-and-character-encoding","title":"35.1.8 Readers, Writers, and Character Encoding","text":"<p><code>Reader</code> and <code>Writer</code> operate on <code>characters</code>, not bytes.</p> <p>This requires a <code>character encoding</code>.</p> <p>If no charset is specified, the platform default is used.</p> <pre><code>new FileReader(\"file.txt\"); // platform default encoding\n</code></pre> <p>Note</p> <p>Relying on the platform default charset leads to non-portable bugs.</p> <p>Always specify a charset explicitly.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#3519-file-vs-filedescriptor","title":"35.1.9 File vs FileDescriptor","text":"<p><code>File</code> represents a <code>path</code> in the filesystem.</p> <p>It does not represent an open resource.</p> <p>FileDescriptor represents a native OS handle to an open file or stream.</p> Class Represents Owns OS handle? <code>File</code> Filesystem path No <code>FileDescriptor</code> Native OS file handle Yes <p>Note</p> <p>Multiple streams may share the same FileDescriptor.</p> <p>Closing one closes the underlying resource for all.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#352-javanio-buffers-channels-and-non-blocking-io","title":"35.2 <code>java.nio</code> \u2014 Buffers, Channels, and Non-Blocking I/O","text":"<p>The <code>java.nio</code> API (New I/O) was introduced to address limitations of legacy <code>java.io</code>.</p> <p>It provides a lower-level, more explicit model of I/O that maps closely to modern operating systems.</p> <p>At its core, <code>java.nio</code> is built around three concepts: - <code>Buffers</code> \u2014 explicit memory containers - <code>Channels</code> \u2014 bidirectional data connections - <code>Selectors</code> \u2014 multiplexing non-blocking I/O</p> <p></p>"},{"location":"en/module-08/io-streams-api/#3521-from-streams-to-buffers-a-conceptual-shift","title":"35.2.1 From Streams to Buffers: A Conceptual Shift","text":"<p>Legacy streams hide memory management from the programmer.</p> <p>In contrast, <code>NIO</code> makes memory explicit through buffers.</p> Aspect java.io java.nio Data model Stream-based (push) Buffer-based (pull from buffers) Memory Hidden inside streams Explicit via buffers Control Simple, coarse-grained More granular and configurable <p>With NIO, the application controls when data is read into memory and how it is consumed.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#3522-buffers-purpose-and-structure","title":"35.2.2 Buffers: Purpose and Structure","text":"<p>A <code>buffer</code> is a fixed-size, typed container for data.</p> <p>All NIO I/O operations read from or write to buffers.</p> <p>The most common buffer is ByteBuffer.</p> <pre><code>ByteBuffer buffer = ByteBuffer.allocate(1024);\n</code></pre> Property Meaning <code>capacity</code> Total size of the buffer <code>position</code> Current read/write index <code>limit</code> Boundary of readable or writable data <p></p>"},{"location":"en/module-08/io-streams-api/#3523-buffer-lifecycle-write-flip-read","title":"35.2.3 Buffer Lifecycle: Write \u2192 Flip \u2192 Read","text":"<p><code>Buffers</code> have a strict <code>usage lifecycle</code>.</p> <p>Misunderstanding it is a common source of bugs.</p> <p>Typical sequence: - Write data into the buffer - <code>flip()</code> to switch to read mode - Read data from the buffer - <code>clear()</code> or <code>compact()</code> to reuse</p> <pre><code>ByteBuffer buffer = ByteBuffer.allocate(16);\n\nbuffer.put((byte) 1);\nbuffer.put((byte) 2);\n\nbuffer.flip(); // switch to read mode\n\nwhile (buffer.hasRemaining()) {\n    byte b = buffer.get();\n}\n\nbuffer.clear(); // ready for writing again\n</code></pre> <p>Note</p> <p><code>flip()</code> does not erase data: it adjusts position and limit.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#3524-clear-vs-compact","title":"35.2.4 <code>clear()</code> vs <code>compact()</code>","text":"<p>After reading, a buffer can be reused in two ways.</p> Method Behavior <code>clear()</code> Discards unread data <code>compact()</code> Preserves unread data <p><code>compact()</code> is useful in streaming protocols where partial messages may remain in the buffer.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#3525-heap-buffers-vs-direct-buffers","title":"35.2.5 Heap Buffers vs Direct Buffers","text":"<p>Buffers can be allocated in two different memory regions.</p> <pre><code>ByteBuffer heap = ByteBuffer.allocate(1024);\nByteBuffer direct = ByteBuffer.allocateDirect(1024);\n</code></pre> Type Memory location Characteristics <code>Heap</code> JVM heap Garbage collected, cheap to allocate <code>Direct</code> Native memory Better I/O throughput, more expensive to allocate <p>Note</p> <p>Direct buffers reduce copying between JVM and OS but must be used carefully to avoid memory pressure.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#3526-channels-what-they-are","title":"35.2.6 Channels: What They Are","text":"<p>A <code>channel</code> represents a connection to an I/O entity such as a file, socket, or device.</p> <p>Unlike streams, channels are bidirectional.</p> Channel Type Purpose <code>FileChannel</code> File File I/O <code>SocketChannel</code> TCP Stream (TCP) networking <code>DatagramChannel</code> UDP Datagram (UDP) networking <pre><code>try (FileChannel channel =\n    FileChannel.open(Path.of(\"file.txt\"))) {\n\n        ByteBuffer buffer = ByteBuffer.allocate(128);\n        channel.read(buffer);\n}\n</code></pre> <p></p>"},{"location":"en/module-08/io-streams-api/#3527-blocking-vs-non-blocking-channels","title":"35.2.7 Blocking vs Non-Blocking Channels","text":"<p>Channels can operate in blocking or non-blocking mode.</p> <pre><code>SocketChannel channel = SocketChannel.open();\nchannel.configureBlocking(false);\n</code></pre> <p>In <code>**non-blocking mode**</code>: - <code>read()</code> may return immediately with 0 bytes - <code>write()</code> may write only part of the data</p> <p>Note</p> <p>Non-blocking I/O shifts complexity from the OS to the application.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#3528-scattergather-io","title":"35.2.8 Scatter/Gather I/O","text":"<p>NIO supports reading into or writing from multiple buffers in a single operation.</p> <pre><code>ByteBuffer header = ByteBuffer.allocate(128);\nByteBuffer body = ByteBuffer.allocate(1024);\n\nByteBuffer[] buffers = { header, body };\nchannel.read(buffers);\n</code></pre> <p>This is useful for structured protocols (headers + payload).</p> <p></p>"},{"location":"en/module-08/io-streams-api/#3529-selectors-multiplexing-non-blocking-io","title":"35.2.9 Selectors: Multiplexing Non-Blocking I/O","text":"<p><code>Selectors</code> allow a single thread to monitor multiple channels.</p> <p>They are the foundation of scalable servers.</p> Component Role <code>Selector</code> Monitors multiple channels <code>SelectionKey</code> Represents channel registration and state <code>Interest set</code> Operations the selector watches for (read, write, etc.) <p></p>"},{"location":"en/module-08/io-streams-api/#35210-when-to-use-javanio","title":"35.2.10 When to Use <code>java.nio</code>","text":"<p><code>NIO</code> is appropriate when: - High concurrency is required - You need fine-grained memory control - You are implementing protocols or servers</p> <p>For simple file operations, <code>java.nio.file.Files</code> is usually sufficient.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#353-javaniofile-nio2-file-and-directory-operations-legacy-vs-modern","title":"35.3 <code>java.nio.file</code> (NIO.2) \u2014 File and Directory Operations (Legacy vs Modern)","text":"<p>This section focuses on practical operations on files and directories.</p> <p>We compare the legacy approaches (java.io.File + java.io streams) with modern NIO.2 approaches (Path + Files).</p> <p>The goal is not only to know the method names, but to understand: - what each method really does - what it returns and how it reports errors - what pitfalls exist (race conditions, links, permissions, portability) - when a Files method is a safe enhancement over the old approach</p> <p></p>"},{"location":"en/module-08/io-streams-api/#3531-existence-and-accessibility-checks","title":"35.3.1 Existence and Accessibility Checks","text":"<p>A very common operation is to check whether a file exists and whether it can be accessed (read, written, executed).</p> <p>Both the legacy API (java.io.File) and the modern NIO.2 API (java.nio.file.Files) provide methods for these checks.</p> <p>However, it is important to understand that these checks are intentionally imprecise in both APIs.</p> <p>They are best-effort hints, not reliable guarantees.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#35311-legacy-api-file","title":"35.3.1.1 Legacy API (File)","text":"<pre><code>File f = new File(\"data.txt\");\n\nboolean exists = f.exists();\nboolean canRead = f.canRead();\nboolean canWrite = f.canWrite();\nboolean canExec = f.canExecute();\n</code></pre> <p>These methods return a boolean and do not explain why an operation failed.</p> <p>For example, exists() may return false when:</p> <ul> <li>the file truly does not exist</li> <li>the file exists but access is denied</li> <li>a symbolic link is broken</li> <li>an I/O error occurs</li> </ul> <p>The API provides no way to distinguish between these cases.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#35312-modern-api-files","title":"35.3.1.2 Modern API (Files)","text":"<pre><code>Path p = Path.of(\"data.txt\");\n\nboolean exists = Files.exists(p);\nboolean readable = Files.isReadable(p);\nboolean writable = Files.isWritable(p);\nboolean executable = Files.isExecutable(p);\n</code></pre> <p>Despite being newer, these methods also return booleans and also hide the reason for failure.</p> <p>NIO.2 adds an explicit method to express uncertainty:</p> <pre><code>boolean notExists = Files.notExists(p);\n</code></pre> <p>Note</p> <p><code>exists()</code> and <code>notExists()</code> can both be <code>false</code> when the status cannot be determined (for example, due to permissions).</p> <p>This does not make the check more accurate \u2014 it merely makes the uncertainty explicit.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#353121-symbolic-link-awareness-real-improvement","title":"35.3.1.2.1 Symbolic Link Awareness (Real Improvement)","text":"<p>One genuine enhancement of NIO.2 is control over symbolic link handling:</p> <pre><code>Files.exists(p, LinkOption.NOFOLLOW_LINKS);\n</code></pre> <p>Legacy File cannot reliably distinguish:</p> <ul> <li>a missing file</li> <li>a broken symbolic link</li> <li>a link pointing to an inaccessible target</li> </ul> <p>NIO.2 allows link-aware checks and explicit link inspection.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#353122-correct-usage-pattern-critical","title":"35.3.1.2.2 Correct Usage Pattern (Critical)","text":"<p>Neither API provides reliable diagnostics through boolean checks alone.</p> <p>Correct NIO.2 code does not \u201ccheck first\u201d.</p> <p>Instead, it attempts the operation and handles the exception:</p> <pre><code>try {\n    Files.delete(p);\n} catch (NoSuchFileException e) {\n    // file truly does not exist\n} catch (AccessDeniedException e) {\n    // permission problem\n} catch (IOException e) {\n    // other I/O error\n}\n</code></pre> <p>Note</p> <p>NIO.2\u2019s real advantage is exception-based diagnostics during operations, not more accurate existence or accessibility checks.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#353123-summary-table","title":"35.3.1.2.3 Summary Table","text":"Goal Legacy (File) Modern (Files) Key detail Check existence <code>exists()</code> <code>exists() / notExists()</code> notExists() may be false when the status cannot be determined Check read/write <code>canRead() / canWrite()</code> <code>isReadable() / isWritable()</code> Files methods can use LinkOption.NOFOLLOW_LINKS where supported Error details Not available Available via exceptions on actions Boolean checks themselves still do not explain the reason for failure"},{"location":"en/module-08/io-streams-api/#3532-creating-files-and-directories","title":"35.3.2 Creating Files and Directories","text":"<p>Creation is a major weakness of legacy File.</p> <p>Legacy often uses createNewFile() and mkdir/mkdirs(), which return boolean and provide little diagnostic information.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#35321-legacy-api-file","title":"35.3.2.1 Legacy API (File)","text":"<pre><code>File f = new File(\"a.txt\");\nboolean created = f.createNewFile(); // may throw IOException\n\nFile dir = new File(\"dir\");\nboolean ok1 = dir.mkdir();\nboolean ok2 = new File(\"a/b/c\").mkdirs();\n</code></pre> <p><code>mkdir()</code> creates only one directory level, <code>mkdirs()</code> creates parents too.</p> <p>Both return false on failure but do not tell you why.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#35322-modern-api-files","title":"35.3.2.2 Modern API (Files)","text":"<pre><code>Path file = Path.of(\"a.txt\");\nFiles.createFile(file);\n\nPath dir1 = Path.of(\"dir\");\nFiles.createDirectory(dir1);\n\nPath dirDeep = Path.of(\"a/b/c\");\nFiles.createDirectories(dirDeep);\n</code></pre> <p>Note</p> <p><code>Files.createFile</code> throws <code>FileAlreadyExistsException</code> if the file exists.</p> <p>This is often preferred over boolean checks because it is race-safe.</p> Goal Legacy (File) Modern (Files) Key detail Create file <code>createNewFile()</code> <code>createFile()</code> NIO throws FileAlreadyExistsException if the file exists Create directory <code>mkdir()</code> <code>createDirectory()</code> NIO throws detailed exceptions on failure Create parents <code>mkdirs()</code> <code>createDirectories()</code> Atomicity is not guaranteed for deep directory creation <p></p>"},{"location":"en/module-08/io-streams-api/#3533-deleting-files-and-directories","title":"35.3.3 Deleting Files and Directories","text":"<p>Deletion semantics differ strongly between legacy and NIO.2.</p> <p>Legacy <code>delete()</code> returns boolean; NIO.2 offers methods that throw meaningful exceptions.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#35331-legacy-api-file","title":"35.3.3.1 Legacy API (File)","text":"<pre><code>File f = new File(\"a.txt\");\nboolean deleted = f.delete();\n</code></pre> <p>If deletion fails (permission denied, file does not exist, directory not empty), <code>delete()</code> usually returns false without explanation.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#35332-modern-api-files","title":"35.3.3.2 Modern API (Files)","text":"<pre><code>Files.delete(Path.of(\"a.txt\"));\n</code></pre> <p>If you want \"delete if present\" semantics, use deleteIfExists().</p> <pre><code>Files.deleteIfExists(Path.of(\"a.txt\"));\n</code></pre> Goal Legacy (File) Modern (Files) Key detail Delete <code>delete()</code> <code>delete()</code> <code>Files.delete()</code> throws an exception with the failure reason Delete if present <code>exists() + delete()</code> <code>deleteIfExists()</code> Avoids TOCTOU (check-then-act) race conditions <p></p>"},{"location":"en/module-08/io-streams-api/#3534-copying-files-and-directories","title":"35.3.4 Copying Files and Directories","text":"<p>Legacy copying typically requires manually reading and writing bytes via streams.</p> <p>NIO.2 provides high-level copy operations with options.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#35341-legacy-technique-manual-streams","title":"35.3.4.1 Legacy technique (manual streams)","text":"<pre><code>try (InputStream in = new FileInputStream(\"src.bin\"); OutputStream out = new FileOutputStream(\"dst.bin\")) {\n\n    byte[] buf = new byte[8192];\n    int n;\n    while ((n = in.read(buf)) != -1) {\n        out.write(buf, 0, n);\n    }\n}\n</code></pre> <p>This is verbose and easy to get wrong (missing buffering, missing close, etc.).</p> <p></p>"},{"location":"en/module-08/io-streams-api/#35342-modern-api-filescopy","title":"35.3.4.2 Modern API (Files.copy)","text":"<pre><code>Files.copy(Path.of(\"src.bin\"), Path.of(\"dst.bin\"));\n</code></pre> <p>Copy behavior can be controlled with options.</p> <pre><code>Files.copy(\n    Path.of(\"src.bin\"),\n    Path.of(\"dst.bin\"),\n    StandardCopyOption.REPLACE_EXISTING,\n    StandardCopyOption.COPY_ATTRIBUTES\n);\n</code></pre> <p>Note</p> <p><code>Files.copy</code> throws FileAlreadyExistsException by default.</p> <p>Use <code>REPLACE_EXISTING</code> when overwriting is intended.</p> Goal Legacy approach Modern (Files) Key detail Copy file Manual stream loop <code>Files.copy(Path, Path, \u2026)</code> Options include <code>REPLACE_EXISTING</code> and <code>COPY_ATTRIBUTES</code> Copy stream InputStream/OutputStream <code>Files.copy(InputStream, Path, \u2026)</code> Useful for uploads, downloads, and piping data Copy directory Manual recursion <code>walkFileTree + Files.copy</code> No single one-liner for full directory tree copy <p></p>"},{"location":"en/module-08/io-streams-api/#3535-moving-and-renaming","title":"35.3.5 Moving and Renaming","text":"<p>Renaming in legacy code typically uses <code>File.renameTo()</code>, which is notoriously unreliable and platform-dependent.</p> <p>NIO.2 provides Files.move() with explicit semantics and options.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#35351-legacy-api","title":"35.3.5.1 Legacy API","text":"<pre><code>boolean ok = new File(\"a.txt\").renameTo(new File(\"b.txt\"));\n</code></pre> <p><code>renameTo()</code> returns false on failure and does not explain why.</p> <p>It may also fail unexpectedly across filesystems.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#35352-modern-api","title":"35.3.5.2 Modern API","text":"<pre><code>Files.move(Path.of(\"a.txt\"), Path.of(\"b.txt\"));\n</code></pre> <p>Move options provide precise behavior.</p> <pre><code>Files.move(\n    Path.of(\"a.txt\"),\n    Path.of(\"b.txt\"),\n    StandardCopyOption.REPLACE_EXISTING,\n    StandardCopyOption.ATOMIC_MOVE\n);\n</code></pre> <p>Note</p> <p>ATOMIC_MOVE is only guaranteed when the move occurs within the same filesystem. Otherwise an exception is thrown.</p> Goal Legacy (File) Modern (Files) Key detail Rename / move <code>renameTo()</code> <code>move()</code> Files.move() provides exceptions and explicit options Atomic move Not supported <code>move(\u2026, ATOMIC_MOVE)</code> Guaranteed only within the same filesystem Replace existing Not explicit <code>REPLACE_EXISTING</code> Makes overwrite intent explicit <p></p>"},{"location":"en/module-08/io-streams-api/#3536-reading-and-writing-text-and-bytes-files-enhancements","title":"35.3.6 Reading and Writing Text and Bytes (Files Enhancements)","text":"<p>A major enhancement of NIO.2 is the <code>Files</code> utility class, which provides high-level methods for common reading and writing tasks.</p> <p>These methods reduce boilerplate and improve correctness.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#35361-legacy-text-readingwriting","title":"35.3.6.1 Legacy text reading/writing","text":"<pre><code>try (BufferedReader r = new BufferedReader(new FileReader(\"file.txt\"))) {\n    String line = r.readLine();\n}\n</code></pre> <pre><code>try (BufferedWriter w = new BufferedWriter(new FileWriter(\"file.txt\"))) {\n    w.write(\"hello\");\n}\n</code></pre> <p>These legacy classes typically use the platform default charset unless you explicitly bridge with InputStreamReader/OutputStreamWriter.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#35362-modern-text-readingwriting","title":"35.3.6.2 Modern text reading/writing","text":"<pre><code>List&lt;String&gt; lines = Files.readAllLines(Path.of(\"file.txt\"), StandardCharsets.UTF_8);\nFiles.write(Path.of(\"file.txt\"), lines, StandardCharsets.UTF_8);\n\nFiles.lines(Path.of(\"file.txt\")).forEach(System.out::println);\n\nString string = Files.readString(Path.of(\"file.txt\"));\nFiles.writeString(Path.of(\"file.txt\"), string);\n</code></pre>"},{"location":"en/module-08/io-streams-api/#35363-modern-binary-readingwriting","title":"35.3.6.3 Modern binary reading/writing","text":"<pre><code>byte[] data = Files.readAllBytes(Path.of(\"data.bin\"));\nFiles.write(Path.of(\"out.bin\"), data);\n</code></pre> <p>Important</p> <p><code>readAllBytes</code> and <code>readAllLines</code> load the entire file into memory.</p> <p>Use <code>Files.lines()</code> instead which lazily process each line or, for large files, prefer streaming APIs such as newBufferedReader or newInputStream.</p> Task Legacy method NIO.2 Files method Key detail Read all bytes Manual InputStream loop <code>readAllBytes()</code> Loads the entire file into memory Read all lines BufferedReader loop <code>readAllLines()</code> Loads the entire file into memory Read lines lazily BufferedReader loop <code>lines()</code> Lazily process each line Write bytes OutputStream <code>write(Path, byte[])</code> Simple and concise Write lines BufferedWriter loop <code>write(Path, Iterable, \u2026)</code> Charset can be specified Append text FileWriter(true) <code>write(\u2026, APPEND)</code> Options make intent explicit <p></p>"},{"location":"en/module-08/io-streams-api/#3537-newinputstreamnewoutputstream-and-newbufferedreadernewbufferedwriter","title":"35.3.7 newInputStream/newOutputStream and newBufferedReader/newBufferedWriter","text":"<p>These <code>factory methods</code> create stream/reader instances from a Path.</p> <p>They are the recommended bridge between classic streaming and NIO.2 path handling.</p> <pre><code>try (InputStream in = Files.newInputStream(Path.of(\"a.bin\"))) { }\ntry (OutputStream out = Files.newOutputStream(Path.of(\"b.bin\"))) { }\n</code></pre> <pre><code>try (BufferedReader r = Files.newBufferedReader(Path.of(\"t.txt\"), StandardCharsets.UTF_8)) { }\ntry (BufferedWriter w = Files.newBufferedWriter(Path.of(\"t.txt\"), StandardCharsets.UTF_8)) { }\n</code></pre> <p></p>"},{"location":"en/module-08/io-streams-api/#3538-listing-directories-and-traversing-trees","title":"35.3.8 Listing Directories and Traversing Trees","text":"<p>Legacy directory listing is based on <code>File.list()</code> and <code>File.listFiles()</code>.</p> <p>These methods return arrays and provide limited error reporting.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#35381-legacy-listing","title":"35.3.8.1 Legacy listing","text":"<pre><code>File dir = new File(\".\");\nFile[] children = dir.listFiles();\n</code></pre> <p>NIO.2 provides multiple approaches depending on needs.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#35382-modern-listing-directorystream","title":"35.3.8.2 Modern listing (DirectoryStream)","text":"<pre><code>try (DirectoryStream&lt;Path&gt; ds = Files.newDirectoryStream(Path.of(\".\"))) {\n    for (Path p : ds) {\n        System.out.println(p);\n    }\n}\n</code></pre>"},{"location":"en/module-08/io-streams-api/#35383-modern-walking-fileswalk","title":"35.3.8.3 Modern walking (Files.walk)","text":"<pre><code>Files.walk(Path.of(\".\"))\n    .filter(Files::isRegularFile)\n        .forEach(System.out::println);\n</code></pre> <p>Note</p> <p><code>Files.walk</code> returns a Stream that must be closed. Prefer try-with-resources when using it.</p> <pre><code>try (Stream&lt;Path&gt; s = Files.walk(Path.of(\".\"))) {\n    s.forEach(System.out::println);\n}\n</code></pre> <p></p>"},{"location":"en/module-08/io-streams-api/#35384-modern-traversal-with-filevisitor","title":"35.3.8.4 Modern traversal with FileVisitor","text":"<p>For full control (skip subtrees, handle errors, follow links), use <code>walkFileTree + FileVisitor</code>.</p> <pre><code>Files.walkFileTree(Path.of(\".\"), new SimpleFileVisitor&lt;&gt;() {\n    @Override\n    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {\n        System.out.println(file);\n        return FileVisitResult.CONTINUE;\n    }\n});\n</code></pre> Goal Legacy Modern Key detail List directory <code>list()</code> / <code>listFiles()</code> <code>newDirectoryStream()</code> Lazy, must be closed Walk tree (simple) Manual recursion <code>walk()</code> (Stream) Stream must be closed Walk tree (full control) Manual recursion <code>walkFileTree()</code> Fine-grained control, error handling, pruning <p></p>"},{"location":"en/module-08/io-streams-api/#3539-searching-and-filtering","title":"35.3.9 Searching and Filtering","text":"<p>Searching is typically implemented by traversing and filtering.</p> <p>NIO.2 provides convenient building blocks: glob patterns, streams, and visitors.</p> <pre><code>try (DirectoryStream&lt;Path&gt; ds =\n    Files.newDirectoryStream(Path.of(\".\"), \"*.txt\")) {\n        for (Path p : ds) {\n            System.out.println(p);\n        }\n}\n</code></pre> <pre><code>try (Stream&lt;Path&gt; s = Files.find(Path.of(\".\"), 10,\n    (p, a) -&gt; a.isRegularFile() &amp;&amp; p.toString().endsWith(\".log\"))) {\n        s.forEach(System.out::println);\n}\n</code></pre> <p></p>"},{"location":"en/module-08/io-streams-api/#35310-attributes-reading-writing-and-views","title":"35.3.10 Attributes: Reading, Writing, and Views","text":"<p>Legacy File exposes only a few attributes (size, lastModified).</p> <p>NIO.2 supports rich metadata via attribute views.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#353101-legacy-attributes","title":"35.3.10.1 Legacy attributes","text":"<pre><code>long size = new File(\"a.txt\").length();\nlong lm = new File(\"a.txt\").lastModified();\n</code></pre>"},{"location":"en/module-08/io-streams-api/#353102-modern-attributes","title":"35.3.10.2 Modern attributes","text":"<pre><code>BasicFileAttributes a =\n    Files.readAttributes(Path.of(\"a.txt\"), BasicFileAttributes.class);\n\nlong size = a.size();\nFileTime modified = a.lastModifiedTime();\n</code></pre> <p>You can also access attributes using string-based names.</p> <pre><code>Object v = Files.getAttribute(Path.of(\"a.txt\"), \"basic:size\");\nFiles.setAttribute(Path.of(\"a.txt\"), \"basic:lastModifiedTime\", FileTime.fromMillis(0));\n</code></pre> <p>Note</p> <p>Attribute views are filesystem-dependent.</p> <p>Unsupported attributes cause exceptions.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#35311-symbolic-links-and-link-following","title":"35.3.11 Symbolic Links and Link Following","text":"<p>NIO.2 can explicitly detect and read symbolic links.</p> <p>This is critical for correct filesystem traversal and security.</p> <pre><code>Path link = Path.of(\"mylink\");\nboolean isLink = Files.isSymbolicLink(link);\n\nif (isLink) {\n    Path target = Files.readSymbolicLink(link);\n}\n</code></pre> <p>Many methods follow links by default.</p> <p>To prevent this, pass <code>LinkOption.NOFOLLOW_LINKS</code> when supported.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#35312-summary-why-files-is-an-enhancement","title":"35.3.12 Summary: Why Files Is an Enhancement","text":"<p>The Files utility class improves filesystem programming by: - reducing boilerplate (copy/move/read/write) - providing explicit options (overwrite, atomic move, follow links) - offering richer metadata (attributes/views) - supporting scalable traversal and searching</p> <p>Legacy APIs remain mostly for backward compatibility or when required by old libraries.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#354-serialization-object-streams-compatibility-and-traps","title":"35.4 Serialization \u2014 Object Streams, Compatibility, and Traps","text":"<p>Serialization is the process of converting an object graph into a byte stream so it can be stored or transmitted, then reconstructed later.</p> <p>In Java, classic serialization is implemented by <code>java.io.ObjectOutputStream</code> and <code>java.io.ObjectInputStream</code>.</p> <p>This topic is critical because it combines: - I/O streams and object graphs - versioning and backward compatibility - security concerns and safe usage patterns - special language rules (<code>transient</code>, static, <code>serialVersionUID</code>)</p> <p></p>"},{"location":"en/module-08/io-streams-api/#3541-what-serialization-does-and-what-it-does-not","title":"35.4.1 What Serialization Does (and What It Does Not)","text":"<p>When an object is serialized, Java writes enough information to reconstruct it later: - the class name - the serialVersionUID - the values of serializable instance fields - references between objects (object identity)</p> <p>Serialization does not automatically include: - static fields (class-level state) - transient fields (explicitly excluded) - non-serializable referenced objects (unless handled specially)</p> <p></p>"},{"location":"en/module-08/io-streams-api/#3542-the-two-main-marker-interfaces","title":"35.4.2 The Two Main Marker Interfaces","text":"<p>Java serialization is enabled by implementing one of these interfaces.</p> Interface Meaning Control level <code>Serializable</code> Opt-in marker, default mechanism Medium (custom hooks possible) <code>Externalizable</code> Requires manual read/write implementation High (full control over format) <p>Note</p> <p><code>Serializable</code> has no methods. It is a marker interface.</p> <p><code>Externalizable</code> extends Serializable and adds readExternal/writeExternal.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#3543-basic-example-writing-and-reading-an-object","title":"35.4.3 Basic Example: Writing and Reading an Object","text":"<p>This is the minimal pattern used in practice.</p> <pre><code>import java.io.*;\n\nclass Person implements Serializable {\n\n    private String name;\n    private int age;\n\n    Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n}\n\npublic class Demo {\n\n    public static void main(String[] args) throws Exception {\n\n        Person p = new Person(\"Alice\", 30);\n\n        try (ObjectOutputStream out =\n                 new ObjectOutputStream(new FileOutputStream(\"p.bin\"))) {\n            out.writeObject(p);\n        }\n\n        try (ObjectInputStream in =\n                 new ObjectInputStream(new FileInputStream(\"p.bin\"))) {\n            Person copy = (Person) in.readObject();\n        }\n    }\n\n}\n</code></pre> <p>Note</p> <p><code>readObject()</code> returns Object. A cast is required. <code>readObject()</code> can throw ClassNotFoundException.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#3544-object-graphs-references-and-identity","title":"35.4.4 Object Graphs, References, and Identity","text":"<p><code>Serialization</code> preserves object identity within the same stream.</p> <p>If the same object reference appears multiple times in the graph, Java writes it once and later writes back-references.</p> <pre><code>Person p = new Person(\"Bob\", 40);\nObject[] arr = { p, p }; // same reference twice\n\nout.writeObject(arr);\nObject[] restored = (Object[]) in.readObject();\n\n// restored[0] and restored[1] refer to the same object instance\n</code></pre> <p>Note</p> <p>This behavior prevents infinite recursion on cyclic graphs.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#3545-serialversionuid-the-versioning-key","title":"35.4.5 <code>serialVersionUID</code>: The Versioning Key","text":"<p><code>serialVersionUID</code> is a long identifier used to verify compatibility between a serialized stream and a class definition.</p> <p>If the UID differs, deserialization typically fails with InvalidClassException.</p> <p>If you do not declare <code>serialVersionUID</code>, the JVM computes one from class details.</p> <p>Small changes may change the computed UID, breaking compatibility.</p> <pre><code>class Person implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private String name;\n    private int age;\n}\n</code></pre> Change type Compatibility impact (default) Add a field Often compatible (new field gets default) Remove a field Often compatible (missing field ignored) Change field type Often incompatible Change class name/package Incompatible Change serialVersionUID Incompatible <p>Note</p> <p>Declaring a stable serialVersionUID is the standard way to control serialization compatibility.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#3546-transient-and-static-fields","title":"35.4.6 <code>transient</code> and <code>static</code> Fields","text":"<p><code>transient</code> fields are excluded from serialization.</p> <p>On <code>deserialization</code>, transient fields are assigned default values (0, false, null) unless explicitly restored.</p> <p><code>static</code> fields belong to the class, not to instances, so they are not serialized.</p> <pre><code>class Session implements Serializable {\n\nprivate static final long serialVersionUID = 1L;\n\nstatic int counter = 0;      // not serialized\ntransient String token;      // not serialized\nString user;                 // serialized\n\n\n}\n</code></pre> <p>Note</p> <p>If a transient field is required after deserialization, you must recompute it or restore it manually.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#3547-non-serializable-fields-and-notserializableexception","title":"35.4.7 Non-Serializable Fields and NotSerializableException","text":"<p>If an object references a field whose type is not serializable, serialization fails with NotSerializableException.</p> <pre><code>class Holder implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private Thread t; // Thread is not serializable\n\n\n}\n</code></pre> <p>Typical solutions: - mark the field transient - replace it with a serializable representation - use custom serialization hooks</p> <p></p>"},{"location":"en/module-08/io-streams-api/#3548-constructors-and-serialization","title":"35.4.8 Constructors and Serialization","text":"<p>Constructor behavior during serialization and deserialization is a frequent source of confusion.</p> <p>Java serialization restores object state primarily from the byte stream, not by running constructors.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#35481-rule-constructors-of-serializable-classes-are-not-called","title":"35.4.8.1 Rule: Constructors of Serializable Classes Are Not Called","text":"<p>During deserialization of a Serializable class, the constructors of that class are NOT executed.</p> <p>The instance is created without calling those constructors, and field values are injected from the stream.</p> <p>Note</p> <p>This is why constructors of Serializable classes must not contain essential initialization logic.</p> <p>That initialization would not run during deserialization.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#35482-inheritance-rule-the-first-non-serializable-superclass-constructor-is-called","title":"35.4.8.2 Inheritance Rule: The First Non-Serializable Superclass Constructor Is Called","text":"<p>When a Serializable class has a non-Serializable superclass, deserialization must still initialize that superclass part.</p> <p>Therefore, Java calls the no-argument constructor of the first non-Serializable superclass.</p> <p>Important implications:</p> <ul> <li>the non-Serializable superclass must have an accessible no-arg constructor</li> <li>serializable subclasses skip constructors, but non-serializable superclasses do not</li> </ul> <p></p>"},{"location":"en/module-08/io-streams-api/#35483-summary-table-which-constructors-run","title":"35.4.8.3 Summary Table: Which Constructors Run","text":"Class type Constructor called during deserialization Serializable class No Serializable subclass No First non-Serializable superclass Yes (no-arg constructor) Externalizable class Yes (public no-arg constructor required)"},{"location":"en/module-08/io-streams-api/#35484-worked-example-which-constructors-are-called","title":"35.4.8.4 Worked Example: Which Constructors Are Called","text":"<p>This example prints which constructors run during normal construction and during deserialization.</p> <pre><code>import java.io.*;\n\nclass A {\n\n    A() {\n        System.out.println(\"A constructor\");\n    }\n}\n\nclass B extends A implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    B() {\n        System.out.println(\"B constructor\");\n    }\n}\n\nclass C extends B { // Extending B, C is Serializable\n\n    private static final long serialVersionUID = 1L;\n\n    C() {\n        System.out.println(\"C constructor\");\n    }\n}\n\npublic class Demo {\n\n    public static void main(String[] args) throws Exception {\n\n        C obj = new C();\n\n        try (ObjectOutputStream out =\n                 new ObjectOutputStream(new FileOutputStream(\"c.bin\"))) {\n            out.writeObject(obj);\n        }\n\n        try (ObjectInputStream in =\n                 new ObjectInputStream(new FileInputStream(\"c.bin\"))) {\n            Object restored = in.readObject();\n        }\n    }\n}\n</code></pre> <p>Expected Output and Explanation During normal construction (new C()): <pre><code>A constructor\nB constructor\nC constructor\n</code></pre></p> <p>During deserialization (readObject): <pre><code>A constructor\n</code></pre></p> <p>Explanation: - C is Serializable, so C() is not called during deserialization - B is Serializable, so B() is not called during deserialization - A is not Serializable, so A() is called (no-arg constructor) - Fields of B and C are restored from the stream instead of constructors running</p> <p>Note</p> <p>If the first non-Serializable superclass has no accessible no-arg constructor, deserialization fails.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#3549-custom-serialization-hooks-writeobject-and-readobject","title":"35.4.9 Custom Serialization Hooks: <code>writeObject</code> and <code>readObject</code>","text":"<p>Custom serialization hooks exist to handle cases where default Java serialization is not enough (transient state, derived fields, encryption, validation, compatibility).</p> <p>They are advanced but extremely important for correct deserialization behavior.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#35491-why-custom-serialization-exists","title":"35.4.9.1 Why Custom Serialization Exists","text":"<p>By default, Java serialization automatically writes and reads all non-static, non-transient instance fields of a Serializable object.</p> <p>This is convenient, but it cannot express certain common needs.</p> <p>Typical reasons to customize serialization: - A field should not be stored directly (sensitive data) - A field is derived/cached and should be recomputed after restore - You need validation when reading (reject invalid state) - You need backward/forward compatibility logic (support older streams) - A referenced object is not Serializable and must be handled specially</p> <p></p>"},{"location":"en/module-08/io-streams-api/#35492-what-writeobject-and-readobject-really-are","title":"35.4.9.2 What <code>writeObject</code> and <code>readObject</code> Really Are","text":"<p>To customize serialization and deserialization, a class may define two special private methods named <code>writeObject</code> and <code>readObject</code>.</p> <p>These methods are not overrides of methods from any interface or superclass.</p> <p>They do not belong to Serializable, and they are not part of the normal method call flow of your program.</p> <p>You never call <code>writeObject</code> or <code>readObject</code> yourself.</p> <p>Instead, the serialization framework (ObjectOutputStream and ObjectInputStream) checks, using reflection, whether the class defines methods with these exact names and signatures.</p> <p>If such methods are found, the serialization framework calls them automatically during serialization or deserialization.</p> <p>If they are not found, the framework performs default serialization instead.</p> <p>Note</p> <p>If the method signature is incorrect (wrong visibility, parameter type, return type, or declared exceptions), the serialization framework does not recognize the method and silently falls back to default serialization.</p> <p>This behavior often makes errors hard to diagnose.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#35493-exact-required-signatures","title":"35.4.9.3 Exact Required Signatures","text":"<pre><code>private void writeObject(ObjectOutputStream out) throws IOException\n\nprivate void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException\n</code></pre> <p>Key constraints: - must be private - must return void - parameter types must match exactly - exceptions must be compatible with the required throws list</p> <p></p>"},{"location":"en/module-08/io-streams-api/#35494-what-happens-during-serialization-step-by-step","title":"35.4.9.4 What Happens During Serialization: Step by Step","text":"<p>When you serialize an object, you typically call:</p> <pre><code>out.writeObject(obj);\n</code></pre> <p>Then the serialization mechanism does roughly this: - Checks if the object\u2019s class implements Serializable - Checks whether the class declares a private writeObject(ObjectOutputStream) - If not present: default serialization runs automatically - If present: your writeObject is called instead</p> <p>A crucial point: inside writeObject, Java does not automatically write the normal fields unless you ask for it.</p> <p>This is why this call exists: <pre><code>out.defaultWriteObject();\n</code></pre></p> <p><code>defaultWriteObject()</code> means: \u201cserialize the object\u2019s normal serializable fields using the default mechanism.\u201d</p> <p>After that, you may write extra data in any format you want.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#35495-typical-pattern-and-the-writeread-order-rule","title":"35.4.9.5 Typical Pattern and the Write/Read Order Rule","text":"<p>The typical pattern is to keep default serialization and then extend it.</p> <p>The order of reads MUST match the order of writes.</p> <pre><code>private void writeObject(ObjectOutputStream out) throws IOException {\n    out.defaultWriteObject(); // writes normal fields\n    out.writeInt(42); // writes extra custom data\n}\n\nprivate void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n\n    in.defaultReadObject();         // reads normal fields\n    int x = in.readInt();           // reads extra custom data in same order\n\n}\n</code></pre> <p>Note</p> <p>If you write extra values (ints/strings/etc.), you must read them back in the same sequence. Otherwise deserialization will fail or restore corrupted state.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#35410-example-use-case-restoring-a-transient-derived-field","title":"35.4.10 Example Use Case: Restoring a transient Derived Field","text":"<p>A classic use case is recomputing a transient cached value after deserialization.</p> <pre><code>class User implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private String firstName;\n    private String lastName;\n\n    private transient String fullName;\n\n    User(String firstName, String lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n        this.fullName = firstName + \" \" + lastName;\n    }\n\n    private void readObject(ObjectInputStream in)\n            throws IOException, ClassNotFoundException {\n\n        in.defaultReadObject(); // restore firstName and lastName\n        fullName = firstName + \" \" + lastName; // recompute transient field\n    }\n}\n</code></pre> <p></p>"},{"location":"en/module-08/io-streams-api/#35411-externalizable-full-control-and-full-responsibility","title":"35.4.11 Externalizable: Full Control (and Full Responsibility)","text":"<p>Externalizable requires you to define how to write and read the object manually.</p> <p>It also requires a public no-argument constructor because deserialization instantiates the object first.</p> <pre><code>import java.io.*;\n\nclass Point implements Externalizable {\nint x;\nint y;\n\npublic Point() { } // required\n\npublic Point(int x, int y) { this.x = x; this.y = y; }\n\n@Override\npublic void writeExternal(ObjectOutput out) throws IOException {\n    out.writeInt(x);\n    out.writeInt(y);\n}\n\n@Override\npublic void readExternal(ObjectInput in) throws IOException {\n    x = in.readInt();\n    y = in.readInt();\n}\n\n\n}\n</code></pre> <p>Note</p> <p>With Externalizable, you control the format. If you change the format later, you must handle backward compatibility yourself.</p> <p></p>"},{"location":"en/module-08/io-streams-api/#35412-readobject-security-considerations","title":"35.4.12 <code>readObject()</code> Security Considerations","text":"<p>Deserialization of untrusted data is dangerous because it can execute code indirectly via: - constructors and initialization logic - readObject hooks - gadget chains in libraries</p> <p>Safe practice guidelines: - Never deserialize untrusted bytes unless you have a strong reason - Prefer safe data formats (JSON, protobuf) for external inputs - If forced, apply object filters and strict validation</p> <p></p>"},{"location":"en/module-08/io-streams-api/#35413-common-traps-and-practical-tips","title":"35.4.13 Common Traps and Practical Tips","text":"<ul> <li>Serializable is marker-only; no method must be implemented</li> <li><code>readObject</code> returns Object and may throw ClassNotFoundException</li> <li><code>static fields</code> are never serialized</li> <li><code>transient fields</code> reset to default values unless restored</li> <li>Missing <code>serialVersionUID</code> may break compatibility unexpectedly</li> <li>Externalizable requires public no-arg constructor</li> <li>NotSerializableException occurs when a referenced field type is not serializable</li> </ul>"},{"location":"en/module-08/io-streams-api/#35414-when-to-use-or-avoid-java-serialization","title":"35.4.14 When to Use (or Avoid) Java Serialization","text":"<p>Use classic Java serialization mainly for: - short-lived local persistence under controlled versions - in-memory caching where both ends are trusted - legacy systems that already depend on it</p> <p>Avoid it for: - public network protocols - long-term storage with evolving schemas - untrusted inputs</p>"},{"location":"en/module-08/io-streams/","title":"34. Java I/O Streams","text":""},{"location":"en/module-08/io-streams/#table-of-contents","title":"Table of Contents","text":"<ul> <li>34.1 What Is an IO Stream in Java</li> <li>34.2 Byte Streams vs Character Streams<ul> <li>34.2.1 Byte Streams</li> <li>34.2.2 Character Streams</li> <li>34.2.3 Summary Table</li> </ul> </li> <li>34.3 Low-Level vs High-Level Streams<ul> <li>34.3.1 Low-Level Streams Node-Streams</li> <li>34.3.2 Common Low-Level Streams</li> <li>34.3.3 High-Level Streams Filter--Processing-Streams</li> <li>34.3.4 Common High-Level Streams</li> <li>34.3.5 Stream Chaining Rules and Common Errors<ul> <li>34.3.5.1 Fundamental Chaining Rule</li> <li>34.3.5.2 Byte vs Character Stream Incompatibility</li> <li>34.3.5.3 Invalid Chaining Compile-Time-Error</li> <li>34.3.5.4 Bridging Byte Streams to Character Streams</li> <li>34.3.5.5 Correct Conversion Pattern</li> <li>34.3.5.6 Ordering Rules in Stream Chains</li> <li>34.3.5.7 Correct Logical Order</li> <li>34.3.5.8 Resource Management Rule</li> <li>34.3.5.9 Common Pitfalls</li> </ul> </li> </ul> </li> <li>34.4 Core javaio Base Classes and Key Methods<ul> <li>34.4.1 InputStream<ul> <li>34.4.1.1 Key Methods</li> <li>34.4.1.2 Typical Usage Example</li> </ul> </li> <li>34.4.2 OutputStream<ul> <li>34.4.2.1 Key Methods</li> <li>34.4.2.2 Typical Usage Example</li> </ul> </li> <li>34.4.3 Reader and Writer<ul> <li>34.4.3.1 Charset Handling</li> </ul> </li> </ul> </li> <li>34.5 Buffered Streams and Performance<ul> <li>34.5.1 Why Buffering Matters</li> <li>34.5.2 How Unbuffered Reading Works</li> <li>34.5.3 How BufferedInputStream Works</li> <li>34.5.4 Buffered Output Example</li> <li>34.5.5 BufferedReader vs Reader</li> <li>34.5.6 BufferedWriter Example</li> </ul> </li> <li>34.6 java io vs java nio and java nio file<ul> <li>34.6.1 Conceptual Differences</li> <li>34.6.2 java-nio Modern-File-IO</li> </ul> </li> <li>34.7 When to Use Which API</li> <li>34.8 Common Traps and Tips</li> </ul> <p>This chapter provides a detailed explanation of <code>Java I/O Streams</code>. </p> <p>It covers classic java.io streams, contrasts them with java.nio / java.nio.file, and explains design principles, APIs, edge cases, and relevant distinctions.</p> <p></p>"},{"location":"en/module-08/io-streams/#341-what-is-an-io-stream-in-java","title":"34.1 What Is an I/O Stream in Java?","text":"<p>An <code>I/O Stream</code> represents a flow of data between a Java program and an external source or destination. </p> <p>The data flows sequentially, like water in a pipe.</p> <ul> <li>A stream is not a data structure; it does not store data permanently</li> <li>Streams are unidirectional (input OR output)</li> <li>Streams abstract the underlying source (file, network, memory, device)</li> <li>Streams operate in a blocking, synchronous manner (classic I/O)</li> </ul> <p>In Java, streams are organized around two major dimensions:</p> <ul> <li><code>Direction</code>: Input vs Output</li> <li><code>Data type</code>: Byte vs Character</li> </ul> <p></p>"},{"location":"en/module-08/io-streams/#342-byte-streams-vs-character-streams","title":"34.2 Byte Streams vs Character Streams","text":"<p>Java distinguishes streams based on the unit of data they process.</p> <p></p>"},{"location":"en/module-08/io-streams/#3421-byte-streams","title":"34.2.1 Byte Streams","text":"<ul> <li>Work with raw 8-bit bytes</li> <li>Used for binary data (images, audio, PDFs, ZIPs)</li> <li>Base classes: <code>InputStream</code> and <code>OutputStream</code> </li> </ul>"},{"location":"en/module-08/io-streams/#3422-character-streams","title":"34.2.2 Character Streams","text":"<ul> <li>Work with 16-bit Unicode characters</li> <li>Handle character encoding automatically</li> <li>Base classes: <code>Reader</code> and <code>Writer</code> </li> </ul>"},{"location":"en/module-08/io-streams/#3423-summary-table","title":"34.2.3 Summary Table","text":"Aspect Byte Streams Character Streams <code>Unit of data</code> byte (8 bits) char (16 bits) <code>Encoding handling</code> None Yes (Charset aware) <code>Base classes</code> InputStream / OutputStream Reader / Writer <code>Typical usage</code> Binary files Text files <code>Focus</code> Low-level I/O Text processing"},{"location":"en/module-08/io-streams/#343-low-level-vs-high-level-streams","title":"34.3 Low-Level vs High-Level Streams","text":"<p>Streams in <code>java.io</code> follow a decorator pattern. Streams are stacked to add functionality.</p> <p></p>"},{"location":"en/module-08/io-streams/#3431-low-level-streams-node-streams","title":"34.3.1 Low-Level Streams (Node Streams)","text":"<p>Low-level streams connect directly to a data source or sink.</p> <ul> <li>They know how to read/write bytes or characters</li> <li>They do NOT provide buffering, formatting, or object handling</li> </ul> <p></p>"},{"location":"en/module-08/io-streams/#3432-common-low-level-streams","title":"34.3.2 Common Low-Level Streams","text":"Stream Class Purpose <code>FileInputStream</code> Read bytes from file <code>FileOutputStream</code> Write bytes to file <code>FileReader</code> Read characters from file <code>FileWriter</code> Write characters to file <ul> <li>Example: Low-Level Byte Stream</li> </ul> <pre><code>try (InputStream in = new FileInputStream(\"data.bin\")) {\n    int b;\n    while ((b = in.read()) != -1) {\n        System.out.println(b);\n    }\n}\n</code></pre> <p>Note</p> <p>Low-level streams are rarely used alone in real applications due to poor performance and limited features.</p> <p></p>"},{"location":"en/module-08/io-streams/#3433-high-level-streams-filter-processing-streams","title":"34.3.3 High-Level Streams (Filter / Processing Streams)","text":"<p>High-level streams wrap other streams to add functionality.</p> <ul> <li>Buffering</li> <li>Data type conversion</li> <li>Object serialization</li> <li>Primitive reading/writing</li> </ul> <p></p>"},{"location":"en/module-08/io-streams/#3434-common-high-level-streams","title":"34.3.4 Common High-Level Streams","text":"Stream Class Adds Functionality <code>BufferedInputStream</code> Buffering <code>BufferedReader</code> Line-based reading <code>DataInputStream</code> Primitive types <code>ObjectInputStream</code> Object serialization <code>PrintWriter</code> Formatted text output <ul> <li>Example: Stream Chaining</li> </ul> <pre><code>try (BufferedReader reader =\n    new BufferedReader(\n        new InputStreamReader(\n            new FileInputStream(\"text.txt\")))) {\n\n    String line;\n    while ((line = reader.readLine()) != null) {\n        System.out.println(line);\n    }\n}\n</code></pre>"},{"location":"en/module-08/io-streams/#3435-stream-chaining-rules-and-common-errors","title":"34.3.5 Stream Chaining Rules and Common Errors","text":"<p>The previous example illustrates stream chaining, a core concept in <code>java.io</code> based on the decorator pattern. </p> <p>Each stream wraps another stream, adding functionality while preserving a strict type hierarchy.</p> <p></p>"},{"location":"en/module-08/io-streams/#34351-fundamental-chaining-rule","title":"34.3.5.1 Fundamental Chaining Rule","text":"<p>A stream can only wrap another stream of a compatible abstraction level.</p> <ul> <li>Byte streams can only wrap byte streams</li> <li>Character streams can only wrap character streams</li> <li>High-level streams require an underlying low-level stream</li> </ul> <p>Note</p> <p>You cannot arbitrarily mix <code>InputStream</code> with <code>Reader</code> or <code>OutputStream</code> with <code>Writer</code>.</p> <p></p>"},{"location":"en/module-08/io-streams/#34352-byte-vs-character-stream-incompatibility","title":"34.3.5.2 Byte vs Character Stream Incompatibility","text":"<p>A very common error is attempting to wrap a byte stream directly with a character-based class (or vice versa).</p> <p></p>"},{"location":"en/module-08/io-streams/#34353-invalid-chaining-compile-time-error","title":"34.3.5.3 Invalid Chaining (Compile-Time Error)","text":"<pre><code>BufferedReader reader =\n    new BufferedReader(new FileInputStream(\"text.txt\"));\n</code></pre> <p>Note</p> <p>This fails because <code>BufferedReader</code> expects a <code>Reader</code>, not an <code>InputStream</code>.</p> <p></p>"},{"location":"en/module-08/io-streams/#34354-bridging-byte-streams-to-character-streams","title":"34.3.5.4 Bridging Byte Streams to Character Streams","text":"<p>To convert between byte-based and character-based streams, Java provides bridge classes that perform explicit charset decoding/encoding.</p> <ul> <li><code>InputStreamReader</code> converts bytes \u2192 characters</li> <li><code>OutputStreamWriter</code> converts characters \u2192 bytes</li> </ul> <p></p>"},{"location":"en/module-08/io-streams/#34355-correct-conversion-pattern","title":"34.3.5.5 Correct Conversion Pattern","text":"<pre><code>BufferedReader reader =\n    new BufferedReader(\n        new InputStreamReader(new FileInputStream(\"text.txt\")));\n</code></pre> <p>Note</p> <p>The bridge handles character decoding using a charset (default or explicit).</p> <p></p>"},{"location":"en/module-08/io-streams/#34356-ordering-rules-in-stream-chains","title":"34.3.5.6 Ordering Rules in Stream Chains","text":"<p>The order of wrapping is not arbitrary.</p> <ul> <li>Low-level stream must be innermost</li> <li>Bridges (if needed) come next</li> <li>Buffered or processing streams come last</li> </ul> <p></p>"},{"location":"en/module-08/io-streams/#34357-correct-logical-order","title":"34.3.5.7 Correct Logical Order","text":"<pre><code>FileInputStream \u2192 InputStreamReader \u2192 BufferedReader\n</code></pre>"},{"location":"en/module-08/io-streams/#34358-resource-management-rule","title":"34.3.5.8 Resource Management Rule","text":"<p>Closing the outermost stream automatically closes all wrapped streams.</p> <p>Note</p> <p>This is why try-with-resources should reference only the highest-level stream.</p> <p></p>"},{"location":"en/module-08/io-streams/#34359-common-pitfalls","title":"34.3.5.9 Common Pitfalls","text":"<ul> <li>Trying to buffer a stream of the wrong type</li> <li>Forgetting the bridge between byte and char streams</li> <li>Assuming <code>Reader</code> works with binary data</li> <li>Using default charset unintentionally</li> <li>Closing inner streams manually (risking double-close): <code>close()</code> on the outer wrapper is enough and recommended</li> </ul>"},{"location":"en/module-08/io-streams/#344-core-javaio-base-classes-and-key-methods","title":"34.4 Core <code>java.io</code> Base Classes and Key Methods","text":"<p>The <code>java.io</code> package is built around a small set of abstract base classes. Understanding these classes and their contracts is essential, because all concrete I/O classes build on them.</p> <p></p>"},{"location":"en/module-08/io-streams/#3441-inputstream","title":"34.4.1 InputStream","text":"<p>Abstract base class for byte-oriented input. All input streams read raw bytes (8-bit values) from a source such as a file, network socket, or memory buffer.</p> <p></p>"},{"location":"en/module-08/io-streams/#34411-key-methods","title":"34.4.1.1 Key Methods","text":"Method Description int <code>read()</code> Reads one byte (0\u2013255); returns -1 at end of stream int <code>read(byte[])</code> Reads bytes into buffer; returns number of bytes read or -1 int <code>read(byte[], int, int)</code> Reads up to length bytes into a buffer slice int <code>available()</code> Bytes readable without blocking (hint, not guarantee) void <code>close()</code> Releases the underlying resource <p>Note</p> <p>The <code>read()</code> methods are blocking by default.</p> <p>They suspend the calling thread until data is available, end-of-stream is reached, or an I/O error occurs.</p> <p>The <code>single-byte read()</code> method is primarily a low-level primitive.</p> <p>In practice, reading one byte at a time is inefficient and should almost always be avoided in favor of buffered reads.</p> <p></p>"},{"location":"en/module-08/io-streams/#34412-typical-usage-example","title":"34.4.1.2 Typical Usage Example","text":"<pre><code>try (InputStream in = new FileInputStream(\"data.bin\")) {\n    byte[] buffer = new byte[1024];\n    int count;\n    while ((count = in.read(buffer)) != -1) {\n        // process buffer[0..count-1]\n    }\n}\n</code></pre>"},{"location":"en/module-08/io-streams/#3442-outputstream","title":"34.4.2 OutputStream","text":"<p>Abstract base class for byte-oriented output.</p> <p>It represents a destination where raw bytes can be written.</p> <p></p>"},{"location":"en/module-08/io-streams/#34421-key-methods","title":"34.4.2.1 Key Methods","text":"Method Description void <code>write(int b)</code> Writes the low 8 bits of the integer void <code>write(byte[])</code> Writes an entire byte array void <code>write(byte[], int, int)</code> Writes a slice of a byte array void <code>flush()</code> Forces buffered data to be written void <code>close()</code> Flushes and releases the resource <p>Note</p> <p>Calling <code>close()</code> implicitly calls <code>flush()</code>.</p> <p>Failing to flush or close an OutputStream may result in data loss.</p> <p></p>"},{"location":"en/module-08/io-streams/#34422-typical-usage-example","title":"34.4.2.2 Typical Usage Example","text":"<pre><code>try (OutputStream out = new FileOutputStream(\"out.bin\")) {\n    out.write(new byte[] {1, 2, 3, 4});\n    out.flush();\n}\n</code></pre>"},{"location":"en/module-08/io-streams/#3443-reader-and-writer","title":"34.4.3 Reader and Writer","text":"<p><code>Reader</code> and <code>Writer</code> are the <code>character-oriented</code> counterparts of InputStream and OutputStream.</p> <p>They operate on 16-bit Unicode characters instead of raw bytes.</p> Class Direction Character-based Encoding aware <code>Reader</code> Input Yes Yes <code>Writer</code> Output Yes Yes <p>Readers and Writers always involve a <code>charset</code>, either explicitly or implicitly.</p> <p>This makes them the correct abstraction for text processing.</p> <p></p>"},{"location":"en/module-08/io-streams/#34431-charset-handling","title":"34.4.3.1 Charset Handling","text":"<pre><code>Reader reader = new InputStreamReader(\n    new FileInputStream(\"file.txt\"),\n    StandardCharsets.UTF_8\n);\n</code></pre> <p>Note</p> <p><code>InputStreamReader</code> and <code>OutputStreamWriter</code> are bridge classes.</p> <p>They convert between <code>byte streams</code> and <code>character streams</code> using a <code>charset</code>.</p> <p></p>"},{"location":"en/module-08/io-streams/#345-buffered-streams-and-performance","title":"34.5 Buffered Streams and Performance","text":"<p><code>Buffered streams</code> wrap another stream and add an in-memory buffer.</p> <p>Instead of interacting with the operating system on every read or write, data is accumulated in memory and transferred in larger chunks.</p> <ul> <li><code>BufferedInputStream</code> / <code>BufferedOutputStream</code> for byte streams</li> <li><code>BufferedReader</code> / <code>BufferedWriter</code> for character streams</li> </ul> <p>Note</p> <p><code>Buffered streams</code> are <code>decorators</code>: they do not replace the underlying stream, they enhance it by adding buffering behavior.</p> <p></p>"},{"location":"en/module-08/io-streams/#3451-why-buffering-matters","title":"34.5.1 Why Buffering Matters","text":"Aspect Unbuffered Buffered <code>System calls</code> Frequent Reduced <code>Performance</code> Poor High <code>Memory usage</code> Minimal Slightly higher <p>System calls are expensive operations.</p> <p>Buffering minimizes them by grouping multiple logical reads or writes into fewer physical I/O operations.</p> <p></p>"},{"location":"en/module-08/io-streams/#3452-how-unbuffered-reading-works","title":"34.5.2 How Unbuffered Reading Works","text":"<p>In an unbuffered stream, each call to read() may result in a native system call.</p> <p>This is especially inefficient when reading large amounts of data.</p> <pre><code>try (InputStream in = new FileInputStream(\"data.bin\")) {\n    int b;\n    while ((b = in.read()) != -1) {\n        // each read() may trigger a system call\n    }\n}\n</code></pre> <p>Note</p> <p>Reading byte-by-byte without buffering is almost always a performance anti-pattern.</p> <p></p>"},{"location":"en/module-08/io-streams/#3453-how-bufferedinputstream-works","title":"34.5.3 How BufferedInputStream Works","text":"<p><code>BufferedInputStream</code> internally reads a large block of bytes into a buffer.</p> <p>Subsequent <code>read()</code> calls are served directly from memory until the buffer is empty.</p> <pre><code>try (InputStream in =\n    new BufferedInputStream(new FileInputStream(\"data.bin\"))) {\n        int b;\n        while ((b = in.read()) != -1) {\n            // most reads are served from memory, not the OS\n        }\n}\n</code></pre> <p>Note</p> <p>The program still calls <code>read()</code> repeatedly, but the operating system is accessed only when the internal buffer needs refilling.</p> <p></p>"},{"location":"en/module-08/io-streams/#3454-buffered-output-example","title":"34.5.4 Buffered Output Example","text":"<p>Buffered output accumulates data in memory and writes it in larger chunks.</p> <p>The <code>flush()</code> operation forces the buffer to be written immediately.</p> <pre><code>try (OutputStream out =\n    new BufferedOutputStream(new FileOutputStream(\"out.bin\"))) {\n        for (int i = 0; i &lt; 1_000; i++) {\n            out.write(i);\n        }\n        out.flush(); // forces buffered data to disk\n}\n</code></pre> <p>Note</p> <p><code>close()</code> automatically calls flush().</p> <p>Calling <code>flush()</code> explicitly is useful when data must be visible immediately.</p> <p></p>"},{"location":"en/module-08/io-streams/#3455-bufferedreader-vs-reader","title":"34.5.5 BufferedReader vs Reader","text":"<p><code>BufferedReader</code> adds efficient <code>**line-based reading**</code> on top of a Reader.</p> <p>Without buffering, each character read may involve a system call.</p> <pre><code>try (BufferedReader reader =\n    new BufferedReader(new FileReader(\"file.txt\"))) {\n\n        String line;\n        while ((line = reader.readLine()) != null) {\n            System.out.println(line);\n        }\n}\n</code></pre> <p>Note</p> <p>The <code>readLine()</code> method is only available on <code>BufferedReader</code> (not <code>Reader</code>), because it relies on buffering to efficiently detect line boundaries.</p> <p></p>"},{"location":"en/module-08/io-streams/#3456-bufferedwriter-example","title":"34.5.6 BufferedWriter Example","text":"<pre><code>try (BufferedWriter writer =\n    new BufferedWriter(new FileWriter(\"file.txt\"))) {\n\n        writer.write(\"Hello\");\n        writer.newLine();\n        writer.write(\"World\");\n}\n</code></pre> <p><code>BufferedWriter</code> minimizes disk access and provides convenience methods such as newLine().</p> <p>Note</p> <p>Always wrap file streams with buffering unless there is a strong reason not to</p> <p>Prefer BufferedReader / BufferedWriter for text</p> <p>Prefer BufferedInputStream / BufferedOutputStream for binary data</p> <p></p>"},{"location":"en/module-08/io-streams/#346-javaio-vs-javanio-and-javaniofile","title":"34.6 java.io vs java.nio (and java.nio.file)","text":"<p>Modern Java applications increasingly favor NIO and NIO.2 APIs, but java.io remains fundamental and widely used.</p> <p></p>"},{"location":"en/module-08/io-streams/#3461-conceptual-differences","title":"34.6.1 Conceptual Differences","text":"Aspect java.io java.nio / nio.2 <code>Programming model</code> Stream-based Buffer / Channel-based <code>Blocking I/O</code> blocking by default Non-blocking capable <code>File API</code> File Path + Files <code>Scalability</code> Limited High <code>Introduced</code> Java 1.0 Java 4 / Java 7 <p>Note</p> <p><code>java.nio</code> does not replace <code>java.io</code>.</p> <p>Many NIO classes internally rely on streams or coexist with them.</p> <p></p>"},{"location":"en/module-08/io-streams/#3462-javanio-modern-file-io","title":"34.6.2 java.nio (Modern File I/O)","text":"<p>The <code>java.nio.file</code> package (NIO.2) provides a high-level, expressive, and safer file API. It is the preferred approach for file operations in Java 11+.</p> <p>Example: Reading a File (NIO)</p> <pre><code>Path path = Path.of(\"file.txt\");\nList&lt;String&gt; lines = Files.readAllLines(path);\n</code></pre> <p>Equivalent java.io Code</p> <pre><code>try (BufferedReader reader = new BufferedReader(new FileReader(\"file.txt\"))) {\n    String line;\n    while ((line = reader.readLine()) != null) {\n        System.out.println(line);\n    }\n}\n</code></pre> <p></p>"},{"location":"en/module-08/io-streams/#347-when-to-use-which-api","title":"34.7 When to Use Which API","text":"Scenario Recommended API <code>Simple file read/write</code> java.nio.file.Files <code>Binary streaming</code> InputStream / OutputStream <code>Character text processing</code> Reader / Writer <code>High-performance servers</code> java.nio.channels <code>Legacy APIs</code> java.io"},{"location":"en/module-08/io-streams/#348-common-traps-and-tips","title":"34.8 Common Traps and Tips","text":"<ul> <li>End-of-file is indicated by -1, not by an exception</li> <li>Closing a wrapper stream closes the wrapped stream automatically</li> <li><code>BufferedReader.readLine()</code> strips line separators</li> <li><code>InputStreamReader</code> always involves a charset</li> <li>Files utility methods throw checked IOException</li> <li><code>available()</code> must not be used to detect EOF</li> </ul> <p>Note</p> <p>Most I/O bugs come from incorrect assumptions about blocking, buffering, or character encoding.</p>"},{"location":"en/module-08/io-user/","title":"36. Interacting with the User (Standard I/O Streams)","text":""},{"location":"en/module-08/io-user/#table-of-contents","title":"Table of Contents","text":"<ul> <li>36.1 The Standard I/O Streams</li> <li>36.2 PrintStream What It Is and Why It Exists<ul> <li>36.2.1 Key Characteristics of PrintStream</li> <li>36.2.2 Basic Usage of PrintStream</li> <li>36.2.3 Formatting Output with PrintStream</li> </ul> </li> <li>36.3 Reading Input as an IO Stream<ul> <li>36.3.1 Low-Level Reading from Systemin</li> <li>36.3.2 Using InputStreamReader and BufferedReader</li> </ul> </li> <li>36.4 The Scanner Class Convenient but Subtle<ul> <li>36.4.1 Common Scanner Pitfalls</li> </ul> </li> <li>36.5 Closing System Streams</li> <li>36.6 Acquiring Input with Console<ul> <li>36.6.1 Reading Input from Console</li> <li>36.6.2 Reading Passwords Securely</li> </ul> </li> <li>36.7 Formatting Console Output</li> <li>36.8 Comparing Console Scanner and BufferedReader</li> <li>36.9 Redirection and Standard Streams</li> <li>36.10 Common Traps and Best Practices</li> <li>36.11 Final Summary</li> </ul> <p>Java programs often need to interact with the user: printing information, reading input, and formatting output.</p> <p>This interaction is implemented using standard I/O streams, which are normal Java streams connected to the operating system.</p> <p>This chapter explains how Java interacts with the console and standard input/output, starting from the most basic concepts and moving to higher-level APIs.</p> <p></p>"},{"location":"en/module-08/io-user/#361-the-standard-io-streams","title":"36.1 The Standard I/O Streams","text":"<p>Every Java program starts with three predefined streams provided by the JVM.</p> <p>They are connected to the process environment (usually a terminal or console).</p> Stream Field Type Purpose Standard output <code>System.out</code> PrintStream Normal output Standard error <code>System.err</code> PrintStream Error output Standard input <code>System.in</code> InputStream User input <p>Note</p> <p>These streams are created by the JVM, not by your program.</p> <p>They exist for the entire lifetime of the process.</p> <p></p>"},{"location":"en/module-08/io-user/#362-printstream-what-it-is-and-why-it-exists","title":"36.2 <code>PrintStream</code>: What It Is and Why It Exists","text":"<p><code>PrintStream</code> is a byte-oriented output stream designed for human-readable output.</p> <p>It wraps another OutputStream and adds convenient printing methods.</p> <p><code>System.out</code> and <code>System.err</code> are both instances of <code>PrintStream</code>.</p> <p></p>"},{"location":"en/module-08/io-user/#3621-key-characteristics-of-printstream","title":"36.2.1 Key Characteristics of PrintStream","text":"<ul> <li>Byte-oriented stream with text-printing helpers</li> <li>Provides <code>print()</code> and <code>println()</code> methods</li> <li>Converts values to text automatically</li> <li>Does not throw <code>IOException</code> on write errors</li> <li>Optionally supports auto-flushing on newline / <code>println()</code></li> </ul> <p>Note</p> <p>Unlike most streams, PrintStream suppresses IOExceptions.</p> <p>Errors must be checked using checkError().</p> <p></p>"},{"location":"en/module-08/io-user/#3622-basic-usage-of-printstream","title":"36.2.2 Basic Usage of PrintStream","text":"<pre><code>System.out.println(\"Hello\");\nSystem.out.print(\"Value: \");\nSystem.out.println(42);\n</code></pre> <p><code>println()</code> appends the platform-specific line separator automatically.</p> <p></p>"},{"location":"en/module-08/io-user/#3623-formatting-output-with-printstream","title":"36.2.3 Formatting Output with PrintStream","text":"<p>PrintStream supports formatted output using <code>printf()</code> and <code>format()</code>, which are based on the same syntax as String.format().</p> <pre><code>System.out.printf(\"Name: %s, Age: %d%n\", \"Alice\", 30);\n</code></pre> Specifier Meaning <code>%s</code> String <code>%d</code> Integer <code>%f</code> Floating-point <code>%n</code> Platform-independent newline <p>Note</p> <p><code>printf()</code> does not automatically add a newline unless you specify <code>%n</code>.</p> <p></p>"},{"location":"en/module-08/io-user/#363-reading-input-as-an-io-stream","title":"36.3 Reading Input as an I/O Stream","text":"<p>Standard input (System.in) is an InputStream connected to user input.</p> <p>It provides raw bytes and must be adapted for practical use.</p> <p></p>"},{"location":"en/module-08/io-user/#3631-low-level-reading-from-systemin","title":"36.3.1 Low-Level Reading from System.in","text":"<p>At the lowest level, you can read raw bytes from System.in.</p> <p>This is rarely convenient for interactive programs.</p> <pre><code>int b = System.in.read();\n</code></pre> <p>Note</p> <p><code>System.in.read()</code> blocks until input is available.</p> <p></p>"},{"location":"en/module-08/io-user/#3632-using-inputstreamreader-and-bufferedreader","title":"36.3.2 Using InputStreamReader and BufferedReader","text":"<p>To read text input, <code>System.in</code> is typically wrapped into a Reader and buffered.</p> <pre><code>BufferedReader reader =\nnew BufferedReader(new InputStreamReader(System.in));\n\nString line = reader.readLine();\n</code></pre> <p>This converts <code>bytes \u2192 characters</code> and allows line-based input.</p> <p></p>"},{"location":"en/module-08/io-user/#364-the-scanner-class-convenient-but-subtle","title":"36.4 The Scanner Class (Convenient but Subtle)","text":"<p><code>Scanner</code> is a high-level utility for parsing text input.</p> <p>It is often used for console interaction, especially in small programs.</p> <pre><code>Scanner sc = new Scanner(System.in);\nint value = sc.nextInt();\nString text = sc.nextLine();\n</code></pre> <p>Note</p> <p><code>Scanner</code> performs tokenization and parsing, not simple reading.</p> <p>This makes it convenient but slower and sometimes surprising.</p> <p></p>"},{"location":"en/module-08/io-user/#3641-common-scanner-pitfalls","title":"36.4.1 Common Scanner Pitfalls","text":"<ul> <li>Mixing <code>nextInt()</code> (and other <code>nextXxx()</code>) with <code>nextLine()</code> can appear to \"skip\" input because the trailing newline from the numeric token is still in the buffer.</li> <li>Parsing errors throw InputMismatchException</li> <li>Scanner is relatively slow for large input</li> </ul>"},{"location":"en/module-08/io-user/#365-closing-system-streams","title":"36.5 Closing System Streams","text":"<p><code>System streams</code> are special and must be handled carefully.</p> Stream Close explicitly? <code>System.out</code> No <code>System.err</code> No <code>System.in</code> Usually no <p>Closing <code>System.out</code> or <code>System.err</code> closes the underlying OS stream and affects the entire JVM: closing these streams affects the entire JVM process, not just the current class or method.</p> <p>Note</p> <p>In almost all applications, you should NOT close <code>System.out</code> or <code>System.err</code>.</p> <p></p>"},{"location":"en/module-08/io-user/#366-acquiring-input-with-console","title":"36.6 Acquiring Input with <code>Console</code>","text":"<p>The <code>Console</code> class provides a higher-level, safer way to interact with the user.</p> <p>It is designed specifically for interactive console programs.</p> <pre><code>Console console = System.console();\nif (console == null) {\n    throw new IllegalStateException(\"No console available\");\n}\n</code></pre> <p>Note</p> <p><code>System.console()</code> may return null when no console is available (e.g. IDEs, redirected input).</p> <p>The presence of a console depends on the underlying platform and on how the JVM is launched.</p> <p>If the JVM is started from an interactive command line and the standard input/output streams are not redirected, a console is typically available. In this case, the console is usually connected to the keyboard and display from which the program was launched.</p> <p>If the JVM is started in a non-interactive context \u2014 for example by an IDE, a background scheduler, a service manager, or with redirected standard streams \u2014 a console will usually not be available.</p> <p>When a console exists, it is represented by a single unique instance of the Console class, which can be obtained by invoking the <code>System.console()</code> method.  If no console device is available, this method will return <code>null</code>.</p> <p></p>"},{"location":"en/module-08/io-user/#3661-reading-input-from-console","title":"36.6.1 Reading Input from Console","text":"<pre><code>String name = console.readLine(\"Name: \");\n</code></pre> <p><code>readLine()</code> prints a prompt and reads a full line of input.</p> <p></p>"},{"location":"en/module-08/io-user/#3662-reading-passwords-securely","title":"36.6.2 Reading Passwords Securely","text":"<p>Console allows reading passwords without echoing characters.</p> <pre><code>char[] password = console.readPassword(\"Password: \");\n</code></pre> <p>Note</p> <p>Passwords are returned as <code>char[]</code> so they can be cleared from memory.</p> <p></p>"},{"location":"en/module-08/io-user/#367-formatting-console-output","title":"36.7 Formatting Console Output","text":"<p>Console also supports formatted output, similar to PrintStream.</p> <pre><code>console.printf(\"Welcome %s%n\", name);\n</code></pre> <p>This uses the same format specifiers as <code>printf()</code>.</p> <p></p>"},{"location":"en/module-08/io-user/#368-comparing-console-scanner-and-bufferedreader","title":"36.8 Comparing Console, Scanner, and BufferedReader","text":"API Use case Strengths Limitations <code>BufferedReader</code> Simple text input Fast, predictable, charset explicit Manual parsing <code>Scanner</code> Token-based / parsed input Convenient, expressive Slower, subtle token behavior <code>Console</code> Interactive console apps Passwords, prompts, formatted I/O May be unavailable (<code>null</code>)"},{"location":"en/module-08/io-user/#369-redirection-and-standard-streams","title":"36.9 Redirection and Standard Streams","text":"<p>Standard streams can be redirected by the operating system. Java code does not need to change.</p> <pre><code>java App &lt; input.txt &gt; output.txt\n</code></pre> <p>From the program\u2019s perspective, System.in and System.out still behave like normal streams.</p> <p>Note</p> <p>Redirection is handled by the operating system or shell. The Java code does not need to change to support it.</p> <p></p>"},{"location":"en/module-08/io-user/#3610-common-traps-and-best-practices","title":"36.10 Common Traps and Best Practices","text":"<ul> <li>PrintStream suppresses IOExceptions</li> <li><code>System.console()</code> can return null</li> <li>Do not close <code>System.out</code> or <code>System.err</code></li> <li>Scanner mixes parsing and reading</li> <li>Console is preferred for passwords</li> <li>If you use <code>Scanner</code> on <code>System.in</code>, do not close the Scanner if other parts of the program still need to read from <code>System.in</code> (closing the Scanner closes <code>System.in</code>).</li> </ul>"},{"location":"en/module-08/io-user/#3611-final-summary","title":"36.11 Final Summary","text":"<ul> <li><code>System.out</code> and <code>System.err</code> are PrintStreams for output</li> <li><code>System.in</code> is a byte stream that must be adapted for text</li> <li><code>BufferedReader</code> and <code>Scanner</code> are common input strategies</li> <li><code>Console</code> provides safe interactive input and output</li> <li>Standard streams integrate naturally with OS redirection</li> </ul>"},{"location":"en/module-09/jpms-compiling/","title":"38. Compiling, Packaging, and Running Modules","text":""},{"location":"en/module-09/jpms-compiling/#table-of-contents","title":"Table of Contents","text":"<ul> <li>38.1 The Module Path vs the Classpath</li> <li>38.2 Module-Related Command-Line Options<ul> <li>38.2.1 Options Available in Both java and javac</li> <li>38.2.2 Options Applicable Only to javac</li> <li>38.2.3 Options Applicable Only to java</li> <li>38.2.4 Important Distinctions</li> </ul> </li> <li>38.3 Compiling a Single Module</li> <li>38.4 Compiling Multiple Interdependent Modules</li> <li>38.5 Packaging a Module into a Modular JAR</li> <li>38.6 Running a Modular Application</li> <li>38.7 Module Directives Explained<ul> <li>38.7.1 requires</li> <li>38.7.2 requires transitive</li> <li>38.7.3 exports</li> <li>38.7.4 exports-to-qualified-exports</li> <li>38.7.5 opens</li> <li>38.7.6 opens-to-qualified-opens</li> <li>38.7.7 Table of Core Directives</li> <li>38.7.8 Exports vs Opens \u2014 Compile-Time vs Runtime Access</li> </ul> </li> <li>38.8 Named, Automatic, and Unnamed Modules<ul> <li>38.8.1 Named Modules</li> <li>38.8.2 Automatic Modules</li> <li>38.8.3 Unnamed Module</li> <li>38.8.4 Comparison Summary</li> </ul> </li> <li>38.9 Inspecting Modules and Dependencies<ul> <li>38.9.1 Describing Modules with java</li> <li>38.9.2 Describing Modular JARs</li> <li>38.9.3 Analyzing Dependencies with jdeps</li> </ul> </li> <li>38.10 Creating Custom Runtime Images with jlink</li> <li>38.11 Creating Self-Contained Applications with jpackage</li> <li>38.12 Final Summary JPMS in Practice</li> </ul> <p>Once a <code>module</code> is defined with a <code>module-info.java</code> file, it must be compiled, packaged, and executed using module-aware tools.</p> <p>This section explains how the <code>Java toolchain</code> changes when modules are involved.</p> <p></p>"},{"location":"en/module-09/jpms-compiling/#381-the-module-path-vs-the-classpath","title":"38.1 The Module Path vs the Classpath","text":"<p><code>JPMS</code> introduces a new concept: the module path.</p> <p>It exists alongside the traditional classpath, but the two behave very differently.</p> Aspect Classpath Module path Structure Flat list of JARs Modules with identities Encapsulation None Strong Dependency checking None Strict Split packages Allowed Forbidden (named modules) Resolution order Order-dependent Deterministic <p>Note</p> <ul> <li>A JAR placed on the <code>module path</code> becomes a <code>named (or automatic) module</code>.</li> <li>A JAR placed on the <code>classpath</code> is treated as part of the <code>unnamed module</code>.</li> <li>Split packages are allowed on the classpath but forbidden for named modules on the module path.</li> </ul> <p></p>"},{"location":"en/module-09/jpms-compiling/#382-module-related-command-line-options","title":"38.2 Module-Related Command-Line Options","text":"<p>When working with the Java Module System, both <code>java</code> and <code>javac</code> provide specific options for compiling and running modular applications. </p> <p>Some options are shared, while others are specific to one tool.</p> <p></p>"},{"location":"en/module-09/jpms-compiling/#3821-options-available-in-both-java-and-javac","title":"38.2.1 Options Available in Both <code>java</code> and <code>javac</code>","text":"<p>These options can be used during compilation as well as execution:</p> <ul> <li> <p><code>--module</code> or <code>-m</code>   Used to compile or run only the specified module.</p> </li> <li> <p><code>--module-path</code> or <code>-p</code>   Specifies the paths where <code>java</code> or <code>javac</code> will look for module definitions.</p> </li> </ul> <p></p>"},{"location":"en/module-09/jpms-compiling/#3822-options-applicable-only-to-javac","title":"38.2.2 Options Applicable Only to <code>javac</code>","text":"<p>These options apply only at compile time:</p> <ul> <li> <p><code>--module-source-path</code>   (no shortcut)   Used by <code>javac</code> to locate source module definitions.</p> </li> <li> <p><code>-d</code>   Specifies the output directory where the <code>.class</code> files will be generated after compilation.</p> </li> </ul> <p></p>"},{"location":"en/module-09/jpms-compiling/#3823-options-applicable-only-to-java","title":"38.2.3 Options Applicable Only to <code>java</code>","text":"<p>These options apply only at runtime:</p> <ul> <li> <p><code>--list-modules</code>   (no shortcut)   Lists all observable modules and then exits.</p> </li> <li> <p><code>--show-module-resolution</code>   (no shortcut)   Displays module resolution details during application startup.</p> </li> <li> <p><code>--describe-module</code> or <code>-d</code>   Describes a specified module and then exits.</p> </li> </ul> <p></p>"},{"location":"en/module-09/jpms-compiling/#3824-important-distinctions","title":"38.2.4 Important Distinctions","text":"<p>The option <code>-d</code> has different meanings depending on the tool:</p> <ul> <li>In <code>javac</code>, <code>-d</code> defines the output directory for compiled class files.</li> <li>In <code>java</code>, <code>-d</code> is a shortcut for <code>--describe-module</code>.</li> </ul> <p>Additionally, <code>-d</code> must not be confused with <code>-D</code> (uppercase D).</p> <ul> <li><code>-D</code> is used when running a Java program to define system properties as name-value pairs on the command line.</li> </ul> <pre><code>java -Dconfig.file=app.properties com.example.Main\n</code></pre> <p>In this example, <code>-Dconfig.file=app.properties</code> sets a system property that can be accessed at runtime using <code>System.getProperty(\"config.file\")</code>.</p> <p></p>"},{"location":"en/module-09/jpms-compiling/#383-compiling-a-single-module","title":"38.3 Compiling a Single Module","text":"<p>To compile a module, you must specify the module source path and the destination directory.</p> <pre><code>javac -d out \\\nsrc/com.example.hello/module-info.java \\\nsrc/com.example.hello/com/example/hello/Main.java\n</code></pre> <p>A more scalable approach uses <code>--module-source-path</code>.</p> <pre><code>javac --module-source-path src \\\n      -d out \\\n      $(find src -name \"*.java\")\n</code></pre> <p>Note</p> <p><code>--module-source-path</code> tells javac where to find multiple modules at once.</p> <p></p>"},{"location":"en/module-09/jpms-compiling/#384-compiling-multiple-interdependent-modules","title":"38.4 Compiling Multiple Interdependent Modules","text":"<p>When modules depend on each other, their dependencies must be resolvable at compile time.</p> <p><code>--module-path</code> mods (sample dir containing interdependent moules) should contain already-compiled modular JARs or compiled module directories (each with its own module-info.class).</p> <pre><code>javac -d out \\\n--module-source-path src \\\n--module-path mods \\\n$(find src -name \"*.java\")\n</code></pre> <p>Here: - <code>--module-source-path</code> locates module source trees - <code>--module-path</code> provides already-compiled modules</p> <p></p>"},{"location":"en/module-09/jpms-compiling/#385-packaging-a-module-into-a-modular-jar","title":"38.5 Packaging a Module into a Modular JAR","text":"<p>After compilation, modules are typically packaged as JAR files.</p> <p>A modular JAR contains a <code>module-info.class</code> at its root.</p> <p>If <code>module-info.class</code> is present, the JAR becomes a <code>named module</code> automatically and its <code>name</code> is taken from the descriptor (not the filename).</p> <pre><code>jar --create \\\n--file mods/com.example.hello.jar \\\n--main-class com.example.hello.Main \\\n-C out/com.example.hello .\n</code></pre> <p>Note</p> <p>A JAR with <code>module-info.class</code> is a <code>named module, not an automatic module</code>. When a JAR contains a <code>module-info.class</code>, its module name is taken from that file and not inferred from the filename.</p> <p></p>"},{"location":"en/module-09/jpms-compiling/#386-running-a-modular-application","title":"38.6 Running a Modular Application","text":"<p>To run a modular application, you use the <code>module path</code> and specify the <code>module name</code>.</p> <pre><code>java --module-path mods \\\n--module com.example.hello/com.example.hello.Main\n</code></pre> <p>You can shorten this using the <code>-p</code> and <code>-m</code> options.</p> <pre><code>java -p mods -m com.example.hello/com.example.hello.Main\n</code></pre> <p>Note</p> <p>When using named modules, the classpath is ignored for resolution of module dependencies.</p> <p></p>"},{"location":"en/module-09/jpms-compiling/#387-module-directives-explained","title":"38.7 Module Directives Explained","text":"<p>The <code>module-info.java</code> file contains directives that describe dependencies, visibility, and services.</p> <p>Each directive has a precise meaning.</p> <p></p>"},{"location":"en/module-09/jpms-compiling/#3871-requires","title":"38.7.1 <code>requires</code>","text":"<p>The <code>requires</code> directive declares a dependency on another module.</p> <p>Without it, types from the dependency module cannot be used.</p> <pre><code>module com.example.app {\n    requires com.example.lib;\n}\n</code></pre> <p>Effects of requires: - Dependency must be present at compile and runtime - Exported packages of the required module become accessible</p> <p></p>"},{"location":"en/module-09/jpms-compiling/#3872-requires-transitive","title":"38.7.2 <code>requires transitive</code>","text":"<p><code>requires transitive</code> exposes a dependency to downstream modules.</p> <p>It propagates readability.</p> <pre><code>module com.example.lib {\n    requires transitive com.example.util;\n    exports com.example.lib.api;\n}\n</code></pre> <p>Meaning: - Any module requiring com.example.lib automatically reads com.example.util - Callers do not need to declare requires com.example.util explicitly</p> <p>Note</p> <p>This is similar to \u201cpublic dependencies\u201d in other module systems.</p> <p>Readable \u2260 exported: a transitive requirement does not export your packages automatically.</p> <p></p>"},{"location":"en/module-09/jpms-compiling/#3873-exports","title":"38.7.3 <code>exports</code>","text":"<p><code>exports</code> makes a package accessible to other modules.</p> <p>Only exported packages are visible outside the module.</p> <pre><code>module com.example.lib {\n    exports com.example.lib.api;\n}\n</code></pre> <p>Non-exported packages remain strongly encapsulated.</p> <p></p>"},{"location":"en/module-09/jpms-compiling/#3874-exports-to-qualified-exports","title":"38.7.4 <code>exports ... to</code> (Qualified Exports)","text":"<p>A qualified export restricts access to specific modules.</p> <pre><code>module com.example.lib {\n    exports com.example.internal to com.example.friend;\n}\n</code></pre> <p>Only the listed modules can access the exported package.</p> <p></p>"},{"location":"en/module-09/jpms-compiling/#3875-opens","title":"38.7.5 <code>opens</code>","text":"<p><code>opens</code> allows deep reflective access to a package.</p> <p>This is primarily for frameworks using reflection.</p> <pre><code>module com.example.app {\n    opens com.example.app.model;\n}\n</code></pre> <p>Note</p> <p>opens does NOT make a package accessible at compile time. It only affects runtime reflection.</p> <p></p>"},{"location":"en/module-09/jpms-compiling/#3876-opens-to-qualified-opens","title":"38.7.6 <code>opens ... to</code> (Qualified Opens)","text":"<p>You can restrict reflective access to specific modules.</p> <pre><code>module com.example.app {\n    opens com.example.app.model to com.fasterxml.jackson.databind;\n}\n</code></pre> <p>Note</p> <p><code>opens</code> affects reflection; <code>exports</code> affects compilation and type visibility.</p> <p></p>"},{"location":"en/module-09/jpms-compiling/#3877-table-of-core-directives","title":"38.7.7 Table of Core Directives","text":"Directive Purpose <code>requires</code> Declare a dependency <code>requires transitive</code> Propagate dependency <code>exports</code> Expose a package <code>exports ... to</code> Expose to specific modules <code>opens</code> Allow runtime reflection <code>opens ... to</code> Restrict reflective access"},{"location":"en/module-09/jpms-compiling/#3878-exports-vs-opens-compile-time-vs-runtime-access","title":"38.7.8 Exports vs Opens \u2014 Compile-Time vs Runtime Access","text":"Visibility Compile-time? Runtime reflection? <code>exports</code> Yes No <code>opens</code> No Yes <code>exports ... to</code> Yes (limited modules) No <code>opens ... to</code> No Yes (limited modules) <p>Important</p> <p><code>JPMS</code> adds a <code>module path</code>, but the <code>classpath</code> still exists. They can coexist, but named modules take precedence.</p> <p></p>"},{"location":"en/module-09/jpms-compiling/#388-named-automatic-and-unnamed-modules","title":"38.8 Named, Automatic, and Unnamed Modules","text":"<p><code>JPMS</code> supports different kinds of modules to allow gradual migration from the classpath.</p> <p>JPMS must interoperate with legacy code.</p> <p>To support gradual adoption, the JVM recognizes three different module categories.</p> <p></p>"},{"location":"en/module-09/jpms-compiling/#3881-named-modules","title":"38.8.1 Named Modules","text":"<p>A <code>named module</code> has a <code>module-info.class</code> and a stable identity.</p> <ul> <li>Strong encapsulation</li> <li>Explicit dependencies</li> <li>Full JPMS support</li> </ul> <p></p>"},{"location":"en/module-09/jpms-compiling/#3882-automatic-modules","title":"38.8.2 Automatic Modules","text":"<p>A JAR without <code>module-info</code> placed on the <code>module path</code> becomes an <code>automatic module</code>.</p> <p>Its name is derived from the JAR file name.</p> <ul> <li>Reads all other modules</li> <li>Exports all packages</li> <li>No strong encapsulation</li> </ul> <p>Note</p> <p>Automatic modules exist to ease migration. They are not suitable as a long-term design.</p> <p></p>"},{"location":"en/module-09/jpms-compiling/#3883-unnamed-module","title":"38.8.3 Unnamed Module","text":"<p>Code on the classpath belongs to the <code>unnamed module</code>.</p> <ul> <li>Reads all named modules</li> <li>All packages are open</li> <li>Cannot be required by named modules</li> </ul> <p>Note</p> <p>The <code>unnamed module</code> preserves legacy classpath behavior.</p> <p></p>"},{"location":"en/module-09/jpms-compiling/#3884-comparison-summary","title":"38.8.4 Comparison Summary","text":"Module type module-info present? Encapsulation Reads <code>Named</code> Yes Strong Declared only <code>Automatic</code> No Weak All modules <code>Unnamed</code> No None All modules"},{"location":"en/module-09/jpms-compiling/#389-inspecting-modules-and-dependencies","title":"38.9 Inspecting Modules and Dependencies","text":""},{"location":"en/module-09/jpms-compiling/#3891-describing-modules-with-java","title":"38.9.1 Describing Modules with java","text":"<pre><code>java --describe-module java.sql\n</code></pre> <p>This shows <code>exports</code>, <code>requires</code>, and <code>services</code> of a module.</p> <p></p>"},{"location":"en/module-09/jpms-compiling/#3892-describing-modular-jars","title":"38.9.2 Describing Modular JARs","text":"<pre><code>jar --describe-module --file mylib.jar\n</code></pre>"},{"location":"en/module-09/jpms-compiling/#3893-analyzing-dependencies-with-jdeps","title":"38.9.3 Analyzing Dependencies with <code>jdeps</code>","text":"<p><code>jdeps</code> analyzes class and module dependencies statically.</p> <pre><code>jdeps myapp.jar\n</code></pre> <pre><code>jdeps --module-path mods --check my.module\n</code></pre> <p>To detect use of JDK internal APIs:</p> <pre><code>jdeps --jdk-internals myapp.jar\n</code></pre> <p></p>"},{"location":"en/module-09/jpms-compiling/#3810-creating-custom-runtime-images-with-jlink","title":"38.10 Creating Custom Runtime Images with <code>jlink</code>","text":"<p><code>jlink</code> builds a minimal Java runtime containing only the modules required by an application.</p> <pre><code>jlink\n--module-path $JAVA_HOME/jmods:mods\n--add-modules com.example.app\n--output runtime-image\n</code></pre> <p>Benefits: - smaller runtime - faster startup - no unused JDK modules</p> <p></p>"},{"location":"en/module-09/jpms-compiling/#3811-creating-self-contained-applications-with-jpackage","title":"38.11 Creating Self-Contained Applications with <code>jpackage</code>","text":"<p><code>jpackage</code> builds platform-specific installers or application images.</p> <pre><code>jpackage\n--name MyApp\n--input mods\n--main-module com.example.app/com.example.Main\n</code></pre> <p><code>jpackage</code> can produce: - .exe / .msi (Windows) - .pkg / .dmg (macOS) - .deb / .rpm (Linux)</p> <p></p>"},{"location":"en/module-09/jpms-compiling/#3812-final-summary-jpms-in-practice","title":"38.12 Final Summary JPMS in Practice","text":"<ul> <li><code>JPMS</code> introduces <code>strong encapsulation</code> and reliable dependencies</li> <li><code>Modules</code> replace fragile classpath conventions</li> <li><code>Services</code> enable decoupled architectures</li> <li><code>Automatic</code> and <code>unnamed modules</code> support migration</li> <li><code>jlink</code> and <code>jpackage</code> enable modern deployment models</li> </ul>"},{"location":"en/module-09/jpms-services/","title":"39. Services in JPMS (The ServiceLoader Model)","text":""},{"location":"en/module-09/jpms-services/#table-of-contents","title":"Table of Contents","text":"<ul> <li>39.1 The Problem Services Solve<ul> <li>39.1.1 Roles in the Service Model</li> <li>39.1.2 Service Interface Module</li> <li>39.1.3 Service Provider Module</li> <li>39.1.4 Service Consumer Module</li> <li>39.1.5 Loading Services at Runtime</li> <li>39.1.6 Service Resolution Rules</li> <li>39.1.7 Service Locator Layer</li> <li>39.1.8 Sequential Invocation Diagram</li> <li>39.1.9 Component Summary Table</li> </ul> </li> </ul> <p><code>JPMS</code> includes a built-in service mechanism that allows <code>modules</code> to discover and use implementations at runtime without hardcoding dependencies between <code>providers</code> and <code>consumers</code>.</p> <p>This mechanism is based on the existing <code>ServiceLoader API</code>, but modules make it reliable, explicit, and safe.</p> <p></p>"},{"location":"en/module-09/jpms-services/#391-the-problem-services-solve","title":"39.1 The Problem Services Solve","text":"<p>Sometimes a module needs to use a capability, but should not depend on a specific implementation.</p> <p>Typical examples include: - logging frameworks - database drivers - plugin systems - service providers selected at runtime</p> <p>Without services, the consumer would need to depend directly on a concrete implementation.</p> <p>This creates tight coupling and reduces flexibility.</p> <p></p>"},{"location":"en/module-09/jpms-services/#3911-roles-in-the-service-model","title":"39.1.1 Roles in the Service Model","text":"<p>The <code>JPMS service model</code> involves four distinct roles.</p> Role Description <code>Service interface</code> Defines the contract <code>Service provider</code> Implements the service <code>Service consumer</code> Uses the service <code>Service loader</code> Discovers implementations at runtime <p></p>"},{"location":"en/module-09/jpms-services/#3912-service-interface-module","title":"39.1.2 Service Interface Module","text":"<p>The <code>service interface</code> defines the API that <code>consumers</code> depend on.</p> <p>It must be exported so other modules can see it.</p> <pre><code>package com.example.service;\n\npublic interface GreetingService {\n    String greet(String name);\n}\n</code></pre> <pre><code>module com.example.service {\n    exports com.example.service;\n}\n</code></pre> <p>Note</p> <p>The service interface module should contain no implementations.</p> <p></p>"},{"location":"en/module-09/jpms-services/#3913-service-provider-module","title":"39.1.3 Service Provider Module","text":"<p>A <code>provider module</code> implements the service interface and declares that it provides the service.</p> <pre><code>package com.example.service.impl;\n\nimport com.example.service.GreetingService;\n\npublic class EnglishGreeting implements GreetingService {\n    public String greet(String name) {\n        return \"Hello \" + name;\n    }\n}\n</code></pre> <pre><code>module com.example.provider.english {\n    requires com.example.service;\n    provides com.example.service.GreetingService with com.example.service.impl.EnglishGreeting;\n}\n</code></pre> <p>Key points: - The <code>provider</code> depends on the <code>service interface</code> - The implementation class does not need to be exported - The <code>provides</code> directive registers the implementation</p> <p></p>"},{"location":"en/module-09/jpms-services/#3914-service-consumer-module","title":"39.1.4 Service Consumer Module","text":"<p>The <code>consumer module</code> declares that it uses a service, but does not name any implementation.</p> <pre><code>module com.example.consumer {\n    requires com.example.service;\n    uses com.example.service.GreetingService;\n}\n</code></pre> <p>Note</p> <p><code>uses</code> declares intent to discover implementations at runtime.</p> <p>A module that declares <code>uses</code> but has no matching provider on the module path compiles normally, but <code>ServiceLoader</code> returns an empty result at runtime.</p> <p></p>"},{"location":"en/module-09/jpms-services/#3915-loading-services-at-runtime","title":"39.1.5 Loading Services at Runtime","text":"<p>The <code>ServiceLoader API</code> performs service discovery.</p> <p>It finds all providers visible to the module graph.</p> <pre><code>ServiceLoader&lt;GreetingService&gt; loader =\n    ServiceLoader.load(GreetingService.class);\n\nfor (GreetingService service : loader) {\n    System.out.println(service.greet(\"World\"));\n}\n</code></pre> <p><code>JPMS</code> guarantees that only declared providers are discovered.</p> <p>Classpath-based \u201caccidental\u201d discovery is prevented.</p> <p></p>"},{"location":"en/module-09/jpms-services/#3916-service-resolution-rules","title":"39.1.6 Service Resolution Rules","text":"<p>For a service to be discoverable by <code>ServiceLoader</code>, several conditions must be satisfied:</p> Rule Meaning Provider module must be readable Resolved by <code>requires</code> graph Service interface must be exported Consumers must see it Consumer must declare <code>uses</code> Otherwise ServiceLoader fails Provider must declare <code>provides</code> Implicit discovery is forbidden <p></p>"},{"location":"en/module-09/jpms-services/#3917-service-locator-layer","title":"39.1.7 Service Locator Layer","text":"<p>It is possible to introduce an additional layer called <code>Service Locator</code>.</p> <p>In this architecture:</p> <ul> <li>The <code>consumer</code> does not directly use <code>ServiceLoader</code></li> <li>The <code>Service Locator</code> is the only component that declares <code>uses</code></li> <li>The <code>consumer</code> depends on the <code>Service Locator</code></li> </ul> <p>Architectural structure:</p> <pre><code>Consumer \u2192 Service Locator \u2192 ServiceLoader \u2192 Provider\n</code></pre> <p>Service Locator module:</p> <pre><code>module com.example.locator {\n    requires com.example.service;\n    uses com.example.service.GreetingService;\n}\n</code></pre> <p>Service Locator class:</p> <pre><code>package com.example.locator;\n\nimport java.util.ServiceLoader;\nimport com.example.service.GreetingService;\n\npublic class GreetingLocator {\n\n    public static GreetingService getService() {\n        return ServiceLoader\n                .load(GreetingService.class)\n                .findFirst()\n                .orElseThrow();\n    }\n}\n</code></pre> <p>Consumer module:</p> <pre><code>module com.example.consumer {\n    requires com.example.locator;\n}\n</code></pre> <p>The consumer does not declare <code>uses</code> because it does not directly invoke <code>ServiceLoader</code>.</p> <p></p>"},{"location":"en/module-09/jpms-services/#3918-sequential-invocation-diagram","title":"39.1.8 Sequential Invocation Diagram","text":"<p>Execution sequence:</p> <ol> <li>The <code>Consumer</code> invokes <code>GreetingLocator.getService()</code></li> <li>The <code>Service Locator</code> invokes <code>ServiceLoader.load(...)</code></li> <li>The <code>ServiceLoader</code> consults the module graph</li> <li>The system identifies modules that declare <code>provides</code></li> <li>The <code>Provider</code> implementation is instantiated</li> <li>The instance is returned to the <code>Consumer</code></li> </ol> <p>Sequential diagram:</p> <pre><code>Consumer\n   \u2502\n   \u2502 1. getService()\n   \u25bc\nService Locator\n   \u2502\n   \u2502 2. ServiceLoader.load()\n   \u25bc\nServiceLoader\n   \u2502\n   \u2502 3. Provider resolution\n   \u25bc\nProvider Implementation\n   \u2502\n   \u2502 4. Instance returned\n   \u25bc\nConsumer\n</code></pre> <p></p>"},{"location":"en/module-09/jpms-services/#3919-component-summary-table","title":"39.1.9 Component Summary Table","text":"Component Role exports requires uses provides SPI Defines contract \u2705 \u274c \u274c \u274c Provider Implements service \u274c \u2705 \u274c \u2705 Service Locator Performs discovery (optional) \u2705 \u2705 \u274c Consumer Uses the service \u274c \u2705 \u274c \u274c"},{"location":"en/module-09/jpms/","title":"37. Java Platform Module System (JPMS)","text":""},{"location":"en/module-09/jpms/#table-of-contents","title":"Table of Contents","text":"<ul> <li>37.1 Why Modules Were Introduced<ul> <li>37.1.1 Problems with the Classpath</li> <li>37.1.2 Example of a Classpath Problem</li> </ul> </li> <li>37.2 What Is a Module<ul> <li>37.2.1 Core Properties of Modules</li> <li>37.2.2 Module vs Package vs JAR</li> </ul> </li> <li>37.3 The module-infojava Descriptor<ul> <li>37.3.1 Minimal Module Descriptor</li> </ul> </li> <li>37.4 Module Directory Structure</li> <li>37.5 A First Modular Program<ul> <li>37.5.1 Main Class</li> <li>37.5.2 Module Descriptor</li> </ul> </li> <li>37.6 Strong Encapsulation Explained</li> <li>37.7 Summary of Key Ideas</li> </ul> <p>The <code>Java Platform Module System</code> (JPMS) was introduced in Java 9.</p> <p>It is a language-level and runtime-level mechanism for structuring Java applications into strongly encapsulated units called <code>modules</code>.</p> <p>JPMS affects how code is: - organized - compiled - linked - packaged - loaded at runtime</p> <p>Understanding JPMS is essential for modern Java, especially for large applications, libraries, runtime images, and deployment tooling.</p> <p></p>"},{"location":"en/module-09/jpms/#371-why-modules-were-introduced","title":"37.1 Why Modules Were Introduced","text":"<p>Before Java 9, Java applications were built using only: - <code>packages</code> - <code>JAR</code> files - the <code>classpath</code></p> <p>This model had serious limitations as applications grew.</p> <p></p>"},{"location":"en/module-09/jpms/#3711-problems-with-the-classpath","title":"37.1.1 Problems with the Classpath","text":"<p>The classpath is a flat list of JARs where: - all public classes are accessible to everyone - there is no reliable dependency declaration - conflicting versions are common - encapsulation is weak or nonexistent - duplicate classes silently overwrite each other based on classpath order</p> <p>This led to well-known issues such as: - \u201cJAR hell\u201d - classpath ordering bugs - accidental use of internal APIs - runtime failures that were not detected at compile time</p> <p></p>"},{"location":"en/module-09/jpms/#3712-example-of-a-classpath-problem","title":"37.1.2 Example of a Classpath Problem","text":"<p>Suppose two libraries depend on different versions of the same third-party JAR.</p> <p>Only one version can be placed on the classpath.</p> <p>Which one is chosen depends on classpath order, not correctness.</p> <p>Note</p> <p>This problem cannot be reliably solved with the classpath alone.</p> <p></p>"},{"location":"en/module-09/jpms/#372-what-is-a-module","title":"37.2 What Is a Module?","text":"<p>A <code>module</code> is a named, self-describing unit of code.</p> <p>In summary, a module is a collection of one or more related packages, together with a module descriptor file that explicitly defines its dependencies and the functionality it makes available.  </p> <p>A module therefore provides its consumers with a clearly defined and controlled set of capabilities.</p> <p>Every named module has a unique name that identifies it to the compiler and module system.</p> <p>It explicitly declares: - what it depends on - what it exposes to other modules - what it keeps hidden</p> <p>A module is stronger than a package and more structured than a JAR.</p> <p></p>"},{"location":"en/module-09/jpms/#3721-core-properties-of-modules","title":"37.2.1 Core Properties of Modules","text":"Property Description Strong encapsulation Packages are hidden by default Explicit dependencies Dependencies must be declared Reliable configuration Missing dependencies cause errors early Named identity Each module has a unique name"},{"location":"en/module-09/jpms/#3722-module-vs-package-vs-jar","title":"37.2.2 Module vs Package vs JAR","text":"Concept Purpose Encapsulation Package Namespace grouping Weak (public still visible) JAR Packaging / deployment None (all classes visible when on classpath) Module Encapsulation + dependency unit Strong (unexported packages hidden)"},{"location":"en/module-09/jpms/#373-the-module-infojava-descriptor","title":"37.3 The <code>module-info.java</code> Descriptor","text":"<p>Every <code>named module</code> is defined by a module descriptor file named:</p> <pre><code>module-info.java\n</code></pre> <p>This file describes the module to the compiler and the runtime.</p> <p></p>"},{"location":"en/module-09/jpms/#3731-minimal-module-descriptor","title":"37.3.1 Minimal Module Descriptor","text":"<p>A minimal module descriptor declares only the module name. The filename must be exactly <code>module-info.java</code>, and it must be located in the root of the module source tree.</p> <pre><code>module com.example.hello {\n}\n</code></pre> <p>Note</p> <p>A module with no directives exports nothing and depends on nothing.</p> <p></p>"},{"location":"en/module-09/jpms/#374-module-directory-structure","title":"37.4 Module Directory Structure","text":"<p>A modular project follows a standard directory layout. The module descriptor sits at the root of the module\u2019s source tree.</p> <pre><code>src/\n\u2514\u2500 com.example.hello/\n    \u251c\u2500 module-info.java\n    \u2514\u2500 com/\n        \u2514\u2500 example/\n            \u2514\u2500 hello/\n                \u2514\u2500 Main.java\n</code></pre> <p>Key points: - The directory name matches the module name - <code>module-info.java</code> is at the top of the module source root - packages follow standard Java naming rules</p> <p>Note</p> <p>In IDE and build-tool projects, the file structure may differ (e.g. Maven uses <code>src/main/java</code>). What always remains true: <code>module-info.java</code> sits in the root of the module source tree and package paths follow standard Java naming.</p> <p></p>"},{"location":"en/module-09/jpms/#375-a-first-modular-program","title":"37.5 A First Modular Program","text":"<p>Let\u2019s create a minimal modular application.</p> <p></p>"},{"location":"en/module-09/jpms/#3751-main-class","title":"37.5.1 Main Class","text":"<pre><code>package com.example.hello;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, modular world!\");\n    }\n}\n</code></pre>"},{"location":"en/module-09/jpms/#3752-module-descriptor","title":"37.5.2 Module Descriptor","text":"<pre><code>module com.example.hello {\n    exports com.example.hello;\n}\n</code></pre> <p>The <code>exports directive</code> makes the package accessible to other modules.</p> <p>Without it, the package is encapsulated and inaccessible.</p> <p></p>"},{"location":"en/module-09/jpms/#376-strong-encapsulation-explained","title":"37.6 Strong Encapsulation Explained","text":"<p>In <code>JPMS</code>, packages are NOT accessible by default.</p> <p>Even public classes are hidden unless explicitly exported.</p> <p>In modules, <code>public</code> means \u201cpublic to other modules only if the containing package is exported.\u201d</p> Situation Accessible from another module? Public class in non-exported package No Public class in exported package Yes Protected member in exported package Yes, but only via subclassing (not general access) Package-private class/member (any package) No Private member No <p>Note</p> <p>This is a fundamental difference from the classpath model.</p> <p></p>"},{"location":"en/module-09/jpms/#377-summary-of-key-ideas","title":"37.7 Summary of Key Ideas","text":"<ul> <li><code>JPMS</code> introduces modules as strong units of encapsulation</li> <li>Dependencies are explicit and checked</li> <li><code>module-info.java</code> is the central descriptor</li> <li>Packages are hidden unless exported</li> <li>Classpath-based visibility no longer applies in modules</li> <li>Public visibility is no longer enough: module exports control accessibility</li> </ul>"},{"location":"fr/","title":"Index","text":"<p>\ud83c\udf0d Langue: English | Italiano | Fran\u00e7ais</p>"},{"location":"fr/#index-du-cours-java-21","title":"Index du cours (Java 21)","text":""},{"location":"fr/#module-00-prerequisites-setup","title":"Module 00 \u2014 Prerequisites &amp; Setup","text":"<ul> <li>Mat\u00e9riel de support</li> <li>Eclipse shortcuts</li> </ul>"},{"location":"fr/#module-01-java-language-basics","title":"Module 01 \u2014 Java Language Basics","text":"<ul> <li>1. Blocs Syntaxiques Fondamentaux</li> <li>2. Blocs de base du langage Java</li> <li>3. R\u00e8gles de nommage Java</li> <li>4. Types de donn\u00e9es Java et cast</li> <li>5. Op\u00e9rateurs Java</li> <li>6. Instanciation des types</li> </ul>"},{"location":"fr/#module-02-control-flow","title":"Module 02 \u2014 Control Flow","text":"<ul> <li>7. Flux de contr\u00f4le</li> <li>8. Constructions de boucle en Java</li> </ul>"},{"location":"fr/#module-03-core-standard-apis","title":"Module 03 \u2014 Core Standard APIs","text":"<ul> <li>9. Cha\u00eenes de caract\u00e8res en Java</li> <li>10. Tableaux en Java</li> <li>11. Math\u00e9matiques en Java</li> <li>12. Date et heure en Java</li> <li>13. Mise en forme et localisation en Java</li> </ul>"},{"location":"fr/#module-04-object-oriented-fundamentals","title":"Module 04 \u2014 Object-Oriented Fundamentals","text":"<ul> <li>14. M\u00e9thodes, Attributs et Variables</li> <li>15. Chargement des Classes, Initialisation et Construction des Objets</li> <li>16. H\u00e9ritage en Java</li> <li>17. Au-del\u00e0 des Classes</li> <li>18. Generics en Java</li> <li>19. Exceptions et Gestion des Erreurs</li> </ul>"},{"location":"fr/#module-05-functional-programming","title":"Module 05 \u2014 Functional Programming","text":"<ul> <li>20. Programmation Fonctionnelle en Java</li> <li>21. Java Optional et Streams</li> </ul>"},{"location":"fr/#module-06-collections-framework","title":"Module 06 \u2014 Collections Framework","text":"<ul> <li>22. Introduction au Framework des Collections</li> <li>23. Op\u00e9rations Partag\u00e9es des Collections &amp; \u00c9galit\u00e9</li> <li>24. Comparable, Comparator &amp; Tri en Java</li> <li>25. L\u2019API List</li> <li>26. Set API</li> <li>27. API Queue &amp; Deque</li> <li>28. Map API</li> <li>29. Collections S\u00e9quenc\u00e9es &amp; Map S\u00e9quenc\u00e9es</li> </ul>"},{"location":"fr/#module-07-concurrency-and-threads","title":"Module 07 \u2014 Concurrency and Threads","text":"<ul> <li>30. Thread Java \u2013 Fondamentaux et Mod\u00e8le d\u2019Ex\u00e9cution</li> <li>31. Java Concurrency APIs</li> </ul>"},{"location":"fr/#module-08-java-io-and-nio","title":"Module 08 \u2014 Java I/O and NIO","text":"<ul> <li>32. Fondamentaux des fichiers et des chemins</li> <li>33. APIs des fichiers et des chemins</li> <li>34. Streams I/O Java</li> <li>35. API Java d\u2019E/S (Legacy et NIO)</li> <li>36. Interagir avec l\u2019Utilisateur (Flux E/S Standard)</li> </ul>"},{"location":"fr/#module-09-java-platform-module-system-jpms","title":"Module 09 \u2014 Java Platform Module System (JPMS)","text":"<ul> <li>37. Java Platform Module System (JPMS)</li> <li>38. Compiler, Empaqueter et Ex\u00e9cuter des Modules</li> <li>39. Services en JPMS (Le Mod\u00e8le ServiceLoader)</li> </ul>"},{"location":"fr/module-00/eclipse-shortcuts/","title":"Eclipse main shortcuts","text":"WIN APPLE DESCRIPTION <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + 3</code> <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + 3</code> Go to quick access search for available views, actions, wizards, menus and more <code>&lt;kbd&gt;Alt&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + Q Q</code> <code>&lt;kbd&gt;\u2325&lt;/kbd&gt; + &lt;kbd&gt;\u2318&lt;/kbd&gt; + Q Q</code> Show all available views and select one or more to open <code>F2</code> <code>F2</code> Show Javadoc for the selected element <code>F3 or &lt;kbd&gt;Ctrl&lt;/kbd&gt; + Left click</code> <code>F3 or &lt;kbd&gt;\u2318&lt;/kbd&gt; + Left click</code> In a code editor, go to the declaration of the selected symbol <code>F4</code> <code>F4</code> Show selected symbol in the \u201cType Hierarchy\u201d view <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + T</code> <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + T</code> Open dialog to search for a type (class, interface, enum) <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + Alt + H</code> <code>^ + &lt;kbd&gt;\u2325&lt;/kbd&gt; + H</code> Open selected callable symbol in the \u201cCall Hierarchy\u201d view <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + G</code> <code>&lt;kbd&gt;\u21e7&lt;/kbd&gt; + &lt;kbd&gt;\u2318&lt;/kbd&gt; + G</code> Search workspace for all references to the symbol <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + R</code> <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + R</code> Open dialog to search resources (e.g. text files) by filename <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + F</code> <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + F</code> Find/replace in the current file <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + H</code> <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + H</code> Find/replace in current file, project, or workspace <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + L</code> <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + L</code> Go to a line number <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + .</code> <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + .</code> Jump to next occurrence, warning or error <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + ,</code> <code>&lt;kbd&gt;\u21e7&lt;/kbd&gt; + &lt;kbd&gt;\u2318&lt;/kbd&gt; + .</code> Jump to previous occurrence, warning or error <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + D</code> <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + D</code> Delete line at cursor position <code>&lt;kbd&gt;Alt&lt;/kbd&gt; + \u2191</code> or <code>&lt;kbd&gt;Alt&lt;/kbd&gt; + \u2193</code> <code>&lt;kbd&gt;\u2325&lt;/kbd&gt; + \u2191</code> or <code>&lt;kbd&gt;\u2325&lt;/kbd&gt; + \u2193</code> Move current line one line above or one line below <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + Space</code> <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + Space</code> Open content assist dialog (based on current context) <code>Type \"main\", \"if\", \"for\", \"while\", \"do\", \"syso\" + &lt;kbd&gt;Ctrl&lt;/kbd&gt; + Space</code> (same as before) +  <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + Space</code> Autocomplete element <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + F</code> Format code <code>&lt;kbd&gt;Alt&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + Z</code> <code>&lt;kbd&gt;\u2325&lt;/kbd&gt; + &lt;kbd&gt;\u2318&lt;/kbd&gt; + Z</code> Toggle Try Catch and other predefined blocks of code <code>&lt;kbd&gt;Alt&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + A</code> <code>&lt;kbd&gt;\u2325&lt;/kbd&gt; + &lt;kbd&gt;\u2318&lt;/kbd&gt; + A</code> Toggle block / column selection in the current text editor <code>&lt;kbd&gt;Alt&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + R</code> <code>&lt;kbd&gt;\u2325&lt;/kbd&gt; + &lt;kbd&gt;\u2318&lt;/kbd&gt; + R</code> Rename (variable, field, method, class...) <code>&lt;kbd&gt;Alt&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + S</code> <code>&lt;kbd&gt;\u2325&lt;/kbd&gt; + &lt;kbd&gt;\u2318&lt;/kbd&gt; + S</code> Show advanced editing operations for current selection <code>&lt;kbd&gt;Alt&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + T</code> <code>&lt;kbd&gt;\u2325&lt;/kbd&gt; + &lt;kbd&gt;\u2318&lt;/kbd&gt; + T</code> Show available refactoring operations for current selection <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + 1</code> <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + 1</code> Show all possible fixes for a problem (on a text element with a problem marker, or in the problem view) <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + C</code> <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + /</code> Add/Remove line comment <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + /</code> <code>^ + &lt;kbd&gt;\u2318&lt;/kbd&gt; + /</code> Add/Remove block line comment"},{"location":"fr/module-00/prerequisites/","title":"Prerequisite material for the course","text":"<p>This is all the prerequisite material you will need for the course</p> <p></p>"},{"location":"fr/module-00/prerequisites/#documentation","title":"DOCUMENTATION","text":"<ul> <li>Java 21 APIs -  Java 21 API Specification</li> <li>Eclipse shortcuts - Eclipse IDE shortcuts</li> </ul>"},{"location":"fr/module-00/prerequisites/#editor","title":"EDITOR","text":"<ul> <li>Eclipse IDE - Download Eclipse here</li> </ul>"},{"location":"fr/module-00/prerequisites/#pandoc","title":"PANDOC","text":"<ul> <li>Pandoc - Download Pandoc here</li> </ul>"},{"location":"fr/module-01/basic-building-blocks/","title":"2. Blocs de base du langage Java","text":""},{"location":"fr/module-01/basic-building-blocks/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>2.1 D\u00e9finition de classe</li> <li>2.2 Commentaires</li> <li>2.3 Modificateurs d\u2019acc\u00e8s</li> <li>2.4 Packages<ul> <li>2.4.1 Organisation et objectif</li> <li>2.4.2 Correspondance avec le syst\u00e8me de fichiers et d\u00e9claration d\u2019un package</li> <li>2.4.3 Appartenir au m\u00eame package</li> <li>2.4.4 Importer depuis un package</li> <li>2.4.5 Imports statiques<ul> <li>2.4.5.1 R\u00e8gles de pr\u00e9c\u00e9dence</li> </ul> </li> <li>2.4.6 Packages standard vs. packages d\u00e9finis par l\u2019utilisateur</li> </ul> </li> <li>2.5 La m\u00e9thode main<ul> <li>2.5.1 Signature de la m\u00e9thode main</li> </ul> </li> <li>2.6 Compiler et ex\u00e9cuter le code<ul> <li>2.6.1 Compiler un fichier, package par d\u00e9faut (r\u00e9pertoire unique)</li> <li>2.6.2 Plusieurs fichiers, package par d\u00e9faut (r\u00e9pertoire unique)</li> <li>2.6.3 Code dans des packages (organisation standard src \u2192 out)</li> <li>2.6.4 Compiler vers un autre r\u00e9pertoire (-d)</li> <li>2.6.5 Plusieurs fichiers sur plusieurs packages (compiler tout l\u2019arbre des sources)</li> <li>2.6.6 Ex\u00e9cution d\u2019un fichier source unique (lancement rapide sans javac)</li> <li>2.6.7 Passer des param\u00e8tres \u00e0 un programme Java</li> </ul> </li> </ul> <p>Ce chapitre pr\u00e9sente les \u00e9l\u00e9ments structurels essentiels d\u2019un programme Java : <code>classes</code>, <code>m\u00e9thodes</code>, <code>commentaires</code>, <code>modificateurs d\u2019acc\u00e8s</code>, <code>packages</code>, la m\u00e9thode <code>main</code> et les outils de base en ligne de commande (<code>javac</code> et <code>java</code>).</p> <p>Ce sont les \u00e9l\u00e9ments minimaux n\u00e9cessaires pour \u00e9crire, compiler, organiser et ex\u00e9cuter du code Java \u00e0 l\u2019aide du JDK (Java Development Kit) \u2014 sans utiliser aucun IDE (Integrated Development Environment).</p> <p></p>"},{"location":"fr/module-01/basic-building-blocks/#21-definition-de-classe","title":"2.1 D\u00e9finition de classe","text":"<p>Une <code>class</code> Java est le bloc fondamental d\u2019un programme Java.</p> <p>Une <code>classe</code> repr\u00e9sente un type de donn\u00e9e d\u00e9fini par l\u2019utilisateur, constitu\u00e9 d\u2019un ensemble de donn\u00e9es internes (<code>fields</code>) et des op\u00e9rations pouvant agir sur celles-ci (<code>methods</code>).</p> <p>Une <code>class</code> est un plan (blueprint), tandis que les <code>objects</code> sont des instances concr\u00e8tes cr\u00e9\u00e9es \u00e0 l\u2019ex\u00e9cution.</p> <p>Une classe Java est compos\u00e9e de deux \u00e9l\u00e9ments principaux, appel\u00e9s ses membres:</p> <ul> <li>Fields (ou variables): repr\u00e9sentent les donn\u00e9es qui d\u00e9finissent l\u2019\u00e9tat de ce nouveau type.</li> <li>Methods (ou fonctions): repr\u00e9sentent les op\u00e9rations qui peuvent \u00eatre effectu\u00e9es sur ces donn\u00e9es.</li> </ul> <p>Certains membres peuvent \u00eatre d\u00e9clar\u00e9s avec le mot-cl\u00e9 static.</p> <p>Un membre static appartient \u00e0 la classe elle-m\u00eame, et non aux objets cr\u00e9\u00e9s \u00e0 partir d\u2019elle.</p> <p>Cela signifie que :</p> <ul> <li>il existe une seule copie partag\u00e9e entre toutes les instances</li> <li>il peut \u00eatre utilis\u00e9 sans cr\u00e9er un objet de la classe</li> <li>il est charg\u00e9 en m\u00e9moire lorsque la classe est charg\u00e9e par la JVM</li> </ul> <p>Les membres non static (appel\u00e9s d\u2019instance) appartiennent en revanche aux objets individuels et chaque instance poss\u00e8de sa propre copie.</p> <p>Normalement, chaque classe est d\u00e9finie dans son propre fichier \".java\" ; par exemple, une classe nomm\u00e9e <code>Person</code> sera d\u00e9finie dans le fichier correspondant <code>Person.java</code>.</p> <p>Toute classe d\u00e9finie ind\u00e9pendamment dans son propre fichier source est appel\u00e9e top-level class.</p> <p>Une telle classe ne peut \u00eatre d\u00e9clar\u00e9e que <code>public</code> ou avec le modificateur d\u2019acc\u00e8s par d\u00e9faut (<code>package-private</code>, c\u2019est-\u00e0-dire sans modificateur explicite).</p> <p>Un seul fichier peut cependant contenir plusieurs d\u00e9finitions de classe. Dans ce cas, une seule classe peut \u00eatre d\u00e9clar\u00e9e <code>public</code>, et le nom du fichier doit correspondre \u00e0 cette classe.</p> <p>Les nested classes, c\u2019est-\u00e0-dire les classes d\u00e9clar\u00e9es \u00e0 l\u2019int\u00e9rieur d\u2019une autre classe, peuvent utiliser n\u2019importe quel modificateur d\u2019acc\u00e8s : <code>public</code>, <code>protected</code>, <code>private</code>, <code>default</code> (package-private).</p> <ul> <li>Exemple :</li> </ul> <pre><code>public class Person {\n\n    // This is a comment: explains the code but is ignored by the compiler. See section below.\n\n    // Field \u2192 defines data/state\n    String personName;\n\n    // Method \u2192 defines behavior (this one take a parameter, newName, in input but does not return a value)\n    void setPersonName(String newName) {\n        personName = newName;\n    }\n\n    // Method \u2192 defines behavior  (this one does not take parameters in input but does return a String)\n    String getPersonName(){\n        return personName;\n    }\n}\n</code></pre> <p>Note</p> <p>Dans sa forme la plus simple, on pourrait th\u00e9oriquement avoir une classe sans m\u00e9thode et sans field. Une telle classe se compilerait, mais aurait tr\u00e8s peu de sens pratique.</p> Token / Identifier Category Meaning Optional? public Keyword / access modifier d\u00e9termine quelles autres classes peuvent utiliser ou voir cet \u00e9l\u00e9ment Mandatory (lorsqu\u2019il est absent, l\u2019acc\u00e8s est par d\u00e9faut package-private) class Keyword D\u00e9clare un type de classe. Mandatory Person Class name (identifier) Le nom de la classe. Mandatory personName Field name (identifier) Stocke le nom de la personne. Optional String Type / Keyword Type du field <code>personName</code> et du param\u00e8tre <code>newName</code>. Mandatory setPersonName, getPersonName Method names (identifier) nomment un comportement de la classe. Optional newName Parameter name (identifier) param\u00e8tre pass\u00e9 \u00e0 la m\u00e9thode <code>setPersonName</code>. Mandatory (si la m\u00e9thode a besoin d\u2019un param\u00e8tre) return Keyword Quitte une m\u00e9thode et renvoie une valeur. Mandatory (dans les m\u00e9thodes avec type de retour non void) void Return Type / Keyword Indique que la m\u00e9thode ne renvoie aucune valeur. Mandatory (si la m\u00e9thode ne renvoie pas de valeur) <p>Note</p> <p>Mandatory = requis par la syntaxe Java, Optional = non requis par la syntaxe ; d\u00e9pend du design.</p> <p></p>"},{"location":"fr/module-01/basic-building-blocks/#22-commentaires","title":"2.2 Commentaires","text":"<p>Les commentaires ne sont pas du code ex\u00e9cutable : ils expliquent le code mais sont ignor\u00e9s par le compilateur.</p> <p>En Java, il existe 3 types de commentaires : - Single-line (<code>//</code>) - Multi-line (<code>/* ... */</code>) - Javadoc (<code>/** ... */</code>)</p> <p>Un single-line comment commence par 2 barres obliques : tout le texte qui suit sur la m\u00eame ligne est ignor\u00e9 par le compilateur.</p> <ul> <li>Exemple :</li> </ul> <pre><code>// This is a single-line comment. It starts with 2 slashes and ends at the end of the line. \n</code></pre> <p>Un multiline comment inclut tout ce qui se trouve entre les symboles <code>/*</code> et <code>*/</code>.</p> <ul> <li>Exemple :</li> </ul> <pre><code>/*  \n * This is a multi-line comment.\n * It can span multiple lines.\n * All the text between its opening and closing symbols is ignored by the compiler.\n *\n */\n</code></pre> <p>Un commentaire Javadoc est similaire \u00e0 un multiline comment, sauf qu\u2019il commence par <code>/**</code> : tout le texte entre les symboles d\u2019ouverture et de fermeture est trait\u00e9 par l\u2019outil Javadoc pour g\u00e9n\u00e9rer la documentation d\u2019API.</p> <pre><code>/**\n * This is a Javadoc comment\n *\n * This class represents a Person.\n * It stores a name and provides methods\n * to set and retrieve it.\n *\n * &lt;p&gt;Javadoc comments can include HTML tags,\n * and special annotations like @param and @return.&lt;/p&gt;\n */\n</code></pre> <p>Warning</p> <p>En Java, chaque block comment doit \u00eatre correctement ferm\u00e9 avec <code>*/</code>.</p> <ul> <li>Exemple :</li> </ul> <pre><code>/* valid block comment */\n</code></pre> <p>est correct, mais</p> <pre><code>/* */ */\n</code></pre> <p>provoquera une erreur de compilation, car les deux premiers symboles font partie du commentaire, mais le dernier non. Le symbole suppl\u00e9mentaire <code>*/</code> n\u2019est pas une syntaxe valide et le compilateur se plaindra.</p> <p></p>"},{"location":"fr/module-01/basic-building-blocks/#23-modificateurs-dacces","title":"2.3 Modificateurs d\u2019acc\u00e8s","text":"<p>En Java, un modificateur d\u2019acc\u00e8s (access modifier) est un mot-cl\u00e9 qui sp\u00e9cifie la visibilit\u00e9 (ou accessibilit\u00e9) d\u2019une classe, d\u2019une m\u00e9thode ou d\u2019un champ. Il d\u00e9termine quelles autres classes peuvent utiliser ou voir cet \u00e9l\u00e9ment.</p> <p>Note</p> <p>Table des modificateurs d\u2019acc\u00e8s disponibles en Java</p> Token / Identifier Category Meaning Optional? public Keyword / access modifier Visible depuis n\u2019importe quelle classe, dans n\u2019importe quel package Oui no modifier (default) Keyword / access modifier Visible uniquement \u00e0 l\u2019int\u00e9rieur du m\u00eame package Oui protected Keyword / access modifier Visible dans le m\u00eame package et par les sous-classes (m\u00eame dans d\u2019autres packages) Oui private Keyword / access modifier Visible uniquement \u00e0 l\u2019int\u00e9rieur de la m\u00eame classe Oui <p>Tip</p> <p>private &gt; default &gt; protected &gt; public Pense que la \u201cvisibilit\u00e9 s\u2019\u00e9tend vers l\u2019ext\u00e9rieur\u201d.</p> <p></p>"},{"location":"fr/module-01/basic-building-blocks/#24-packages","title":"2.4 Packages","text":"<p>Les packages Java sont des regroupements logiques de classes, d\u2019interfaces et de sous-packages. Ils aident \u00e0 organiser de grands codebases, \u00e0 \u00e9viter les conflits de noms et \u00e0 contr\u00f4ler l\u2019acc\u00e8s entre diff\u00e9rentes parties d\u2019une application.</p> <p></p>"},{"location":"fr/module-01/basic-building-blocks/#241-organisation-et-objectif","title":"2.4.1 Organisation et objectif","text":"<ul> <li>La d\u00e9nomination des packages suit les m\u00eames r\u00e8gles que les noms de variables. Voir : Java Naming Rules.  </li> <li>Les packages sont comme des dossiers pour votre code source Java.  </li> <li>Ils permettent de regrouper des classes li\u00e9es entre elles (par exemple toutes les utilitaires dans <code>java.util</code>, toutes les classes r\u00e9seau dans <code>java.net</code>).  </li> <li>En utilisant les packages, vous pouvez \u00e9viter les conflits de noms : par exemple, vous pouvez avoir deux classes nomm\u00e9es <code>Date</code>, l\u2019une <code>java.util.Date</code> et l\u2019autre <code>java.sql.Date</code>.</li> </ul>"},{"location":"fr/module-01/basic-building-blocks/#242-correspondance-avec-le-systeme-de-fichiers-et-declaration-dun-package","title":"2.4.2 Correspondance avec le syst\u00e8me de fichiers et d\u00e9claration d\u2019un package","text":"<ul> <li>Les packages correspondent directement \u00e0 la hi\u00e9rarchie de r\u00e9pertoires sur le syst\u00e8me de fichiers.</li> <li>Vous d\u00e9clarez le package en haut du fichier source (avant tout import).</li> <li>Si vous ne d\u00e9clarez pas de package, la classe appartient au package par d\u00e9faut.</li> <li> <p>Ceci n\u2019est pas recommand\u00e9 pour des projets r\u00e9els, car cela complique l\u2019organisation et les imports.</p> </li> <li> <p>Exemple :</p> </li> </ul> <pre><code>package com.example.myapp.utils;\n\npublic class MyApp{\n\n}\n</code></pre> <p>Important</p> <p>Cette d\u00e9claration signifie que la classe doit \u00eatre situ\u00e9e dans le r\u00e9pertoire : com/example/myapp/utils/MyApp.java</p> <p></p>"},{"location":"fr/module-01/basic-building-blocks/#243-appartenir-au-meme-package","title":"2.4.3 Appartenir au m\u00eame package","text":"<p>Deux classes appartiennent au m\u00eame package si et seulement si :</p> <ul> <li>Elles sont d\u00e9clar\u00e9es avec la m\u00eame instruction <code>package</code> en haut de leur fichier source.</li> <li> <p>Elles se trouvent dans le m\u00eame r\u00e9pertoire de la hi\u00e9rarchie des sources.</p> </li> <li> <p>Exemple :</p> </li> </ul> <p>Une classe dans le package <code>A.B.C</code> appartient uniquement \u00e0 <code>A.B.C</code>, pas \u00e0 <code>A.B</code>. Les classes dans <code>A.B</code> ne peuvent pas acc\u00e9der directement aux membres package-private des classes de <code>A.B.C</code>, car il s\u2019agit de packages diff\u00e9rents.</p> <p>Les classes dans le m\u00eame package :</p> <ul> <li>Peuvent acc\u00e9der aux membres package-private les unes des autres (c\u2019est-\u00e0-dire les membres sans modificateur d\u2019acc\u00e8s explicite).</li> <li>Partagent le m\u00eame espace de noms, donc il n\u2019est pas n\u00e9cessaire de les importer pour les utiliser.</li> </ul> <p>Exemple : deux fichiers dans le m\u00eame package</p> <pre><code>// File: src/com/example/tools/Tool.java\npackage com.example.tools;\n\npublic class Tool {\n    static void hello() { System.out.println(\"Hi!\"); }\n}\n</code></pre> <pre><code>// File: src/com/example/tools/Runner.java\npackage com.example.tools;\n\npublic class Runner {\n    public static void main(String[] args) {\n        Tool.hello();    // OK : m\u00eame package, aucun import n\u00e9cessaire\n    }\n}\n</code></pre> <p></p>"},{"location":"fr/module-01/basic-building-blocks/#244-importer-depuis-un-package","title":"2.4.4 Importer depuis un package","text":"<p>Pour utiliser des classes provenant d\u2019un autre package, vous devez les importer :</p> <ul> <li>Exemple :</li> </ul> <pre><code>import java.util.List;       // importe une classe sp\u00e9cifique\nimport java.util.*;          // importe toutes les classes dans java.util\n\nimport java.nio.file.*.*     // ERROR! only one wildcard is allowed and it must be at the end!\n</code></pre> <p>Note</p> <p>Le caract\u00e8re wildcard <code>*</code> importe tous les types du package, mais pas ses sous-packages.</p> <p>Vous pouvez toujours utiliser le nom compl\u00e8tement qualifi\u00e9 (fully qualified name) au lieu d\u2019importer toutes les classes du package :</p> <pre><code>java.util.List myList = new java.util.ArrayList&lt;&gt;();\n</code></pre> <p>Note</p> <p>Si vous importez explicitement un nom de classe, il est prioritaire sur tout import avec wildcard ; si vous voulez utiliser deux classes ayant le m\u00eame nom (par exemple <code>Date</code> de <code>java.util</code> et de <code>java.sql</code>), il est pr\u00e9f\u00e9rable d\u2019utiliser un import avec nom enti\u00e8rement qualifi\u00e9.</p> <p></p>"},{"location":"fr/module-01/basic-building-blocks/#245-imports-statiques","title":"2.4.5 Imports statiques","text":"<p>En plus d\u2019importer des classes depuis un package, Java permet un autre type d\u2019import : l\u2019import statique. Un static import permet d\u2019importer les membres statiques d\u2019une classe \u2014 tels que des m\u00e9thodes statiques et des variables statiques \u2014 afin de les utiliser sans faire r\u00e9f\u00e9rence au nom de la classe.</p> <p>Vous pouvez importer des membres statiques sp\u00e9cifiques ou utiliser un wildcard pour importer tous les membres statiques d\u2019une classe.</p> <p>Exemple \u2014 import statique sp\u00e9cifique</p> <pre><code>import static java.util.Arrays.asList;   // Imports Arrays.asList()\n\npublic class Example {\n\n    List&lt;String&gt; arr = asList(\"first\", \"second\");\n    // We can call asList() directly, without using Arrays.asList()\n}\n</code></pre> <p>Exemple \u2014 import statique d\u2019une constante</p> <pre><code>import static java.lang.Math.PI;\nimport static java.lang.Math.sqrt;\n\npublic class Circle {\n    double radius = 3;\n\n    double area = PI * radius * radius;\n    double diagonal = sqrt(2); \n}\n</code></pre> <p>Exemple \u2014 import statique avec wildcard</p> <pre><code>import static java.lang.Math.*;\n\npublic class Calculator {\n    double x = sqrt(49);   // 7.0\n    double y = max(10, 20); \n    double z = random();   // calls Math.random()\n}\n</code></pre> <p>Les imports statiques avec wildcard se comportent exactement comme les imports normaux avec wildcard : ils mettent tous les membres statiques de la classe dans la port\u00e9e courante.</p> <p>Warning</p> <p>Vous pouvez toujours appeler un membre statique avec le nom de la classe : <code>Math.sqrt(16)</code> fonctionne toujours \u2014 m\u00eame si le membre a \u00e9t\u00e9 import\u00e9 statiquement.</p> <p></p>"},{"location":"fr/module-01/basic-building-blocks/#2451-regles-de-precedence","title":"2.4.5.1 R\u00e8gles de pr\u00e9c\u00e9dence","text":"<p>Si la classe courante d\u00e9clare d\u00e9j\u00e0 une m\u00e9thode ou une variable portant le m\u00eame nom qu\u2019un membre import\u00e9 statiquement :</p> <ul> <li>Le membre local est prioritaire.</li> <li>Le membre statique import\u00e9 est masqu\u00e9 (shadowing).</li> </ul> <p>Exemple :</p> <pre><code>import static java.lang.Math.max;\n\npublic class Test {\n\n    static int max(int a, int b) {   // version locale\n        return a &gt; b ? a : b;\n    }\n\n    void run() {\n        System.out.println(max(2, 5));  \n        // Appelle la version LOCALE de max(), pas Math.max()\n    }\n}\n</code></pre> <p>Warning</p> <ul> <li>Un import statique doit toujours respecter exactement la syntaxe : <code>import static</code>.</li> <li>Le compilateur interdit d\u2019importer deux membres statiques portant le m\u00eame simple name si cela cr\u00e9e une ambigu\u00eft\u00e9 \u2014 m\u00eame s\u2019ils proviennent de classes ou de packages diff\u00e9rents.</li> </ul> <p>Exemple \u2014 Non autoris\u00e9 :</p> <pre><code>import static java.util.Collections.emptyList;\nimport static java.util.List.of;\n\n// \u274c ERROR: both methods have the same name `of()`\nimport static java.util.Set.of;\n</code></pre> <p>Le compilateur ne sait pas quel <code>of()</code> vous souhaitez appeler \u2192 \u00e9chec de compilation.</p> <p>Tip</p> <ul> <li>Si deux imports statiques introduisent le m\u00eame nom, toute tentative d\u2019utiliser ce nom provoque une erreur de compilation.</li> <li>Les imports statiques n\u2019importent pas les classes, seulement les membres statiques.  </li> <li>Vous pouvez toujours appeler le membre statique avec le nom de la classe, m\u00eame s\u2019il est import\u00e9 statiquement.</li> </ul> <p>Exemple :</p> <pre><code>import static java.lang.Math.sqrt;\n\ndouble a = sqrt(16);        // import statique\ndouble b = Math.sqrt(25);   // fully qualified \u2014 toujours autoris\u00e9\n</code></pre> <p></p>"},{"location":"fr/module-01/basic-building-blocks/#246-packages-standard-vs-packages-definis-par-lutilisateur","title":"2.4.6 Packages standard vs packages d\u00e9finis par l\u2019utilisateur","text":"<ul> <li>Packages standard : fournis avec le JDK (par ex. <code>java.lang</code>, <code>java.util</code>, <code>java.io</code>).  </li> <li>Packages d\u00e9finis par l\u2019utilisateur : cr\u00e9\u00e9s par les d\u00e9veloppeurs pour organiser le code de l\u2019application.</li> </ul>"},{"location":"fr/module-01/basic-building-blocks/#25-la-methode-main","title":"2.5 La m\u00e9thode <code>main</code>","text":"<p>En Java, la m\u00e9thode <code>main</code> sert de point d\u2019entr\u00e9e \u00e0 une application autonome. Sa d\u00e9claration correcte est cruciale pour que la JVM puisse la reconna\u00eetre.</p> <p></p>"},{"location":"fr/module-01/basic-building-blocks/#251-signature-de-la-methode-main","title":"2.5.1 Signature de la m\u00e9thode main","text":"<p>Observons la signature de la m\u00e9thode <code>main</code> dans deux des classes les plus simples possibles :</p> <ul> <li>Exemple : sans modificateurs optionnels</li> </ul> <pre><code>public class MainFirstExample {\n\n    public static void main(String[] args){\n\n        System.out.print(\"Hello World!!\");\n\n    }\n\n}\n</code></pre> <ul> <li>Exemple : avec les deux modificateurs optionnels <code>final</code></li> </ul> <pre><code>public class MainSecondExample {\n\n    public final static void main(final String options[]){\n\n        System.out.print(\"Hello World!!\");\n\n    }\n\n}\n</code></pre> <p>Note</p> <p>Table des modificateurs pour la m\u00e9thode main</p> Token / Identifier Category Meaning Optional? public Keyword / Access Modifier Rend la m\u00e9thode accessible depuis n\u2019importe o\u00f9. N\u00e9cessaire pour que la JVM puisse l\u2019appeler depuis l\u2019ext\u00e9rieur de la classe. Mandatory static Keyword Signifie que la m\u00e9thode appartient \u00e0 la classe elle-m\u00eame et peut \u00eatre appel\u00e9e sans cr\u00e9er d\u2019objet. N\u00e9cessaire car la JVM n\u2019a aucune instance au d\u00e9marrage du programme. Mandatory final (before return type) Modifier Emp\u00eache la m\u00e9thode d\u2019\u00eatre red\u00e9finie (overridden). Peut appara\u00eetre l\u00e9galement avant le type de retour, mais n\u2019a aucun effet particulier sur <code>main</code> et n\u2019est pas requis. Optional main Method name (predefined) Nom exact que la JVM recherche comme point d\u2019entr\u00e9e du programme. Doit \u00eatre \u00e9crit exactement <code>main</code> (en minuscules). Mandatory void Return Type / Keyword D\u00e9clare que la m\u00e9thode ne renvoie aucune valeur \u00e0 la JVM. Mandatory String[] args Parameter list Tableau de <code>String</code> qui contient les arguments de ligne de commande pass\u00e9s au programme. Peut aussi s\u2019\u00e9crire <code>String args[]</code> ou <code>String... args</code>. Le nom du param\u00e8tre (<code>args</code>) est arbitraire. Mandatory (le type du param\u00e8tre est requis, le nom peut varier) final (in parameter) Modifier Marque le param\u00e8tre comme non r\u00e9affectable \u00e0 l\u2019int\u00e9rieur du corps de la m\u00e9thode (vous ne pouvez pas r\u00e9assigner <code>args</code> vers un autre tableau). Optional <p>Important</p> <p>Les modificateurs <code>public</code>, <code>static</code> (obligatoires) et <code>final</code> (s\u2019il est pr\u00e9sent) peuvent \u00eatre permut\u00e9s ; <code>public</code> et <code>static</code> ne peuvent pas \u00eatre omis.</p> <p>Java consid\u00e8re <code>String[] args</code> et <code>String... args</code> comme \u00e9quivalents. Les deux variantes compilent et fonctionnent correctement comme points d\u2019entr\u00e9e.</p> <p></p>"},{"location":"fr/module-01/basic-building-blocks/#26-compiler-et-executer-le-code","title":"2.6 Compiler et ex\u00e9cuter le code","text":"<p>Cette section pr\u00e9sente des commandes <code>javac</code> et <code>java</code> correctes et fonctionnelles pour des situations courantes en Java 21 : fichiers uniques, plusieurs fichiers, packages, r\u00e9pertoires de sortie s\u00e9par\u00e9s, utilisation du classpath/module-path.</p> <p>Suivez exactement l\u2019organisation des r\u00e9pertoires.</p> <p>check your tools</p> <pre><code>javac -version   # should print: javac 21.x\njava  -version   # should print: java version \"21.0.7\" ... (the output could be different depending on the implementation of the jvm you installed)\n</code></pre> <p>Warning</p> <p>Lors de l\u2019ex\u00e9cution d\u2019une classe \u00e0 l\u2019int\u00e9rieur d\u2019un package, java exige le nom compl\u00e8tement qualifi\u00e9, JAMAIS le chemin :</p> <p><code>java com.example.app.Main</code> \u2714 <code>java src/com/example/app/Main</code> \u274c</p> <p></p>"},{"location":"fr/module-01/basic-building-blocks/#261-compiler-un-fichier-package-par-defaut-repertoire-unique","title":"2.6.1 Compiler un fichier, package par d\u00e9faut (r\u00e9pertoire unique)","text":"<p>Fichiers <pre><code>.\n\u2514\u2500\u2500 Hello.java\n</code></pre></p> <p>Hello.java <pre><code>public class Hello {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, Java 21!\");\n    }\n}\n</code></pre></p> <p>Compiler (dans le m\u00eame r\u00e9pertoire)</p> <pre><code>javac Hello.java\n</code></pre> <p>Cette commande va cr\u00e9er, dans le m\u00eame r\u00e9pertoire, un fichier portant le m\u00eame nom que le fichier \".java\" mais avec l\u2019extension \".class\" ; c\u2019est le fichier de bytecode qui sera interpr\u00e9t\u00e9 et ex\u00e9cut\u00e9 par la JVM.</p> <p>Une fois que vous avez le fichier <code>.class</code>, dans ce cas <code>Hello.class</code>, vous pouvez lancer le programme avec :</p> <p>Ex\u00e9cution</p> <pre><code>java Hello\n</code></pre> <p>Important</p> <p>Vous n\u2019avez pas \u00e0 pr\u00e9ciser l\u2019extension \".class\" lors de l\u2019ex\u00e9cution du programme.</p> <p></p>"},{"location":"fr/module-01/basic-building-blocks/#262-plusieurs-fichiers-package-par-defaut-repertoire-unique","title":"2.6.2 Plusieurs fichiers, package par d\u00e9faut (r\u00e9pertoire unique)","text":"<p>Fichiers <pre><code>.\n\u251c\u2500\u2500 A.java\n\u2514\u2500\u2500 B.java\n</code></pre></p> <p>Tout compiler <pre><code>javac *.java\n</code></pre></p> <p>Ou, si les classes appartiennent \u00e0 un package sp\u00e9cifique :</p> <pre><code>javac packagex/*.java\n</code></pre> <p>Ou en les sp\u00e9cifiant explicitement :</p> <pre><code>javac A.java B.java\n</code></pre> <p>et</p> <pre><code>javac packagex/A.java packagey/B.java\n</code></pre> <p>Ex\u00e9cuter le point d\u2019entr\u00e9e : la classe qui poss\u00e8de une m\u00e9thode <code>main</code></p> <pre><code>java A    # si A poss\u00e8de main(...)\n# ou\njava B\n</code></pre> <p>Important</p> <p>Le chemin vers vos classes correspond, en Java, au classpath. Vous pouvez sp\u00e9cifier le classpath avec l\u2019une des options suivantes :</p> <ul> <li><code>-cp &lt;classpath&gt;</code> </li> <li><code>-classpath &lt;classpath&gt;</code> </li> <li><code>--class-path &lt;classpath&gt;</code></li> </ul> <p></p>"},{"location":"fr/module-01/basic-building-blocks/#263-code-dans-des-packages-organisation-standard-src-out","title":"2.6.3 Code dans des packages (organisation standard src \u2192 out)","text":"<p>Fichiers <pre><code>.\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 com/\n\u2502       \u2514\u2500\u2500 example/\n\u2502           \u2514\u2500\u2500 app/\n\u2502               \u2514\u2500\u2500 Main.java\n\u2514\u2500\u2500 out/\n</code></pre></p> <p>Note</p> <p>Les dossiers <code>src</code> et <code>out</code> ne font pas partie de nos packages : ce sont simplement les r\u00e9pertoires qui contiennent tous les fichiers source et les fichiers <code>.class</code> compil\u00e9s.</p> <p>Main.java</p> <pre><code>package com.example.app;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Packages done right.\");\n    }\n}\n</code></pre> <p>Compiler dans le m\u00eame r\u00e9pertoire</p> <pre><code># Cr\u00e9e le fichier .class juste \u00e0 c\u00f4t\u00e9 du fichier source\njavac src/com/example/app/Main.java\n</code></pre> <p></p>"},{"location":"fr/module-01/basic-building-blocks/#264-compiler-vers-un-autre-repertoire-d","title":"2.6.4 Compiler vers un autre r\u00e9pertoire (<code>-d</code>)","text":"<p>L\u2019option <code>-d out</code> place les fichiers <code>.class</code> compil\u00e9s dans le r\u00e9pertoire <code>out/</code>, en cr\u00e9ant des sous-dossiers qui refl\u00e8tent les noms de packages :</p> <pre><code>javac -d out -sourcepath src src/com/example/app/Main.java\n</code></pre> <p>Ex\u00e9cution (utiliser le classpath pointant sur out/)</p> <pre><code># Unix/macOS\njava -cp out com.example.app.Main\n\n# Windows\njava -cp out com.example.app.Main\n</code></pre> <p></p>"},{"location":"fr/module-01/basic-building-blocks/#265-plusieurs-fichiers-sur-plusieurs-packages-compiler-tout-larbre-des-sources","title":"2.6.5 Plusieurs fichiers sur plusieurs packages (compiler tout l\u2019arbre des sources)","text":"<p>Fichiers <pre><code>.\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 com/\n\u2502       \u2514\u2500\u2500 example/\n\u2502           \u251c\u2500\u2500 util/\n\u2502           \u2502   \u2514\u2500\u2500 Utils.java\n\u2502           \u2514\u2500\u2500 app/\n\u2502               \u2514\u2500\u2500 Main.java\n\u2514\u2500\u2500 out/\n</code></pre></p> <p>Compiler tout l\u2019arbre des sources dans <code>out/</code></p> <pre><code># Option A : indiquer \u00e0 javac les packages de plus haut niveau\njavac -d out   src/com/example/util/Utils.java   src/com/example/app/Main.java\n\n# Option B : utiliser -sourcepath pour laisser javac trouver les d\u00e9pendances\njavac -d out -sourcepath src   src/com/example/app/Main.java\n</code></pre> <p>Important</p> <p><code>-sourcepath &lt;sourcepath&gt;</code> indique \u00e0 <code>javac</code> o\u00f9 chercher d\u2019autres fichiers <code>.java</code> dont d\u00e9pendent les sources.</p> <p></p>"},{"location":"fr/module-01/basic-building-blocks/#266-execution-dun-fichier-source-unique-lancement-rapide-sans-javac","title":"2.6.6 Ex\u00e9cution d\u2019un fichier source unique (lancement rapide sans <code>javac</code>)","text":"<p>Java 21 (depuis Java 11) permet d\u2019ex\u00e9cuter de petits programmes directement \u00e0 partir du code source :</p> <pre><code># Uniquement package par d\u00e9faut\njava Hello.java\n</code></pre> <p>Plusieurs fichiers source sont autoris\u00e9s s\u2019ils se trouvent dans le package par d\u00e9faut et dans le m\u00eame r\u00e9pertoire :</p> <pre><code>java Main.java Helper.java\n</code></pre> <p>Si vous utilisez des packages, il est pr\u00e9f\u00e9rable de compiler dans <code>out/</code> et d\u2019ex\u00e9cuter avec <code>-cp</code>.</p> <p></p>"},{"location":"fr/module-01/basic-building-blocks/#267-passer-des-parametres-a-un-programme-java","title":"2.6.7 Passer des param\u00e8tres \u00e0 un programme Java","text":"<p>Vous pouvez transmettre des donn\u00e9es \u00e0 votre programme Java via les param\u00e8tres du point d\u2019entr\u00e9e <code>main</code>.</p> <p>Comme nous l\u2019avons vu, la m\u00e9thode <code>main</code> peut recevoir un tableau de cha\u00eenes sous la forme : <code>String[] args</code>. Voir la section sur main.</p> <p>Main.java qui affiche deux param\u00e8tres re\u00e7us en entr\u00e9e par la m\u00e9thode <code>main</code> :</p> <pre><code>package com.example.app;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(args[0]);\n        System.out.println(args[1]);\n    }\n}\n</code></pre> <p>Pour passer des param\u00e8tres, il suffit de taper (par exemple) :</p> <pre><code>java Main.java Hello World  # spaces are used to separate the two arguments\n</code></pre> <p>Si vous voulez passer un argument contenant des espaces, utilisez des guillemets :</p> <pre><code>java Main.java Hello \"World Mario\" # spaces are used to separate the two arguments\n</code></pre> <p>Si vous d\u00e9clarez utiliser (ici, afficher) les deux premiers \u00e9l\u00e9ments du tableau de param\u00e8tres, mais que vous passez en r\u00e9alit\u00e9 moins d\u2019arguments, la JVM vous signalera un probl\u00e8me via une <code>java.lang.ArrayIndexOutOfBoundsException</code>.  </p> <p>Si, au contraire, vous passez plus d\u2019arguments que ce que la m\u00e9thode utilise, elle n\u2019affichera que les deux premiers (dans ce cas).  </p> <p><code>args.length</code> vous indique combien d\u2019arguments ont \u00e9t\u00e9 fournis.</p>"},{"location":"fr/module-01/data-types/","title":"4. Types de donn\u00e9es Java et cast","text":""},{"location":"fr/module-01/data-types/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>4.1 Types primitifs</li> <li>4.2 Types r\u00e9f\u00e9rence</li> <li>4.3 Tableau des types primitifs</li> <li>4.4 Notes</li> <li>4.5 R\u00e9capitulatif</li> <li>4.6 Arithm\u00e9tique et promotion num\u00e9rique primitive<ul> <li>4.6.1 R\u00e8gles de promotion num\u00e9rique en Java<ul> <li>4.6.1.1 R\u00e8gle 1 \u2013 Types num\u00e9riques mixtes \u2192 le plus petit type est promu vers le plus grand</li> <li>4.6.1.2 R\u00e8gle 2 \u2013 Entier + flottant \u2192 l\u2019entier est promu vers le flottant</li> <li>4.6.1.3 R\u00e8gle 3 \u2013 byte, short et char sont promus en int lors des op\u00e9rations arithm\u00e9tiques</li> <li>4.6.1.4 R\u00e8gle 4 \u2013 Le type du r\u00e9sultat correspond au type promu des op\u00e9randes</li> </ul> </li> <li>4.6.2 R\u00e9capitulatif du comportement de promotion num\u00e9rique<ul> <li>4.6.2.1 Points cl\u00e9s</li> </ul> </li> </ul> </li> <li>4.7 Cast en Java<ul> <li>4.7.1 Cast primitif<ul> <li>4.7.1.1 Cast large implicite</li> <li>4.7.1.2 Cast \u00e9troit explicite</li> <li>4.7.1.3 Cast \u00e9troit Implicite \u00e0 la Compilation</li> </ul> </li> <li>4.7.2 Perte de donn\u00e9es, d\u00e9passement et sous-d\u00e9passement</li> <li>4.7.3 Cast de valeurs versus variables</li> <li>4.7.4 Cast de r\u00e9f\u00e9rence d\u2019objets<ul> <li>4.7.4.1 Upcasting (cast large de r\u00e9f\u00e9rence)</li> <li>4.7.4.2 Downcasting (cast \u00e9troit de r\u00e9f\u00e9rence)</li> </ul> </li> <li>4.7.5 R\u00e9sum\u00e9 des points cl\u00e9s</li> <li>4.7.6 Exemples</li> </ul> </li> <li>4.8 R\u00e9sum\u00e9</li> </ul> <p>Comme nous l\u2019avons vu dans les Blocs Syntaxiques, Java propose deux cat\u00e9gories de types de donn\u00e9es :</p> <ul> <li>Types primitifs </li> <li>Types r\u00e9f\u00e9rence</li> </ul> <p>\ud83d\udc49 Pour une vue compl\u00e8te des types primitifs avec leur taille, plage de valeurs, valeurs par d\u00e9faut et exemples, voir le Tableau des types primitifs.</p> <p></p>"},{"location":"fr/module-01/data-types/#41-types-primitifs","title":"4.1 Types primitifs","text":"<p>Les <code>primitives</code> repr\u00e9sentent des valeurs brutes uniques stock\u00e9es directement en m\u00e9moire. Chaque type primitif poss\u00e8de une taille fixe qui d\u00e9termine le nombre d\u2019octets qu\u2019il occupe.</p> <p>Conceptuellement, un primitif est simplement une cellule m\u00e9moire contenant une valeur :</p> <pre><code>+-------+\n|  42   |   \u2190 valeur de type short (2 octets en m\u00e9moire)\n+-------+\n</code></pre> <p></p>"},{"location":"fr/module-01/data-types/#42-types-reference","title":"4.2 Types r\u00e9f\u00e9rence","text":"<p>Un type <code>r\u00e9f\u00e9rence</code> ne contient pas l\u2019<code>objet</code> lui-m\u00eame, mais une r\u00e9f\u00e9rence (pointeur) vers celui-ci. La r\u00e9f\u00e9rence a une taille fixe (d\u00e9pendante de la JVM, souvent 4 ou 8 octets) qui pointe vers un emplacement m\u00e9moire o\u00f9 l\u2019objet r\u00e9el est stock\u00e9.</p> <ul> <li>Exemple : une variable de type <code>String</code> pointe vers un objet cha\u00eene dans le tas (heap), qui est lui-m\u00eame compos\u00e9 en interne d\u2019un tableau de primitives <code>char</code>.</li> </ul> <p>Diagramme :</p> <pre><code>R\u00e9f\u00e9rence (4 ou 8 octets)\n+---------+\n| address | \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba  Objet dans le tas (Heap)\n+---------+                  +-------------------+\n                             |   \"Hello\"         |\n                             | ['H','e','l','l','o']  \u2190 tableau de char\n                             +-------------------+\n</code></pre> <p></p>"},{"location":"fr/module-01/data-types/#43-tableau-des-types-primitifs","title":"4.3 Tableau des types primitifs","text":"Mot-cl\u00e9 Type Taille Valeur min Valeur max Valeur par d\u00e9faut Exemple <code>byte</code> int 8 bits 1 octet \u2013128 127 0 <code>byte b = 100;</code> <code>short</code> int 16 bits 2 octets \u201332 768 32 767 0 <code>short s = 2000;</code> <code>int</code> int 32 bits 4 octets \u20132 147 483 648 (\u20132^31) 2 147 483 647 (2^31\u20131) 0 <code>int i = 123456;</code> <code>long</code> int 64 bits 8 octets \u20132^63 2^63\u20131 0L <code>long l = 123456789L;</code> <code>float</code> flottant 32 bits 4 octets voir note voir note 0.0f <code>float f = 3.14f;</code> <code>double</code> flottant 64 bits 8 octets voir note voir note 0.0 <code>double d = 2.718;</code> <code>char</code> UTF-16 2 octets <code>'\\u0000'</code> (0) <code>'\\uffff'</code> (65 535) <code>'\\u0000'</code> <code>char c = 'A';</code> <code>boolean</code> true/false d\u00e9pend de la JVM (souvent 1 octet) false true false <code>boolean b = true;</code>"},{"location":"fr/module-01/data-types/#44-notes","title":"4.4 Notes","text":"<p><code>float</code> et <code>double</code> n\u2019ont pas de bornes enti\u00e8res fixes comme les types entiers. Ils suivent la norme IEEE 754 :</p> <ul> <li>Plus petites valeurs positives non nulles :  </li> <li><code>Float.MIN_VALUE \u2248 1.4E\u201345</code> </li> <li> <p><code>Double.MIN_VALUE \u2248 4.9E\u2013324</code> </p> </li> <li> <p>Plus grandes valeurs finies :  </p> </li> <li><code>Float.MAX_VALUE \u2248 3.4028235E+38</code> </li> <li><code>Double.MAX_VALUE \u2248 1.7976931348623157E+308</code> </li> </ul> <p>Ils supportent \u00e9galement des valeurs sp\u00e9ciales : <code>+Infinity</code>, <code>-Infinity</code>, et <code>NaN</code> (Not a Number).</p> <ul> <li>FP = floating point (virgule flottante).  </li> <li>La taille de <code>boolean</code> d\u00e9pend de la JVM mais le type se comporte logiquement comme <code>true</code>/<code>false</code>.  </li> <li>Les valeurs par d\u00e9faut s\u2019appliquent aux champs (variables de classe).   Les variables locales doivent \u00eatre explicitement initialis\u00e9es avant utilisation.</li> </ul> <p></p>"},{"location":"fr/module-01/data-types/#45-recapitulatif","title":"4.5 R\u00e9capitulatif","text":"<ul> <li>Primitif = valeur r\u00e9elle, stock\u00e9e directement en m\u00e9moire.  </li> <li>R\u00e9f\u00e9rence = pointeur vers un objet ; l\u2019objet lui-m\u00eame peut contenir des primitives et d\u2019autres r\u00e9f\u00e9rences.  </li> <li>Pour les d\u00e9tails des primitives, voir le Tableau des types primitifs.</li> </ul>"},{"location":"fr/module-01/data-types/#46-arithmetique-et-promotion-numerique-primitive","title":"4.6 Arithm\u00e9tique et promotion num\u00e9rique primitive","text":"<p>Lorsqu\u2019on applique des op\u00e9rateurs arithm\u00e9tiques ou de comparaison \u00e0 des types primitifs, Java convertit (ou promeut) automatiquement les valeurs vers des types compatibles selon des r\u00e8gles de promotion num\u00e9rique bien d\u00e9finies.</p> <p>Ces r\u00e8gles garantissent des calculs coh\u00e9rents et \u00e9vitent la perte de donn\u00e9es lors du m\u00e9lange de types num\u00e9riques diff\u00e9rents.</p> <p></p>"},{"location":"fr/module-01/data-types/#461-regles-de-promotion-numerique-en-java","title":"4.6.1 \ud83d\udd39 R\u00e8gles de promotion num\u00e9rique en Java","text":""},{"location":"fr/module-01/data-types/#4611-regle-1-types-numeriques-mixtes-le-plus-petit-type-est-promu-vers-le-plus-grand","title":"4.6.1.1 R\u00e8gle 1 \u2013 Types num\u00e9riques mixtes \u2192 le plus petit type est promu vers le plus grand","text":"<p>Si deux op\u00e9randes appartiennent \u00e0 des types num\u00e9riques diff\u00e9rents, Java promeut automatiquement le type le plus petit vers le type le plus grand avant d\u2019effectuer l\u2019op\u00e9ration.</p> Exemple Explication <code>int x = 10; double y = 5.5; double result = x + y;</code> La valeur <code>int x</code> est promue en <code>double</code>, donc le r\u00e9sultat est un <code>double</code> (<code>15.5</code>). <p>Ordre de promotion valide (du plus petit au plus grand) : <code>byte \u2192 short \u2192 int \u2192 long \u2192 float \u2192 double</code></p> <p></p>"},{"location":"fr/module-01/data-types/#4612-regle-2-entier-flottant-lentier-est-promu-vers-le-flottant","title":"4.6.1.2 R\u00e8gle 2 \u2013 Entier + flottant \u2192 l\u2019entier est promu vers le flottant","text":"<p>Si un op\u00e9rande est de type entier (<code>byte</code>, <code>short</code>, <code>char</code>, <code>int</code>, <code>long</code>) et l\u2019autre de type flottant (<code>float</code>, <code>double</code>), la valeur enti\u00e8re est promue vers le type flottant avant l\u2019op\u00e9ration.</p> Exemple Explication <code>float f = 2.5F; int n = 3; float result = f * n;</code> <code>n</code> (int) est promu en <code>float</code>. Le r\u00e9sultat est un <code>float</code> (<code>7.5</code>). <code>double d = 10.0; long l = 3; double result = d / l;</code> <code>l</code> (long) est promu en <code>double</code>. Le r\u00e9sultat est un <code>double</code> (<code>3.333...</code>). <p></p>"},{"location":"fr/module-01/data-types/#4613-regle-3-byte-short-et-char-sont-promus-en-int-lors-des-operations-arithmetiques","title":"4.6.1.3 R\u00e8gle 3 \u2013 <code>byte</code>, <code>short</code> et <code>char</code> sont promus en <code>int</code> lors des op\u00e9rations arithm\u00e9tiques","text":"<p>Lorsqu\u2019on effectue une op\u00e9ration arithm\u00e9tique sur des variables (et non des constantes litt\u00e9rales) de type <code>byte</code>, <code>short</code> ou <code>char</code>, Java les promeut automatiquement en <code>int</code>, m\u00eame si les deux op\u00e9randes sont plus petits que <code>int</code>.</p> Exemple Explication <code>byte a = 10, b = 20; byte c = a + b;</code> \u274c Erreur de compilation : le r\u00e9sultat de <code>a + b</code> est un <code>int</code>, pas un <code>byte</code>. Il faut caster \u2192 <code>byte c = (byte)(a + b);</code> <code>short s1 = 1000, s2 = 2000; short sum = (short)(s1 + s2);</code> Les op\u00e9randes sont promus en <code>int</code>, un cast explicite est n\u00e9cessaire pour affecter \u00e0 <code>short</code>. <code>char c1 = 'A', c2 = 2; int result = c1 + c2;</code> <code>'A'</code> (65) et <code>2</code> sont promus en <code>int</code>, r\u00e9sultat = <code>67</code>. <p>Note</p> <p>Cette r\u00e8gle s\u2019applique uniquement lorsqu\u2019on utilise des variables. Lorsque l\u2019on utilise des litt\u00e9raux constants, le compilateur peut parfois \u00e9valuer l\u2019expression \u00e0 la compilation et l\u2019affecter sans probl\u00e8me.</p> <pre><code>byte a = 10 + 20;   // \u2705 OK : expression constante qui tient dans un byte\nbyte b = 10;\nbyte c = 20;\nbyte d = b + c;     // \u274c Erreur : b + c est \u00e9valu\u00e9 \u00e0 l\u2019ex\u00e9cution \u2192 int\n</code></pre> <p></p>"},{"location":"fr/module-01/data-types/#4614-regle-4-le-type-du-resultat-correspond-au-type-promu-des-operandes","title":"4.6.1.4 R\u00e8gle 4 \u2013 Le type du r\u00e9sultat correspond au type promu des op\u00e9randes","text":"<p>Une fois les promotions appliqu\u00e9es, et lorsque les deux op\u00e9randes sont du m\u00eame type, le r\u00e9sultat de l\u2019expression a ce m\u00eame type promu.</p> Exemple Explication <code>int i = 5; double d = 6.0; var result = i * d;</code> <code>i</code> est promu en <code>double</code>, le r\u00e9sultat est un <code>double</code>. <code>float f = 3.5F; long l = 4L; var result = f + l;</code> <code>l</code> est promu en <code>float</code>, le r\u00e9sultat est un <code>float</code>. <code>int x = 10, y = 4; var div = x / y;</code> Les deux sont <code>int</code>, le r\u00e9sultat est un <code>int</code> (<code>2</code>), la partie fractionnaire est tronqu\u00e9e. <p>Warning</p> <p>La division enti\u00e8re produit toujours un r\u00e9sultat entier. Pour obtenir un r\u00e9sultat d\u00e9cimal, au moins un op\u00e9rande doit \u00eatre flottant :</p> <pre><code>double result = 10.0 / 4; // \u2705 2.5\nint result2 = 10 / 4;     // \u274c 2 (fraction ignor\u00e9e)\n</code></pre> <p></p>"},{"location":"fr/module-01/data-types/#462-recapitulatif-du-comportement-de-promotion-numerique","title":"4.6.2 \u2705 R\u00e9capitulatif du comportement de promotion num\u00e9rique","text":"Situation R\u00e9sultat de promotion Exemple M\u00e9lange de petits et grands types num\u00e9riques Le plus petit est promu vers le plus grand int + double \u2192 double Entier + flottant L\u2019entier est promu vers le flottant long + float \u2192 float Arithm\u00e9tique sur byte, short, char Promu en int byte + byte \u2192 int R\u00e9sultat apr\u00e8s promotion Le type du r\u00e9sultat correspond au type promu float + long \u2192 float"},{"location":"fr/module-01/data-types/#4621-points-cles","title":"4.6.2.1 \ud83e\udde0 Points cl\u00e9s","text":"<ul> <li>Toujours tenir compte de la promotion de type lorsqu\u2019on m\u00e9lange des types dans une expression arithm\u00e9tique.  </li> <li>Pour les petits types (<code>byte</code>, <code>short</code>, <code>char</code>), la promotion en <code>int</code> est automatique d\u00e8s qu\u2019il y a une op\u00e9ration avec des variables.  </li> <li>Utilisez le cast explicite seulement lorsque vous \u00eates s\u00fbr que le r\u00e9sultat tient dans le type cible.  </li> <li>Rappelez-vous : la division enti\u00e8re tronque, la division en flottant conserve les d\u00e9cimales.  </li> <li>Comprendre ces r\u00e8gles est essentiel pour \u00e9viter les pertes de pr\u00e9cision inattendues ou les erreurs de compilation \u00e0 l\u2019examen de certification Java.</li> </ul>"},{"location":"fr/module-01/data-types/#47-cast-en-java","title":"4.7 Cast en Java","text":"<p>En Java, le <code>cast</code> est le processus par lequel on convertit explicitement une valeur d\u2019un type vers un autre. Cela s\u2019applique \u00e0 la fois aux <code>types primitifs</code> (nombres) et aux <code>types r\u00e9f\u00e9rence</code> (objets dans une hi\u00e9rarchie de classes).</p> <p></p>"},{"location":"fr/module-01/data-types/#471-cast-primitif","title":"4.7.1 Cast primitif","text":"<p>Le cast primitif modifie le type d\u2019une valeur num\u00e9rique.</p> <p>Il existe deux cat\u00e9gories de cast :</p> Type Description Exemple Explicite ? Risque Widening plus petit type \u2192 plus grand type int \u2192 double Non Aucune perte Narrowing plus grand type \u2192 plus petit type double \u2192 int Oui Perte possible <p></p>"},{"location":"fr/module-01/data-types/#4711-cast-large-implicite","title":"4.7.1.1 Cast large implicite","text":"<p>Conversion automatique d\u2019un type \u201cplus petit\u201d vers un type compatible \u201cplus grand\u201d. G\u00e9r\u00e9e par le compilateur, ne n\u00e9cessite pas de syntaxe explicite.</p> <pre><code>int i = 100;\ndouble d = i;  // cast implicite : int \u2192 double\nSystem.out.println(d); // 100.0\n</code></pre> <p>\u2705 S\u00fbr \u2013 pas de d\u00e9passement (m\u00eame s\u2019il faut garder en t\u00eate la pr\u00e9cision des flottants).</p> <p></p>"},{"location":"fr/module-01/data-types/#4712-cast-etroit-explicite","title":"4.7.1.2 Cast \u00e9troit explicite","text":"<p>Conversion manuelle d\u2019un type \u00ab plus grand \u00bb vers un type \u00ab plus petit \u00bb. N\u00e9cessite une cast expression car cela peut provoquer une perte de donn\u00e9es.</p> <pre><code>double d = 9.78;\nint i = (int) d;  // explicit cast: double \u2192 int\nSystem.out.println(i); // 9 (fraction discarded)\n</code></pre> <p>Warning</p> <p>\u26a0 Utiliser uniquement lorsque vous \u00eates certain que la valeur tient dans le type cible.</p> <p></p>"},{"location":"fr/module-01/data-types/#4713-cast-etroit-implicite-a-la-compilation","title":"4.7.1.3 Cast \u00e9troit Implicite \u00e0 la Compilation","text":"<p>Dans certains cas sp\u00e9cifiques, le compilateur autorise une conversion de narrowing sans cast explicite.</p> <p>Si une variable est d\u00e9clar\u00e9e <code>final</code> et initialis\u00e9e avec une constant expression dont la valeur tient dans le type cible, le compilateur peut effectuer la conversion en toute s\u00e9curit\u00e9 au moment de la compilation.</p> <pre><code>final int k = 10;\nbyte b = k;  // allowed: value 10 fits into byte range\n\nfinal int x = 200;\nbyte c = x;  // does NOT compile: 200 is outside byte range\n</code></pre> <p>Cela fonctionne parce que le compilateur conna\u00eet la valeur exacte d\u2019une variable <code>final</code> et peut v\u00e9rifier qu\u2019elle se situe dans l\u2019intervalle du type plus petit.</p> <p>Ce type de narrowing est autoris\u00e9 entre : - <code>byte</code> - <code>short</code> - <code>char</code> - <code>int</code></p> <p>Cependant, cela ne s\u2019applique pas \u00e0 : - <code>long</code> - <code>float</code> - <code>double</code></p> <p>Par exemple :</p> <pre><code>final float f = 10.0f;\nint n = f;   // does not compile\n</code></pre> <p>M\u00eame si la valeur semble compatible, les types \u00e0 virgule flottante ne sont pas \u00e9ligibles pour cette forme de narrowing implicite.</p> <p></p>"},{"location":"fr/module-01/data-types/#472-perte-de-donnees-depassement-et-sous-depassement","title":"4.7.2 Perte de donn\u00e9es, d\u00e9passement et sous-d\u00e9passement","text":"<p>Lorsqu\u2019une valeur d\u00e9passe la capacit\u00e9 d\u2019un type, on peut obtenir :</p> <ul> <li>D\u00e9passement (overflow) : r\u00e9sultat sup\u00e9rieur \u00e0 la valeur maximale repr\u00e9sentable</li> <li>Sous-d\u00e9passement (underflow) : r\u00e9sultat inf\u00e9rieur \u00e0 la valeur minimale repr\u00e9sentable</li> <li> <p>Troncature : les donn\u00e9es qui ne tiennent pas sont perdues (par exemple, les d\u00e9cimales)</p> </li> <li> <p>Exemple \u2013 overflow/underflow avec int</p> </li> </ul> <pre><code>int max = Integer.MAX_VALUE;\nint overflow = max + 1;     // retour (\u201cwrap-around\u201d) vers une valeur n\u00e9gative\n\nint min = Integer.MIN_VALUE;\nint underflow = min - 1;    // retour (\u201cwrap-around\u201d) vers une valeur positive\n</code></pre> <ul> <li>Exemple \u2013 troncature</li> </ul> <pre><code>double d = 9.99;\nint i = (int) d; // 9 (fraction supprim\u00e9e)\n</code></pre> <p>Note</p> <p>Les types flottants (<code>float</code>, <code>double</code>) ne font pas de wrap-around : - overflow \u2192 <code>Infinity</code> / <code>-Infinity</code> - underflow (valeurs tr\u00e8s petites) \u2192 0.0 ou valeurs d\u00e9normalis\u00e9es.</p> <p></p>"},{"location":"fr/module-01/data-types/#473-cast-de-valeurs-versus-variables","title":"4.7.3 Cast de valeurs versus variables","text":"<p>Java traite :</p> <ul> <li>Les litt\u00e9raux entiers comme des <code>int</code> par d\u00e9faut</li> <li>Les litt\u00e9raux flottants comme des <code>double</code> par d\u00e9faut</li> </ul> <p>Le compilateur n\u2019exige pas de cast lorsqu\u2019un litt\u00e9ral tient dans la plage du type cible :</p> <pre><code>byte first = 10;        // OK : 10 tient dans un byte\nshort second = 9 * 10;  // OK : expression constante \u00e9valu\u00e9e \u00e0 la compilation\n</code></pre> <p>Mais :</p> <pre><code>long a = 5729685479;    // \u274c erreur : litt\u00e9ral int hors plage\nlong b = 5729685479L;   // \u2705 litt\u00e9ral long (suffixe L)\n\nfloat c = 3.14;         // \u274c double \u2192 float : n\u00e9cessite F ou cast\nfloat d = 3.14F;        // \u2705 litt\u00e9ral float\n\nint e = 0x7FFF_FFFF;    // \u2705 max int en hexad\u00e9cimal\nint f = 0x8000_0000;    // \u274c hors plage int (n\u00e9cessite L)\n</code></pre> <p>Cependant, lorsque les r\u00e8gles de promotion num\u00e9rique s\u2019appliquent :</p> <p>Avec des variables de type <code>byte</code>, <code>short</code> et <code>char</code> dans une expression arithm\u00e9tique, les op\u00e9randes sont promus en <code>int</code> et le r\u00e9sultat est un <code>int</code>.</p> <pre><code>byte first = 10;\nshort second = 9 + first;       // \u274c 9 (litt\u00e9ral int) + first (byte \u2192 int) = int\n// second = (short) (9 + first);  // \u2705 cast de l\u2019expression enti\u00e8re\n</code></pre> <pre><code>short b = 10;\nshort a = 5 + b;               // \u274c 5 (int) + b (short \u2192 int) = int\nshort a2 = (short) (5 + b);    // \u2705 cast de l\u2019expression enti\u00e8re\n</code></pre> <p>Warning</p> <p>Le cast est un op\u00e9rateur unaire :</p> <p><code>short a = (short) 5 + b;</code> Le cast s\u2019applique uniquement \u00e0 <code>5</code> \u2192 le r\u00e9sultat de l\u2019expression reste un int \u2192 l\u2019affectation \u00e9choue toujours.</p> <p></p>"},{"location":"fr/module-01/data-types/#474-cast-de-reference-dobjets","title":"4.7.4 Cast de r\u00e9f\u00e9rence d\u2019objets","text":"<p>Le cast s\u2019applique aussi aux r\u00e9f\u00e9rences d\u2019objets dans une hi\u00e9rarchie de classes. Il ne change pas l\u2019objet en m\u00e9moire \u2014 seulement le type de r\u00e9f\u00e9rence utilis\u00e9 pour y acc\u00e9der.</p> <p>R\u00e8gles importantes :</p> <ul> <li>Le type r\u00e9el de l\u2019objet d\u00e9termine quels champs/m\u00e9thodes existent r\u00e9ellement.</li> <li>Le type de la r\u00e9f\u00e9rence d\u00e9termine ce que vous pouvez appeler/acc\u00e9der \u00e0 cet endroit du code.</li> </ul> <p></p>"},{"location":"fr/module-01/data-types/#4741-upcasting-cast-large-de-reference","title":"4.7.4.1 Upcasting (cast large de r\u00e9f\u00e9rence)","text":"<p>Conversion d\u2019une sous-classe vers une super-classe.</p> <p>Implicite et toujours s\u00fbre : chaque <code>Dog</code> est aussi un <code>Animal</code>.</p> <pre><code>class Animal { }\nclass Dog extends Animal { }\n\nDog dog = new Dog();\nAnimal a = dog;    // upcast implicite : Dog \u2192 Animal\n</code></pre> <p></p>"},{"location":"fr/module-01/data-types/#4742-downcasting-cast-etroit-de-reference","title":"4.7.4.2 Downcasting (cast \u00e9troit de r\u00e9f\u00e9rence)","text":"<p>Conversion d\u2019une super-classe vers une sous-classe.</p> <ul> <li>Explicite</li> <li>Peut \u00e9chouer \u00e0 l\u2019ex\u00e9cution avec <code>ClassCastException</code> si l\u2019objet n\u2019est pas r\u00e9ellement de ce type</li> </ul> <pre><code>Animal a = new Dog();\nDog d = (Dog) a;   // OK : a r\u00e9f\u00e9rence r\u00e9ellement un Dog\n\nAnimal x = new Animal();\nDog d2 = (Dog) x;  // \u26a0 Erreur \u00e0 l\u2019ex\u00e9cution : ClassCastException\n</code></pre> <p>Pour plus de s\u00e9curit\u00e9, utilisez <code>instanceof</code> :</p> <pre><code>if (x instanceof Dog) {\n    Dog safeDog = (Dog) x;   // cast s\u00fbr\n}\n</code></pre> <p></p>"},{"location":"fr/module-01/data-types/#475-resume-des-points-cles","title":"4.7.5 R\u00e9sum\u00e9 des points cl\u00e9s","text":"Type de cast S\u2019applique \u00e0 Direction Syntaxe S\u00fbr ? Effettu\u00e9 par Widening Primitive Primitifs petit \u2192 grand Implice Oui Compilateur Narrowing Primitive Primitifs grand \u2192 petit Explicite Non Programmeur Upcasting Objets sous-classe \u2192 super-classe Implice Oui Compilateur Downcasting Objets super-classe \u2192 sous-classe Explicite V\u00e9rification \u00e0 l\u2019ex\u00e9cution Programmeur"},{"location":"fr/module-01/data-types/#476-exemples","title":"4.7.6 Exemples","text":"<pre><code>// Cast primitif\nshort s = 50;\nint i = s;           // widening\nbyte b = (byte) i;   // narrowing (perte possible)\n\n// Cast d\u2019objet\nObject obj = \"Hello\";\nString str = (String) obj; // OK : obj r\u00e9f\u00e9rence une String\n\nObject n = Integer.valueOf(10);\n// String fail = (String) n;  // ClassCastException \u00e0 l\u2019ex\u00e9cution\n</code></pre>"},{"location":"fr/module-01/data-types/#48-resume","title":"4.8 R\u00e9sum\u00e9","text":"<ul> <li>Le cast primitif change le type num\u00e9rique.  </li> <li>Le cast de r\u00e9f\u00e9rence change la \u201cvue\u201d d\u2019un objet dans la hi\u00e9rarchie.  </li> <li>Upcasting \u2192 s\u00fbr et implicite.  </li> <li>Downcasting \u2192 explicite, \u00e0 utiliser avec prudence (souvent apr\u00e8s <code>instanceof</code>).</li> </ul>"},{"location":"fr/module-01/instantiating-types/","title":"6. Instanciation des types","text":""},{"location":"fr/module-01/instantiating-types/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>6.1 Introduction<ul> <li>6.1.1 Gestion des types primitifs<ul> <li>6.1.1.1 D\u00e9clarer un primitif</li> <li>6.1.1.2 Affecter un primitif</li> </ul> </li> <li>6.1.2 Gestion des types r\u00e9f\u00e9rence<ul> <li>6.1.2.1 Cr\u00e9er et affecter une r\u00e9f\u00e9rence</li> <li>6.1.2.2 Constructeurs</li> <li>6.1.2.3 Blocs-dinitialisation-dinstance</li> </ul> </li> </ul> </li> <li>6.2 Initialisation par d\u00e9faut des variables<ul> <li>6.2.1 Variables d\u2019instance et de classe</li> <li>6.2.2 Variables d\u2019instance final</li> <li>6.2.3 Variables locales<ul> <li>6.2.3.1 Inf\u00e9rer les types avec var</li> </ul> </li> </ul> </li> <li>6.3 Types wrapper<ul> <li>6.3.1 Objectif des types wrapper</li> <li>6.3.2 Autoboxing et unboxing</li> <li>6.3.3 Parsing et conversion</li> <li>6.3.4 M\u00e9thodes utilitaires</li> <li>6.3.5 Valeurs null</li> </ul> </li> <li>6.4 \u00c9galit\u00e9 en Java<ul> <li>6.4.1 \u00c9galit\u00e9 avec les types primitifs<ul> <li>6.4.1.1 Points cl\u00e9s)</li> </ul> </li> <li>6.4.2 \u00c9galit\u00e9 avec les types r\u00e9f\u00e9rence<ul> <li>6.4.2.1 Comparaison d\u2019identit\u00e9</li> <li>6.4.2.2 equals Comparaison logique</li> <li>6.4.2.3 Points cl\u00e9s</li> </ul> </li> <li>6.4.3 String Pool et \u00e9galit\u00e9<ul> <li>6.4.3.1 La m\u00e9thode intern</li> </ul> </li> <li>6.4.4 \u00c9galit\u00e9 avec les types wrapper</li> <li>6.4.5 \u00c9galit\u00e9 et null</li> <li>6.4.6 Tableau r\u00e9capitulatif</li> </ul> </li> </ul>"},{"location":"fr/module-01/instantiating-types/#61-introduction","title":"6.1 Introduction","text":"<p>En Java, un type peut \u00eatre soit un type primitif (comme <code>int</code>, <code>double</code>, <code>boolean</code>, etc.), soit un type r\u00e9f\u00e9rence (classes, interfaces, tableaux, enums, records, etc.). Voir : Java Data Types and Casting</p> <p>La fa\u00e7on dont les instances sont cr\u00e9\u00e9es d\u00e9pend de la cat\u00e9gorie du type :</p> <ul> <li>Types primitifs   Les instances des types primitifs sont cr\u00e9\u00e9es simplement en d\u00e9clarant une variable.   La JVM alloue automatiquement la m\u00e9moire n\u00e9cessaire pour contenir la valeur, et aucun mot-cl\u00e9 explicite n\u2019est requis. </li> </ul> <pre><code>int age = 30;         // cr\u00e9e un int primitif avec la valeur 30\nboolean flag = true;  // cr\u00e9e un boolean primitif avec la valeur true\ndouble pi = 3.14159;  // cr\u00e9e un double primitif avec la valeur 3.14159\n</code></pre> <ul> <li>Types r\u00e9f\u00e9rence (objets)     Les instances des types classe sont cr\u00e9\u00e9es \u00e0 l\u2019aide du mot-cl\u00e9 <code>new</code> (sauf quelques cas particuliers comme les litt\u00e9raux String, les records avec constructeur canonique, ou les m\u00e9thodes factory).     Le mot-cl\u00e9 <code>new</code> alloue de la m\u00e9moire sur le tas (heap) et invoque un constructeur de la classe.</li> </ul> <pre><code>String name = new String(\"Alice\"); // cr\u00e9e explicitement un nouvel objet String\nPerson p = new Person();           // cr\u00e9e un nouvel objet Person via son constructeur\n</code></pre> <p>Il est aussi courant de s\u2019appuyer sur des litt\u00e9raux ou des m\u00e9thodes factory pour cr\u00e9er des objets.</p> <pre><code>String text = \"Hello World\";\n\nList&lt;String&gt; list = List.of(\"A\", \"B\", \"C\");              // factory method immutabile\nMap&lt;String, Integer&gt; map = Map.of(\"one\", 1, \"two\", 2);   // factory method immutabile\nOptional&lt;String&gt; opt = Optional.of(\"value\");             // factory method\n\nLocalDate date = LocalDate.of(2025, 3, 15);\nInteger boxed = Integer.valueOf(10);\n</code></pre> <p>Important</p> <p>Les litt\u00e9raux String ne n\u00e9cessitent pas <code>new</code> et sont stock\u00e9s dans le String pool. Utiliser <code>new String(\"x\")</code> cr\u00e9e toujours un nouvel objet sur le heap.</p> <p></p>"},{"location":"fr/module-01/instantiating-types/#611-gestion-des-types-primitifs","title":"6.1.1 Gestion des types primitifs","text":""},{"location":"fr/module-01/instantiating-types/#6111-declarer-un-primitif","title":"6.1.1.1 D\u00e9clarer un primitif","text":"<p>D\u00e9clarer un type primitif (comme pour les types r\u00e9f\u00e9rence) signifie r\u00e9server un espace m\u00e9moire pour une variable d\u2019un type donn\u00e9, sans n\u00e9cessairement lui attribuer une valeur.  </p> <p>Warning</p> <p>Contrairement aux primitifs, dont la taille d\u00e9pend du type sp\u00e9cifique (par ex. <code>int</code> vs <code>long</code>), les variables r\u00e9f\u00e9rence occupent toujours la m\u00eame taille fixe en m\u00e9moire \u2014 ce qui varie, c\u2019est la taille de l\u2019objet qu\u2019elles pointent.</p> <ul> <li>Exemples de syntaxe (d\u00e9claration uniquement) :</li> </ul> <pre><code>int number;\n\nboolean active;\n\nchar letter;\n\nint x, y, z;          // D\u00e9clarations multiples dans une seule instruction : Java autorise la d\u00e9claration de plusieurs variables du m\u00eame type\n</code></pre> <p>Important</p> <p>Les <code>modificateurs</code> et le <code>type</code> d\u00e9clar\u00e9s au d\u00e9but d\u2019une d\u00e9claration de variables s\u2019appliquent \u00e0 toutes les variables d\u00e9clar\u00e9es dans la m\u00eame instruction.</p> <p>Exception : lors de la d\u00e9claration de tableaux en utilisant les crochets apr\u00e8s le nom de la variable, les crochets font partie du d\u00e9clarateur de la variable individuelle, et non du type de base.</p> <ul> <li>Examples</li> </ul> <pre><code>static int a, b, c;\n\n// est \u00e9quivalent \u00e0 :\n\nstatic int a;\nstatic int b;\nstatic int c;\n\n\nint[] a, b;   // les deux sont des tableaux de int\nint c[], d;   // seul c est un tableau, d est un int normal\n</code></pre> <p></p>"},{"location":"fr/module-01/instantiating-types/#6112-affecter-un-primitif","title":"6.1.1.2 Affecter un primitif","text":"<p>Affecter un type primitif (comme pour les types r\u00e9f\u00e9rence) signifie stocker une valeur dans une variable d\u00e9clar\u00e9e de ce type. Pour les primitifs, la variable contient la valeur elle-m\u00eame, tandis que pour les types r\u00e9f\u00e9rence elle contient l\u2019adresse m\u00e9moire (une r\u00e9f\u00e9rence) de l\u2019objet point\u00e9.</p> <ul> <li>Exemples de syntaxe :</li> </ul> <pre><code>int number;                     // D\u00e9claration d\u2019un int : une variable appel\u00e9e \"number\"\n\nnumber = 10;                    // Affectation de la valeur 10 \u00e0 cette variable\n\nchar letter = 'A';              // D\u00e9claration et affectation en une seule instruction : d\u00e9claration et affectation peuvent \u00eatre combin\u00e9es \n\nint a1, a2;                      // D\u00e9clarations multiples  \n\nint a = 1, b = 2, c = 3;        // D\u00e9clarations multiples &amp; affectations\n\nchar b1, b2, b3 = 'C';          // D\u00e9clarations mixtes (2 d\u00e9clarations + 1 affectation)\n\ndouble d1, double d2;            // ERROR - NOT LEGAL\n\nint v1; v2;                      // ERROR - NOT LEGAL\n</code></pre> <p>Important</p> <p>Quand tu \u00e9cris un nombre directement dans le code (un litt\u00e9ral num\u00e9rique), Java suppose par d\u00e9faut qu\u2019il est de type int. Si la valeur ne tient pas dans un <code>int</code>, le code ne compile pas, \u00e0 moins de le marquer explicitement avec le suffixe appropri\u00e9.</p> <ul> <li>Exemple de syntaxe pour un litt\u00e9ral num\u00e9rique :</li> </ul> <pre><code>long exNumLit = 5729685479; // \u274c Does not compile.\n                          // M\u00eame si la valeur pourrait tenir dans un long,\n                          // un litt\u00e9ral num\u00e9rique simple est consid\u00e9r\u00e9 comme un int,\n                          // et ce nombre est trop grand pour un int.\n\n// Changing the declaration adding the correct suffix (L or l) will solve:\n\nlong exNumLit = 5729685479L;\n\nor\n\nlong exNumLit = 5729685479l;\n</code></pre> <p>D\u00e9clarer un type <code>reference</code> signifie r\u00e9server de l\u2019espace m\u00e9moire pour une variable qui contiendra une r\u00e9f\u00e9rence (pointeur) vers un objet du type sp\u00e9cifi\u00e9.</p> <p>\u00c0 ce stade, aucun objet n\u2019est encore cr\u00e9\u00e9 \u2014 la variable a seulement la capacit\u00e9 d\u2019en r\u00e9f\u00e9rencer un.</p> <p>Warning</p> <p>Contrairement aux primitifs, dont la taille d\u00e9pend du type sp\u00e9cifique (par ex. <code>int</code> vs <code>long</code>), les variables r\u00e9f\u00e9rence occupent toujours la m\u00eame taille fixe en m\u00e9moire (suffisante pour stocker une r\u00e9f\u00e9rence). Ce qui varie, c\u2019est la taille de l\u2019objet point\u00e9, qui est allou\u00e9 s\u00e9par\u00e9ment sur le heap.</p> <ul> <li>Exemples de syntaxe (d\u00e9claration uniquement) :</li> </ul> <pre><code>String name;\nPerson person;\nList&lt;Integer&gt; numbers;\n\nPerson p1, p2, p3;   // D\u00e9clarations multiples dans une seule instruction\n\nString a = \"abc\", b = \"def\", c = \"ghi\";     // D\u00e9clarations multiples &amp; affectations\n\nString b1, b2, b3 = \"abc\"                   // D\u00e9clarations mixtes (b1, b2) avec une affectation (b3)\n\nString d1, String d2;                   // ERROR - NOT LEGAL\n\nString v1; v2;                          // ERROR - NOT LEGAL\n</code></pre> <p></p>"},{"location":"fr/module-01/instantiating-types/#612-gestion-des-types-reference","title":"6.1.2 Gestion des types r\u00e9f\u00e9rence","text":""},{"location":"fr/module-01/instantiating-types/#6121-creer-et-affecter-une-reference","title":"6.1.2.1 Cr\u00e9er et affecter une r\u00e9f\u00e9rence","text":"<p>Affecter un type <code>reference</code> signifie stocker dans la variable l\u2019adresse m\u00e9moire d\u2019un objet.</p> <p>On le fait normalement apr\u00e8s la cr\u00e9ation de l\u2019objet avec le mot-cl\u00e9 new et un constructeur, ou en utilisant un litt\u00e9ral ou une m\u00e9thode factory.</p> <p>Une r\u00e9f\u00e9rence peut aussi \u00eatre affect\u00e9e \u00e0 un autre objet du m\u00eame type ou d\u2019un type compatible.</p> <p>Les types r\u00e9f\u00e9rence peuvent \u00e9galement recevoir null, ce qui signifie qu\u2019ils ne r\u00e9f\u00e9rencent aucun objet.</p> <ul> <li>Exemples de syntaxe :</li> </ul> <pre><code>Person person = new Person(); // Exemple avec 'new' et un constructeur 'Person()' :\n                            // 'new Person()' cr\u00e9e un nouvel objet Person sur le heap\n                            // et renvoie sa r\u00e9f\u00e9rence, stock\u00e9e dans la variable 'person'.\n\nString greeting = \"Hello\";   // Exemple avec un litt\u00e9ral (pour String).\n\nList&lt;Integer&gt; numbers = List.of(1, 2, 3);   // Exemple avec une m\u00e9thode factory.\n</code></pre> <p></p>"},{"location":"fr/module-01/instantiating-types/#6122-constructeurs","title":"6.1.2.2 Constructeurs","text":"<p>Dans l\u2019exemple, <code>Person()</code> est un constructeur \u2014 un type sp\u00e9cial de m\u00e9thode utilis\u00e9e pour initialiser de nouveaux objets.</p> <p>Chaque fois que tu appelles <code>new Person()</code>, le constructeur s\u2019ex\u00e9cute et configure l\u2019instance nouvellement cr\u00e9\u00e9e.</p> <p>Les constructeurs ont trois caract\u00e9ristiques principales :</p> <ul> <li>Le nom du constructeur doit correspondre exactement au nom de la classe (sensible \u00e0 la casse).  </li> <li>Les constructeurs ne d\u00e9clarent pas de type de retour (pas m\u00eame <code>void</code>).  </li> <li>Si tu ne d\u00e9finis aucun constructeur dans ta classe, le compilateur fournit automatiquement un constructeur par d\u00e9faut sans argument qui ne fait rien.</li> </ul> <p>Warning</p> <p>Si tu vois une m\u00e9thode qui a le m\u00eame nom que la classe mais qui d\u00e9clare un type de retour, ce n\u2019est pas un constructeur. C\u2019est simplement une m\u00e9thode ordinaire (m\u00eame si commencer les noms de m\u00e9thodes par une majuscule va \u00e0 l\u2019encontre des conventions de nommage Java).</p> <p>Le but d\u2019un constructeur est d\u2019initialiser l\u2019\u00e9tat d\u2019un objet nouvellement cr\u00e9\u00e9 \u2014 g\u00e9n\u00e9ralement en affectant des valeurs \u00e0 ses champs, soit avec des valeurs par d\u00e9faut, soit \u00e0 partir de param\u00e8tres pass\u00e9s au constructeur.</p> <ul> <li>Exemple 1 : Constructeur par d\u00e9faut (sans param\u00e8tres)</li> </ul> <pre><code>public class Person {\n    String name;\n    int age;\n\n    // Default constructor\n    public Person() {\n        name = \"Unknown\";\n        age = 0;\n    }\n}\n\nPerson p1 = new Person(); // name = \"Unknown\", age = 0\n</code></pre> <ul> <li>Exemple 2 : Constructeur avec param\u00e8tres</li> </ul> <pre><code>public class Person {\n    String name;\n    int age;\n\n    // Constructor with parameters\n    public Person(String newName, int newAge) {\n        name = newName;\n        age = newAge;\n    }\n}\n\nPerson p2 = new Person(\"Alice\", 30); // name = \"Alice\", age = 30\n</code></pre> <ul> <li>Exemple 3 : Plusieurs constructeurs (surcharge de constructeurs)</li> </ul> <pre><code>public class Person {\n    String name;\n    int age;\n\n    // Default constructor\n    public Person() {\n        this(\"Unknown\", 0); // calls the other constructor\n    }\n\n    // Constructor with parameters\n    public Person(String newName, int newAge) {\n        name = newName;\n        age = newAge;\n    }\n}\n\nPerson p1 = new Person();            // name = \"Unknown\", age = 0\nPerson p2 = new Person(\"Bob\", 25);   // name = \"Bob\", age = 25\n</code></pre> <p>Important</p> <ul> <li>Les constructeurs ne sont pas h\u00e9rit\u00e9s : si une superclasse d\u00e9finit des constructeurs, ils ne sont pas automatiquement disponibles dans la sous-classe \u2014 tu dois les d\u00e9clarer explicitement.</li> <li>Si tu d\u00e9clares un constructeur quelconque dans une classe, le compilateur ne g\u00e9n\u00e8re pas le constructeur par d\u00e9faut sans argument : si tu as encore besoin d\u2019un constructeur sans argument, tu dois le d\u00e9clarer manuellement.</li> </ul> <p></p>"},{"location":"fr/module-01/instantiating-types/#6123-blocs-dinitialisation-dinstance","title":"6.1.2.3 Blocs d\u2019initialisation d\u2019instance","text":"<p>En plus des constructeurs, Java fournit un m\u00e9canisme appel\u00e9 initializer blocks pour aider \u00e0 initialiser les objets. Ce sont des blocs de code \u00e0 l\u2019int\u00e9rieur d\u2019une classe, entour\u00e9s par <code>{ }</code>, qui s\u2019ex\u00e9cutent \u00e0 chaque cr\u00e9ation d\u2019instance, juste avant l\u2019ex\u00e9cution du corps du constructeur.</p> <p>Caract\u00e9ristiques</p> <ul> <li>Aussi appel\u00e9s instance initializer blocks.  </li> <li>Ex\u00e9cut\u00e9s, avec les initialisations de champs, dans l\u2019ordre o\u00f9 ils apparaissent dans la d\u00e9finition de la classe, mais toujours avant les constructeurs.    </li> <li>Utiles lorsque plusieurs constructeurs doivent partager un code d\u2019initialisation commun.</li> </ul> <p>Exemple : utilisation d\u2019un Instance Initializer Block</p> <pre><code>public class Person {\n    String name;\n    int age;\n\n    // Instance initializer block\n    {\n        System.out.println(\"Instance initializer block executed\");\n        age = 18; // default age for every Person\n    }\n\n    // Default constructor\n    public Person() {\n        name = \"Unknown\";\n    }\n\n    // Constructor with parameters\n    public Person(String newName) {\n        name = newName;\n    }\n}\n\nPerson p1 = new Person();          // prints \"Instance initializer block executed\"\nPerson p2 = new Person(\"Alice\");   // prints \"Instance initializer block executed\"\n</code></pre> <p>Note</p> <p>Dans cet exemple, le bloc d\u2019initialisation s\u2019ex\u00e9cute avant le corps de chacun des constructeurs. p1 et p2 commenceront tous les deux avec age = 18, quel que soit le constructeur utilis\u00e9.</p> <p>Plusieurs blocs d\u2019initialisation : si une classe contient plusieurs blocs d\u2019initialisation, ils s\u2019ex\u00e9cutent dans l\u2019ordre o\u00f9 ils apparaissent dans le fichier source :</p> <ul> <li>Exemple : </li> </ul> <pre><code>public class Example {\n    {\n        System.out.println(\"First block\");\n    }\n\n    {\n        System.out.println(\"Second block\");\n    }\n}\n\nExample ex = new Example();\n// Output:\n// First block\n// Second block\n</code></pre> <p>Note</p> <p>Les blocs d\u2019initialisation d\u2019instance sont moins courants en pratique, car une logique similaire peut souvent \u00eatre plac\u00e9e directement dans les constructeurs. Il est important de savoir que : - Ils s\u2019ex\u00e9cutent toujours avant le corps du constructeur. - Ils sont ex\u00e9cut\u00e9s dans l\u2019ordre de d\u00e9claration dans la classe. - Ils peuvent \u00eatre combin\u00e9s avec les constructeurs pour \u00e9viter la duplication de code.</p> <p>Warning</p> <p>Ordre d\u2019initialisation lors de la cr\u00e9ation d\u2019un objet 1. Champs statiques 2. Blocs d\u2019initialisation statiques 3. Champs d\u2019instance 4. Blocs d\u2019initialisation d\u2019instance 5. Corps du constructeur</p> <p></p>"},{"location":"fr/module-01/instantiating-types/#62-initialisation-par-defaut-des-variables","title":"6.2 Initialisation par d\u00e9faut des variables","text":""},{"location":"fr/module-01/instantiating-types/#621-variables-dinstance-et-de-classe","title":"6.2.1 Variables d\u2019instance et de classe","text":"<ul> <li>Une variable d\u2019instance (un champ/field) est une valeur d\u00e9finie dans une instance d\u2019un objet ;</li> <li>Une variable de classe (d\u00e9finie avec le mot-cl\u00e9 static) est d\u00e9finie au niveau de la classe et est partag\u00e9e entre tous les objets (instances de la classe)</li> </ul> <p>Les variables d\u2019instance et de classe re\u00e7oivent une valeur par d\u00e9faut, par le compilateur, si elles ne sont pas initialis\u00e9es.</p> <ul> <li>Tableau des valeurs par d\u00e9faut pour les variables d\u2019instance et de classe :</li> </ul> Type Default Value Object null Numeric 0 boolean false char '\\u0000' (NUL) <p></p>"},{"location":"fr/module-01/instantiating-types/#622-variables-dinstance-final","title":"6.2.2 Variables d\u2019instance final","text":"<p>Contrairement aux variables d\u2019instance et de classe ordinaires, les variables <code>final</code> ne sont pas initialis\u00e9es par d\u00e9faut par le compilateur. Une variable <code>final</code> doit \u00eatre affect\u00e9e explicitement exactement une fois, sinon le code ne compile pas.</p> <p>Cela s\u2019applique aux :</p> <ul> <li>variables final d\u2019instance</li> <li>variables de classe static final</li> </ul> <p>Note</p> <p>On peut affecter une valeur <code>null</code> \u00e0 une variable final d\u2019instance ou de classe tant que cela est fait explicitement.</p> <p>Java impose cette r\u00e8gle car une variable <code>final</code> repr\u00e9sente une valeur qui doit \u00eatre connue et fix\u00e9e avant usage.</p> <p><code>Final Instance Variables</code></p> <p>Une variable final d\u2019instance doit \u00eatre affect\u00e9e exactement une fois, et l\u2019affectation doit se produire dans un des endroits suivants :</p> <ol> <li>Au point de d\u00e9claration</li> <li>Dans un bloc d\u2019initialisation d\u2019instance</li> <li>\u00c0 l\u2019int\u00e9rieur de chaque constructeur</li> </ol> <p>Si la classe a plusieurs constructeurs, la variable doit \u00eatre affect\u00e9e dans tous.</p> <ul> <li>Exemple : <pre><code>public class Person {\n    final int id;   // doit \u00eatre affect\u00e9e avant la fin du constructeur\n    String name;\n\n    // Constructeur 1\n    public Person(int id, String name) {\n        this.id = id;        // ok\n        this.name = name;\n    }\n\n    // Constructeur 2\n    public Person() {\n        this.id = 0;         // requis aussi ici\n        this.name = \"Unknown\";\n    }\n}\n</code></pre></li> </ul> <p>Warning</p> <p>Compiler sans affecter <code>id</code> dans chaque constructeur produit une erreur de compilation : variable id might not have been initialized</p> <p>Variables de classe <code>static final</code> (constantes)</p> <p>Une variable static final appartient \u00e0 la classe plut\u00f4t qu\u2019\u00e0 une instance. Elle doit aussi \u00eatre affect\u00e9e exactement une fois, mais l\u2019affectation peut se faire \u00e0 l\u2019un des endroits suivants :</p> <ol> <li>Au point de d\u00e9claration</li> <li> <p>Dans un bloc d\u2019initialisation statique</p> </li> <li> <p>Exemple : <pre><code>public class AppConfig {\n\n    static final int TIMEOUT = 5000;    // affect\u00e9e \u00e0 la d\u00e9claration\n\n    static final String VERSION;        // affect\u00e9e dans le bloc static\n\n    static {\n        VERSION = \"1.0.0\";              // ok\n    }\n}\n</code></pre></p> </li> </ol> <p>Tenter d\u2019affecter une <code>static final</code> dans un constructeur est ill\u00e9gal.</p> <p>R\u00e8gles cl\u00e9s pour les champs <code>final</code></p> Scenario Allowed? Notes Assign at declaration \u2714 Most common pattern Assign in constructor \u2714 All constructors must assign it Assign in instance initializer \u2714 Before constructor body runs Assign in static initializer (static final only) \u2714 For class-level constants Assign multiple times \u274c Compilation error Default initialization \u274c Must be explicitly assigned <p>Exemple d\u2019une situation ill\u00e9gale : <pre><code>public class Example {\n    final int x;        // not initialized\n}\n\nExample e = new Example(); // \u274c compile-time error\n</code></pre></p> <p>Pourquoi les variables <code>final</code> ne sont-elles pas initialis\u00e9es par d\u00e9faut ?</p> <p>Parce que :</p> <ul> <li>Leur valeur doit \u00eatre connue et immuable, et</li> <li>Java doit garantir que la valeur est d\u00e9finie avant utilisation,</li> <li>Une initialisation par d\u00e9faut cr\u00e9erait une situation o\u00f9 <code>0</code>, <code>null</code> ou <code>false</code> pourraient devenir involontairement la valeur permanente.</li> </ul> <p>Ainsi, Java oblige les d\u00e9veloppeurs \u00e0 initialiser explicitement les champs <code>final</code>.</p> <p>Tip</p> <p><code>final</code> signifie affect\u00e9 une seule fois, pas objet immuable.</p> <p>Une r\u00e9f\u00e9rence final peut toujours pointer vers un objet mutable.</p> <pre><code>final List&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"ok\");      // autoris\u00e9\nlist = new ArrayList&lt;&gt;(); // \u274c impossible de r\u00e9affecter la r\u00e9f\u00e9rence\n</code></pre> <p></p>"},{"location":"fr/module-01/instantiating-types/#623-variables-locales","title":"6.2.3 Variables locales","text":"<p>Les variables locales sont des variables d\u00e9finies dans un constructeur, une m\u00e9thode ou un bloc d\u2019initialisation ;</p> <p>Les variables locales n\u2019ont pas de valeurs par d\u00e9faut et doivent \u00eatre initialis\u00e9es avant d\u2019\u00eatre utilis\u00e9es. Si tu essaies d\u2019utiliser une variable locale non initialis\u00e9e, le compilateur signalera une ERREUR.</p> <ul> <li>Exemple </li> </ul> <pre><code>public int localMethod {\n\n    int firstVar = 25;\n    int secondVar;\n    secondVar = 35;\n    int firstSum = firstVar + secondVar;    // OK variables are both initialized before use\n\n    int thirdVar;\n    int secondSum = firstSum + thirdVar;    // ERROR: variable thirdVar has not been initialized before use; if you do not try to use thirdVar the compiler will not complain\n}\n</code></pre> <p></p>"},{"location":"fr/module-01/instantiating-types/#6231-inferer-les-types-avec-var","title":"6.2.3.1 Inf\u00e9rer les types avec var","text":"<p>Dans certaines conditions, tu peux utiliser le mot-cl\u00e9 var \u00e0 la place du type appropri\u00e9 lors de la d\u00e9claration de variables locales ;</p> <p>Warning</p> <ul> <li>var N\u2019EST PAS un mot r\u00e9serv\u00e9 en Java ;</li> <li>var ne peut \u00eatre utilis\u00e9 que pour les variables locales : il NE PEUT PAS \u00eatre utilis\u00e9 pour les param\u00e8tres de constructeur, les variables d\u2019instance ou les param\u00e8tres de m\u00e9thode ;</li> <li>Le compilateur inf\u00e8re le type en regardant UNIQUEMENT le code sur la ligne de d\u00e9claration ; une fois le bon type inf\u00e9r\u00e9, tu ne peux pas r\u00e9affecter avec un autre type.</li> </ul> <ul> <li>Exemple</li> </ul> <pre><code>public int localMethod {\n\n    var inferredInt = 10;   // The compiler infer int by the context;\n    inferredInt = 25;       // OK\n\n    inferredInt = \"abcd\";   // ERROR: the compiler has already inferred the type of the variable as int\n\n    var notInferred;\n    notInferred = 30;       // ERROR: in order to infer the type, the compiler looks ONLY at the line with declaration\n\n    var first, second = 15; // ERROR: var cannot be used to define two variables on the same statement;\n\n    var x = null;           // ERROR: var cannot be initialized with null but it can be reassigned to null provided that the underlying type is a reference type.\n}\n</code></pre> <p>Warning</p> <p>Les variables locales n\u2019obtiennent jamais de valeurs par d\u00e9faut. Les champs d\u2019instance et statiques en obtiennent toujours.</p> <p></p>"},{"location":"fr/module-01/instantiating-types/#63-types-wrapper","title":"6.3 Types wrapper","text":"<p>En Java, les types wrapper sont des repr\u00e9sentations objet des huit types primitifs. Chaque primitif a une classe wrapper correspondante dans le package <code>java.lang</code> :</p> Primitive Wrapper Class <code>byte</code> <code>Byte</code> <code>short</code> <code>Short</code> <code>int</code> <code>Integer</code> <code>long</code> <code>Long</code> <code>float</code> <code>Float</code> <code>double</code> <code>Double</code> <code>char</code> <code>Character</code> <code>boolean</code> <code>Boolean</code> <p>Les objets wrapper sont immuables \u2014 une fois cr\u00e9\u00e9s, leur valeur ne peut pas changer.</p> <p></p>"},{"location":"fr/module-01/instantiating-types/#631-objectif-des-types-wrapper","title":"6.3.1 Objectif des types wrapper","text":"<ul> <li>Permettre d\u2019utiliser des primitifs dans des contextes qui exigent des objets (par ex. collections, generics).  </li> <li>Fournir des m\u00e9thodes utilitaires pour parser, convertir et manipuler des valeurs.  </li> <li>Supporter des constantes comme <code>Integer.MAX_VALUE</code> ou <code>Double.MIN_VALUE</code>.  </li> </ul>"},{"location":"fr/module-01/instantiating-types/#632-autoboxing-et-unboxing","title":"6.3.2 Autoboxing et unboxing","text":"<p>Depuis Java 5, le compilateur convertit automatiquement entre primitifs et wrappers :</p> <ul> <li>Autoboxing : primitif \u2192 wrapper  </li> <li>Unboxing : wrapper \u2192 primitif  </li> </ul> <pre><code>Integer i = 10;       // autoboxing: int \u2192 Integer\nint n = i;            // unboxing: Integer \u2192 int\n\nInteger int1 = Integer.valueOf(11);\nlong long1 = int1;  // Unboxing --&gt; implicit cast OK\n\nLong long2 = 11;   // \u274c Does not compile. \n                   // 11 is an int literal \u2192 requires autoboxing + widening \u2192 illegal\n\nCharacter char1 = null;\nchar char2 = char1;  // WARNING: NullPointerException\n\nInteger  arr1 = {11.5, 13.6}  // WARNING: Does not compile!!\nDouble[] arr2 = {11, 22};     // WARNING: Does not compile!!\n</code></pre> <p>Tip</p> <p>Java ne r\u00e9alise jamais autoboxing + widening/narrowing en une seule \u00e9tape.</p> <p>Warning</p> <ul> <li>AUTOBOXING et cast implicite ne sont pas autoris\u00e9s dans la m\u00eame instruction : tu ne peux pas faire les deux en m\u00eame temps. (voir l\u2019exemple ci-dessus)</li> <li>Cette r\u00e8gle s\u2019applique aussi aux appels de m\u00e9thode.</li> </ul> <p></p>"},{"location":"fr/module-01/instantiating-types/#633-parsing-et-conversion","title":"6.3.3 Parsing et conversion","text":"<p>Les wrappers fournissent des m\u00e9thodes statiques pour convertir des cha\u00eenes ou d\u2019autres types en primitifs :</p> <pre><code>int x = Integer.parseInt(\"123\");    // returns primitive int\nInteger y = Integer.valueOf(\"456\"); // returns Integer object\ndouble d = Double.parseDouble(\"3.14\");\n\n// On the numeric wrapper class valueOf() throws a NumberFormatException on invalid input.\n// Example:\n\nInteger w = Integer.valueOf(\"two\"); // NumberFormatException\n\n// On Boolean, the method returns Boolean.TRUE for any value that matches \"true\" ignoring case, otherwise Boolean.false\n// Example:\n\nBoolean.valueOf(\"true\");    // true\nBoolean.valueOf(\"TrUe\");    // true\nBoolean.valueOf(\"TRUE\");    // true\nBoolean.valueOf(\"false\");   // false\nBoolean.valueOf(\"FALSE\");   // false\nBoolean.valueOf(\"xyz\");     // false\nBoolean.valueOf(null);      // false\n\n// The numeric integral classes Byte, Short, Integer and Long include an overloaded **valueOf(String str, int base)** method which takes a base value\n// Example with base 16 (hexadecimal) which includes character 0 -&gt; 9 and A -&gt; F (ignore case)\n\nInteger.valueOf(\"6\", 16);   // 6\nInteger.valueOf(\"a\", 16);   // 10\nInteger.valueOf(\"A\", 16);   // 10\nInteger.valueOf(\"F\", 16);   // 15\nInteger.valueOf(\"G\", 16);   // NumberFormatException\n</code></pre> <p>Note</p> <p>Les m\u00e9thodes parseXxx() renvoient un primitif tandis que valueOf() renvoie un objet wrapper.</p> <p></p>"},{"location":"fr/module-01/instantiating-types/#634-methodes-utilitaires","title":"6.3.4 M\u00e9thodes utilitaires","text":"<p>Toutes les classes wrapper num\u00e9riques \u00e9tendent la classe <code>Number</code> et h\u00e9ritent donc de m\u00e9thodes utilitaires telles que : <code>byteValue()</code>, <code>shortValue()</code>, <code>intValue()</code>, <code>longValue()</code>, <code>floatValue()</code>, <code>doubleValue()</code>.</p> <p>Les classes wrapper <code>Boolean</code> et <code>Character</code> incluent : <code>booleanValue()</code> et <code>charValue()</code>.</p> <ul> <li>Exemple :</li> </ul> <pre><code>// In trying to convert those helper methods can result in a loss of precision.\n\nDouble baseDouble = Double.valueOf(\"300.56\");\n\ndouble wrapDouble = baseDouble.doubleValue();\nSystem.out.println(\"baseDouble.doubleValue(): \" + wrapDouble);  // 300.56\n\nbyte wrapByte = baseDouble.byteValue();\nSystem.out.println(\"baseDouble.byteValue(): \" + wrapByte);      // 44  -&gt; There is no 300 in byte\n\nint wrapInt = baseDouble.intValue();\nSystem.out.println(\"baseDouble.intValue(): \" + wrapInt);        // 300 -&gt; The value is truncated\n</code></pre> <p></p>"},{"location":"fr/module-01/instantiating-types/#635-valeurs-null","title":"6.3.5 Valeurs null","text":"<p>Contrairement aux primitifs, les wrappers peuvent contenir null. Tenter d\u2019unboxer <code>null</code> provoque une NullPointerException :</p> <pre><code>Integer val = null;\nint z = val; // \u274c NullPointerException at runtime\n</code></pre> <p></p>"},{"location":"fr/module-01/instantiating-types/#64-egalite-en-java","title":"6.4 \u00c9galit\u00e9 en Java","text":"<p>Java fournit deux m\u00e9canismes diff\u00e9rents pour v\u00e9rifier l\u2019\u00e9galit\u00e9 :</p> <ul> <li><code>==</code> (op\u00e9rateur d\u2019\u00e9galit\u00e9)</li> <li><code>.equals()</code> (m\u00e9thode d\u00e9finie dans <code>Object</code> et red\u00e9finie dans de nombreuses classes)</li> </ul> <p>Comprendre la diff\u00e9rence est essentiel.</p> <p></p>"},{"location":"fr/module-01/instantiating-types/#641-egalite-avec-les-types-primitifs","title":"6.4.1 \u00c9galit\u00e9 avec les types primitifs","text":"<p>Pour les valeurs primitives (<code>int</code>, <code>double</code>, <code>char</code>, <code>boolean</code>, etc.), l\u2019op\u00e9rateur <code>==</code> compare leur valeur num\u00e9rique ou bool\u00e9enne r\u00e9elle.</p> <p>Exemple : <pre><code>int a = 5;\nint b = 5;\nSystem.out.println(a == b);     // true\n\nchar c1 = 'A';\nchar c2 = 65;                   // same Unicode code point\nSystem.out.println(c1 == c2);   // true\n</code></pre></p> <p></p>"},{"location":"fr/module-01/instantiating-types/#6411-points-cles","title":"6.4.1.1 Points cl\u00e9s","text":"<ul> <li><code>==</code> effectue une comparaison de valeur pour les primitifs.</li> <li>Les types primitifs n\u2019ont pas de m\u00e9thode <code>.equals()</code>.</li> <li>Les types primitifs mixtes suivent les r\u00e8gles de promotion num\u00e9rique   (par ex. <code>int == long</code> \u2192 <code>int</code> promu en <code>long</code>).</li> </ul>"},{"location":"fr/module-01/instantiating-types/#642-egalite-avec-les-types-reference","title":"6.4.2 \u00c9galit\u00e9 avec les types r\u00e9f\u00e9rence","text":"<p>Avec les objets (types r\u00e9f\u00e9rence), la signification de <code>==</code> change.</p> <p></p>"},{"location":"fr/module-01/instantiating-types/#6421-comparaison-didentite","title":"6.4.2.1 <code>==</code> (Comparaison d\u2019identit\u00e9)","text":"<p><code>==</code> v\u00e9rifie si deux r\u00e9f\u00e9rences pointent vers le m\u00eame objet en m\u00e9moire.</p> <pre><code>String s1 = new String(\"Hi\");\nString s2 = new String(\"Hi\");\n\nSystem.out.println(s1 == s2);      // false \u2192 objets diff\u00e9rents\n</code></pre> <p>M\u00eame si les contenus sont identiques, <code>==</code> est false sauf si les deux variables r\u00e9f\u00e9rencent le m\u00eame objet exact.</p> <p></p>"},{"location":"fr/module-01/instantiating-types/#6422-equals-comparaison-logique","title":"6.4.2.2 <code>.equals()</code> (Comparaison logique)","text":"<p>De nombreuses classes red\u00e9finissent <code>.equals()</code> pour comparer les valeurs, pas les adresses m\u00e9moire.</p> <pre><code>System.out.println(s1.equals(s2)); // true \u2192 m\u00eame contenu\n</code></pre> <p></p>"},{"location":"fr/module-01/instantiating-types/#6423-points-cles","title":"6.4.2.3 Points cl\u00e9s","text":"<ul> <li><code>.equals()</code> est d\u00e9finie dans <code>Object</code>.</li> <li>Si une classe ne red\u00e9finit pas <code>.equals()</code>, elle se comporte comme <code>==</code>.</li> <li>Des classes comme <code>String</code>, <code>Integer</code>, <code>List</code>, etc. red\u00e9finissent <code>.equals()</code>   pour fournir une comparaison de valeur pertinente.</li> </ul>"},{"location":"fr/module-01/instantiating-types/#643-string-pool-et-egalite","title":"6.4.3 String Pool et \u00e9galit\u00e9","text":"<p>Les litt\u00e9raux String sont stock\u00e9s dans le String pool, donc des litt\u00e9raux identiques r\u00e9f\u00e9rencent le m\u00eame objet.</p> <pre><code>String a = \"Java\";\nString b = \"Java\";\nSystem.out.println(a == b);       // true \u2192 m\u00eame litt\u00e9ral dans le pool\n</code></pre> <p>Mais l\u2019utilisation de <code>new</code> cr\u00e9e un objet diff\u00e9rent :</p> <pre><code>String x = new String(\"Java\");\nString y = \"Java\";\n\nSystem.out.println(x == y);       // false \u2192 x n\u2019est pas dans le pool\nSystem.out.println(x.equals(y));  // true\n</code></pre> <p>Pi\u00e8ges courants</p> <pre><code>String x = \"Java string literal\";\nString y = \" Java string literal\".trim();\n\nSystem.out.println(x == y);       // false \u2192 x et y ne sont pas identiques \u00e0 la compilation\n\nString a = \"Java string literal\";\nString b = \"Java \";\nb += \"string literal\";\n\nSystem.out.println(a == b);  // false\n</code></pre> <p>Warning</p> <p>Toute String cr\u00e9\u00e9e \u00e0 l\u2019ex\u00e9cution n\u2019entre pas automatiquement dans le pool. Utilise <code>intern()</code> si tu veux le pooling.</p> <p>Tip</p> <p><code>\"Hello\" == \"Hel\" + \"lo\"</code> \u2192 true (constante \u00e0 la compilation)</p> <p><code>\"Hello\" == getHello()</code> \u2192 false (concat\u00e9nation \u00e0 l\u2019ex\u00e9cution)</p> <pre><code>String x = \"Hello\";\nString y = \"Hel\" + \"lo\";   // compile-time \u2192 m\u00eame litt\u00e9ral\nString z = \"Hel\";\nz += \"lo\";                 // runtime \u2192 nouvelle String\n\nSystem.out.println(x == y); // true\nSystem.out.println(x == z); // false\n</code></pre> <p></p>"},{"location":"fr/module-01/instantiating-types/#6431-la-methode-intern","title":"6.4.3.1 La m\u00e9thode intern","text":"<p>Tu peux aussi demander \u00e0 Java d\u2019utiliser une String du String Pool (si elle existe d\u00e9j\u00e0) via la m\u00e9thode <code>intern()</code> :</p> <pre><code>String x = \"Java\";\nString y = new String(\"Java\").intern();\n\nSystem.out.println(x == y);       // true\n</code></pre> <p></p>"},{"location":"fr/module-01/instantiating-types/#644-egalite-avec-les-types-wrapper","title":"6.4.4 \u00c9galit\u00e9 avec les types wrapper","text":"<p>Les classes wrapper (<code>Integer</code>, <code>Double</code>, etc.) se comportent comme des objets :</p> <ul> <li><code>==</code> \u2192 compare les r\u00e9f\u00e9rences  </li> <li><code>.equals()</code> \u2192 compare les valeurs  </li> </ul> <p>Cependant, certains wrappers sont mis en cache (Integer de \u2212128 \u00e0 127) :</p> <pre><code>Integer a = 100;\nInteger b = 100;\nSystem.out.println(a == b);        // true \u2192 cached\n\nInteger c = 1000;\nInteger d = 1000;\nSystem.out.println(c == d);        // false \u2192 not cached\n\nSystem.out.println(c.equals(d));   // true \u2192 m\u00eame valeur num\u00e9rique\n</code></pre> <p>Warning</p> <p>Fais tr\u00e8s attention au caching des wrappers.</p> <p></p>"},{"location":"fr/module-01/instantiating-types/#645-egalite-et-null","title":"6.4.5 \u00c9galit\u00e9 et <code>null</code>","text":"<ul> <li><code>== null</code> est toujours s\u00fbr.</li> <li>Appeler <code>.equals()</code> sur une r\u00e9f\u00e9rence <code>null</code> d\u00e9clenche une <code>NullPointerException</code>.</li> </ul> <pre><code>String s = null;\nSystem.out.println(s == null);   // true\n// s.equals(\"Hi\");               // \u274c NullPointerException\n</code></pre>"},{"location":"fr/module-01/instantiating-types/#646-tableau-recapitulatif","title":"6.4.6 Tableau r\u00e9capitulatif","text":"Comparison Primitives Objects / Wrappers Strings <code>==</code> compares value compares reference identity (affected by String pool) <code>.equals()</code> N/A compares content if overridden content comparison"},{"location":"fr/module-01/java-operators/","title":"5. Op\u00e9rateurs Java","text":""},{"location":"fr/module-01/java-operators/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>5.1 D\u00e9finition</li> <li>5.2 Types d\u2019op\u00e9rateurs</li> <li>5.3 Cat\u00e9gories d\u2019op\u00e9rateurs</li> <li>5.4 Priorit\u00e9 des op\u00e9rateurs et ordre d\u2019\u00e9valuation</li> <li>5.5 Tableau r\u00e9capitulatif des op\u00e9rateurs Java<ul> <li>5.5.1 Notes compl\u00e9mentaires</li> </ul> </li> <li>5.6 Op\u00e9rateurs unaires<ul> <li>5.6.1 Cat\u00e9gories d\u2019op\u00e9rateurs unaires</li> <li>5.6.2 Exemples</li> </ul> </li> <li>5.7 Op\u00e9rateurs binaires<ul> <li>5.7.1 Cat\u00e9gories d\u2019op\u00e9rateurs binaires</li> <li>5.7.2 Op\u00e9rateurs de division et de modulo (reste)<ul> <li>5.7.2.1 Op\u00e9rateur de division</li> <li>5.7.2.2 Op\u00e9rateur Modulo</li> </ul> </li> <li>5.7.3 La valeur de retour de l\u2019op\u00e9rateur d\u2019affectation</li> <li>5.7.4 Op\u00e9rateurs d\u2019affectation compos\u00e9e</li> <li>5.7.5 Op\u00e9rateurs d\u2019\u00e9galit\u00e9 == et !=<ul> <li>5.7.5.1 \u00c9galit\u00e9 avec les types primitifs</li> <li>5.7.5.2 \u00c9galit\u00e9 avec les types r\u00e9f\u00e9rence (objets)</li> </ul> </li> <li>5.7.6 L\u2019op\u00e9rateur instanceof<ul> <li>5.7.6.1 V\u00e9rification \u00e0 la compilation vs \u00e0 l\u2019ex\u00e9cution</li> <li>5.7.6.2 Pattern matching pour instanceof</li> <li>5.7.6.3 Flow scoping &amp; logique short-circuit</li> <li>5.7.6.4 Tableaux et types r\u00e9ifiables</li> </ul> </li> </ul> </li> <li>5.8 Op\u00e9rateur Ternaire<ul> <li>5.8.1 R\u00e8gles de Typage de l\u2019Op\u00e9rateur Ternaire<ul> <li>5.8.1.1 Op\u00e9randes Num\u00e9riques</li> <li>5.8.1.2 Types de R\u00e9f\u00e9rence</li> </ul> </li> <li>5.8.2 Syntaxe</li> <li>5.8.3 Exemple</li> <li>5.8.4 Exemple de Ternaire Imbriqu\u00e9</li> <li>5.8.5 Remarques</li> </ul> </li> </ul>"},{"location":"fr/module-01/java-operators/#51-definition","title":"5.1 D\u00e9finition","text":"<p>En Java, les op\u00e9rateurs sont des symboles sp\u00e9ciaux qui effectuent des op\u00e9rations sur des variables et des valeurs. Ce sont les briques de base des expressions et ils permettent aux d\u00e9veloppeurs de manipuler des donn\u00e9es, de comparer des valeurs, d\u2019effectuer des op\u00e9rations arithm\u00e9tiques et de contr\u00f4ler le flux logique.</p> <p>Une expression est une combinaison d\u2019op\u00e9rateurs et d\u2019op\u00e9randes qui produit un r\u00e9sultat.</p> <p>Par exemple : <pre><code>int result = (a + b) * c;\n</code></pre></p> <p>Ici, <code>+</code> et <code>*</code> sont des op\u00e9rateurs, et <code>a</code>, <code>b</code> et <code>c</code> sont des op\u00e9randes.</p> <p></p>"},{"location":"fr/module-01/java-operators/#52-types-doperateurs","title":"5.2 Types d\u2019op\u00e9rateurs","text":"<p>Java d\u00e9finit trois types d\u2019op\u00e9rateurs, regroup\u00e9s selon le nombre d\u2019op\u00e9randes qu\u2019ils utilisent :</p> Type Description Exemples Unary Op\u00e8re sur un seul op\u00e9rande <code>+x</code>, <code>-x</code>, <code>++x</code>, <code>--x</code>, <code>!flag</code>, <code>~num</code> Binary Op\u00e8re sur deux op\u00e9randes <code>a + b</code>, <code>a - b</code>, <code>x * y</code>, <code>x / y</code>, <code>x % y</code> Ternary Op\u00e8re sur trois op\u00e9randes (un seul en Java) <code>condition ? valueIfTrue : valueIfFalse</code> <p></p>"},{"location":"fr/module-01/java-operators/#53-categories-doperateurs","title":"5.3 Cat\u00e9gories d\u2019op\u00e9rateurs","text":"<p>Les op\u00e9rateurs peuvent \u00e9galement \u00eatre regroup\u00e9s, selon leur objectif, en cat\u00e9gories :</p> Cat\u00e9gorie Description Exemples Assignment Assigne des valeurs aux variables <code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code> Relational Compare des valeurs <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> Logical Combine ou inverse des expressions bool\u00e9ennes <code>|</code>, <code>&amp;</code>, <code>^</code> Conditional Combine ou inverse des expressions bool\u00e9ennes <code>||</code>, <code>&amp;&amp;</code> Bitwise Manipule des bits <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>~</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code> Instanceof Teste le type d\u2019un objet <code>obj instanceof ClassName</code> Lambda Utilis\u00e9 dans les expressions lambda <code>(x, y) -&gt; x + y</code> <p></p>"},{"location":"fr/module-01/java-operators/#54-priorite-des-operateurs-et-ordre-devaluation","title":"5.4 Priorit\u00e9 des op\u00e9rateurs et ordre d\u2019\u00e9valuation","text":"<p>La priorit\u00e9 des op\u00e9rateurs d\u00e9termine comment les op\u00e9rateurs sont regroup\u00e9s dans une expression \u2014 c\u2019est-\u00e0-dire quelles op\u00e9rations sont effectu\u00e9es en premier. L\u2019associativit\u00e9 (ou ordre d\u2019\u00e9valuation) d\u00e9termine si l\u2019expression est \u00e9valu\u00e9e de gauche \u00e0 droite ou de droite \u00e0 gauche lorsque des op\u00e9rateurs ont la m\u00eame priorit\u00e9.</p> <p>Exemple :</p> <pre><code>int result = 10 + 5 * 2;  // La multiplication est effectu\u00e9e avant l\u2019addition \u2192 result = 20\n</code></pre> <p>Les parenth\u00e8ses <code>()</code> peuvent \u00eatre utilis\u00e9es pour surclasser la priorit\u00e9 :</p> <pre><code>int result = (10 + 5) * 2;  // Les parenth\u00e8ses sont \u00e9valu\u00e9es en premier \u2192 result = 30\n</code></pre> <p>Note</p> <ul> <li>La priorit\u00e9 des op\u00e9rateurs concerne le regroupement, pas l\u2019ordre concret d\u2019\u00e9valuation.</li> <li>Utilise les parenth\u00e8ses pour la priorit\u00e9 et la clart\u00e9 dans les expressions complexes.</li> </ul> <p></p>"},{"location":"fr/module-01/java-operators/#55-tableau-recapitulatif-des-operateurs-java","title":"5.5 Tableau r\u00e9capitulatif des op\u00e9rateurs Java","text":"Priorit\u00e9 (Haute \u2192 Basse) Type Op\u00e9rateurs Exemple Ordre d\u2019\u00e9valuation Applicable \u00e0 1 Postfix Unary <code>expr++</code>, <code>expr--</code> <code>x++</code> Gauche \u2192 Droite Types num\u00e9riques 2 Prefix Unary <code>++expr</code>, <code>--expr</code> <code>--x</code> Gauche \u2192 Droite Num\u00e9riques 3 Other Unary <code>(type)</code>, <code>+</code>, <code>-</code>, <code>~</code>, <code>!</code> <code>-x</code>, <code>!flag</code> Droite \u2192 Gauche Num\u00e9riques, boolean 4 Cast Unary <code>(Type) reference</code> <code>(short) 22</code> Droite \u2192 Gauche reference, primitifs 5 Multiplication/division/modulus <code>*</code>, <code>/</code>, <code>%</code> <code>a * b</code> Gauche \u2192 Droite Types num\u00e9riques 6 Additive <code>+</code>, <code>-</code> <code>a + b</code> Gauche \u2192 Droite Num\u00e9riques, String (concat\u00e9nation) 7 Shift <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code> <code>a &lt;&lt; 2</code> Gauche \u2192 Droite Types int\u00e9graux 8 Relational <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>instanceof</code> <code>a &lt; b</code>, <code>obj instanceof Person</code> Gauche \u2192 Droite Num\u00e9riques, reference 9 Equality <code>==</code>, <code>!=</code> <code>a == b</code> Gauche \u2192 Droite Tous les types (sauf boolean pour <code>&lt;</code>, <code>&gt;</code>) 10 Logical AND <code>&amp;</code> <code>a &amp; b</code> Gauche \u2192 Droite boolean 11 Logical exclusive OR <code>^</code> <code>a ^ b</code> Gauche \u2192 Droite boolean 12 Logical inclusive OR <code>|</code> <code>a</code><code>|</code><code>b</code> Gauche \u2192 Droite boolean 13 Conditional AND <code>&amp;&amp;</code> <code>a</code><code>&amp;&amp;</code><code>b</code> Gauche \u2192 Droite boolean 14 Conditional OR <code>||</code> <code>a</code><code>||</code><code>b</code> Gauche \u2192 Droite boolean 15 Ternary (Conditional) <code>? :</code> <code>a &gt; b ? x : y</code> Droite \u2192 Gauche Tous les types 16 Assignment <code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code> <code>x += 5</code> Droite \u2192 Gauche Tous les types assignables 17 Arrow operator <code>-&gt;</code> <code>(x, y) -&gt; x + y</code> Droite \u2192 Gauche Expressions lambda, switch rules"},{"location":"fr/module-01/java-operators/#551-notes-complementaires","title":"5.5.1 Notes compl\u00e9mentaires","text":"<ul> <li>La concat\u00e9nation de cha\u00eenes (<code>+</code>) a une priorit\u00e9 plus faible que le <code>+</code> arithm\u00e9tique sur les nombres.</li> <li>Utilise les parenth\u00e8ses <code>()</code> pour la priorit\u00e9 et la lisibilit\u00e9 \u2014 elles ne changent pas la s\u00e9mantique mais rendent l\u2019intention explicite.</li> </ul>"},{"location":"fr/module-01/java-operators/#56-operateurs-unaires","title":"5.6 Op\u00e9rateurs unaires","text":"<p>Les op\u00e9rateurs unaires op\u00e8rent sur un seul op\u00e9rande pour produire une nouvelle valeur. Ils sont utilis\u00e9s pour des op\u00e9rations comme l\u2019incr\u00e9mentation/d\u00e9cr\u00e9mentation, la n\u00e9gation d\u2019une valeur, l\u2019inversion d\u2019un bool\u00e9en ou le compl\u00e9ment bit \u00e0 bit.</p> <p></p>"},{"location":"fr/module-01/java-operators/#561-categories-doperateurs-unaires","title":"5.6.1 Cat\u00e9gories d\u2019op\u00e9rateurs unaires","text":"Op\u00e9rateur Nom Description Exemple R\u00e9sultat <code>+</code> Unary plus Indique une valeur positive (souvent redondant). <code>+x</code> Identique \u00e0 <code>x</code> <code>-</code> Unary minus Indique qu\u2019un nombre litt\u00e9ral est n\u00e9gatif ou nie une expression. <code>-5</code> <code>-5</code> <code>++</code> Increment Augmente une variable de 1. Peut \u00eatre pr\u00e9fixe ou postfixe. <code>++x</code>, <code>x++</code> <code>x+1</code> <code>--</code> Decrement Diminue une variable de 1. Peut \u00eatre pr\u00e9fixe ou postfixe. <code>--x</code>, <code>x--</code> <code>x-1</code> <code>!</code> Logical complement Inverse une valeur bool\u00e9enne. <code>!true</code> <code>false</code> <code>~</code> Bitwise complement Inverse chaque bit d\u2019un entier. <code>~5</code> <code>-6</code> <code>(type)</code> Cast Convertit la valeur vers un autre type. <code>(int) 3.9</code> <code>3</code>"},{"location":"fr/module-01/java-operators/#562-exemples","title":"5.6.2 Exemples","text":"<pre><code>int x = 5;\nSystem.out.println(++x);  // 6  (pr\u00e9fixe : incr\u00e9mente x \u00e0 6, puis renvoie 6)\nSystem.out.println(x++);  // 6  (postfixe : renvoie 6, puis incr\u00e9mente x \u00e0 7)\nSystem.out.println(x);    // 7\n\nboolean flag = false;\nSystem.out.println(!flag);  // true\n\nint a = 5;                  // binaire : 0000 0101\nSystem.out.println(~a);     // -6 \u2192 binaire : 1111 1010 (compl\u00e9ment \u00e0 deux)\n</code></pre> <p>Note</p> <ul> <li>Pr\u00e9fixe (<code>++x</code> / <code>--x</code>) : met \u00e0 jour la valeur d\u2019abord, puis renvoie la nouvelle valeur.</li> <li>Postfixe (<code>x++</code> / <code>x--</code>) : renvoie d\u2019abord la valeur courante, puis la met \u00e0 jour.</li> <li>L\u2019op\u00e9rateur <code>!</code> s\u2019applique aux valeurs boolean ; <code>~</code> s\u2019applique aux types num\u00e9riques int\u00e9graux.</li> </ul> <p></p>"},{"location":"fr/module-01/java-operators/#57-operateurs-binaires","title":"5.7 Op\u00e9rateurs binaires","text":"<p>Les op\u00e9rateurs binaires n\u00e9cessitent deux op\u00e9randes. Ils effectuent des op\u00e9rations arithm\u00e9tiques, relationnelles, logiques, bit \u00e0 bit et d\u2019affectation.</p> <p></p>"},{"location":"fr/module-01/java-operators/#571-categories-doperateurs-binaires","title":"5.7.1 Cat\u00e9gories d\u2019op\u00e9rateurs binaires","text":"Cat\u00e9gorie Op\u00e9rateurs Exemple Description Arithmetic <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code> <code>a + b</code> Op\u00e9rations math\u00e9matiques de base. Relational <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code>, <code>!=</code> <code>a &lt; b</code> Compare des valeurs. Logical (boolean) <code>&amp;</code>, <code>|</code>, <code>^</code> <code>a</code><code>&amp;</code><code>b</code> Voir note ci-dessous. Conditional <code>&amp;&amp;</code>, <code>||</code> <code>a</code><code>&amp;&amp;</code><code>b</code> Voir note ci-dessous. Bitwise (integral) <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code> <code>a &lt;&lt; 2</code> Op\u00e8re sur les bits. Assignment <code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code> <code>x += 3</code> Modifie puis affecte. String Concatenation <code>+</code> <code>\"Hello \" + name</code> Concat\u00e8ne des cha\u00eenes. <p>Important</p> <ul> <li>Les op\u00e9rateurs logiques (<code>&amp;</code>, <code>|</code>, <code>^</code>) \u00e9valuent toujours les deux c\u00f4t\u00e9s.</li> <li>Les op\u00e9rateurs conditionnels (<code>&amp;&amp;</code>, <code>||</code>) sont short-circuit :</li> <li><code>a &amp;&amp; b</code> \u2192 <code>b</code> est \u00e9valu\u00e9 uniquement si <code>a</code> est true</li> <li><code>a || b</code> \u2192 <code>b</code> est \u00e9valu\u00e9 uniquement si <code>a</code> est false</li> </ul> <p>Exemples :</p> <p>Exemple arithm\u00e9tique : <pre><code>int a = 10, b = 4;\nSystem.out.println(a + b);  // 14\nSystem.out.println(a - b);  // 6\nSystem.out.println(a * b);  // 40\nSystem.out.println(a / b);  // 2\nSystem.out.println(a % b);  // 2\n</code></pre></p> <p>Exemple relationnel : <pre><code>int a = 5, b = 8;\nSystem.out.println(a &lt; b);   // true\nSystem.out.println(a &gt;= b);  // false\nSystem.out.println(a == b);  // false\nSystem.out.println(a != b);  // true\n</code></pre></p> <p>Exemple logique : <pre><code>boolean x = true, y = false;\nSystem.out.println(x &amp;&amp; y);  // false\nSystem.out.println(x || y);  // true\nSystem.out.println(!x);      // false\n</code></pre></p> <p>Exemple bit \u00e0 bit : <pre><code>int a = 5;   // 0101\nint b = 3;   // 0011\nSystem.out.println(a &amp; b);  // 1  (0001)\nSystem.out.println(a | b);  // 7  (0111)\nSystem.out.println(a ^ b);  // 6  (0110)\nSystem.out.println(a &lt;&lt; 1); // 10 (1010)\nSystem.out.println(a &gt;&gt; 1); // 2  (0010)\n</code></pre></p> <p></p>"},{"location":"fr/module-01/java-operators/#572-operateurs-de-division-et-de-modulo-reste","title":"5.7.2 Op\u00e9rateurs de division et de modulo (reste)","text":""},{"location":"fr/module-01/java-operators/#5721-operateur-de-division","title":"5.7.2.1 Op\u00e9rateur de Division","text":"<p>Diviser un <code>entier</code> par z\u00e9ro (par exemple, 10 / 0) provoque le lancement par la JVM d\u2019une <code>java.lang.ArithmeticException: / by zero</code>.</p> <p>Cependant, la division en virgule flottante se comporte diff\u00e9remment.</p> <p>Lorsqu\u2019une valeur <code>float</code> ou <code>double</code> est divis\u00e9e par 0 ou 0.0, aucune exception n\u2019est lev\u00e9e. \u00c0 la place, le r\u00e9sultat est :</p> <ul> <li>Float.POSITIVE_INFINITY ou Float.NEGATIVE_INFINITY</li> <li>Double.POSITIVE_INFINITY ou Double.NEGATIVE_INFINITY</li> </ul> <p>Le signe d\u00e9pend des op\u00e9randes impliqu\u00e9s dans l\u2019op\u00e9ration.</p> <p>Pour d\u00e9terminer si une valeur en virgule flottante repr\u00e9sente l\u2019infini, les classes <code>Float</code> et <code>Double</code> fournissent des m\u00e9thodes utilitaires :</p> <p>M\u00e9thodes statiques :</p> <ul> <li>Float.isInfinite(float value)</li> <li>Double.isInfinite(double value)</li> </ul> <p>M\u00e9thodes d\u2019instance :</p> <ul> <li>Float.isInfinite()</li> <li>Double.isInfinite()</li> </ul> <p>Ces m\u00e9thodes retournent <code>true</code> si la valeur correspond \u00e0 l\u2019infini positif ou \u00e0 l\u2019infini n\u00e9gatif.</p> <p></p>"},{"location":"fr/module-01/java-operators/#5722-operateur-modulo","title":"5.7.2.2 Op\u00e9rateur Modulo","text":"<p>L\u2019op\u00e9rateur modulo donne le reste lorsque deux nombres sont divis\u00e9s. Si deux nombres se divisent exactement, le reste est 0 : par exemple 10 % 5 vaut 0. En revanche, 13 % 4 donne un reste de 1.</p> <p>On peut utiliser le modulo avec des nombres n\u00e9gatifs selon les r\u00e8gles suivantes :</p> <ul> <li>si le diviseur est n\u00e9gatif (ex. : 7 % -5), le signe est ignor\u00e9 et le r\u00e9sultat est 2 ;</li> <li>si le dividende est n\u00e9gatif (ex. : -7 % 5), le signe est conserv\u00e9 et le r\u00e9sultat est -2 ;</li> </ul> <pre><code>System.out.println(8 % 5);      // GIVES 3\nSystem.out.println(10 % 5);     // GIVES 0\nSystem.out.println(10 % 3);     // GIVES 1    \nSystem.out.println(-10 % 3);    // GIVES -1    \nSystem.out.println(10 % -3);    // GIVES 1   \nSystem.out.println(-10 % -3);   // GIVES -1 \n\nSystem.out.println(8 % 9);      // GIVES 8\nSystem.out.println(3 % 4);      // GIVES 3    \nSystem.out.println(2 % 4);      // GIVES 2\nSystem.out.println(-8 % 9);     // GIVES -8\n</code></pre> <p></p>"},{"location":"fr/module-01/java-operators/#573-la-valeur-de-retour-de-loperateur-daffectation","title":"5.7.3 La valeur de retour de l\u2019op\u00e9rateur d\u2019affectation","text":"<p>En Java, l\u2019op\u00e9rateur d\u2019affectation (<code>=</code>) ne fait pas que stocker une valeur dans une variable \u2014 il renvoie aussi la valeur affect\u00e9e comme r\u00e9sultat de l\u2019expression enti\u00e8re.</p> <p>Cela signifie que l\u2019affectation peut \u00eatre utilis\u00e9e comme partie d\u2019une autre expression, par exemple dans une condition <code>if</code>, dans la condition d\u2019une boucle, ou m\u00eame dans une autre affectation.</p> <pre><code>int x;\nint y = (x = 10);   // l\u2019affectation (x = 10) renvoie 10\nSystem.out.println(y);  // 10\n\n// x = 10 affecte 10 \u00e0 x.\n// L\u2019expression (x = 10) s\u2019\u00e9value \u00e0 10.\n// Cette valeur est ensuite affect\u00e9e \u00e0 y.\n// Donc x et y finissent avec la m\u00eame valeur (10).\n</code></pre> <p>Comme l\u2019affectation renvoie une valeur, elle peut aussi appara\u00eetre dans un if. Cependant, cela conduit souvent \u00e0 des erreurs logiques si c\u2019est fait involontairement.</p> <pre><code>boolean flag = false;\n\nif (flag = true) {\n    System.out.println(\"This will always execute!\");\n}\n\n// Ici la condition (flag = true) affecte true \u00e0 flag, puis s\u2019\u00e9value \u00e0 true,\n// donc le bloc if s\u2019ex\u00e9cute toujours.\n\n// Usage correct (comparaison au lieu d\u2019affectation) :\n\nif (flag == true) {\n    System.out.println(\"Condition checked, not assigned\");\n}\n</code></pre> <p>Warning</p> <p>Si tu vois <code>if (x = quelque chose)</code>, stop : c\u2019est une affectation, pas une comparaison.</p> <p></p>"},{"location":"fr/module-01/java-operators/#574-operateurs-daffectation-composee","title":"5.7.4 Op\u00e9rateurs d\u2019affectation compos\u00e9e","text":"<p>Les op\u00e9rateurs d\u2019affectation compos\u00e9e en Java combinent une op\u00e9ration arithm\u00e9tique ou bit \u00e0 bit avec une affectation en une seule \u00e9tape. Au lieu d\u2019\u00e9crire <code>x = x + 5</code>, tu peux utiliser la forme abr\u00e9g\u00e9e <code>x += 5</code>. Ils effectuent automatiquement un cast implicite vers le type de la variable \u00e0 gauche lorsque c\u2019est n\u00e9cessaire.</p> <p>Les op\u00e9rateurs compos\u00e9s courants incluent : <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&amp;=</code>, <code>|=</code>, <code>^=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, et <code>&gt;&gt;&gt;=</code>.</p> <pre><code>int x = 10;\n\n// Affectations compos\u00e9es arithm\u00e9tiques\nx += 5;   // \u00e9quivalent \u00e0 x = x + 5 \u2192 x = 15\nx -= 3;   // \u00e9quivalent \u00e0 x = x - 3 \u2192 x = 12\nx *= 2;   // \u00e9quivalent \u00e0 x = x * 2 \u2192 x = 24\nx /= 4;   // \u00e9quivalent \u00e0 x = x / 4 \u2192 x = 6\nx %= 5;   // \u00e9quivalent \u00e0 x = x % 5 \u2192 x = 1\n\n// Affectations compos\u00e9es bit \u00e0 bit\nint y = 6;   // 0110 (binaire)\ny &amp;= 3;      // y = y &amp; 3 \u2192 0110 &amp; 0011 = 0010 \u2192 y = 2\ny |= 4;      // y = y | 4 \u2192 0010 | 0100 = 0110 \u2192 y = 6\ny ^= 5;      // y = y ^ 5 \u2192 0110 ^ 0101 = 0011 \u2192 y = 3\n\n// Affectations compos\u00e9es avec d\u00e9calage\nint z = 8;   // 0000 1000\nz &lt;&lt;= 2;     // z = z &lt;&lt; 2 \u2192 0010 0000 \u2192 z = 32\nz &gt;&gt;= 1;     // z = z &gt;&gt; 1 \u2192 0001 0000 \u2192 z = 16\nz &gt;&gt;&gt;= 2;    // z = z &gt;&gt;&gt; 2 \u2192 0000 0100 \u2192 z = 4\n\n// Exemple de cast de type\nbyte b = 10;\n// b = b + 1;   // \u274c erreur de compilation : le r\u00e9sultat int ne peut pas \u00eatre affect\u00e9 \u00e0 byte\nb += 1;         // \u2705 fonctionne : cast implicite vers byte\n</code></pre> <p>Note</p> <p>Les affectations compos\u00e9es effectuent un cast implicite vers le type de la variable \u00e0 gauche. C\u2019est pourquoi <code>b += 1</code> compile alors que <code>b = b + 1</code> ne compile pas.</p> <p></p>"},{"location":"fr/module-01/java-operators/#575-operateurs-degalite-et","title":"5.7.5 Op\u00e9rateurs d\u2019\u00e9galit\u00e9 (<code>==</code> et <code>!=</code>)","text":"<p>Les op\u00e9rateurs d\u2019\u00e9galit\u00e9 en Java <code>==</code> (\u00e9gal \u00e0) et <code>!=</code> (diff\u00e9rent de) servent \u00e0 comparer deux op\u00e9randes. Cependant, leur comportement diff\u00e8re selon qu\u2019ils s\u2019appliquent \u00e0 des types primitifs ou \u00e0 des types r\u00e9f\u00e9rence (objets).</p> <p>Note</p> <ul> <li><code>==</code> compare les valeurs pour les primitifs</li> <li><code>==</code> compare les r\u00e9f\u00e9rences pour les objets  </li> <li><code>.equals()</code> compare le contenu d\u2019un objet (si impl\u00e9ment\u00e9)</li> </ul> <p></p>"},{"location":"fr/module-01/java-operators/#5751-egalite-avec-les-types-primitifs","title":"5.7.5.1 \u00c9galit\u00e9 avec les types primitifs","text":"<p>Lorsqu\u2019on compare des valeurs primitives, <code>==</code> et <code>!=</code> comparent les valeurs stock\u00e9es.</p> <pre><code>int a = 5, b = 5;\nSystem.out.println(a == b);  // true  \u2192 m\u00eames valeurs\nSystem.out.println(a != b);  // false \u2192 valeurs \u00e9gales\n</code></pre> <p>Important</p> <ul> <li>Si les op\u00e9randes sont de types num\u00e9riques diff\u00e9rents, Java les promeut automatiquement vers un type commun avant la comparaison.</li> <li>Cependant, comparer float et double peut produire des r\u00e9sultats inattendus \u00e0 cause des erreurs de pr\u00e9cision (voir ci-dessous).</li> </ul> <pre><code>int x = 10;\ndouble y = 10.0;\nSystem.out.println(x == y);  // true \u2192 x promu en double (10.0)\n\ndouble d = 0.1 + 0.2;\nSystem.out.println(d == 0.3); // false \u2192 probl\u00e8me d\u2019arrondi floating-point\n</code></pre> <p></p>"},{"location":"fr/module-01/java-operators/#5752-egalite-avec-les-types-reference-objets","title":"5.7.5.2 \u00c9galit\u00e9 avec les types r\u00e9f\u00e9rence (objets)","text":"<p>Pour les objets, <code>==</code> et <code>!=</code> comparent les r\u00e9f\u00e9rences, pas le contenu. Ils renvoient true uniquement si les deux r\u00e9f\u00e9rences pointent vers le m\u00eame objet en m\u00e9moire.</p> <pre><code>String s1 = new String(\"Java\");\nString s2 = new String(\"Java\");\nSystem.out.println(s1 == s2);      // false \u2192 objets diff\u00e9rents en m\u00e9moire\nSystem.out.println(s1 != s2);      // true  \u2192 pas la m\u00eame r\u00e9f\u00e9rence\n</code></pre> <p>M\u00eame si deux objets ont un contenu identique, <code>==</code> compare leurs adresses, pas leurs valeurs. Pour comparer le contenu des objets, utilise <code>.equals()</code>.</p> <pre><code>System.out.println(s1.equals(s2)); // true \u2192 m\u00eame contenu de cha\u00eene\n</code></pre> <p>Cas particulier : null et litt\u00e9raux String</p> <ul> <li>Toute r\u00e9f\u00e9rence peut \u00eatre compar\u00e9e \u00e0 <code>null</code> avec <code>==</code> ou <code>!=</code>.</li> </ul> <pre><code>String text = null;\nSystem.out.println(text == null);  // true\n</code></pre> <ul> <li>Les litt\u00e9raux String sont intern\u00e9s par la JVM : des litt\u00e9raux identiques peuvent donc pointer vers la m\u00eame r\u00e9f\u00e9rence en m\u00e9moire :</li> </ul> <pre><code>String a = \"Java\";\nString b = \"Java\";\nSystem.out.println(a == b);       // true \u2192 m\u00eame litt\u00e9ral intern\u00e9\n</code></pre> <ul> <li>\u00c9galit\u00e9 avec types mixtes : avec <code>==</code> entre cat\u00e9gories diff\u00e9rentes (ex. primitif vs objet), le compilateur tente l\u2019unboxing si l\u2019un des deux est une classe wrapper.</li> </ul> <pre><code>Integer i = 100;\nint j = 100;\nSystem.out.println(i == j);   // true \u2192 unboxing avant comparaison\n</code></pre> <p></p>"},{"location":"fr/module-01/java-operators/#576-loperateur-instanceof","title":"5.7.6 L\u2019op\u00e9rateur <code>instanceof</code>","text":"<p><code>instanceof</code> est un op\u00e9rateur relationnel qui teste si une r\u00e9f\u00e9rence est une instance d\u2019un certain type r\u00e9f\u00e9rence \u00e0 l\u2019ex\u00e9cution. Il renvoie un <code>boolean</code>.</p> <pre><code>Object o = \"Java\";\nboolean b1 = (o instanceof String);   // true\nboolean b2 = (o instanceof Number);   // false\n</code></pre> <p>Comportement avec null : si l\u2019expression est null, expr instanceof Type est toujours false.</p> <pre><code>Object n = null;\nSystem.out.println(n instanceof Object);  // false\n</code></pre> <p>Warning</p> <p><code>instanceof</code> renvoie toujours <code>false</code> lorsque l\u2019op\u00e9rande gauche est <code>null</code>.</p> <p></p>"},{"location":"fr/module-01/java-operators/#5761-verification-a-la-compilation-vs-a-lexecution","title":"5.7.6.1 V\u00e9rification \u00e0 la compilation vs \u00e0 l\u2019ex\u00e9cution","text":"<ul> <li>\u00c0 la compilation, le compilateur rejette les types inconvertibles (qui ne peuvent pas \u00eatre li\u00e9s \u00e0 l\u2019ex\u00e9cution).</li> <li>\u00c0 l\u2019ex\u00e9cution, si la v\u00e9rification compile-time a pass\u00e9, la JVM \u00e9value le type r\u00e9el de l\u2019objet.</li> </ul> <pre><code>// \u274c Erreur de compilation : types inconvertibles (String est sans rapport avec Integer)\nboolean bad = (\"abc\" instanceof Integer);\n\n// \u2705 Compile, mais le r\u00e9sultat \u00e0 l\u2019ex\u00e9cution d\u00e9pend de l\u2019objet r\u00e9el :\n\nNumber num = Integer.valueOf(10);\nSystem.out.println(num instanceof Integer); // true \u00e0 l\u2019ex\u00e9cution\nSystem.out.println(num instanceof Double);  // false \u00e0 l\u2019ex\u00e9cution\n</code></pre>"},{"location":"fr/module-01/java-operators/#5762-pattern-matching-pour-instanceof","title":"5.7.6.2 Pattern matching pour instanceof","text":"<p>Java supporte les type patterns avec <code>instanceof</code>, qui testent et lient une variable si le test r\u00e9ussit. Ajouter une variable apr\u00e8s le type indique au compilateur d\u2019interpr\u00e9ter cela comme du Pattern Matching.</p> <p>Syntaxe (forme pattern) :</p> <pre><code>Object obj = \"Hello\";\n\nif (obj instanceof String str) {\n    // Ajouter la variable str apr\u00e8s le type indique au compilateur de faire du Pattern Matching\n\n    System.out.println(str.toUpperCase()); // l\u2019identifiant est en scope ici, de type String (s\u00fbr).\n}\n</code></pre> <p>Propri\u00e9t\u00e9s cl\u00e9s :</p> <ul> <li>Si le test r\u00e9ussit, la variable de pattern (ex. <code>str</code>) est d\u00e9finitivement assign\u00e9e et visible dans la branche true.</li> <li>Les variables de pattern sont implicitement final (ne peuvent pas \u00eatre r\u00e9assign\u00e9es).</li> <li>Le nom ne doit pas entrer en conflit avec une variable existante dans le m\u00eame scope.</li> </ul> <p></p>"},{"location":"fr/module-01/java-operators/#5763-flow-scoping-logique-short-circuit","title":"5.7.6.3 Flow scoping &amp; logique short-circuit","text":"<p>Les variables de pattern deviennent disponibles selon l\u2019analyse de flux :</p> <pre><code>Object obj = \"data\";\n\n// Test n\u00e9gatif, variable disponible dans la branche else\nif (!(obj instanceof String s)) {\n    // s n\u2019est pas en scope ici\n} else {\n    System.out.println(s.length()); // s est en scope ici\n}\n\n// Avec &amp;&amp;, la variable de pattern peut \u00eatre utilis\u00e9e \u00e0 droite si la gauche l\u2019a \u00e9tablie\nif (obj instanceof String s &amp;&amp; s.length() &gt; 3) {\n    System.out.println(s.substring(0, 3)); // s en scope\n}\n\n// Avec ||, la variable de pattern n\u2019est PAS s\u00fbre \u00e0 droite (le short-circuit peut emp\u00eacher de l\u2019\u00e9tablir)\nif (obj instanceof String s || s.length() &gt; 3) {  // \u274c s n\u2019est pas en scope ici\n    // ...\n}\n\n// Les parenth\u00e8ses peuvent aider \u00e0 regrouper la logique\nif ((obj instanceof String s) &amp;&amp; s.contains(\"a\")) { // \u2705 s en scope apr\u00e8s le test group\u00e9\n    System.out.println(s);\n}\n</code></pre> <p>Le pattern matching avec <code>null</code> s\u2019\u00e9value, comme toujours pour <code>instanceof</code>, \u00e0 <code>false</code> :</p> <pre><code>String str = null;\n\n// instanceof classique\nif (str instanceof String) {  \n    System.out.print(\"NOT EXECUTED\"); // instanceof vaut false\n}\n\n// Pattern matching\nif (str instanceof String s) {  \n    System.out.print(\"NOT EXECUTED\"); // instanceof vaut toujours false\n}\n</code></pre> <p>Types support\u00e9s :</p> <p>Le type de la variable de pattern doit \u00eatre un sous-type, un super-type, ou le m\u00eame type que la variable r\u00e9f\u00e9rence.</p> <pre><code>Number num = Short.valueOf(10);\n\nif (num instanceof String s) {}  // \u274c Erreur de compilation\nif (num instanceof Short s) {}   // \u2705 Ok\nif (num instanceof Object s) {}  // \u2705 Ok\nif (num instanceof Number s) {}  // \u2705 Ok\n</code></pre> <p></p>"},{"location":"fr/module-01/java-operators/#5764-tableaux-et-types-reifiables","title":"5.7.6.4 Tableaux et types r\u00e9ifiables","text":"<p><code>instanceof</code> fonctionne avec les tableaux (r\u00e9ifiables) et avec des formes g\u00e9n\u00e9riques effac\u00e9es ou avec wildcard. Les types r\u00e9ifiables sont ceux dont la repr\u00e9sentation \u00e0 l\u2019ex\u00e9cution conserve pleinement leur type (par exemple : raw types, tableaux, classes non g\u00e9n\u00e9riques, wildcard <code>?</code>). \u00c0 cause de l\u2019effacement de type (type erasure), <code>List&lt;String&gt;</code> ne peut pas \u00eatre test\u00e9e directement \u00e0 l\u2019ex\u00e9cution.</p> <pre><code>Object arr = new int[]{1,2,3};\nSystem.out.println(arr instanceof int[]); // true\n\nObject list = java.util.List.of(1,2,3);\n// System.out.println(list instanceof List&lt;Integer&gt;); // \u274c Erreur de compilation : type param\u00e9tr\u00e9 non r\u00e9ifiable\nSystem.out.println(list instanceof java.util.List&lt;?&gt;); // \u2705 true\n</code></pre> <p></p>"},{"location":"fr/module-01/java-operators/#58-operateur-ternaire","title":"5.8 Op\u00e9rateur ternaire","text":"<p>L\u2019op\u00e9rateur ternaire (<code>? :</code>) est le seul op\u00e9rateur en Java qui prend trois op\u00e9randes. Il constitue une forme concise de l\u2019instruction <code>if-else</code>.</p> <p></p>"},{"location":"fr/module-01/java-operators/#581-regles-de-typage-de-loperateur-ternaire","title":"5.8.1 R\u00e8gles de Typage de l\u2019Op\u00e9rateur Ternaire","text":"<p>Le type d\u2019une expression conditionnelle (ternaire) est d\u00e9termin\u00e9 par les types du deuxi\u00e8me et du troisi\u00e8me op\u00e9rande.</p> <p></p>"},{"location":"fr/module-01/java-operators/#5811-operandes-numeriques","title":"5.8.1.1 Op\u00e9randes Num\u00e9riques","text":"<ul> <li>Si un op\u00e9rande est de type <code>byte</code> et l\u2019autre de type <code>short</code>, le type r\u00e9sultant est <code>short</code>.</li> <li>Si un op\u00e9rande est de type <code>T</code> (<code>byte</code>, <code>short</code> ou <code>char</code>) et l\u2019autre est une expression constante de type <code>int</code> dont la valeur est repr\u00e9sentable dans <code>T</code>, alors le type r\u00e9sultant est <code>T</code>.</li> <li>Dans tous les autres cas num\u00e9riques, la binary numeric promotion est appliqu\u00e9e aux deux op\u00e9randes.   Le type de l\u2019expression conditionnelle devient le type promu.</li> </ul> <p>La binary numeric promotion inclut la conversion d\u2019unboxing et la value set conversion.</p> <p></p>"},{"location":"fr/module-01/java-operators/#5812-types-de-reference","title":"5.8.1.2 Types de R\u00e9f\u00e9rence","text":"<ul> <li>Si un op\u00e9rande est <code>null</code> et l\u2019autre est un type de r\u00e9f\u00e9rence, le type r\u00e9sultant est ce type de r\u00e9f\u00e9rence.</li> <li>Si les deux op\u00e9randes sont de types de r\u00e9f\u00e9rence diff\u00e9rents, l\u2019un doit \u00eatre assignable \u00e0 l\u2019autre (compatibilit\u00e9 d\u2019assignation).   Le type r\u00e9sultant est le type le plus g\u00e9n\u00e9ral, c\u2019est-\u00e0-dire celui auquel l\u2019autre peut \u00eatre assign\u00e9.</li> <li>Si aucun des deux types n\u2019est compatible par assignation avec l\u2019autre, une erreur \u00e0 la compilation se produit.</li> </ul> <p>En r\u00e9sum\u00e9, l\u2019op\u00e9rateur ternaire d\u00e9termine son type en appliquant :</p> <ul> <li>Des r\u00e8gles sp\u00e9cifiques de narrowing pour les petits types entiers  </li> <li>La binary numeric promotion pour les valeurs num\u00e9riques  </li> <li>Les r\u00e8gles de compatibilit\u00e9 d\u2019assignation pour les types de r\u00e9f\u00e9rence  </li> </ul> <p>Tip</p> <p>L\u2019op\u00e9rateur ternaire doit produire une valeur d\u2019un type compatible. Si les deux branches retournent des types non li\u00e9s, la compilation \u00e9choue.</p> <pre><code>String s = true ? \"ok\" : 5; // \u274c erreur de compilation : types incompatibles\n</code></pre> <p></p>"},{"location":"fr/module-01/java-operators/#582-syntaxe","title":"5.8.2 Syntaxe","text":"<pre><code>condition ? expressionIfTrue : expressionIfFalse;\n</code></pre>"},{"location":"fr/module-01/java-operators/#583-exemple","title":"5.8.3 Exemple","text":"<pre><code>int age = 20;\nString access = (age &gt;= 18) ? \"Autoris\u00e9\" : \"Refus\u00e9\";\nSystem.out.println(access);  // \"Autoris\u00e9\"\n</code></pre>"},{"location":"fr/module-01/java-operators/#584-exemple-de-ternaire-imbrique","title":"5.8.4 Exemple de Ternaire Imbriqu\u00e9","text":"<pre><code>int score = 85;\nString grade = (score &gt;= 90) ? \"A\" :\n               (score &gt;= 75) ? \"B\" :\n               (score &gt;= 60) ? \"C\" : \"F\";\nSystem.out.println(grade);  // \"B\"\n</code></pre>"},{"location":"fr/module-01/java-operators/#585-remarques","title":"5.8.5 Remarques","text":"<p>Warning</p> <ul> <li>Les expressions ternaires imbriqu\u00e9es peuvent r\u00e9duire la lisibilit\u00e9. Utilisez des parenth\u00e8ses pour plus de clart\u00e9.</li> <li>L\u2019op\u00e9rateur ternaire retourne une valeur, contrairement \u00e0 <code>if-else</code>, qui est une instruction.</li> </ul>"},{"location":"fr/module-01/naming-rules/","title":"3. R\u00e8gles de nommage Java","text":""},{"location":"fr/module-01/naming-rules/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>3.1 R\u00e8gles pour les identifiants<ul> <li>3.1.1 Mots r\u00e9serv\u00e9s<ul> <li>3.1.1.1 Mots-cl\u00e9s Java r\u00e9serv\u00e9s</li> <li>3.1.1.2 Litt\u00e9raux r\u00e9serv\u00e9s</li> </ul> </li> <li>3.1.2 Sensibilit\u00e9 \u00e0 la casse</li> <li>3.1.3 D\u00e9but des identifiants</li> <li>3.1.4 Chiffres dans les identifiants</li> <li>3.1.5 Jeton <code>_</code> seul</li> <li>3.1.6 Litt\u00e9raux num\u00e9riques et caract\u00e8re underscore</li> </ul> </li> </ul> <p>Java d\u00e9finit des r\u00e8gles pr\u00e9cises pour les identifiants, c\u2019est-\u00e0-dire les noms donn\u00e9s aux variables, m\u00e9thodes, classes, interfaces et packages.</p> <p>Tant que vous respectez les r\u00e8gles de nommage d\u00e9crites ci-dessous, vous \u00eates libre de choisir des noms significatifs pour les \u00e9l\u00e9ments de votre programme.</p> <p></p>"},{"location":"fr/module-01/naming-rules/#31-regles-pour-les-identifiants","title":"3.1 R\u00e8gles pour les identifiants","text":""},{"location":"fr/module-01/naming-rules/#311-mots-reserves","title":"3.1.1 Mots r\u00e9serv\u00e9s","text":"<p>Les <code>identifiers</code> ne peuvent pas \u00eatre identiques aux mots-cl\u00e9s Java ni aux litt\u00e9raux r\u00e9serv\u00e9s.</p> <p>Les <code>keywords</code> sont des mots sp\u00e9ciaux pr\u00e9d\u00e9finis dans le langage Java que vous n\u2019\u00eates pas autoris\u00e9 \u00e0 utiliser comme identifiants (voir tableau ci-dessous).</p> <p>Les <code>literals</code> comme <code>true</code>, <code>false</code> et <code>null</code> sont \u00e9galement r\u00e9serv\u00e9s et ne peuvent pas \u00eatre utilis\u00e9s comme identifiants.</p> <ul> <li>Exemple : <pre><code>int class = 5;        // invalid: 'class' is a keyword\nboolean true = false; // invalid: 'true' is a literal\nint year = 2024;      // valid\n</code></pre></li> </ul> <p></p>"},{"location":"fr/module-01/naming-rules/#3111-mots-cles-java-reserves","title":"3.1.1.1 Mots-cl\u00e9s Java r\u00e9serv\u00e9s","text":"a -&gt; c c -&gt; f f -&gt; n n -&gt; s s -&gt; w abstract continue for new switch assert default goto* package synchronized boolean do if private this break double implements protected throw byte else import public throws case enum instanceof return transient catch extends int short try char final interface static void class finally long strictfp volatile const* float native super while <p>Note</p> <p><code>goto</code> et <code>const</code> sont r\u00e9serv\u00e9s mais non utilis\u00e9s.</p> <p></p>"},{"location":"fr/module-01/naming-rules/#3112-litteraux-reserves","title":"3.1.1.2 Litt\u00e9raux r\u00e9serv\u00e9s","text":"<ul> <li><code>true</code> </li> <li><code>false</code> </li> <li><code>null</code> </li> </ul>"},{"location":"fr/module-01/naming-rules/#312-sensibilite-a-la-casse","title":"3.1.2 Sensibilit\u00e9 \u00e0 la casse","text":"<p>Les identifiants en Java sont sensibles \u00e0 la casse (case sensitive). Cela signifie que <code>myVar</code>, <code>MyVar</code> et <code>MYVAR</code> sont trois identifiants diff\u00e9rents.</p> <ul> <li>Exemple : <pre><code>int myVar = 1;\nint MyVar = 2;\nint MYVAR = 3;\nint CLASS = 6; // legal but, please, don't do it!!\n</code></pre></li> </ul> <p>Tip</p> <p>Java traite les identifiants litt\u00e9ralement : <code>Count</code>, <code>count</code> et <code>COUNt</code> sont ind\u00e9pendants et peuvent coexister.</p> <p>\u00c0 cause de la sensibilit\u00e9 \u00e0 la casse, il est possible d\u2019utiliser des variantes de mots-cl\u00e9s qui diff\u00e8rent uniquement par la casse. M\u00eame si c\u2019est l\u00e9gal, ce type de nommage est fortement d\u00e9conseill\u00e9, car il nuit \u00e0 la lisibilit\u00e9 et est consid\u00e9r\u00e9 comme une tr\u00e8s mauvaise pratique.</p> <p></p>"},{"location":"fr/module-01/naming-rules/#313-debut-des-identifiants","title":"3.1.3 D\u00e9but des identifiants","text":"<p>Les identifiants en Java doivent commencer par une lettre, un symbole mon\u00e9taire (<code>$</code>, <code>\u20ac</code>, <code>\u00a3</code>, <code>\u20b9</code>...) ou le symbole <code>_</code>.</p> <p>Exemple : <pre><code>int myVarA;\nint $myVarB;\nint _myVarC;\nString \u20acuro = \"currency\"; // legal (rarely seen in practice)\n</code></pre></p> <p>Note</p> <p>Les symboles de devise sont autoris\u00e9s, mais ils ne sont pas recommand\u00e9s dans du code r\u00e9el.</p> <p></p>"},{"location":"fr/module-01/naming-rules/#314-chiffres-dans-les-identifiants","title":"3.1.4 Chiffres dans les identifiants","text":"<p>Les identifiants Java peuvent contenir des chiffres, mais ne peuvent pas commencer par un chiffre.</p> <p>Exemple : <pre><code>int my33VarA;\nint $myVar44;\nint 3myVarC; // invalid: identifier cannot start with a digit\nint var2024 = 10; // valid\n</code></pre></p> <p></p>"},{"location":"fr/module-01/naming-rules/#315-jeton-_-seul","title":"3.1.5 Jeton <code>_</code> seul","text":"<ul> <li>Un underscore (<code>_</code>) seul n\u2019est pas autoris\u00e9 comme identifiant.</li> <li> <p>Depuis Java 9, <code>_</code> est un jeton r\u00e9serv\u00e9 pour un usage futur du langage.</p> </li> <li> <p>Exemple : <pre><code>int _;  // invalid since Java 9\n</code></pre></p> </li> </ul> <p>Warning</p> <p><code>_</code> est autoris\u00e9 \u00e0 l\u2019int\u00e9rieur des litt\u00e9raux num\u00e9riques (voir section suivante), mais pas comme identifiant isol\u00e9.</p> <p></p>"},{"location":"fr/module-01/naming-rules/#316-litteraux-numeriques-et-caractere-underscore","title":"3.1.6 Litt\u00e9raux num\u00e9riques et caract\u00e8re underscore","text":"<p>Vous pouvez utiliser un ou plusieurs caract\u00e8res <code>_</code> (underscore) dans les litt\u00e9raux num\u00e9riques afin de les rendre plus lisibles.</p> <p>Vous pouvez placer des underscores presque partout, sauf au d\u00e9but, \u00e0 la fin ou juste autour du point d\u00e9cimal (imm\u00e9diatement avant ou apr\u00e8s).</p> <ul> <li>Exemple : <pre><code>int firstNum = 1_000_000;\nint secondNum = 1 _____________ 2;\n\ndouble firstDouble = _1000.00   // DOES NOT COMPILE\ndouble secondDouble = 1000_.00  // DOES NOT COMPILE\ndouble thirdDouble = 1000._00   // DOES NOT COMPILE\ndouble fourthDouble = 1000.00_  // DOES NOT COMPILE\n\ndouble pi = 3.14_159_265; // valid\nlong mask = 0b1111_0000;  // valid in binary literals\n</code></pre></li> </ul> <p>Tip</p> <p>Les underscores am\u00e9liorent la lisibilit\u00e9 : <code>1_000_000</code> est plus facile \u00e0 lire que <code>1000000</code>.</p>"},{"location":"fr/module-01/syntax-building-blocks/","title":"1. Blocs Syntaxiques Fondamentaux","text":""},{"location":"fr/module-01/syntax-building-blocks/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>1.1 Valeur</li> <li>1.2 Litt\u00e9ral</li> <li>1.3 Identifiant</li> <li>1.4 Variable</li> <li>1.5 Type</li> <li>1.6 Op\u00e9rateur</li> <li>1.7 Expression</li> <li>1.8 Instruction</li> <li>1.9 Bloc de code</li> <li>1.10 Fonction / M\u00e9thode</li> <li>1.11 Classe / Objet</li> <li>1.12 Module / Package</li> <li>1.13 Programme</li> <li>1.14 Syst\u00e8me</li> <li>1.15 R\u00e9sum\u00e9 sous forme d\u2019\u00e9chelle croissante</li> <li>1.16 Diagramme hi\u00e9rarchique ASCII</li> <li>1.17 Diagramme hi\u00e9rarchique Mermaid</li> </ul> <p>Tout syst\u00e8me logiciel ou programme informatique est compos\u00e9 d\u2019un ensemble de donn\u00e9es et d\u2019un ensemble d\u2019op\u00e9rations appliqu\u00e9es \u00e0 ces donn\u00e9es afin de produire un r\u00e9sultat.</p> <p>Plus formellement :</p> <p>Un programme informatique consiste en un ensemble de structures de donn\u00e9es repr\u00e9sentant l\u2019\u00e9tat du syst\u00e8me, accompagn\u00e9 d\u2019algorithmes qui sp\u00e9cifient les op\u00e9rations \u00e0 effectuer sur cet \u00e9tat pour produire des sorties.</p> <p>Ce document d\u00e9crit une hi\u00e9rarchie d\u2019abstractions : les blocs \u00e9l\u00e9mentaires qui, combin\u00e9s en structures de plus en plus complexes, forment un logiciel.</p> <p>La s\u00e9quence est pr\u00e9sent\u00e9e dans un ordre croissant de complexit\u00e9, avec des d\u00e9finitions g\u00e9n\u00e9rales (informatique) et des r\u00e9f\u00e9rences \u00e0 Java.</p> <p></p>"},{"location":"fr/module-01/syntax-building-blocks/#11-valeur","title":"1.1 Valeur","text":"<ul> <li>D\u00e9finition : Entit\u00e9 abstraite repr\u00e9sentant une information (nombre, caract\u00e8re, bool\u00e9en, cha\u00eene, etc.).</li> <li>Th\u00e9orie : Une valeur appartient \u00e0 un domaine (ensemble) math\u00e9matique, comme \u2115 pour les nombres naturels ou \u03a3* pour les cha\u00eenes de caract\u00e8res.</li> <li>Exemple (abstrait) : le nombre quarante-deux, la valeur de v\u00e9rit\u00e9 true, le caract\u00e8re \u00ab a \u00bb.</li> </ul> <p>Exemple Java (valeurs) :</p> <pre><code>// Voici des valeurs :\n42        // une valeur int\ntrue      // une valeur boolean\n'a'       // une valeur char\n\"Hello\"   // une valeur String\n</code></pre> <p></p>"},{"location":"fr/module-01/syntax-building-blocks/#12-litteral","title":"1.2 Litt\u00e9ral","text":"<ul> <li>D\u00e9finition : Un litt\u00e9ral est la notation concr\u00e8te dans le code source qui d\u00e9signe directement une valeur fixe.</li> <li>En Java : <code>42</code>, <code>'a'</code>, <code>true</code>, <code>\"Hello\"</code>.</li> <li>Th\u00e9orie : Un litt\u00e9ral est de la syntaxe, tandis que la valeur correspond \u00e0 sa s\u00e9mantique.</li> <li>Remarque : Les litt\u00e9raux sont la mani\u00e8re la plus courante d\u2019introduire des valeurs dans les programmes.</li> </ul> <p>Exemple Java (litt\u00e9raux) :</p> <pre><code>int answer = 42;          // 42 est un litt\u00e9ral int\nchar letter = 'a';        // 'a' est un litt\u00e9ral char\nboolean flag = true;      // true est un litt\u00e9ral boolean\nString msg = \"Hello\";     // \"Hello\" est un litt\u00e9ral String\n</code></pre> <p></p>"},{"location":"fr/module-01/syntax-building-blocks/#13-identifiant","title":"1.3 Identifiant","text":"<ul> <li>D\u00e9finition : Nom symbolique qui associe une valeur (ou une structure) \u00e0 une \u00e9tiquette lisible.</li> <li>En Java :</li> <li>Identifiants d\u00e9finis par l\u2019utilisateur : choisis par le programmeur pour nommer variables, m\u00e9thodes, classes, etc.     Exemples : <code>x</code>, <code>counter</code>, <code>MyClass</code>, <code>calculateSum</code>.</li> <li>Mots-cl\u00e9s (r\u00e9serv\u00e9s) : noms pr\u00e9d\u00e9finis r\u00e9serv\u00e9s par le langage Java et qui ne peuvent pas \u00eatre red\u00e9finis.     Exemples : <code>class</code>, <code>public</code>, <code>static</code>, <code>if</code>, <code>return</code>.</li> </ul> <p>Note</p> <p>Les identifiants doivent respecter les r\u00e8gles de nommage de Java : voir Java Naming Rules.</p> <ul> <li>Th\u00e9orie : Fonction de liaison (binding) : relie un nom \u00e0 une valeur ou une ressource.</li> </ul> <p>Exemple Java (identifiants) :</p> <pre><code>int counter = 0;          // counter est un identifiant (nom de variable)\nString userName = \"Bob\";  // userName est un identifiant\nclass MyService { }       // MyService est un identifiant de classe\n</code></pre> <p></p>"},{"location":"fr/module-01/syntax-building-blocks/#14-variable","title":"1.4 Variable","text":"<ul> <li>D\u00e9finition : \u00ab Case m\u00e9moire \u00bb \u00e9tiquet\u00e9e par un identifiant, qui peut contenir et changer de valeur.</li> <li>En Java : <code>int counter = 0; counter = counter + 1;</code>.</li> <li>Th\u00e9orie : \u00c9tat mutable susceptible d\u2019\u00e9voluer pendant l\u2019ex\u00e9cution.</li> </ul> <p>Exemple Java (variable qui \u00e9volue dans le temps) :</p> <pre><code>int counter = 0;       // variable initialis\u00e9e\ncounter = counter + 1; // variable mise \u00e0 jour\ncounter++;             // autre mise \u00e0 jour (post-incr\u00e9ment)\n</code></pre> <p></p>"},{"location":"fr/module-01/syntax-building-blocks/#15-type","title":"1.5 Type","text":"<ul> <li>D\u00e9finition : Un type est un ensemble de valeurs et un ensemble d\u2019op\u00e9rations autoris\u00e9es sur ces valeurs.</li> <li>En Java :</li> <li>Types primitifs (simples) : repr\u00e9sentent directement des valeurs de base.     Exemples : <code>int</code>, <code>double</code>, <code>boolean</code>, <code>char</code>, <code>byte</code>, <code>short</code>, <code>long</code>, <code>float</code>.</li> <li>Types r\u00e9f\u00e9rence : repr\u00e9sentent des r\u00e9f\u00e9rences (pointeurs) vers des objets en m\u00e9moire.     Exemples : <code>String</code>, tableaux (par ex. <code>int[]</code>), classes, interfaces et types d\u00e9finis par l\u2019utilisateur.</li> </ul> <p>Note</p> <p>Voir Java Data Types.</p> <ul> <li>Th\u00e9orie : Un syst\u00e8me de types est l\u2019ensemble des r\u00e8gles qui associent des ensembles de valeurs et des op\u00e9rations admissibles.</li> </ul> <p>Exemple Java (types) :</p> <pre><code>int age = 30;           // type int\ndouble price = 9.99;    // type double\nboolean active = true;  // type boolean\nString name = \"Alice\";  // type r\u00e9f\u00e9rence (classe String)\n</code></pre> <p></p>"},{"location":"fr/module-01/syntax-building-blocks/#16-operateur","title":"1.6 Op\u00e9rateur","text":"<ul> <li>D\u00e9finition : Symbole ou mot-cl\u00e9 qui effectue un calcul ou une action sur un ou plusieurs op\u00e9randes.</li> <li>R\u00f4le : Les op\u00e9rateurs combinent valeurs, variables et expressions pour produire de nouvelles valeurs ou modifier l\u2019\u00e9tat du programme.</li> <li>En Java :</li> </ul> <p>Note</p> <p>Voir Java Operators.</p> <ul> <li>Th\u00e9orie : Les op\u00e9rateurs d\u00e9finissent les calculs autoris\u00e9s sur les types ; avec les valeurs et variables, ils forment les expressions.</li> </ul> <p>Exemple Java (op\u00e9rateurs en contexte) :</p> <pre><code>int a = 5 + 3;          // + arithm\u00e9tique\nboolean ok = a &gt; 3;     // &gt; comparaison\nok = ok &amp;&amp; true;        // &amp;&amp; logique\na += 2;                 // += affectation compos\u00e9e\nint sign = (a &gt;= 0) ? 1 : -1; // ?: ternaire\n</code></pre> <p></p>"},{"location":"fr/module-01/syntax-building-blocks/#17-expression","title":"1.7 Expression","text":"<ul> <li>D\u00e9finition : Combinaison de valeurs, litt\u00e9raux, variables, op\u00e9rateurs et fonctions produisant une nouvelle valeur.</li> <li>En Java : <code>x + 3</code>, <code>Math.sqrt(25)</code>, <code>\"Hello\" + \" world\"</code>.</li> <li>Th\u00e9orie : Arbre syntaxique qui, une fois \u00e9valu\u00e9, donne un r\u00e9sultat.</li> </ul> <p>Exemple Java (expressions) :</p> <pre><code>int x = 10;\nint y = x + 3;               // x + 3 est une expression\ndouble r = Math.sqrt(25);    // Math.sqrt(25) est une expression\nString msg = \"Hello\" + \" \";  // \"Hello\" + \" \" est une expression\nmsg = msg + \"world\";         // msg + \"world\" est une autre expression\n</code></pre> <p></p>"},{"location":"fr/module-01/syntax-building-blocks/#18-instruction","title":"1.8 Instruction","text":"<ul> <li>D\u00e9finition : Unit\u00e9 d\u2019ex\u00e9cution qui modifie l\u2019\u00e9tat ou contr\u00f4le le flot d\u2019ex\u00e9cution.</li> <li>En Java : <code>x = x + 1;</code>, <code>if (x &gt; 0) { ... }</code>.</li> <li>Th\u00e9orie : S\u00e9quence d\u2019actions qui ne renvoie pas de valeur en tant que r\u00e9sultat de l\u2019instruction elle-m\u00eame, mais modifie la configuration de la machine abstraite.</li> </ul> <p>Exemple Java (instructions) :</p> <pre><code>int x = 0;                // d\u00e9claration (instruction de d\u00e9finition)\nx = x + 1;                // instruction d\u2019affectation\n\nif (x &gt; 0) {              // instruction if\n    System.out.println(\"Positive\");\n}\n</code></pre> <p></p>"},{"location":"fr/module-01/syntax-building-blocks/#19-bloc-de-code","title":"1.9 Bloc de code","text":"<ul> <li>D\u00e9finition : Ensemble d\u2019instructions d\u00e9limit\u00e9es formant une unit\u00e9 ex\u00e9cutable.</li> <li>En Java : <code>{ int y = 5; x = x + y; }</code>.</li> <li>Th\u00e9orie : Composition s\u00e9quentielle d\u2019instructions, avec des r\u00e8gles de port\u00e9e (visibilit\u00e9).</li> </ul> <p>Exemple Java (bloc de code et port\u00e9e) :</p> <pre><code>int x = 10;\n\n{\n    int y = 5;        // y n\u2019est visible qu\u2019\u00e0 l\u2019int\u00e9rieur de ce bloc\n    x = x + y;        // OK : x est visible ici\n}\n\n// y n\u2019est plus visible ici\n// x est toujours visible ici\n</code></pre> <p></p>"},{"location":"fr/module-01/syntax-building-blocks/#110-fonction-methode","title":"1.10 Fonction / M\u00e9thode","text":"<ul> <li>D\u00e9finition : S\u00e9quence d\u2019instructions encapsul\u00e9e, identifi\u00e9e par un nom, pouvant recevoir des entr\u00e9es (param\u00e8tres) et renvoyer une sortie (valeur).</li> <li>En Java :</li> </ul> <pre><code>int square(int n) {\n    return n * n;\n}\n</code></pre> <ul> <li>Th\u00e9orie : Application (mapping) entre domaines d\u2019entr\u00e9e et de sortie, avec un corps op\u00e9rationnel.</li> </ul> <p>Exemple d\u2019utilisation Java :</p> <pre><code>int result = square(5); // result = 25\n</code></pre> <p></p>"},{"location":"fr/module-01/syntax-building-blocks/#111-classe-objet","title":"1.11 Classe / Objet","text":"<ul> <li>D\u00e9finition :</li> <li>Classe : description abstraite d\u2019un ensemble d\u2019objets (\u00e9tat + comportement).</li> <li> <p>Objet : instance concr\u00e8te de la classe.</p> </li> <li> <p>En Java :</p> </li> </ul> <pre><code>class Point {\n    int x, y;\n\n    void move(int dx, int dy) {\n        x += dx;\n        y += dy;\n    }\n}\n\nPoint p = new Point();   // p est un objet (instance de Point)\np.move(1, 2);            // appel de m\u00e9thode sur l\u2019objet\n</code></pre> <ul> <li>Th\u00e9orie : Abstraction d\u2019un ADT (Abstract Data Type, type de donn\u00e9e abstrait).</li> </ul> <p></p>"},{"location":"fr/module-01/syntax-building-blocks/#112-module-package","title":"1.12 Module / Package","text":"<ul> <li>D\u00e9finition : Regroupement logique de classes, fonctions et ressources partageant un objectif commun.</li> <li>En Java : <code>package java.util;</code> \u2192 regroupe des utilitaires.</li> <li>Th\u00e9orie : M\u00e9canisme d\u2019organisation et de r\u00e9utilisation, r\u00e9duisant la complexit\u00e9.</li> </ul> <p>Exemple Java (package) :</p> <pre><code>package com.example.app;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Hello\");\n    }\n}\n</code></pre> <p></p>"},{"location":"fr/module-01/syntax-building-blocks/#113-programme","title":"1.13 Programme","text":"<ul> <li>D\u00e9finition : Ensemble coh\u00e9rent de modules, classes et fonctions qui, lorsqu\u2019il est ex\u00e9cut\u00e9 sur une machine, r\u00e9alise un comportement global.</li> <li>En Java : La m\u00e9thode <code>main</code> et tout ce qu\u2019elle invoque.</li> <li>Th\u00e9orie : Sp\u00e9cification de transformations d\u2019entr\u00e9es en sorties sur une machine abstraite.</li> </ul> <p>Exemple Java (programme minimal) :</p> <pre><code>public class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, Java 21!\");\n    }\n}\n</code></pre> <p></p>"},{"location":"fr/module-01/syntax-building-blocks/#114-systeme","title":"1.14 Syst\u00e8me","text":"<ul> <li>D\u00e9finition : Ensemble de programmes coop\u00e9rant qui interagissent avec des ressources externes (utilisateur, r\u00e9seau, p\u00e9riph\u00e9riques).</li> <li>Exemple : Une plateforme Java d\u2019entreprise avec base de donn\u00e9es, services REST, interface utilisateur.</li> <li>Th\u00e9orie : Architecture complexe de composants logiciels et mat\u00e9riels.</li> </ul> <p>Exemple (conceptuel) :</p> <ul> <li>Un backend Java (service Spring Boot)</li> <li>Une base de donn\u00e9es (PostgreSQL)</li> <li>Une application web front-end</li> <li>Des services externes (API REST, files de messages)</li> </ul> <p>Ensemble, ils forment un syst\u00e8me.</p> <p></p>"},{"location":"fr/module-01/syntax-building-blocks/#115-resume-sous-forme-dechelle-croissante","title":"1.15 \ud83d\udccc R\u00e9sum\u00e9 sous forme d\u2019\u00e9chelle croissante","text":"<p><code>Valeur \u2192 Litt\u00e9ral \u2192 Identifiant \u2192 Variable \u2192 Type \u2192 Op\u00e9rateur \u2192 Expression \u2192 Instruction \u2192 Bloc de code \u2192 Fonction/M\u00e9thode \u2192 Classe/Objet \u2192 Module/Package \u2192 Programme \u2192 Syst\u00e8me</code></p> <p>Cette \u00e9chelle montre comment de petites unit\u00e9s conceptuelles sont combin\u00e9es en structures de plus en plus grandes et complexes.</p> <p></p>"},{"location":"fr/module-01/syntax-building-blocks/#116-diagramme-hierarchique-ascii","title":"1.16 \ud83d\udcca Diagramme hi\u00e9rarchique (ASCII)","text":"<p>Description : Ce diagramme ASCII montre la relation hi\u00e9rarchique entre les blocs de construction, du plus complexe (Syst\u00e8me) au plus simple (Valeur et sa forme concr\u00e8te, le Litt\u00e9ral).</p> <pre><code>Syst\u00e8me\n\u2514\u2500\u2500 Programme\n    \u2514\u2500\u2500 Module / Package\n        \u2514\u2500\u2500 Classe / Objet\n            \u2514\u2500\u2500 Fonction / M\u00e9thode\n                \u2514\u2500\u2500 Bloc de code\n                    \u2514\u2500\u2500 Instruction\n                        \u2514\u2500\u2500 Expression\n                            \u2514\u2500\u2500 Op\u00e9rateur\n                                \u2514\u2500\u2500 Type\n                                    \u2514\u2500\u2500 Variable\n                                        \u2514\u2500\u2500 Identifiant\n                                            \u2514\u2500\u2500 Litt\u00e9ral\n                                                \u2514\u2500\u2500 Valeur\n</code></pre> <p></p>"},{"location":"fr/module-01/syntax-building-blocks/#117-diagramme-hierarchique-mermaid","title":"1.17 \ud83d\udcca Diagramme hi\u00e9rarchique (Mermaid)","text":"<p>Description : Le diagramme Mermaid rend la m\u00eame hi\u00e9rarchie sous forme d\u2019arbre descendant. Il met en \u00e9vidence qu\u2019un Litt\u00e9ral est la forme syntaxique d\u2019une Valeur.</p> <pre><code>graph TD\n    A[Syst\u00e8me]\n    A --&gt; B[Programme]\n    B --&gt; C[Module / Package]\n    C --&gt; D[Classe / Objet]\n    D --&gt; E[Fonction / M\u00e9thode]\n    E --&gt; F[Bloc de code]\n    F --&gt; G[Instruction]\n    G --&gt; H[Expression]\n    H --&gt; H2[Op\u00e9rateur]\n    H2 --&gt; I[Type]\n    I --&gt; J[Variable]\n    J --&gt; K[Identifiant]\n    K --&gt; L[Litt\u00e9ral]\n    L --&gt; M[Valeur]\n</code></pre>"},{"location":"fr/module-02/control-flow/","title":"7. Flux de contr\u00f4le","text":""},{"location":"fr/module-02/control-flow/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>7.1 L\u2019instruction if</li> <li>7.2 L\u2019instruction &amp; l\u2019expression switch<ul> <li>7.2.1 La variable cible du switch peut \u00eatre</li> <li>7.2.2 Valeurs case acceptables</li> <li>7.2.3 Compatibilit\u00e9 de type entre selector et case</li> <li>7.2.4 Pattern matching dans switch<ul> <li>7.2.4.1 Noms de variables et port\u00e9e entre les branches</li> <li>7.2.4.2 Ordonnancement, dominance et exhaustivit\u00e9 dans les switch \u00e0 patterns</li> </ul> </li> </ul> </li> <li>7.3 Deux formes de switch : switch Statement vs switch Expression<ul> <li>7.3.1 L\u2019instruction switch<ul> <li>7.3.1.1 Comportement de fall-through</li> </ul> </li> <li>7.3.2 L\u2019expression switch<ul> <li>7.3.2.1 yield dans les blocs d\u2019expression switch</li> <li>7.3.2.2 Exhaustivit\u00e9 pour les expressions switch</li> </ul> </li> </ul> </li> <li>7.4 Gestion de null</li> </ul> <p>Le flux de contr\u00f4le en Java fait r\u00e9f\u00e9rence \u00e0 l\u2019ordre dans lequel les instructions individuelles, les commandes ou les appels de m\u00e9thode sont ex\u00e9cut\u00e9s pendant l\u2019ex\u00e9cution du programme.</p> <p>Par d\u00e9faut, les instructions s\u2019ex\u00e9cutent s\u00e9quentiellement de haut en bas, mais les instructions de contr\u00f4le du flux permettent au programme de prendre des d\u00e9cisions, r\u00e9p\u00e9ter des actions ou d\u00e9river les chemins d\u2019ex\u00e9cution en fonction de conditions.</p> <p>Java fournit trois grandes cat\u00e9gories de constructions de contr\u00f4le du flux :</p> <ul> <li>Instructions d\u00e9cisionnelles \u2014 <code>if</code>, <code>if-else</code>, <code>switch</code></li> <li>Instructions de boucle \u2014 <code>for</code>, <code>while</code>, <code>do-while</code> et le <code>for</code> am\u00e9lior\u00e9</li> <li>Instructions de branchement \u2014 <code>break</code>, <code>continue</code> et <code>return</code></li> </ul> <p>Tip</p> <p>Comprendre le flux de contr\u00f4le est essentiel pour voir comment les donn\u00e9es circulent dans votre programme et comment chaque d\u00e9cision logique est \u00e9valu\u00e9e \u00e9tape par \u00e9tape.</p> <p></p>"},{"location":"fr/module-02/control-flow/#71-linstruction-if","title":"7.1 L\u2019instruction <code>if</code>","text":"<p>L\u2019instruction <code>if</code> est une structure conditionnelle de contr\u00f4le du flux qui ex\u00e9cute un bloc de code uniquement si une expression bool\u00e9enne sp\u00e9cifi\u00e9e est \u00e9valu\u00e9e \u00e0 <code>true</code>. Elle permet au programme de prendre des d\u00e9cisions \u00e0 l\u2019ex\u00e9cution.</p> <p>Syntaxe :</p> <pre><code>if (condition) {\n    // ex\u00e9cut\u00e9 uniquement lorsque la condition est true\n}\n</code></pre> <p>Une clause <code>else</code> optionnelle g\u00e8re le chemin alternatif :</p> <pre><code>if (score &gt;= 60) {\n    System.out.println(\"Passed\");\n} else {\n    System.out.println(\"Failed\");\n}\n</code></pre> <p>Plusieurs conditions peuvent \u00eatre cha\u00een\u00e9es \u00e0 l\u2019aide de <code>else if</code> :</p> <pre><code>if (grade &gt;= 90) {\n    System.out.println(\"A\");\n} else if (grade &gt;= 80) {\n    System.out.println(\"B\");\n} else if (grade &gt;= 70) {\n    System.out.println(\"C\");\n} else {\n    System.out.println(\"D or below\");\n}\n</code></pre> <p>Note</p> <p>La condition de <code>if</code> doit \u00eatre \u00e9valu\u00e9e comme un boolean ; les types num\u00e9riques ou les objets ne peuvent pas \u00eatre utilis\u00e9s directement comme conditions.</p> <p>Les accolades <code>{}</code> sont facultatives pour une seule instruction mais sont fortement recommand\u00e9es afin d\u2019\u00e9viter des erreurs logiques subtiles.</p> <p>Une cha\u00eene <code>if-else</code> est \u00e9valu\u00e9e de haut en bas, et seul le premier branchement dont la condition est \u00e9valu\u00e9e \u00e0 <code>true</code> est ex\u00e9cut\u00e9.</p> <p></p>"},{"location":"fr/module-02/control-flow/#72-linstruction-switch-lexpression","title":"7.2 L\u2019instruction <code>switch</code> &amp; l\u2019expression","text":"<p>La construction <code>switch</code> est une structure de contr\u00f4le du flux qui s\u00e9lectionne une branche parmi plusieurs alternatives en fonction de la valeur d\u2019une expression (le selector).</p> <p>Compar\u00e9 aux longues cha\u00eenes de <code>if-else-if</code>, un <code>switch</code> :</p> <ul> <li>Est souvent plus facile \u00e0 lire lorsqu\u2019on teste de nombreuses valeurs discr\u00e8tes (constantes, enums, cha\u00eenes).</li> <li>Peut \u00eatre plus s\u00fbr et plus concis lorsqu\u2019il est utilis\u00e9 comme expression switch </li> </ul> <p>parce que :</p> <ul> <li>Il produit une valeur.</li> <li>Le compilateur peut imposer l\u2019exhaustivit\u00e9 et la coh\u00e9rence de type.</li> </ul> <p>Java 21 prend en charge :</p> <ul> <li>Le <code>switch</code> classique en tant qu\u2019instruction (contr\u00f4le du flux uniquement).</li> <li>Le <code>switch</code> en tant qu\u2019expression (produit un r\u00e9sultat).</li> <li>Le pattern matching dans <code>switch</code>, y compris les type patterns et les guards.</li> </ul> <p>Les deux formes de <code>switch</code> partagent les m\u00eames r\u00e8gles concernant le selector (la variable cible du switch) et les valeurs case acceptables.</p> <p></p>"},{"location":"fr/module-02/control-flow/#721-la-variable-cible-du-switch-peut-etre","title":"7.2.1 La <code>variable cible</code> du switch peut \u00eatre","text":"Control Variable type <code>byte</code> / <code>Byte</code> <code>short</code> / <code>Short</code> <code>char</code> / <code>Character</code> <code>int</code> / <code>Integer</code> <code>String</code> Enum types (selectors of an <code>enum</code>) Any reference type (with pattern matching) <code>var</code> (if it resolves to one of the allowed types) <p>Warning</p> <p>Non autoris\u00e9 comme type de selector pour switch :</p> <ul> <li><code>boolean</code></li> <li><code>long</code></li> <li><code>float</code></li> <li><code>double</code></li> </ul> <p></p>"},{"location":"fr/module-02/control-flow/#722-valeurs-case-acceptables","title":"7.2.2 Valeurs <code>case</code> acceptables","text":"<p>Pour un switch non pattern, chaque \u00e9tiquette <code>case</code> doit \u00eatre une constante \u00e0 la compilation compatible avec le type du selector.</p> <p>Autoris\u00e9 comme \u00e9tiquettes case :</p> <ul> <li>Litt\u00e9raux tels que <code>0</code>, <code>'A'</code>, <code>\"ON\"</code>.</li> <li>Constantes enum, par ex. <code>RED</code> ou <code>Color.GREEN</code>.</li> <li>Variables constantes final (constantes \u00e0 la compilation).</li> </ul> <p>Une variable constante \u00e0 la compilation :</p> <ul> <li>Doit \u00eatre d\u00e9clar\u00e9e avec <code>final</code> et initialis\u00e9e dans la m\u00eame instruction.</li> <li>Son initialiseur doit lui-m\u00eame \u00eatre une expression constante (g\u00e9n\u00e9ralement en utilisant des litt\u00e9raux et d\u2019autres constantes \u00e0 la compilation).</li> </ul> <p></p>"},{"location":"fr/module-02/control-flow/#723-compatibilite-de-type-entre-selector-et-case","title":"7.2.3 Compatibilit\u00e9 de type entre selector et case","text":"<p>Le type du selector et chaque \u00e9tiquette <code>case</code> doivent \u00eatre compatibles :</p> <ul> <li>Les constantes num\u00e9riques des case doivent \u00eatre dans l\u2019intervalle du type du selector.</li> <li>Pour un selector <code>enum</code>, les \u00e9tiquettes case doivent \u00eatre des constantes de cet <code>enum</code>.</li> <li>Pour un selector <code>String</code>, les \u00e9tiquettes case doivent \u00eatre des constantes de cha\u00eene.</li> </ul> <p></p>"},{"location":"fr/module-02/control-flow/#724-pattern-matching-dans-switch","title":"7.2.4 Pattern Matching dans Switch","text":"<p>Le switch en Java 21 prend en charge le pattern matching, y compris :</p> <ul> <li>Type patterns : <code>case String s</code></li> <li>Patterns avec garde : <code>case String s when s.length() &gt; 3</code></li> <li>Pattern null : <code>case null</code></li> </ul> <p>Exemple :</p> <pre><code>String describe(Object o) {\n    return switch (o) {\n        case null -&gt; \"null\";\n        case Integer i -&gt; \"int \" + i;\n        case String s when s.isEmpty() -&gt; \"empty string\";\n        case String s -&gt; \"string (\" + s.length() + \")\";\n        default -&gt; \"other\";\n    };\n}\n</code></pre> <p>Points cl\u00e9s :</p> <ul> <li>Chaque pattern introduit une variable de pattern (comme <code>i</code> ou <code>s</code>).</li> <li>Les variables de pattern sont dans la port\u00e9e uniquement \u00e0 l\u2019int\u00e9rieur de leur arm (ou des chemins o\u00f9 le pattern est connu comme correspondant).</li> <li>L\u2019ordre est important en raison de la dominance : les patterns plus sp\u00e9cifiques doivent pr\u00e9c\u00e9der les plus g\u00e9n\u00e9raux.</li> </ul> <p></p>"},{"location":"fr/module-02/control-flow/#7241-noms-de-variables-et-portee-entre-les-branches","title":"7.2.4.1 Noms de variables et port\u00e9e entre les branches","text":"<p>Avec le pattern matching, la variable de pattern n\u2019existe que dans la port\u00e9e de l\u2019arm dans lequel elle est d\u00e9finie. Cela signifie que vous pouvez r\u00e9utiliser le m\u00eame nom de variable dans diff\u00e9rents branches case.</p> <ul> <li>Exemple :</li> </ul> <pre><code>switch (o) {\n    case String str -&gt; System.out.println(str.length());\n    case CharSequence str -&gt; System.out.println(str.charAt(0));\n    default -&gt; { }\n}\n</code></pre> <p>Note</p> <p>Ce dernier exemple ne retourne pas de valeur, il s\u2019agit donc d\u2019un switch instruction et non d\u2019une expression switch.</p> <p></p>"},{"location":"fr/module-02/control-flow/#7242-ordonnancement-dominance-et-exhaustivite-dans-les-switch-a-patterns","title":"7.2.4.2 Ordonnancement, dominance et exhaustivit\u00e9 dans les switch \u00e0 patterns","text":"<p>Lorsqu\u2019on utilise le pattern matching, l\u2019ordre des branches est crucial en raison de la dominance et du potentiel code inatteignable.</p> <p>Un pattern plus g\u00e9n\u00e9ral ne doit pas appara\u00eetre avant un pattern plus sp\u00e9cifique, sinon ce dernier devient inatteignable.</p> <ul> <li>Exemple (branche inatteignable) :</li> </ul> <pre><code>return switch (o) {\n    case Object obj -&gt; \"object\";\n    case String s -&gt; \"string\"; // \u274c DOES NOT COMPILE: unreachable, String is already matched by Object\n};\n</code></pre> <ul> <li>Autre exemple avec une garde :</li> </ul> <pre><code>return switch (o) {\n    case Integer a -&gt; \"First\";\n    case Integer a when a &gt; 0 -&gt; \"Second\"; // \u274c DOES NOT COMPILE: unreachable, the first case matches all Integers\n    // ...\n};\n</code></pre> <p>Lorsqu\u2019on utilise le pattern matching, les switch doivent \u00eatre exhaustifs ; c\u2019est-\u00e0-dire qu\u2019ils doivent g\u00e9rer toutes les valeurs possibles du selector.</p> <p>Cela peut \u00eatre r\u00e9alis\u00e9 en :</p> <ul> <li>Fournissant un case <code>default</code> qui g\u00e8re toutes les valeurs non correspondantes aux autres cases.</li> <li> <p>Fournissant une clause case finale avec un type de pattern qui correspond au type de r\u00e9f\u00e9rence du selector.</p> </li> <li> <p>Exemple (non exhaustif) :</p> </li> </ul> <pre><code>Number number = Short.valueOf(10);\n\nswitch (number) {\n    case Short s -&gt; System.out.println(\"A\"); // \u274c DOES NOT COMPILE: not exhaustive, selector is of type Number\n}\n</code></pre> <p>Pour corriger cela, vous pouvez :</p> <ul> <li>Changer le type de r\u00e9f\u00e9rence de <code>number</code> en <code>Short</code> (l\u2019exhaustivit\u00e9 est alors satisfaite par le seul case).</li> <li>Ajouter une clause <code>default</code> qui couvre toutes les valeurs restantes.</li> <li>Ajouter une clause case finale couvrant le type de la variable selector, par exemple :</li> </ul> <pre><code>Number number = Short.valueOf(10);\n\nswitch (number) {\n    case Short s -&gt; System.out.println(\"A\");\n    case Number n -&gt; System.out.println(\"B\");\n}\n</code></pre> <p>Warning</p> <p>L\u2019exemple suivant, qui utilise \u00e0 la fois une clause <code>default</code> et une clause finale avec le m\u00eame type que la variable selector, ne compile pas : le compilateur consid\u00e8re l\u2019un des deux cases comme dominant toujours l\u2019autre.</p> <pre><code>Number number = Short.valueOf(10);\n\nswitch (number) {\n    case Short s -&gt; System.out.println(\"A\");\n    case Number n -&gt; System.out.println(\"B\"); // \u274c DOES NOT COMPILE: dominated by either the default or the Number pattern\n    default -&gt; System.out.println(\"C\");\n}\n</code></pre> <p></p>"},{"location":"fr/module-02/control-flow/#73-deux-formes-de-switch-switch-statement-vs-switch-expression","title":"7.3 Deux formes de <code>switch</code> : <code>switch</code> Statement vs <code>switch</code> Expression","text":""},{"location":"fr/module-02/control-flow/#731-linstruction-switch","title":"7.3.1 L\u2019instruction switch","text":"<p>Une instruction switch est utilis\u00e9e comme construction de contr\u00f4le du flux.</p> <p>Elle ne s\u2019\u00e9value pas, en elle-m\u00eame, comme une valeur, bien que ses branches puissent contenir des instructions <code>return</code> qui retournent depuis la m\u00e9thode englobante.</p> <pre><code>switch (mode) { // switch statement\n    case \"ON\":\n        start();\n        break; // prevents fall-through\n    case \"OFF\":\n        stop();\n        break;\n    default:\n        reset();\n}\n</code></pre> <p>Points cl\u00e9s :</p> <ul> <li>Chaque clause <code>case</code> inclut une ou plusieurs valeurs correspondantes s\u00e9par\u00e9es par des virgules <code>,</code>. Un s\u00e9parateur suit, qui peut \u00eatre soit deux-points <code>:</code> soit, moins couramment pour les instructions, l\u2019op\u00e9rateur fl\u00e8che <code>-&gt;</code>. Enfin, une expression ou un bloc (entour\u00e9 de <code>{}</code>) d\u00e9finit le code \u00e0 ex\u00e9cuter lorsqu\u2019une correspondance se produit. Si vous utilisez l\u2019op\u00e9rateur fl\u00e8che pour une clause, vous devez l\u2019utiliser pour toutes les clauses de cette instruction switch.</li> <li>Le fall-through est possible pour les case de style deux-points \u00e0 moins qu\u2019une branche utilise <code>break</code>, <code>return</code> ou <code>throw</code>. Lorsqu\u2019il est pr\u00e9sent, <code>break</code> termine le switch apr\u00e8s l\u2019ex\u00e9cution de son case ; sans lui, l\u2019ex\u00e9cution continue, dans l\u2019ordre, vers les branches suivantes.</li> <li>Une clause <code>default</code> est optionnelle et peut appara\u00eetre n\u2019importe o\u00f9 dans l\u2019instruction switch. Elle s\u2019ex\u00e9cute s\u2019il n\u2019y a pas de correspondance pour les cases pr\u00e9c\u00e9dents.</li> <li>Une instruction switch ne produit pas de valeur comme une expression ; vous ne pouvez pas assigner directement une instruction switch \u00e0 une variable.</li> </ul> <p></p>"},{"location":"fr/module-02/control-flow/#7311-comportement-de-fall-through","title":"7.3.1.1 Comportement de fall-through","text":"<p>Avec des case de style deux-points, l\u2019ex\u00e9cution saute \u00e0 l\u2019\u00e9tiquette case correspondante.</p> <p>S\u2019il n\u2019y a pas de <code>break</code>, elle continue dans le case suivant jusqu\u2019\u00e0 ce qu\u2019un <code>break</code>, <code>return</code> ou <code>throw</code> soit rencontr\u00e9.</p> <pre><code>int n = 2;\n\nswitch (n) {\n    case 1:\n        System.out.println(\"1\");\n    case 2:\n        System.out.println(\"2\"); // printed\n    case 3:\n        System.out.println(\"3\"); // printed (fall-through)\n        break;\n    default:\n        System.out.println(\"message default\");\n}\n</code></pre> <p>Sortie :</p> <pre><code>2\n3\n</code></pre> <p>Note</p> <p>Si, dans l\u2019exemple pr\u00e9c\u00e9dent, nous supprimons le <code>break</code> sur le <code>case 3</code>, le message de la branche <code>default</code> sera \u00e9galement affich\u00e9.</p> <p></p>"},{"location":"fr/module-02/control-flow/#732-lexpression-switch","title":"7.3.2 L\u2019expression switch","text":"<p>Une expression switch produit toujours une valeur unique comme r\u00e9sultat.</p> <ul> <li>Exemple :</li> </ul> <pre><code>int len = switch (s) { // switch expression\n    case null -&gt; 0;\n    case \"\" -&gt; 0;\n    default -&gt; s.length();\n};\n</code></pre> <p>Points cl\u00e9s :</p> <ul> <li>Chaque clause <code>case</code> inclut une ou plusieurs valeurs correspondantes s\u00e9par\u00e9es par des virgules <code>,</code>, suivies de l\u2019op\u00e9rateur fl\u00e8che <code>-&gt;</code>. Puis une expression ou un bloc (entour\u00e9 de <code>{}</code>) d\u00e9finit le r\u00e9sultat pour cet arm.</li> <li>Lorsqu\u2019elle est utilis\u00e9e avec une assignation ou une instruction <code>return</code>, une expression switch n\u00e9cessite un point-virgule de terminaison <code>;</code> apr\u00e8s l\u2019expression.</li> <li>Il n\u2019y a pas de fall-through entre les arms avec fl\u00e8che. Chaque arm correspondant est ex\u00e9cut\u00e9 exactement une fois.</li> <li>Une expression switch doit \u00eatre exhaustive : toutes les valeurs possibles du selector doivent \u00eatre couvertes (via des case explicites et/ou <code>default</code>).</li> <li>Le type du r\u00e9sultat doit \u00eatre coh\u00e9rent entre toutes les branches. Par exemple, si un arm produit un <code>int</code>, les autres arms doivent produire des valeurs compatibles avec <code>int</code>.</li> </ul> <p></p>"},{"location":"fr/module-02/control-flow/#7321-yield-dans-les-blocs-dexpression-switch","title":"7.3.2.1 <code>yield</code> dans les blocs d\u2019expression switch","text":"<p>Lorsqu\u2019un arm d\u2019une expression switch utilise un bloc au lieu d\u2019une expression unique, vous devez utiliser <code>yield</code> pour fournir le r\u00e9sultat de cet arm.</p> <pre><code>int len = switch (s) {\n    case null -&gt; 0;\n    default -&gt; {\n        int l = s.trim().length();\n        System.out.println(\"Length: \" + l);\n        yield l; // result of this arm\n    }\n};\n</code></pre> <p>Note</p> <p><code>yield</code> est utilis\u00e9 uniquement dans les expressions switch. <code>break value;</code> n\u2019est pas autoris\u00e9 comme moyen de retourner une valeur depuis une expression switch.</p> <p></p>"},{"location":"fr/module-02/control-flow/#7322-exhaustivite-pour-les-expressions-switch","title":"7.3.2.2 Exhaustivit\u00e9 pour les expressions switch","text":"<p>Puisqu\u2019une expression switch doit retourner une valeur, elle doit \u00e9galement \u00eatre exhaustive ; en d\u2019autres termes, elle doit g\u00e9rer toutes les valeurs possibles du selector.</p> <p>Vous pouvez garantir cela en :</p> <ul> <li>Fournissant un case <code>default</code>.</li> <li>Pour un selector enum : couvrant explicitement toutes les constantes enum.</li> <li>Pour des types sealed ou des pattern switch : couvrant tous les sous-types autoris\u00e9s ou fournissant un <code>default</code>.</li> </ul> <p>Exemple, exhaustif via <code>default</code> :</p> <pre><code>int val = switch (s) {\n    case \"one\" -&gt; 1;\n    case \"two\" -&gt; 2;\n    default -&gt; 0;\n};\n</code></pre> <p></p>"},{"location":"fr/module-02/control-flow/#74-gestion-de-null","title":"7.4 Gestion de null","text":"<p>Switch classique (sans patterns)</p> <p>Si l\u2019expression selector d\u2019un switch classique (sans pattern matching) est \u00e9valu\u00e9e \u00e0 <code>null</code>, une <code>NullPointerException</code> est lev\u00e9e \u00e0 l\u2019ex\u00e9cution.</p> <p>Pour \u00e9viter cela, v\u00e9rifiez <code>null</code> avant d\u2019effectuer le switch :</p> <pre><code>if (s == null) {\n    // handle null\n} else {\n    switch (s) {\n        case \"A\" -&gt; ...\n        default -&gt; ...\n    }\n}\n</code></pre> <p>Pattern switch (avec <code>case null</code>)</p> <p>Avec le pattern matching, vous pouvez g\u00e9rer <code>null</code> directement \u00e0 l\u2019int\u00e9rieur du switch :</p> <pre><code>int len = switch (s) {\n    case null -&gt; 0;\n    default -&gt; s.length();\n};\n</code></pre> <p>Note</p> <p>Pour les expressions switch :</p> <p>Si vous ne g\u00e9rez pas <code>null</code> et que le selector est <code>null</code>, une <code>NullPointerException</code> est lev\u00e9e.</p> <p>L\u2019utilisation de <code>case null</code> rend le switch explicitement s\u00fbr vis-\u00e0-vis de null.</p> <p>Warning</p> <p>Chaque fois que <code>case null</code> est utilis\u00e9 dans un switch, le switch est trait\u00e9 comme un pattern switch, et toutes les r\u00e8gles applicables aux pattern switch (y compris l\u2019exhaustivit\u00e9 et la dominance) s\u2019appliquent.</p>"},{"location":"fr/module-02/loops/","title":"8. Constructions de boucle en Java","text":""},{"location":"fr/module-02/loops/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>8.1 La boucle while</li> <li>8.2 La boucle do-while</li> <li>8.3 La boucle for</li> <li>8.4 La boucle for-each am\u00e9lior\u00e9e</li> <li>8.5 Boucles imbriqu\u00e9es</li> <li>8.6 Boucles infinies</li> <li>8.7 break et continue</li> <li>8.8 Boucles \u00e9tiquet\u00e9es</li> <li>8.9 Port\u00e9e des variables de boucle</li> <li>8.10 Code inatteignable apr\u00e8s break continue et return<ul> <li>8.10.1 Code inatteignable apr\u00e8s break</li> <li>8.10.2 Code inatteignable apr\u00e8s continue</li> <li>8.10.3 Code inatteignable apr\u00e8s return</li> </ul> </li> </ul> <p>Java fournit plusieurs constructions de boucle qui permettent l\u2019ex\u00e9cution r\u00e9p\u00e9t\u00e9e d\u2019un bloc de code tant qu\u2019une condition est v\u00e9rifi\u00e9e.</p> <p>Les boucles sont essentielles pour l\u2019it\u00e9ration, le parcours de structures de donn\u00e9es, les calculs r\u00e9p\u00e9titifs et l\u2019impl\u00e9mentation d\u2019algorithmes.</p> <p></p>"},{"location":"fr/module-02/loops/#81-la-boucle-while","title":"8.1 La boucle <code>while</code>","text":"<p>La boucle <code>while</code> \u00e9value sa condition bool\u00e9enne avant chaque it\u00e9ration. Si la condition est <code>false</code> d\u00e8s le d\u00e9but, le corps n\u2019est jamais ex\u00e9cut\u00e9.</p> <p>Syntaxe <pre><code>while (condition) {\n    // loop body\n}\n</code></pre></p> <ul> <li>La condition doit \u00eatre \u00e9valu\u00e9e comme un bool\u00e9en.</li> <li>La boucle peut s\u2019ex\u00e9cuter z\u00e9ro ou plusieurs fois.</li> <li> <p>Les erreurs courantes incluent l\u2019oubli de mettre \u00e0 jour la variable de boucle, provoquant une boucle infinie.</p> </li> <li> <p>Exemple : <pre><code>int i = 0;\nwhile (i &lt; 3) {\n    System.out.println(i);\n    i++;\n}\n</code></pre></p> </li> </ul> <p>Sortie : <pre><code>0\n1\n2\n</code></pre></p> <p></p>"},{"location":"fr/module-02/loops/#82-la-boucle-do-while","title":"8.2 La boucle <code>do-while</code>","text":"<p>La boucle <code>do-while</code> \u00e9value sa condition apr\u00e8s l\u2019ex\u00e9cution du corps, garantissant que le corps s\u2019ex\u00e9cute au moins une fois.</p> <p>Syntaxe <pre><code>do {\n    // loop body\n} while (condition);\n</code></pre></p> <p>Tip</p> <p><code>do-while</code> n\u00e9cessite un point-virgule apr\u00e8s la parenth\u00e8se fermante.</p> <ul> <li>Exemple : <pre><code>int x = 5;\ndo {\n    System.out.println(x);\n    x--;\n} while (x &gt; 5); // body runs once even though condition is false\n</code></pre></li> </ul> <p>Sortie : <pre><code>5\n</code></pre></p> <p></p>"},{"location":"fr/module-02/loops/#83-la-boucle-for","title":"8.3 La boucle <code>for</code>","text":"<p>La boucle <code>for</code> traditionnelle convient le mieux aux boucles avec une variable compteur. Elle se compose de trois parties : initialisation, condition, mise \u00e0 jour.</p> <p>Syntaxe <pre><code>for (initialization; condition; update) {\n    // loop body\n}\n</code></pre></p> <ul> <li>L\u2019initialisation s\u2019ex\u00e9cute une fois avant le d\u00e9but de la boucle.</li> <li>La condition est \u00e9valu\u00e9e avant chaque it\u00e9ration.</li> <li>La mise \u00e0 jour s\u2019ex\u00e9cute apr\u00e8s chaque it\u00e9ration.</li> <li>L\u2019initialisation et la mise \u00e0 jour peuvent contenir plusieurs instructions s\u00e9par\u00e9es par des virgules.</li> <li>Les variables dans l\u2019initialisation doivent toutes \u00eatre du m\u00eame type.</li> <li> <p>Tout composant peut \u00eatre omis, mais les points-virgules restent.</p> </li> <li> <p>Exemple : <pre><code>for (int i = 0; i &lt; 3; i++) {\n    System.out.println(i);\n}\n</code></pre></p> </li> </ul> <p>Omission de parties : <pre><code>int j = 0;\nfor (; j &lt; 3;) {  // valid\n    j++;\n}\n</code></pre></p> <p>Instructions multiples : <pre><code>int x = 0;\nfor (long i = 0, c = 3; x &lt; 3 &amp;&amp; i &lt; 12; x++, i++) {\n    System.out.println(i);\n}\n</code></pre></p> <p></p>"},{"location":"fr/module-02/loops/#84-la-boucle-for-each-amelioree","title":"8.4 La boucle <code>for-each</code> am\u00e9lior\u00e9e","text":"<p>Le <code>for</code> am\u00e9lior\u00e9 simplifie l\u2019it\u00e9ration sur les tableaux et les collections.</p> <p>Syntaxe <pre><code>for (ElementType var : arrayOrCollection) {\n    // loop body\n}\n</code></pre></p> <ul> <li>La variable de boucle est en lecture seule par rapport \u00e0 la collection sous-jacente.</li> <li>Fonctionne avec n\u2019importe quel <code>Iterable</code> ou tableau.</li> <li> <p>Ne peut pas supprimer des \u00e9l\u00e9ments sans it\u00e9rateur.</p> </li> <li> <p>Exemple : <pre><code>String[] names = {\"A\", \"B\", \"C\"};\nfor (String n : names) {\n    System.out.println(n);\n}\n</code></pre></p> </li> </ul> <p>Sortie : <pre><code>A\nB\nC\n</code></pre></p> <p></p>"},{"location":"fr/module-02/loops/#85-boucles-imbriquees","title":"8.5 Boucles imbriqu\u00e9es","text":"<p>Les boucles peuvent \u00eatre imbriqu\u00e9es ; chacune conserve ses propres variables et conditions.</p> <pre><code>for (int i = 1; i &lt;= 2; i++) {\n    for (int j = 1; j &lt;= 3; j++) {\n        System.out.println(i + \",\" + j);\n    }\n}\n</code></pre> <p>Sortie : <pre><code>1,1\n1,2\n1,3\n2,1\n2,2\n2,3\n</code></pre></p> <p></p>"},{"location":"fr/module-02/loops/#86-boucles-infinies","title":"8.6 Boucles infinies","text":"<p>Une boucle est infinie lorsque sa condition est toujours \u00e9valu\u00e9e \u00e0 <code>true</code> ou est omise.</p> <pre><code>while (true) { ... }\n</code></pre> <pre><code>for (;;) { ... }\n</code></pre> <p>Tip</p> <p>Les boucles infinies doivent contenir <code>break</code>, <code>return</code> ou un contr\u00f4le externe.</p> <p></p>"},{"location":"fr/module-02/loops/#87-break-et-continue","title":"8.7 <code>break</code> et <code>continue</code>","text":"<p>break Quitte imm\u00e9diatement la boucle la plus interne. <pre><code>for (int i = 0; i &lt; 5; i++) {\n    if (i == 2) break;\n    System.out.println(i);\n}\n</code></pre></p> <p>continue Saute le reste du corps de la boucle et passe \u00e0 l\u2019it\u00e9ration suivante. <pre><code>for (int i = 0; i &lt; 5; i++) {\n    if (i % 2 == 0) continue;\n    System.out.println(i);\n}\n</code></pre></p> <p>Note</p> <p><code>break</code> et <code>continue</code> s\u2019appliquent \u00e0 la boucle la plus proche \u00e0 moins que des \u00e9tiquettes ne soient utilis\u00e9es.</p> <p></p>"},{"location":"fr/module-02/loops/#88-boucles-etiquetees","title":"8.8 Boucles \u00e9tiquet\u00e9es","text":"<p>Une \u00e9tiquette (identifiant + deux-points) peut \u00eatre appliqu\u00e9e \u00e0 une boucle pour permettre \u00e0 break/continue d\u2019affecter les boucles externes.</p> <pre><code>labelName:\nfor (...) {\n    for (...) {\n        break labelName;\n    }\n}\n</code></pre> <ul> <li>Exemple : <pre><code>outer:\nfor (int i = 1; i &lt;= 3; i++) {\n    for (int j = 1; j &lt;= 3; j++) {\n        if (j == 2) break outer;\n        System.out.println(i + \",\" + j);\n    }\n}\n</code></pre></li> </ul> <p></p>"},{"location":"fr/module-02/loops/#89-portee-des-variables-de-boucle","title":"8.9 Port\u00e9e des variables de boucle","text":"<ul> <li>Les variables d\u00e9clar\u00e9es dans l\u2019en-t\u00eate de la boucle sont limit\u00e9es \u00e0 la port\u00e9e de cette boucle.</li> <li>Les variables d\u00e9clar\u00e9es \u00e0 l\u2019int\u00e9rieur du corps existent uniquement \u00e0 l\u2019int\u00e9rieur de ce bloc.</li> </ul> <pre><code>for (int i = 0; i &lt; 3; i++) {\n    int x = i * 2;\n}\n// i and x are not accessible here\n</code></pre>"},{"location":"fr/module-02/loops/#810-code-inatteignable-apres-break-continue-et-return","title":"8.10 Code inatteignable apr\u00e8s <code>break</code>, <code>continue</code> et <code>return</code>","text":"<p>Toute instruction plac\u00e9e apr\u00e8s <code>break</code>, <code>continue</code> ou <code>return</code> dans le m\u00eame bloc est consid\u00e9r\u00e9e comme inatteignable et ne compile pas.</p> <p></p>"},{"location":"fr/module-02/loops/#8101-code-inatteignable-apres-break","title":"8.10.1 Code inatteignable apr\u00e8s <code>break</code>","text":"<pre><code>for (int i = 0; i &lt; 3; i++) {\n    break;\n    System.out.println(\"Unreachable\"); // \u274c Compile-time error\n}\n</code></pre>"},{"location":"fr/module-02/loops/#8102-code-inatteignable-apres-continue","title":"8.10.2 Code inatteignable apr\u00e8s <code>continue</code>","text":"<pre><code>for (int i = 0; i &lt; 3; i++) {\n    continue;\n    System.out.println(\"Unreachable\"); // \u274c Compile-time error\n}\n</code></pre> <p>Note</p> <p><code>continue</code> saute \u00e0 l\u2019it\u00e9ration suivante, donc le code qui suit n\u2019est jamais ex\u00e9cut\u00e9.</p> <p></p>"},{"location":"fr/module-02/loops/#8103-code-inatteignable-apres-return","title":"8.10.3 Code inatteignable apr\u00e8s <code>return</code>","text":"<pre><code>int test() {\n    return 5;\n    System.out.println(\"Unreachable\"); // \u274c Compile-time error\n}\n</code></pre> <p>Note</p> <p><code>return</code> quitte la m\u00e9thode imm\u00e9diatement ; aucune instruction ne peut le suivre.</p>"},{"location":"fr/module-03/arrays/","title":"10. Tableaux en Java","text":""},{"location":"fr/module-03/arrays/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>10.1 Ce qu\u2019est un tableau<ul> <li>10.1.1 D\u00e9clarer des tableaux</li> <li>10.1.2 Cr\u00e9er des tableaux (instanciation)</li> <li>10.1.3 Valeurs par d\u00e9faut dans les tableaux</li> <li>10.1.4 Acc\u00e9der aux \u00e9l\u00e9ments</li> <li>10.1.5 Raccourcis d\u2019initialisation de tableaux<ul> <li>10.1.5.1 Cr\u00e9ation anonyme de tableau</li> <li>10.1.5.2 Syntaxe courte (uniquement \u00e0 la d\u00e9claration)</li> </ul> </li> </ul> </li> <li>10.2 Tableaux multidimensionnels (tableaux de tableaux)<ul> <li>10.2.1 Cr\u00e9er un tableau rectangulaire</li> <li>10.2.2 Cr\u00e9er un tableau dentel\u00e9 (irr\u00e9gulier)</li> </ul> </li> <li>10.3 Longueur d\u2019un tableau vs longueur d\u2019une cha\u00eene</li> <li>10.4 Affectations de r\u00e9f\u00e9rences de tableaux<ul> <li>10.4.1 Affecter des r\u00e9f\u00e9rences compatibles</li> <li>10.4.2 Affectations incompatibles (erreurs \u00e0 la compilation)</li> <li>10.4.3 Danger d\u2019ex\u00e9cution de la covariance : ArrayStoreException</li> </ul> </li> <li>10.5 Comparer des tableaux</li> <li>10.6 M\u00e9thodes utilitaires de Arrays<ul> <li>10.6.1 Arrays.toString</li> <li>10.6.2 Arrays.deepToString pour les tableaux imbriqu\u00e9s</li> <li>10.6.3 Arrays.sort</li> <li>10.6.4 Arrays.binarySearch</li> <li>10.6.5 Arrays.compare</li> </ul> </li> <li>10.7 Boucle for am\u00e9lior\u00e9e avec les tableaux</li> <li>10.8 Pi\u00e8ges courants</li> <li>10.9 R\u00e9sum\u00e9</li> </ul>"},{"location":"fr/module-03/arrays/#101-ce-quest-un-tableau","title":"10.1 Ce qu\u2019est un tableau","text":"<p>Les tableaux en Java sont des collections \u00e0 taille fixe, index\u00e9es, ordonn\u00e9es d\u2019\u00e9l\u00e9ments du m\u00eame type.</p> <p>Ce sont des objets, m\u00eame lorsque les \u00e9l\u00e9ments sont des primitifs.</p> <p></p>"},{"location":"fr/module-03/arrays/#1011-declarer-des-tableaux","title":"10.1.1 D\u00e9clarer des tableaux","text":"<p>Vous pouvez d\u00e9clarer un tableau de deux fa\u00e7ons :</p> <pre><code>int[] a;      // preferred modern syntax\nint b[];      // legal, older style\nString[] names;\nPerson[] people;\n\n// [] can be before or after the name: all the following declarations are equivalent.\n\nint[] x;\nint [] x1;\nint []x2;\nint x3[];\nint x5 [];\n\n// MULTIPLE ARRAY DECLARATIONS\n\nint[] arr1, arr2;   // Declares two arrays of int\n\n// WARNING:\n// Here arr1 is an int[] and arr2 is just an int (NOT an array!)\nint arr1[], arr2;\n</code></pre> <p>D\u00e9clarer ne cr\u00e9e PAS le tableau \u2014 cela cr\u00e9e seulement une variable capable d\u2019en r\u00e9f\u00e9rencer un.</p> <p></p>"},{"location":"fr/module-03/arrays/#1012-creer-des-tableaux-instanciation","title":"10.1.2 Cr\u00e9er des tableaux (instanciation)","text":"<p>Un tableau est cr\u00e9\u00e9 en utilisant <code>new</code> suivi du type des \u00e9l\u00e9ments et de la longueur du tableau :</p> <pre><code>int[] numbers = new int[5];\nString[] words = new String[3];\n</code></pre> <p>R\u00e8gles cl\u00e9s - La longueur doit \u00eatre non n\u00e9gative et sp\u00e9cifi\u00e9e au moment de la cr\u00e9ation. - La longueur ne peut pas \u00eatre modifi\u00e9e ensuite. - La longueur du tableau peut \u00eatre n\u2019importe quelle expression <code>int</code>.</p> <pre><code>int size = 4;\ndouble[] values = new double[size];\n</code></pre> <ul> <li>Exemples ill\u00e9gaux de cr\u00e9ation de tableau :</li> </ul> <pre><code>// int length = -1;           \n// int[] arr = new int[-1];   // Runtime: NegativeArraySizeException\n\n// int[] arr = new int[2.5];  // Compile error: size must be int\n</code></pre> <p></p>"},{"location":"fr/module-03/arrays/#1013-valeurs-par-defaut-dans-les-tableaux","title":"10.1.3 Valeurs par d\u00e9faut dans les tableaux","text":"<p>Les tableaux (puisque ce sont des objets) re\u00e7oivent toujours une initialisation par d\u00e9faut :</p> Type d\u2019\u00e9l\u00e9ment Valeur par d\u00e9faut Num\u00e9rique 0 boolean false char '\\u0000' Types r\u00e9f\u00e9rence null <ul> <li>Exemple :</li> </ul> <pre><code>int[] nums = new int[3]; \nSystem.out.println(nums[0]); // 0\n\nString[] s = new String[3];\nSystem.out.println(s[0]);    // null\n</code></pre> <p></p>"},{"location":"fr/module-03/arrays/#1014-acceder-aux-elements","title":"10.1.4 Acc\u00e9der aux \u00e9l\u00e9ments","text":"<p>On acc\u00e8de aux \u00e9l\u00e9ments en utilisant une indexation \u00e0 base z\u00e9ro :</p> <pre><code>int[] a = new int[3];\na[0] = 10;\na[1] = 20;\nSystem.out.println(a[1]); // 20\n</code></pre> <p>Exception courante - <code>ArrayIndexOutOfBoundsException</code> (\u00e0 l\u2019ex\u00e9cution)</p> <pre><code>// int[] x = new int[2];\n// System.out.println(x[2]); // \u274c index 2 out of bounds\n</code></pre> <p></p>"},{"location":"fr/module-03/arrays/#1015-raccourcis-dinitialisation-de-tableaux","title":"10.1.5 Raccourcis d\u2019initialisation de tableaux","text":""},{"location":"fr/module-03/arrays/#10151-creation-anonyme-de-tableau","title":"10.1.5.1 Cr\u00e9ation anonyme de tableau","text":"<pre><code>int[] a = new int[] {1,2,3};\n</code></pre>"},{"location":"fr/module-03/arrays/#10152-syntaxe-courte-uniquement-a-la-declaration","title":"10.1.5.2 Syntaxe courte (uniquement \u00e0 la d\u00e9claration)","text":"<pre><code>int[] b = {1,2,3};\n</code></pre> <p>La syntaxe courte <code>{1,2,3}</code> ne peut \u00eatre utilis\u00e9e qu\u2019au moment de la d\u00e9claration.</p> <pre><code>// int[] c;\n// c = {1,2,3};  // \u274c does not compile\n</code></pre> <p></p>"},{"location":"fr/module-03/arrays/#102-tableaux-multidimensionnels-tableaux-de-tableaux","title":"10.2 Tableaux multidimensionnels (tableaux de tableaux)","text":"<p>Java impl\u00e9mente les tableaux multi-dimensionnels comme des tableaux de tableaux.</p> <p>D\u00e9claration :</p> <pre><code>int[][] matrix;\nString[][][] cube;\n</code></pre> <p></p>"},{"location":"fr/module-03/arrays/#1021-creer-un-tableau-rectangulaire","title":"10.2.1 Cr\u00e9er un tableau rectangulaire","text":"<pre><code>int[][] rect = new int[3][4]; // 3 rows, 4 columns each\n</code></pre>"},{"location":"fr/module-03/arrays/#1022-creer-un-tableau-dentele-irregulier","title":"10.2.2 Cr\u00e9er un tableau dentel\u00e9 (irr\u00e9gulier)","text":"<p>Vous pouvez cr\u00e9er des lignes de longueurs diff\u00e9rentes :</p> <pre><code>int[][] jagged = new int[3][];\njagged[0] = new int[2];\njagged[1] = new int[5];\njagged[2] = new int[1];\n</code></pre> <p></p>"},{"location":"fr/module-03/arrays/#103-longueur-dun-tableau-vs-longueur-dune-chaine","title":"10.3 Longueur d\u2019un tableau vs longueur d\u2019une cha\u00eene","text":"<ul> <li>Les tableaux utilisent <code>.length</code> (champ <code>public final</code>).</li> <li>Les cha\u00eenes utilisent <code>.length()</code> (m\u00e9thode).</li> </ul> <p>Tip</p> <p>C\u2019est un pi\u00e8ge classique: champs vs m\u00e9thodes.</p> <pre><code>// int x = arr.length;   // OK\n// int y = s.length;     // \u274c does not compile: missing ()\nint yOk = s.length();\n</code></pre> <p></p>"},{"location":"fr/module-03/arrays/#104-affectations-de-references-de-tableaux","title":"10.4 Affectations de r\u00e9f\u00e9rences de tableaux","text":""},{"location":"fr/module-03/arrays/#1041-affecter-des-references-compatibles","title":"10.4.1 Affecter des r\u00e9f\u00e9rences compatibles","text":"<pre><code>int[] a = {1,2,3};\nint[] b = a; // both now point to the same array\n</code></pre> <p>Modifier une r\u00e9f\u00e9rence affecte l\u2019autre :</p> <pre><code>b[0] = 99;\nSystem.out.println(a[0]); // 99\n</code></pre> <p></p>"},{"location":"fr/module-03/arrays/#1042-affectations-incompatibles-erreurs-a-la-compilation","title":"10.4.2 Affectations incompatibles (erreurs \u00e0 la compilation)","text":"<pre><code>// int[] x = new int[3];\n// long[] y = x;     // \u274c incompatible types\n</code></pre> <p>Les r\u00e9f\u00e9rences de tableaux suivent les r\u00e8gles normales d\u2019h\u00e9ritage :</p> <pre><code>String[] s = new String[3];\nObject[] o = s;      // OK: arrays are covariant\n</code></pre> <p></p>"},{"location":"fr/module-03/arrays/#1043-danger-dexecution-de-la-covariance-arraystoreexception","title":"10.4.3 Danger d\u2019ex\u00e9cution de la covariance : <code>ArrayStoreException</code>","text":"<pre><code>Object[] objs = new String[3];\n// objs[0] = Integer.valueOf(5); // \u274c ArrayStoreException at runtime\n</code></pre>"},{"location":"fr/module-03/arrays/#105-comparer-des-tableaux","title":"10.5 Comparer des tableaux","text":"<p><code>==</code> compare les r\u00e9f\u00e9rences (identit\u00e9) :</p> <pre><code>int[] a = {1,2};\nint[] b = {1,2};\nSystem.out.println(a == b); // false\n</code></pre> <p><code>equals()</code> sur les tableaux ne compare pas le contenu (il se comporte comme <code>==</code>) :</p> <pre><code>System.out.println(a.equals(b)); // false\n</code></pre> <p>Pour comparer le contenu, utilisez des m\u00e9thodes de <code>java.util.Arrays</code> :</p> <pre><code>Arrays.equals(a, b);         // shallow comparison\nArrays.deepEquals(o1, o2);   // deep comparison for nested arrays\n</code></pre> <p></p>"},{"location":"fr/module-03/arrays/#106-methodes-utilitaires-de-arrays","title":"10.6 M\u00e9thodes utilitaires de <code>Arrays</code>","text":""},{"location":"fr/module-03/arrays/#1061-arraystostring","title":"10.6.1 <code>Arrays.toString()</code>","text":"<pre><code>System.out.println(Arrays.toString(new int[]{1,2,3})); // [1, 2, 3]\n</code></pre>"},{"location":"fr/module-03/arrays/#1062-arraysdeeptostring-pour-les-tableaux-imbriques","title":"10.6.2 <code>Arrays.deepToString()</code> (pour les tableaux imbriqu\u00e9s)","text":"<pre><code>System.out.println(Arrays.deepToString(new int[][] {{1,2},{3,4}}));\n// [[1, 2], [3, 4]]\n</code></pre>"},{"location":"fr/module-03/arrays/#1063-arrayssort","title":"10.6.3 <code>Arrays.sort()</code>","text":"<pre><code>int[] a = {4,1,3};\nArrays.sort(a); // [1, 3, 4]\n</code></pre> <p>Tip</p> <ul> <li>Les cha\u00eenes sont tri\u00e9es selon l\u2019ordre naturel (lexicographique).</li> <li>Les nombres sont tri\u00e9s avant les lettres, et les lettres majuscules sont tri\u00e9es avant les minuscules (nombres &lt; majuscules &lt; minuscules).</li> <li>Pour les types r\u00e9f\u00e9rence, <code>null</code> est consid\u00e9r\u00e9 plus petit que toute valeur non nulle.</li> </ul> <pre><code>String[] arr = {\"AB\", \"ac\", \"Ba\", \"bA\", \"10\", \"99\"};\n\nArrays.sort(arr);\n\nSystem.out.println(Arrays.toString(arr));  // [10, 99, AB, Ba, ac, bA]\n</code></pre> <p></p>"},{"location":"fr/module-03/arrays/#1064-arraysbinarysearch","title":"10.6.4 <code>Arrays.binarySearch()</code>","text":"<p>Exigences : le tableau doit \u00eatre tri\u00e9 selon le m\u00eame ordre ; sinon le r\u00e9sultat est impr\u00e9visible.</p> <pre><code>int[] a = {1,3,5,7};\nint idx = Arrays.binarySearch(a, 5); // returns 2\n</code></pre> <p>Quand la valeur n\u2019est pas trouv\u00e9e, <code>binarySearch</code> renvoie <code>-(insertionPoint) - 1</code> :</p> <pre><code>int pos = Arrays.binarySearch(a, 4); // returns -3\n// Insertion point is index 2 \u2192 -(2) - 1 = -3\n</code></pre> <p></p>"},{"location":"fr/module-03/arrays/#1065-arrayscompare","title":"10.6.5 <code>Arrays.compare()</code>","text":"<p>La classe <code>Arrays</code> propose un <code>equals()</code> surcharg\u00e9 qui v\u00e9rifie si deux tableaux contiennent les m\u00eames \u00e9l\u00e9ments (et ont la m\u00eame longueur) :</p> <pre><code>System.out.println(Arrays.equals(new int[] {200}, new int[] {100}));        // false\nSystem.out.println(Arrays.equals(new int[] {200}, new int[] {200}));        // true\nSystem.out.println(Arrays.equals(new int[] {200}, new int[] {100, 200}));   // false\n</code></pre> <p>Elle fournit aussi une m\u00e9thode <code>compare()</code> avec ces r\u00e8gles :</p> <ul> <li>Si le r\u00e9sultat <code>n &lt; 0</code> \u2192 le premier tableau est consid\u00e9r\u00e9 \u201cplus petit\u201d que le second.</li> <li>Si le r\u00e9sultat <code>n &gt; 0</code> \u2192 le premier tableau est consid\u00e9r\u00e9 \u201cplus grand\u201d que le second.</li> <li> <p>Si le r\u00e9sultat <code>n == 0</code> \u2192 les tableaux sont \u00e9gaux.</p> </li> <li> <p>Exemples :</p> </li> </ul> <pre><code>int[] arr1 = new int[] {200, 300};\nint[] arr2 = new int[] {200, 300, 400};\nSystem.out.println(Arrays.compare(arr1, arr2));  // -1\n\nint[] arr3 = new int[] {200, 300, 400};\nint[] arr4 = new int[] {200, 300};\nSystem.out.println(Arrays.compare(arr3, arr4));  // 1\n\nString[] arr5 = new String[] {\"200\", \"300\", \"aBB\"};\nString[] arr6 = new String[] {\"200\", \"300\", \"ABB\"};\nSystem.out.println(Arrays.compare(arr5, arr6));     // Positive: \"aBB\" &gt; \"ABB\"\n\nString[] arr7 = new String[] {\"200\", \"300\", \"ABB\"};\nString[] arr8 = new String[] {\"200\", \"300\", \"aBB\"};\nSystem.out.println(Arrays.compare(arr7, arr8));     // Negative: \"ABB\" &lt; \"aBB\"\n\nString[] arr9 = null;\nString[] arr10 = new String[] {\"200\", \"300\", \"ABB\"};\nSystem.out.println(Arrays.compare(arr9, arr10));    // -1 (null considered smaller)\n</code></pre> <p></p>"},{"location":"fr/module-03/arrays/#107-boucle-for-amelioree-avec-les-tableaux","title":"10.7 Boucle for am\u00e9lior\u00e9e avec les tableaux","text":"<pre><code>for (int value : new int[]{1,2,3}) {\n    System.out.println(value);\n}\n</code></pre> <p>R\u00e8gles - Le c\u00f4t\u00e9 droit doit \u00eatre un tableau ou un <code>Iterable</code>. - Le type de la variable de boucle doit \u00eatre compatible avec le type d\u2019\u00e9l\u00e9ment (pas d\u2019\u00e9largissement de primitifs ici).</p> <p>Erreur courante :</p> <pre><code>// for (long v : new int[]{1,2}) {} // \u274c not allowed: int elements cannot be assigned to long in enhanced for-loop\n</code></pre> <p></p>"},{"location":"fr/module-03/arrays/#108-pieges-courants","title":"10.8 Pi\u00e8ges courants","text":"<ul> <li> <p>Acc\u00e8s hors limites \u2192 lance <code>ArrayIndexOutOfBoundsException</code>.</p> </li> <li> <p>Mauvaise utilisation de l\u2019initialiseur court</p> </li> </ul> <pre><code>// int[] x;\n// x = {1,2}; // \u274c does not compile\n</code></pre> <ul> <li>Confondre <code>.length</code> et <code>.length()</code></li> <li> <p>Oublier que les tableaux sont des objets (ils vivent sur le heap et sont r\u00e9f\u00e9renc\u00e9s).</p> </li> <li> <p>M\u00e9langer des tableaux de primitifs et des tableaux de wrappers</p> </li> </ul> <pre><code>// int[] p = new Integer[3]; // \u274c incompatible\n</code></pre> <ul> <li>Utiliser <code>binarySearch</code> sur des tableaux non tri\u00e9s \u2192 r\u00e9sultats impr\u00e9visibles.</li> <li>Exceptions d\u2019ex\u00e9cution dues aux tableaux covariants (<code>ArrayStoreException</code>).</li> </ul> <p></p>"},{"location":"fr/module-03/arrays/#109-resume","title":"10.9 R\u00e9sum\u00e9","text":"<p>Les tableaux en Java sont :</p> <ul> <li>Des objets (m\u00eame s\u2019ils contiennent des primitifs).</li> <li>Des collections index\u00e9es \u00e0 taille fixe.</li> <li>Toujours initialis\u00e9s avec des valeurs par d\u00e9faut.</li> <li>Type-safe, mais soumis aux r\u00e8gles de covariance (ce qui peut provoquer des exceptions \u00e0 l\u2019ex\u00e9cution si mal utilis\u00e9).</li> </ul>"},{"location":"fr/module-03/date-time/","title":"12. Date et heure en Java","text":""},{"location":"fr/module-03/date-time/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>12.1 Date et heure<ul> <li>12.1.1 Cr\u00e9er des dates et heures sp\u00e9cifiques</li> <li>12.1.2 Arithm\u00e9tique date/heure : m\u00e9thodes plus et minus</li> <li>12.1.3 Mod\u00e8les courants</li> <li>12.1.4 Arithm\u00e9tique LocalDate</li> <li>12.1.5 Arithm\u00e9tique LocalTime</li> <li>12.1.6 Arithm\u00e9tique LocalDateTime</li> <li>12.1.7 Arithm\u00e9tique ZonedDateTime</li> <li>12.1.8 Tableau r\u00e9capitulatif</li> </ul> </li> <li>12.2 M\u00e9thodes withXxx</li> <li>12.3 Conversion et m\u00e9thodes at (lier date, heure et zone)</li> <li>12.4 Period, Duration et Instant</li> <li>12.5 Period \u2014 Dur\u00e9es humaines bas\u00e9es sur la date</li> <li>12.6 Duration \u2014 Dur\u00e9es machine bas\u00e9es sur le temps</li> <li>12.7 Instant \u2014 Point sur la chronologie UTC</li> <li>12.8 Tableau r\u00e9capitulatif : Period vs Duration vs Instant</li> <li>12.9 TemporalUnit et TemporalAmount<ul> <li>12.9.1 TemporalUnit</li> <li>12.9.2 Enum ChronoUnit</li> <li>12.9.3 TemporalAmount</li> <li>12.9.4 Period en tant que TemporalAmount</li> <li>12.9.5 Duration en tant que TemporalAmount</li> <li>12.9.6 Utiliser TemporalAmount vs TemporalUnit</li> <li>12.9.7 M\u00e9thodes between</li> <li>12.9.8 Pi\u00e8ges courants</li> <li>12.9.9 R\u00e9sum\u00e9</li> </ul> </li> </ul>"},{"location":"fr/module-03/date-time/#121-date-et-heure","title":"12.1 Date et heure","text":"<p>Java fournit une API moderne, coh\u00e9rente et immuable de date/heure dans le package <code>java.time.*</code>.</p> <p>Cette API remplace les anciennes classes <code>java.util.Date</code> et <code>java.util.Calendar</code>.</p> <p>Selon le niveau de d\u00e9tail requis, Java propose quatre classes principales :</p> <ul> <li><code>LocalDate</code> \u2192 repr\u00e9sente une date uniquement (ann\u00e9e\u2013mois\u2013jour)</li> <li><code>LocalTime</code> \u2192 repr\u00e9sente une heure uniquement (heure\u2013minute\u2013seconde\u2013nanoseconde)</li> <li><code>LocalDateTime</code> \u2192 combine date + heure, mais sans fuseau horaire</li> <li><code>ZonedDateTime</code> \u2192 date + heure + d\u00e9calage + fuseau horaire</li> </ul> <p>Note</p> <ul> <li>Un fuseau horaire d\u00e9finit des r\u00e8gles comme les changements d\u2019heure d\u2019\u00e9t\u00e9 (par exemple, <code>Europe/Paris</code>).</li> <li>Un d\u00e9calage de zone (zone offset) est un d\u00e9calage fixe par rapport \u00e0 UTC/GMT (par exemple, <code>+01:00</code>, <code>-07:00</code>).  </li> <li>Pour comparer deux instants provenant de fuseaux horaires diff\u00e9rents, convertissez-les en UTC (GMT) en appliquant le d\u00e9calage.</li> </ul> <p>Obtenir la date/heure actuelle</p> <p>Vous pouvez r\u00e9cup\u00e9rer les valeurs syst\u00e8me actuelles en utilisant les m\u00e9thodes statiques <code>now()</code> :</p> <pre><code>System.out.println(LocalDate.now());\nSystem.out.println(LocalTime.now());\nSystem.out.println(LocalDateTime.now());\nSystem.out.println(ZonedDateTime.now());\n</code></pre> <ul> <li>Exemple de sortie (votre syst\u00e8me peut diff\u00e9rer) :</li> </ul> <pre><code>2025-12-01\n19:11:53.213856300\n2025-12-01T19:11:53.213856300\n2025-12-01T19:11:53.214856900+01:00[Europe/Paris]\n</code></pre> <ul> <li>Exemple : conversion de <code>ZonedDateTime</code> vers GMT (UTC)</li> </ul> <pre><code>// Conceptual examples (not real code, just illustrating offsets):\n// 2024-07-01T12:00+09:00[Asia/Tokyo]        ---&gt; 12:00 minus 9 hours ---&gt; 03:00 UTC\n// 2024-07-01T20:00-07:00[America/Los_Angeles] ---&gt; 20:00 plus 7 hours ---&gt; 03:00 UTC\n</code></pre> <p>Les deux repr\u00e9sentent le m\u00eame instant dans le temps, simplement exprim\u00e9 dans des fuseaux horaires diff\u00e9rents.</p> <p></p>"},{"location":"fr/module-03/date-time/#1211-creer-des-dates-et-heures-specifiques","title":"12.1.1 Cr\u00e9er des dates et heures sp\u00e9cifiques","text":"<p>Vous pouvez construire des objets date/heure pr\u00e9cis en utilisant les m\u00e9thodes de fabrique <code>of()</code>.  </p> <p>Toutes les classes incluent plusieurs versions surcharg\u00e9es de <code>of()</code> (seules les plus courantes sont list\u00e9es ici).</p> <p>**LocalDate \u2014 formes surcharg\u00e9es de <code>of()</code> - <code>of(int year, int month, int dayOfMonth)</code> - <code>of(int year, Month month, int dayOfMonth)</code></p> <p>**LocalTime \u2014 formes surcharg\u00e9es de <code>of()</code> - <code>of(int hour, int minute)</code> - <code>of(int hour, int minute, int second)</code> - <code>of(int hour, int minute, int second, int nanoOfSecond)</code></p> <p>**LocalDateTime \u2014 formes surcharg\u00e9es de <code>of()</code> - <code>of(int year, int month, int day, int hour, int minute)</code> - <code>of(int year, int month, int day, int hour, int minute, int second)</code> - <code>of(int year, int month, int day, int hour, int minute, int second, int nano)</code> - <code>of(LocalDate date, LocalTime time)</code></p> <p>**ZonedDateTime \u2014 formes surcharg\u00e9es de <code>of()</code> - <code>of(LocalDate date, LocalTime time, ZoneId zone)</code> - <code>of(int y, int m, int d, int h, int min, int s, int nano, ZoneId zone)</code></p> <ul> <li>Exemples</li> </ul> <pre><code>// Creating specific dates\n\nvar localDate1 = LocalDate.of(2025, 7, 31);\nvar localDate2 = LocalDate.of(2025, Month.JULY, 31);\n\n// Creating specific times\n\nvar localTime1 = LocalTime.of(13, 21);\nSystem.out.println(localTime1);                     // 13:21\nSystem.out.println(LocalTime.of(13, 21, 52));       // 13:21:52\nSystem.out.println(LocalTime.of(13, 21, 52, 200));  // 13:21:52.000000200\n\n// Creating LocalDateTime\n\nvar localDateTime1 = LocalDateTime.of(2025, 7, 31, 13, 55, 22);\nvar localDateTime2 = LocalDateTime.of(localDate1, localTime1);\n\n// Creating a ZonedDateTime\n\nvar zoned = ZonedDateTime.of(2025, 7, 31, 13, 55, 22, 0, ZoneId.of(\"Europe/Paris\"));\n</code></pre> <p></p>"},{"location":"fr/module-03/date-time/#1212-arithmetique-dateheure-methodes-plus-et-minus","title":"12.1.2 Arithm\u00e9tique date/heure : m\u00e9thodes <code>plus</code> et <code>minus</code>","text":"<p>Toutes les classes du package <code>java.time</code> (comme <code>LocalDate</code>, <code>LocalTime</code>, <code>LocalDateTime</code>, <code>ZonedDateTime</code>, etc.) sont immutables.</p> <p>Cela signifie que des m\u00e9thodes comme <code>plusXxx()</code> et <code>minusXxx()</code> ne modifient jamais l\u2019objet original \u2014 elles renvoient \u00e0 la place une nouvelle instance avec la valeur ajust\u00e9e.</p> <p></p>"},{"location":"fr/module-03/date-time/#1213-modeles-courants","title":"12.1.3 Mod\u00e8les courants","text":"<p>La plupart des classes date/heure prennent en charge trois types de m\u00e9thodes arithm\u00e9tiques :</p> <ul> <li>Raccourcis sp\u00e9cifiques au type </li> <li><code>plusDays(long daysToAdd)</code> </li> <li><code>plusHours(long hoursToAdd)</code> </li> <li> <p>etc.</p> </li> <li> <p>M\u00e9thodes g\u00e9n\u00e9riques bas\u00e9es sur une quantit\u00e9 </p> </li> <li><code>plus(TemporalAmount amount)</code> \u2192 par exemple <code>Period</code>, <code>Duration</code> </li> <li> <p><code>minus(TemporalAmount amount)</code> </p> </li> <li> <p>M\u00e9thodes g\u00e9n\u00e9riques bas\u00e9es sur une unit\u00e9 </p> </li> <li><code>plus(long amountToAdd, TemporalUnit unit)</code> </li> <li><code>minus(long amountToSubtract, TemporalUnit unit)</code> </li> </ul> <p>Elles permettent une arithm\u00e9tique de date/heure flexible et lisible.</p> <p></p>"},{"location":"fr/module-03/date-time/#1214-arithmetique-localdate","title":"12.1.4 Arithm\u00e9tique <code>LocalDate</code>","text":"<p><code>LocalDate</code> repr\u00e9sente une date uniquement (pas d\u2019heure, pas de zone).</p> <p>Principales m\u00e9thodes <code>plus</code> / <code>minus</code> (surcharges)</p> M\u00e9thode Description <code>plusDays(long days)</code> Ajouter des jours <code>plusWeeks(long weeks)</code> Ajouter des semaines <code>plusMonths(long months)</code> Ajouter des mois <code>plusYears(long years)</code> Ajouter des ann\u00e9es <code>minusDays(long days)</code> Soustraire des jours <code>minusWeeks(long weeks)</code> Soustraire des semaines <code>minusMonths(long months)</code> Soustraire des mois <code>minusYears(long years)</code> Soustraire des ann\u00e9es <code>plus(TemporalAmount amount)</code> Ajouter une Period <code>minus(TemporalAmount amount)</code> Soustraire une Period <code>plus(long amountToAdd, TemporalUnit unit)</code> Ajouter en utilisant ChronoUnit (par ex. DAYS, MONTHS) <code>minus(long amountToSubtract, TemporalUnit unit)</code> Soustraire en utilisant ChronoUnit <ul> <li>Exemples :</li> </ul> <pre><code>LocalDate date = LocalDate.of(2025, 3, 10);\n\nLocalDate d1 = date.plusDays(5);            // 2025-03-15\nLocalDate d2 = date.minusWeeks(2);          // 2025-02-24\nLocalDate d3 = date.plusMonths(1);          // 2025-04-10\nLocalDate d4 = date.plusYears(2);           // 2027-03-10\n\n// Using ChronoUnit\nLocalDate d5 = date.plus(10, ChronoUnit.DAYS);   // 2025-03-20\n\n// Using Period\nPeriod p = Period.of(1, 2, 3);  // 1 year, 2 months, 3 days\nLocalDate d6 = date.plus(p);\n</code></pre> <p></p>"},{"location":"fr/module-03/date-time/#1215-arithmetique-localtime","title":"12.1.5 Arithm\u00e9tique <code>LocalTime</code>","text":"<p><code>LocalTime</code> repr\u00e9sente une heure uniquement (pas de date, pas de zone).</p> <p>Principales m\u00e9thodes <code>plus</code> / <code>minus</code> (surcharges)</p> M\u00e9thode Description <code>plusNanos(long nanos)</code> Ajouter des nanosecondes <code>plusSeconds(long seconds)</code> Ajouter des secondes <code>plusMinutes(long minutes)</code> Ajouter des minutes <code>plusHours(long hours)</code> Ajouter des heures <code>minusNanos(long nanos)</code> Soustraire des nanosecondes <code>minusSeconds(long seconds)</code> Soustraire des secondes <code>minusMinutes(long minutes)</code> Soustraire des minutes <code>minusHours(long hours)</code> Soustraire des heures <code>plus(TemporalAmount amount)</code> Ajouter une Duration <code>minus(TemporalAmount amount)</code> Soustraire une Duration <code>plus(long amountToAdd, TemporalUnit unit)</code> Ajouter en utilisant ChronoUnit <code>minus(long amountToSubtract, TemporalUnit unit)</code> Soustraire en utilisant ChronoUnit <ul> <li>Exemples</li> </ul> <pre><code>LocalTime time = LocalTime.of(13, 30);       // 13:30\n\nLocalTime t1 = time.plusHours(2);            // 15:30\nLocalTime t2 = time.minusMinutes(45);        // 12:45\nLocalTime t3 = time.plusSeconds(90);         // 13:31:30\n\n// Using ChronoUnit\nLocalTime t4 = time.plus(3, ChronoUnit.HOURS);    // 16:30\n\n// Using Duration\nDuration d = Duration.ofMinutes(90);\nLocalTime t5 = time.plus(d);                // 15:00\n</code></pre> <p>Note</p> <p>Quand l\u2019arithm\u00e9tique des heures franchit minuit, la date est ignor\u00e9e avec <code>LocalTime</code>. Par exemple, 23:30 + 2 heures = 01:30 (sans date impliqu\u00e9e).</p> <p></p>"},{"location":"fr/module-03/date-time/#1216-arithmetique-localdatetime","title":"12.1.6 Arithm\u00e9tique <code>LocalDateTime</code>","text":"<p><code>LocalDateTime</code> combine date + heure, mais toujours sans fuseau horaire.  </p> <p>Il prend en charge \u00e0 la fois les m\u00e9thodes de raccourci li\u00e9es \u00e0 la date et celles li\u00e9es \u00e0 l\u2019heure.</p> <p>Principales m\u00e9thodes <code>plus</code> / <code>minus</code> (surcharges)</p> M\u00e9thode Description <code>plusYears(long years)</code> / <code>minusYears(long years)</code> Ajuster les ann\u00e9es <code>plusMonths(long months)</code> / <code>minusMonths(long months)</code> Ajuster les mois <code>plusWeeks(long weeks)</code> / <code>minusWeeks(long weeks)</code> Ajuster les semaines <code>plusDays(long days)</code> / <code>minusDays(long days)</code> Ajuster les jours <code>plusHours(long hours)</code> / <code>minusHours(long hours)</code> Ajuster les heures <code>plusMinutes(long minutes)</code> / <code>minusMinutes(long minutes)</code> Ajuster les minutes <code>plusSeconds(long seconds)</code> / <code>minusSeconds(long seconds)</code> Ajuster les secondes <code>plusNanos(long nanos)</code> / <code>minusNanos(long nanos)</code> Ajuster les nanosecondes <code>plus(TemporalAmount amount)</code> / <code>minus(TemporalAmount amount)</code> Ajouter/soustraire Period ou Duration <code>plus(long amountToAdd, TemporalUnit unit)</code> / <code>minus(long amountToSubtract, TemporalUnit unit)</code> En utilisant ChronoUnit <ul> <li>Exemples</li> </ul> <pre><code>LocalDateTime ldt = LocalDateTime.of(2025, 3, 10, 13, 30); // 2025-03-10T13:30\n\nLocalDateTime l1 = ldt.plusDays(1);          // 2025-03-11T13:30\nLocalDateTime l2 = ldt.minusHours(3);        // 2025-03-10T10:30\nLocalDateTime l3 = ldt.plusMinutes(90);      // 2025-03-10T15:00\n\n// Using ChronoUnit\nLocalDateTime l4 = ldt.plus(2, ChronoUnit.WEEKS); // 2025-03-24T13:30\n\n// Using Period and Duration\nPeriod p = Period.ofDays(10);\nDuration d = Duration.ofHours(5);\n\nLocalDateTime l5 = ldt.plus(p);    // 2025-03-20T13:30\nLocalDateTime l6 = ldt.plus(d);    // 2025-03-10T18:30\n</code></pre> <p></p>"},{"location":"fr/module-03/date-time/#1217-arithmetique-zoneddatetime","title":"12.1.7 Arithm\u00e9tique <code>ZonedDateTime</code>","text":"<p><code>ZonedDateTime</code> repr\u00e9sente date + heure + fuseau horaire + d\u00e9calage.</p> <p>Il prend en charge les m\u00eames m\u00e9thodes <code>plus</code>/<code>minus</code> que <code>LocalDateTime</code>, mais avec une attention suppl\u00e9mentaire aux fuseaux horaires et \u00e0 l\u2019heure d\u2019\u00e9t\u00e9 (DST).</p> <p>Principales m\u00e9thodes <code>plus</code> / <code>minus</code> (surcharges)</p> M\u00e9thode Description <code>plusYears(long years)</code> / <code>minusYears(long years)</code> Ajuster les ann\u00e9es <code>plusMonths(long months)</code> / <code>minusMonths(long months)</code> Ajuster les mois <code>plusWeeks(long weeks)</code> / <code>minusWeeks(long weeks)</code> Ajuster les semaines <code>plusDays(long days)</code> / <code>minusDays(long days)</code> Ajuster les jours <code>plusHours(long hours)</code> / <code>minusHours(long hours)</code> Ajuster les heures <code>plusMinutes(long minutes)</code> / <code>minusMinutes(long minutes)</code> Ajuster les minutes <code>plusSeconds(long seconds)</code> / <code>minusSeconds(long seconds)</code> Ajuster les secondes <code>plusNanos(long nanos)</code> / <code>minusNanos(long nanos)</code> Ajuster les nanosecondes <code>plus(TemporalAmount amount)</code> / <code>minus(TemporalAmount amount)</code> Period / Duration <code>plus(long amountToAdd, TemporalUnit unit)</code> / <code>minus(long amountToSubtract, TemporalUnit unit)</code> En utilisant ChronoUnit <ul> <li>Exemples (avec fuseaux horaires et DST) :</li> </ul> <pre><code>ZonedDateTime zdt = ZonedDateTime.of(\n    2025, 3, 30, 1, 30, 0, 0,\n    ZoneId.of(\"Europe/Paris\")\n);\n\n// Add 2 hours across a possible DST change\nZonedDateTime z1 = zdt.plusHours(2);\nSystem.out.println(zdt);\nSystem.out.println(z1);\n</code></pre> <p>Selon les r\u00e8gles d\u2019heure d\u2019\u00e9t\u00e9 pour cette date :</p> <ul> <li>L\u2019heure locale peut passer de 02:00 \u00e0 03:00 ou similaire.</li> <li><code>ZonedDateTime</code> ajuste le d\u00e9calage et l\u2019heure locale selon les r\u00e8gles de zone, mais repr\u00e9sente toujours le bon instant sur la timeline.</li> </ul> <p>Important</p> <p>Pour <code>ZonedDateTime</code>, l\u2019arithm\u00e9tique est d\u00e9finie en fonction de la timeline locale et des r\u00e8gles de fuseau horaire, ce qui peut provoquer des d\u00e9calages d\u2019heures pendant les transitions DST.</p> <p></p>"},{"location":"fr/module-03/date-time/#1218-tableau-recapitulatif","title":"12.1.8 Tableau r\u00e9capitulatif","text":"Classe M\u00e9thodes plus/minus de raccourci M\u00e9thodes g\u00e9n\u00e9riques LocalDate plusDays, plusWeeks, plusMonths, plusYears (et minus) plus/minus(TemporalAmount), plus/minus(long, TemporalUnit) LocalTime plusNanos, plusSeconds, plusMinutes, plusHours (et minus) plus/minus(TemporalAmount), plus/minus(long, TemporalUnit) LocalDateTime Tous les raccourcis de LocalDate + LocalTime plus/minus(TemporalAmount), plus/minus(long, TemporalUnit) ZonedDateTime Identiques \u00e0 LocalDateTime, mais sensibles \u00e0 la zone plus/minus(TemporalAmount), plus/minus(long, TemporalUnit)"},{"location":"fr/module-03/date-time/#122-methodes-withxxx","title":"12.2 M\u00e9thodes <code>withXxx(...)</code>","text":"<p>Les m\u00e9thodes <code>with...</code> renvoient une copie de l\u2019objet avec un champ modifi\u00e9. Elles ne mutent jamais l\u2019instance originale.</p> Classe M\u00e9thodes with... courantes (non exhaustif) Description <code>LocalDate</code> withYear(int year) M\u00eame date, mais avec une ann\u00e9e diff\u00e9rente LocalDate LocalDate.withMonth(int month) M\u00eame date, mois diff\u00e9rent (1\u201312) LocalDate LocalDate.withDayOfMonth(int dayOfMonth) M\u00eame date, jour du mois diff\u00e9rent LocalDate LocalDate.with(TemporalField field, long newValue) Ajustement g\u00e9n\u00e9rique bas\u00e9 sur un champ LocalDate LocalDate.with(TemporalAdjuster adjuster) Utilise un adjuster (par ex. firstDayOfMonth()) <code>LocalTime</code> withHour(int hour) M\u00eame heure, heure diff\u00e9rente LocalTime LocalTime.withMinute(int minute) M\u00eame heure, minute diff\u00e9rente LocalTime LocalTime.withSecond(int second) M\u00eame heure, seconde diff\u00e9rente LocalTime LocalTime.withNano(int nanoOfSecond) M\u00eame heure, nanoseconde diff\u00e9rente LocalTime LocalTime.with(TemporalField field, long newValue) Ajustement g\u00e9n\u00e9rique bas\u00e9 sur un champ LocalTime LocalTime.with(TemporalAdjuster adjuster) Ajuster via un temporal adjuster <code>LocalDateTime</code> withYear(int year), withMonth(int month), withDayOfMonth(int day) Changer uniquement la partie date LocalDateTime withHour(int hour), withMinute(int minute), withSecond(int second) Changer uniquement la partie heure LocalDateTime withNano(int nanoOfSecond) Changer la nanoseconde LocalDateTime with(TemporalField field, long newValue) Ajustement g\u00e9n\u00e9rique bas\u00e9 sur un champ LocalDateTime with(TemporalAdjuster adjuster) Ajuster via un temporal adjuster <code>ZonedDateTime</code> tous les withXxx(...) de LocalDateTime Changer les composants locaux date/heure ZonedDateTime withZoneSameInstant(ZoneId zone) M\u00eame instant, zone diff\u00e9rente (change l\u2019heure locale) ZonedDateTime withZoneSameLocal(ZoneId zone) M\u00eame date/heure locale, zone diff\u00e9rente (change l\u2019instant) <p></p>"},{"location":"fr/module-03/date-time/#123-conversion-et-methodes-at-lier-date-heure-et-zone","title":"12.3 Conversion et m\u00e9thodes <code>at...</code> (lier date, heure et zone)","text":"<p>Ces m\u00e9thodes sont utilis\u00e9es pour combiner ou convertir entre <code>LocalDate</code>, <code>LocalTime</code>, <code>LocalDateTime</code> et <code>ZonedDateTime</code>.</p> Depuis M\u00e9thode R\u00e9sultat Description <code>LocalDate</code> atTime(LocalTime time) LocalDateTime Combine cette date avec une heure donn\u00e9e LocalDate atTime(int hour, int minute) LocalDateTime Surcharges de convenance avec des composantes horaires num\u00e9riques LocalDate atTime(int hour, int minute, int second) LocalDateTime \u2014 LocalDate atTime(int hour, int minute, int second, int nano) LocalDateTime \u2014 LocalDate atStartOfDay() LocalDateTime Cette date \u00e0 l\u2019heure 00:00 LocalDate atStartOfDay(ZoneId zone) ZonedDateTime Cette date au d\u00e9but de la journ\u00e9e dans une zone sp\u00e9cifique <code>LocalTime</code> atDate(LocalDate date) LocalDateTime Combine cette heure avec une date donn\u00e9e <code>LocalDateTime</code> atZone(ZoneId zone) ZonedDateTime Ajoute un fuseau horaire \u00e0 une date-heure locale LocalDateTime toLocalDate() LocalDate Extrait la composante date LocalDateTime toLocalTime() LocalTime Extrait la composante heure <code>ZonedDateTime</code> toLocalDate() LocalDate Supprime zone/d\u00e9calage, conserve la date locale ZonedDateTime toLocalTime() LocalTime Supprime zone/d\u00e9calage, conserve l\u2019heure locale ZonedDateTime toLocalDateTime() LocalDateTime Supprime zone/d\u00e9calage, conserve la date-heure locale <p></p>"},{"location":"fr/module-03/date-time/#124-period-duration-et-instant","title":"12.4 Period, Duration et Instant","text":"<p>Le package <code>java.time</code> fournit trois classes temporelles essentielles qui repr\u00e9sentent des dur\u00e9es ou des points sur la timeline :</p> <ul> <li>Period \u2192 dur\u00e9es humaines bas\u00e9es sur la date (ann\u00e9es, mois, jours)</li> <li>Duration \u2192 dur\u00e9es machine bas\u00e9es sur le temps (secondes, nanosecondes)</li> <li>Instant \u2192 un point sur la timeline UTC</li> </ul> <p></p>"},{"location":"fr/module-03/date-time/#125-period-durees-humaines-basees-sur-la-date","title":"12.5 <code>Period</code> \u2014 Dur\u00e9es humaines bas\u00e9es sur la date","text":"<p><code>Period</code> repr\u00e9sente une dur\u00e9e bas\u00e9e sur la date, telle que \u201c3 ans, 2 mois et 5 jours\u201d.  </p> <p>Il est utilis\u00e9 avec <code>LocalDate</code> et <code>LocalDateTime</code> (car ils contiennent des parties date).</p> <p>M\u00e9thodes de cr\u00e9ation</p> M\u00e9thode Description Period.ofYears(int years) Uniquement des ann\u00e9es Period.ofMonths(int months) Uniquement des mois Period.ofWeeks(int weeks) Convertit les semaines en jours Period.ofDays(int days) Uniquement des jours Period.of(int years, int months, int days) P\u00e9riode compl\u00e8te Period.parse(CharSequence text) Format ISO-8601 : \"P1Y2M3D\", \"P7D\", \"P1W\", ... <p>Propri\u00e9t\u00e9s cl\u00e9s</p> <ul> <li>Ne prend pas en charge les heures, minutes, secondes, nanosecondes.</li> <li>Peut \u00eatre n\u00e9gatif.</li> <li> <p>Immuable.</p> </li> <li> <p>Exemples</p> </li> </ul> <pre><code>Period p1 = Period.ofYears(1);             // P1Y\nPeriod p2 = Period.of(1, 2, 3);            // P1Y2M3D\nPeriod p3 = Period.ofWeeks(2);             // P14D (converted to days)\n\nLocalDate base = LocalDate.of(2025, 1, 10);\nLocalDate result = base.plus(p2);          // 2026-03-13\n</code></pre> <p>Note</p> <p><code>Period.parse(\"P1W\")</code> est autoris\u00e9 et repr\u00e9sente une p\u00e9riode de 7 jours (\u00e9quivalente \u00e0 \"P7D\").</p> <p>Tip</p> <p><code>Period</code> est bas\u00e9 sur le calendrier : ajouter une p\u00e9riode de mois/ann\u00e9es respecte la longueur des mois et les ann\u00e9es bissextiles.</p> <p></p>"},{"location":"fr/module-03/date-time/#126-duration-durees-machine-basees-sur-le-temps","title":"12.6 <code>Duration</code> \u2014 Dur\u00e9es machine bas\u00e9es sur le temps","text":"<p><code>Duration</code> repr\u00e9sente une dur\u00e9e bas\u00e9e sur le temps en secondes et nanosecondes.</p> <p>Il est utilis\u00e9 avec <code>LocalTime</code>, <code>LocalDateTime</code>, <code>ZonedDateTime</code> et <code>Instant</code>.</p> <p>M\u00e9thodes de cr\u00e9ation</p> M\u00e9thode Description Duration.ofDays(long days) Convertit les jours en secondes Duration.ofHours(long hours) Convertit les heures en secondes Duration.ofMinutes(long minutes) Convertit les minutes en secondes Duration.ofSeconds(long seconds) Repr\u00e9sentation de base en secondes Duration.ofSeconds(long seconds, long nanoAdjustment) Secondes plus nanos suppl\u00e9mentaires Duration.ofMillis(long millis) Convertit les millisecondes en nanos Duration.ofNanos(long nanos) Uniquement des nanosecondes Duration.between(Temporal start, Temporal end) Calculer la dur\u00e9e entre deux instants Duration.parse(CharSequence text) ISO : \"PT20H\", \"PT15M\", \"PT10S\" <p>Caract\u00e9ristiques cl\u00e9s</p> <ul> <li>Prend en charge des heures jusqu\u2019aux nanosecondes, mais pas les ann\u00e9es/mois/semaines directement.</li> <li>Id\u00e9al pour des calculs temporels au niveau machine.</li> <li> <p>Immuable.</p> </li> <li> <p>Exemples</p> </li> </ul> <pre><code>Duration d1 = Duration.ofHours(5);           // PT5H\nDuration d2 = Duration.ofMinutes(90);        // PT1H30M\n\nLocalTime t = LocalTime.of(10, 0);\nLocalTime t2 = t.plus(d2);                   // 11:30\n\nZonedDateTime z1 = ZonedDateTime.of(\n    2024, 3, 30, 1, 0, 0, 0,\n    ZoneId.of(\"Europe/Paris\")\n);\n\nZonedDateTime z2 = z1.plusHours(2);          // DST-aware\nZonedDateTime z3 = z1.plus(d2);              // Duration-based\n</code></pre> <p>Note</p> <p><code>Duration.ofDays(1)</code> repr\u00e9sente exactement 24 heures de temps machine. Dans une zone avec DST, 24 heures peuvent ne pas correspondre \u00e0 \u201cla m\u00eame heure locale demain\u201d.</p> <p></p>"},{"location":"fr/module-03/date-time/#127-instant-point-sur-la-chronologie-utc","title":"12.7 <code>Instant</code> \u2014 Point sur la chronologie UTC","text":"<p><code>Instant</code> repr\u00e9sente un seul moment dans le temps par rapport \u00e0 UTC, avec une pr\u00e9cision \u00e0 la nanoseconde.</p> <p>Il contient :</p> <ul> <li>Des secondes depuis l\u2019\u00e9poque (1970-01-01T00:00Z).</li> <li>Un ajustement de nanosecondes.</li> </ul> <p>M\u00e9thodes de cr\u00e9ation</p> M\u00e9thode Description Instant.now() Moment actuel en UTC Instant.ofEpochSecond(long seconds) \u00c0 partir des secondes depuis l\u2019\u00e9poque Instant.ofEpochSecond(long seconds, long nanos) \u00c0 partir des secondes plus nanos Instant.ofEpochMilli(long millis) \u00c0 partir des millisecondes depuis l\u2019\u00e9poque Instant.parse(CharSequence text) ISO : \"2024-01-01T10:15:30Z\" <p>Conversions</p> Action M\u00e9thode Instant \u2192 heure zon\u00e9e instant.atZone(zoneId) ZonedDateTime \u2192 Instant zdt.toInstant() LocalDateTime \u2192 Instant Non autoris\u00e9 directement (n\u00e9cessite une zone) <ul> <li>Exemple</li> </ul> <pre><code>Instant i = Instant.now();\n\nZonedDateTime z = i.atZone(ZoneId.of(\"Europe/Paris\"));\nInstant back = z.toInstant();  // same moment\n\n// Duration between instants\nInstant start = Instant.parse(\"2024-01-01T10:00:00Z\");\nInstant end   = Instant.parse(\"2024-01-01T12:30:00Z\");\n\nDuration between = Duration.between(start, end); // PT2H30M\n</code></pre> <p>Important</p> <p><code>Instant</code> est toujours en UTC, sans information de fuseau horaire attach\u00e9e. Il ne peut pas \u00eatre combin\u00e9 avec une <code>Period</code> ; utilisez <code>Duration</code> \u00e0 la place.</p> <p></p>"},{"location":"fr/module-03/date-time/#128-tableau-recapitulatif-period-vs-duration-vs-instant","title":"12.8 Tableau r\u00e9capitulatif (Period vs Duration vs Instant)","text":"Concept Repr\u00e9sente Bon pour Fonctionne avec Notes Period Ann\u00e9es, mois, jours Arithm\u00e9tique calendaire LocalDate, LocalDateTime Unit\u00e9s humaines Duration Heures \u00e0 nanosecondes Calculs temporels pr\u00e9cis LocalTime, LocalDateTime, ZonedDateTime, Instant Unit\u00e9s machine Instant Point exact sur la timeline UTC Repr\u00e9sentation d\u2019horodatage Convertible vers/depuis ZonedDateTime Ne peut pas \u00eatre combin\u00e9 avec Period <p>Pi\u00e8ges courants</p> <ul> <li><code>Period.of(1, 0, 0)</code> n\u2019est pas la m\u00eame chose que <code>Duration.ofDays(365)</code> (ann\u00e9es bissextiles !).</li> <li><code>Duration.ofDays(1)</code> peut ne pas \u00eatre \u00e9gal \u00e0 une \u201cjourn\u00e9e calendaire\u201d compl\u00e8te dans une zone DST.</li> <li><code>LocalDateTime</code> ne peut pas \u00eatre converti en <code>Instant</code> sans fuseau horaire.</li> <li><code>Period.parse(\"P1W\")</code> est valide et donne une p\u00e9riode de 7 jours.</li> </ul> <p></p>"},{"location":"fr/module-03/date-time/#129-temporalunit-et-temporalamount","title":"12.9 TemporalUnit et TemporalAmount","text":"<p>L\u2019API <code>java.time</code> repose sur deux interfaces cl\u00e9s qui d\u00e9finissent comment les dates, les heures et les dur\u00e9es sont manipul\u00e9es :</p> <ul> <li><code>TemporalUnit</code> \u2192 repr\u00e9sente une unit\u00e9 de temps (par exemple, DAYS, HOURS, MINUTES).</li> <li><code>TemporalAmount</code> \u2192 repr\u00e9sente une quantit\u00e9 de temps (par exemple, <code>Period</code>, <code>Duration</code>).</li> </ul> <p>Les deux sont essentiels pour comprendre comment fonctionnent les m\u00e9thodes <code>plus</code>, <code>minus</code> et <code>with</code>.</p> <p></p>"},{"location":"fr/module-03/date-time/#1291-temporalunit","title":"12.9.1 <code>TemporalUnit</code>","text":"<p><code>TemporalUnit</code> repr\u00e9sente une seule unit\u00e9 de mesure date/heure. L\u2019impl\u00e9mentation principale utilis\u00e9e en Java est :</p> <p></p>"},{"location":"fr/module-03/date-time/#1292-enum-chronounit","title":"12.9.2 Enum <code>ChronoUnit</code>","text":"<p>Cet enum fournit les unit\u00e9s standard utilis\u00e9es dans la chronologie ISO-8601 :</p> Cat\u00e9gorie Unit\u00e9s Unit\u00e9s de date DAYS, WEEKS, MONTHS, YEARS, DECADES, CENTURIES, MILLENNIA, ERAS Unit\u00e9s de temps NANOS, MICROS, MILLIS, SECONDS, MINUTES, HOURS, HALF_DAYS Sp\u00e9cial FOREVER <p>Un <code>TemporalUnit</code> peut \u00eatre utilis\u00e9 directement avec les m\u00e9thodes <code>plus()</code> et <code>minus()</code>.</p> <ul> <li>Exemples avec <code>ChronoUnit</code> :</li> </ul> <pre><code>LocalDate date = LocalDate.of(2025, 3, 10);\n\nLocalDate d1 = date.plus(10, ChronoUnit.DAYS);     // 2025-03-20\nLocalDate d2 = date.minus(2, ChronoUnit.MONTHS);   // 2025-01-10\n\nLocalTime time = LocalTime.of(10, 0);\nLocalTime t1 = time.plus(90, ChronoUnit.MINUTES);  // 11:30\n</code></pre> <p>Important</p> <p>Vous ne pouvez pas utiliser des unit\u00e9s bas\u00e9es sur le temps avec <code>LocalDate</code>, ni des unit\u00e9s bas\u00e9es sur la date avec <code>LocalTime</code>.</p> <ul> <li>Exemples :</li> </ul> <pre><code>// \u274c UnsupportedTemporalTypeException\nLocalDate d = LocalDate.now().plus(5, ChronoUnit.HOURS);\n\n// \u274c UnsupportedTemporalTypeException\nLocalTime t = LocalTime.now().plus(1, ChronoUnit.DAYS);\n</code></pre> <p></p>"},{"location":"fr/module-03/date-time/#1293-temporalamount","title":"12.9.3 <code>TemporalAmount</code>","text":"<p><code>TemporalAmount</code> repr\u00e9sente une quantit\u00e9 de temps \u00e0 unit\u00e9s multiples (par exemple, \u201c2 ans, 3 mois\u201d, ou \u201c90 minutes\u201d). Elle est impl\u00e9ment\u00e9e par :</p> <ul> <li><code>Period</code> \u2192 ann\u00e9es, mois, jours (bas\u00e9 sur la date)</li> <li><code>Duration</code> \u2192 secondes, nanosecondes (bas\u00e9 sur le temps)</li> </ul> <p>Les deux peuvent \u00eatre pass\u00e9s aux objets date/heure pour les ajuster via <code>plus()</code> et <code>minus()</code>.</p> <p></p>"},{"location":"fr/module-03/date-time/#1294-period-en-tant-que-temporalamount","title":"12.9.4 <code>Period</code> en tant que <code>TemporalAmount</code>","text":"<p><code>Period</code> repr\u00e9sente une quantit\u00e9 humaine : ann\u00e9es, mois, jours.</p> <ul> <li>Exemples :</li> </ul> <pre><code>Period p = Period.of(1, 2, 3);  // 1 year, 2 months, 3 days\n\nLocalDate base = LocalDate.of(2025, 3, 10);\nLocalDate result = base.plus(p); // 2026-05-13\n</code></pre> <p>Notes</p> <ul> <li><code>Period</code> ne peut pas \u00eatre utilis\u00e9 avec <code>LocalTime</code> (pas de composante date).</li> <li><code>Period.ofWeeks(n)</code> est converti en interne en jours (n \u00d7 7).</li> </ul> <p></p>"},{"location":"fr/module-03/date-time/#1295-duration-en-tant-que-temporalamount","title":"12.9.5 <code>Duration</code> en tant que <code>TemporalAmount</code>","text":"<p><code>Duration</code> repr\u00e9sente un temps machine : secondes + nanosecondes.</p> <ul> <li>Exemples :</li> </ul> <pre><code>Duration d = Duration.ofHours(5).plusMinutes(30); // PT5H30M\n\nLocalDateTime ldt = LocalDateTime.of(2025, 3, 10, 10, 0);\nLocalDateTime result = ldt.plus(d); // 2025-03-10T15:30\n</code></pre> <p>Notes</p> <ul> <li><code>Duration</code> peut \u00eatre utilis\u00e9e avec des classes qui ont des composantes de temps (<code>LocalTime</code>, <code>LocalDateTime</code>, <code>ZonedDateTime</code>, <code>Instant</code>).</li> <li><code>Duration</code> ne peut pas \u00eatre appliqu\u00e9e \u00e0 <code>LocalDate</code> \u2192 cela lance <code>UnsupportedTemporalTypeException</code>.</li> <li><code>Duration</code> interagit avec les zones et les transitions DST lorsqu\u2019elle est appliqu\u00e9e \u00e0 <code>ZonedDateTime</code>.</li> </ul> <p></p>"},{"location":"fr/module-03/date-time/#1296-utiliser-temporalamount-vs-temporalunit","title":"12.9.6 Utiliser <code>TemporalAmount</code> vs <code>TemporalUnit</code>","text":"<p>Utiliser un <code>TemporalUnit</code> :</p> <pre><code>LocalDate d1 = LocalDate.now().plus(5, ChronoUnit.DAYS);\n</code></pre> <p>Utiliser un <code>TemporalAmount</code> :</p> <pre><code>Period p = Period.ofDays(5);\nLocalDate d2 = LocalDate.now().plus(p);\n</code></pre> <p>Les deux produisent le m\u00eame r\u00e9sultat lorsque c\u2019est pris en charge.</p> <p>Diff\u00e9rences</p> Aspect TemporalUnit TemporalAmount Repr\u00e9sente Une seule unit\u00e9 (par ex. DAYS) Une quantit\u00e9 structur\u00e9e (par ex. 2Y, 5M, 3D) Exemples ChronoUnit.DAYS Period.of(2,5,3) Prend en charge plusieurs champs Non Oui Bon pour Incr\u00e9ments simples Incr\u00e9ments complexes Fr\u00e9quent avec Toutes les classes date/heure Restreint selon le type <p></p>"},{"location":"fr/module-03/date-time/#1297-methodes-between","title":"12.9.7 M\u00e9thodes <code>between(...)</code>","text":"<p>De nombreuses classes fournissent une m\u00e9thode <code>between</code> via <code>ChronoUnit</code>, <code>Duration</code> ou <code>Period</code>.</p> <p>Utiliser <code>Duration.between</code> (pour les classes bas\u00e9es sur le temps)</p> <pre><code>Duration d = Duration.between(\n    LocalTime.of(10, 0),\n    LocalTime.of(13, 30)\n);\n// PT3H30M\n</code></pre> <p>Utiliser <code>Period.between</code> (uniquement pour les dates)</p> <pre><code>Period p = Period.between(\n    LocalDate.of(2025, 3, 1),\n    LocalDate.of(2025, 5, 10)\n);\n// P2M9D\n</code></pre> <p>Utiliser <code>ChronoUnit</code> <code>between</code></p> <pre><code>long days = ChronoUnit.DAYS.between(\n    LocalDate.of(2025, 3, 1),\n    LocalDate.of(2025, 3, 10)\n);\n// 9\n</code></pre> <p>Important</p> <p><code>ChronoUnit.between(...)</code> renvoie toujours un <code>long</code>, tandis que <code>Period.between</code> renvoie une <code>Period</code>, et <code>Duration.between</code> renvoie une <code>Duration</code>.</p> <p></p>"},{"location":"fr/module-03/date-time/#1298-pieges-courants","title":"12.9.8 Pi\u00e8ges courants","text":"<ul> <li>Appliquer le mauvais <code>TemporalAmount</code> :</li> </ul> <pre><code>// LocalTime.plus(Period.ofDays(1))   // \u274c compile-time error\n// LocalDate.plus(Duration.ofHours(1)) // \u274c runtime error: UnsupportedTemporalTypeException\n</code></pre> <ul> <li>Changements DST avec <code>Duration</code> : ajouter 24 heures n\u2019est pas toujours \u201cdemain\u201d dans une zone avec DST.</li> <li><code>Period.ofWeeks(1)</code> fait exactement 7 jours ; les effets DST apparaissent lorsqu\u2019il est appliqu\u00e9 \u00e0 des types sensibles \u00e0 la zone.</li> <li><code>Instant.plus(Period)</code> \u2192 <code>UnsupportedTemporalTypeException</code> \u00e0 l\u2019ex\u00e9cution ; utilisez <code>Duration</code> \u00e0 la place.</li> <li><code>Instant</code> ne peut pas \u00eatre cr\u00e9\u00e9 directement depuis un <code>LocalDateTime</code> ; vous devez d\u2019abord appliquer une zone : <code>ldt.atZone(zone).toInstant()</code>.</li> </ul>"},{"location":"fr/module-03/date-time/#1299-resume","title":"12.9.9 R\u00e9sum\u00e9","text":"Fonctionnalit\u00e9 TemporalUnit TemporalAmount ChronoUnit Period Duration Repr\u00e9sente Une unit\u00e9 Une quantit\u00e9 enum d\u2019unit\u00e9s Y/M/J S + nanos Multi-champ Non Oui Non Oui Non Fonctionne avec plus/minus plus/minus date/heure LocalDate/LocalDateTime Temps/zone Bas\u00e9 sur l\u2019humain Non Oui Non Oui Non Bas\u00e9 sur la machine Oui Oui Oui Non Oui"},{"location":"fr/module-03/formatting/","title":"13. Mise en forme et localisation en Java","text":""},{"location":"fr/module-03/formatting/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>13.1 Mise en forme des cha\u00eenes<ul> <li>13.1.1 String.format et formatted<ul> <li>13.1.1.1 Indicateurs pour nombres \u00e0 virgule flottante</li> <li>13.1.1.2 Pr\u00e9cision n</li> <li>13.1.1.3 Largeur m</li> <li>13.1.1.4 Indicateur de remplissage par z\u00e9ro 0</li> <li>13.1.1.5 Justification \u00e0 gauche Indicateur -</li> <li>13.1.1.6 Signe explicite Indicateur +</li> <li>13.1.1.7 Parenth\u00e8ses pour les n\u00e9gatifs Indicateur (</li> <li>13.1.1.8 Combinaison des indicateurs</li> <li>13.1.1.9 Effets du Locale</li> <li>13.1.1.10 Erreurs courantes</li> </ul> </li> <li>13.1.2 Valeurs de texte personnalis\u00e9es et \u00e9chappement</li> </ul> </li> <li>13.2 Mise en forme des nombres<ul> <li>13.2.1 NumberFormat</li> <li>13.2.2 Localisation des nombres</li> <li>13.2.3 DecimalFormat et NumberFormat</li> <li>13.2.4 Structure du pattern DecimalFormat</li> <li>13.2.5 Le symbole 0 (chiffre obligatoire)</li> <li>13.2.6 Le symbole # (chiffre optionnel)</li> <li>13.2.7 Combiner 0 et #</li> <li>13.2.8 S\u00e9parateurs d\u00e9cimaux et de groupement</li> <li>13.2.9 DecimalFormatSymbols : symboles de format sp\u00e9cifiques au Locale</li> <li>13.2.10 Patterns sp\u00e9ciaux de DecimalFormat</li> <li>13.2.11 R\u00e8gles et erreurs courantes</li> </ul> </li> <li>13.3 Analyse (parsing) des nombres<ul> <li>13.3.1 Parsing avec DecimalFormat</li> <li>13.3.2 CompactNumberFormat</li> </ul> </li> <li>13.4 Mise en forme des dates et heures<ul> <li>13.4.1 DateTimeFormatter</li> <li>13.4.2 Symboles standard de date et d\u2019heure</li> <li>13.4.3 datetime.format vs formatter.format</li> <li>13.4.4 Localisation des dates</li> </ul> </li> <li>13.5 Internationalisation (i18n) et localisation (l10n)<ul> <li>13.5.1 Locales</li> <li>13.5.2 Cat\u00e9gories de Locale</li> <li>13.5.3 Exemple r\u00e9el</li> </ul> </li> <li>13.6 Properties et Resource Bundles<ul> <li>13.6.1 R\u00e8gles de r\u00e9solution des Resource Bundles</li> </ul> </li> <li>13.7 R\u00e8gles et erreurs courantes</li> </ul> <p>Ce chapitre fournit un traitement approfondi et pratique de la mise en forme en Java 21.</p> <p></p>"},{"location":"fr/module-03/formatting/#131-mise-en-forme-des-chaines","title":"13.1 Mise en forme des cha\u00eenes","text":""},{"location":"fr/module-03/formatting/#1311-stringformat-et-formatted","title":"13.1.1 String.format et formatted","text":"<p><code>String.format()</code> cr\u00e9e des cha\u00eenes format\u00e9es en utilisant des substituts de type printf.</p> <p>Il est sensible au locale et retourne une nouvelle <code>String</code> immuable.</p> <pre><code>String result = String.format(\"The User: %s | Score: %d\", \"Bob\", 42);\nSystem.out.println(result);\n\n// Or\n\nSystem.out.println(\"The User: %s | Score: %d\".formatted(\"Bob\", 42));\n</code></pre> <p>Sortie :</p> <pre><code>The User: Bob | Score: 42\n</code></pre> <p>Caract\u00e9ristiques cl\u00e9s :</p> <ul> <li>Utilise des sp\u00e9cificateurs de format tels que <code>%s</code> (tout type, g\u00e9n\u00e9ralement des cha\u00eenes), <code>%d</code> (valeurs enti\u00e8res), <code>%f</code> (valeurs \u00e0 virgule flottante).</li> <li>Ne modifie pas les cha\u00eenes existantes.</li> <li>Lance <code>IllegalFormatException</code> si les arguments ne correspondent pas au format.</li> <li>Est sensible au locale lorsqu\u2019un <code>Locale</code> est fourni.</li> </ul> <pre><code>String price = String.format(Locale.GERMANY, \"%.2f\", 1234.5);\n// Sortie (locale allemand) : 1234,50\n</code></pre> <p></p>"},{"location":"fr/module-03/formatting/#13111-indicateurs-pour-nombres-a-virgule-flottante","title":"13.1.1.1 Indicateurs pour nombres \u00e0 virgule flottante","text":"<p><code>%f</code> est utilis\u00e9 pour formater les nombres \u00e0 virgule flottante (<code>float</code>, <code>double</code>, <code>BigDecimal</code>) en notation d\u00e9cimale.</p> <pre><code>System.out.printf(\"%f\", 12.345);\n</code></pre> <pre><code>12.345000\n</code></pre> <ul> <li>Affiche toujours 6 chiffres apr\u00e8s le s\u00e9parateur d\u00e9cimal par d\u00e9faut.</li> <li>Utilise l\u2019arrondi (et non la troncature).</li> <li>Est sensible au locale pour le s\u00e9parateur d\u00e9cimal.</li> </ul> <p></p>"},{"location":"fr/module-03/formatting/#13112-precision-n","title":"13.1.1.2 Pr\u00e9cision (.n)","text":"<p>La pr\u00e9cision d\u00e9finit le nombre de chiffres affich\u00e9s apr\u00e8s le s\u00e9parateur d\u00e9cimal.</p> <pre><code>System.out.printf(\"%.2f\", 12.345);\n</code></pre> <pre><code>12.35\n</code></pre> <ul> <li><code>%.0f</code> n\u2019affiche aucun chiffre d\u00e9cimal.</li> <li>L\u2019arrondi est appliqu\u00e9.</li> <li>La pr\u00e9cision est appliqu\u00e9e avant le remplissage de la largeur.</li> </ul> <p></p>"},{"location":"fr/module-03/formatting/#13113-largeur-m","title":"13.1.1.3 Largeur (m)","text":"<p>La largeur d\u00e9finit le nombre total minimal de caract\u00e8res dans la sortie.</p> <pre><code>System.out.printf(\"%8.2f\", 12.34);\n</code></pre> <pre><code>   12.34\n</code></pre> <ul> <li>Remplit avec des espaces par d\u00e9faut.</li> <li>Si la valeur est plus longue, la largeur est ignor\u00e9e (elle ne tronque jamais).</li> <li>Le remplissage est appliqu\u00e9 \u00e0 gauche par d\u00e9faut.</li> </ul> <p></p>"},{"location":"fr/module-03/formatting/#13114-indicateur-de-remplissage-par-zero-0","title":"13.1.1.4 Indicateur de remplissage par z\u00e9ro <code>0</code>","text":"<p>L\u2019indicateur <code>0</code> remplace le remplissage par des espaces par des z\u00e9ros.</p> <pre><code>System.out.printf(\"%08.2f\", 12.34);\n</code></pre> <pre><code>00012.34\n</code></pre> <ul> <li>N\u00e9cessite une largeur.</li> <li>Les z\u00e9ros sont ins\u00e9r\u00e9s apr\u00e8s le signe.</li> <li>Ignor\u00e9 si la justification \u00e0 gauche est pr\u00e9sente (indicateur <code>-</code>).</li> </ul> <p></p>"},{"location":"fr/module-03/formatting/#13115-justification-a-gauche-indicateur-","title":"13.1.1.5 Justification \u00e0 gauche Indicateur <code>-</code>","text":"<p>L\u2019indicateur <code>-</code> aligne la valeur \u00e0 gauche \u00e0 l\u2019int\u00e9rieur de la largeur.</p> <pre><code>System.out.printf(\"%-8.2f\", 12.34);\n</code></pre> <pre><code>12.34   \n</code></pre> <ul> <li>Le remplissage est d\u00e9plac\u00e9 vers la droite.</li> <li>\u00c9crase le remplissage par z\u00e9ro.</li> </ul> <p></p>"},{"location":"fr/module-03/formatting/#13116-signe-explicite-indicateur","title":"13.1.1.6 Signe explicite Indicateur <code>+</code>","text":"<p>L\u2019indicateur <code>+</code> force l\u2019affichage du signe pour les nombres positifs.</p> <pre><code>System.out.printf(\"%+8.2f\", 12.34);\n</code></pre> <pre><code>   +12.34\n</code></pre> <ul> <li>Les nombres n\u00e9gatifs affichent d\u00e9j\u00e0 <code>-</code>.</li> <li>\u00c9crase l\u2019indicateur espace (qui affiche un espace en t\u00eate pour les valeurs positives).</li> </ul> <p></p>"},{"location":"fr/module-03/formatting/#13117-parentheses-pour-les-negatifs-indicateur","title":"13.1.1.7 Parenth\u00e8ses pour les n\u00e9gatifs Indicateur <code>(</code>","text":"<p>L\u2019indicateur <code>(</code> formate les nombres n\u00e9gatifs en utilisant des parenth\u00e8ses.</p> <pre><code>System.out.printf(\"%(8.2f\", -12.34);\n</code></pre> <pre><code> (12.34)\n</code></pre> <ul> <li>N\u2019affecte que les valeurs n\u00e9gatives.</li> <li>Rarement utilis\u00e9 en pratique.</li> </ul> <p></p>"},{"location":"fr/module-03/formatting/#13118-combinaison-des-indicateurs","title":"13.1.1.8 Combinaison des indicateurs","text":"<pre><code>System.out.printf(\"%+010.2f\", 12.34);\n</code></pre> <pre><code>+000012.34\n</code></pre> <p>Ordre d\u2019\u00e9valuation (simplifi\u00e9) :</p> <ul> <li>La pr\u00e9cision est appliqu\u00e9e.</li> <li>Le signe est trait\u00e9.</li> <li>La largeur est appliqu\u00e9e.</li> <li>Le remplissage (espaces ou z\u00e9ros) est appliqu\u00e9.</li> </ul> <p></p>"},{"location":"fr/module-03/formatting/#13119-effets-du-locale","title":"13.1.1.9 Effets du Locale","text":"<pre><code>System.out.printf(Locale.FRANCE, \"%,.2f\", 12345.67);\n</code></pre> <pre><code>12 345,67\n</code></pre> <p>Les s\u00e9parateurs d\u00e9cimaux et de groupement d\u00e9pendent du <code>Locale</code> actif.</p> <p></p>"},{"location":"fr/module-03/formatting/#131110-erreurs-courantes","title":"13.1.1.10 Erreurs courantes","text":"<ul> <li><code>%f</code> utilise 6 d\u00e9cimales par d\u00e9faut si aucune pr\u00e9cision n\u2019est sp\u00e9cifi\u00e9e.</li> <li>La largeur ne tronque jamais la sortie ; elle ne fait qu\u2019ajouter du remplissage si n\u00e9cessaire.</li> <li>L\u2019indicateur <code>0</code> est ignor\u00e9 lorsque <code>-</code> est pr\u00e9sent.</li> <li><code>+</code> \u00e9crase l\u2019indicateur espace.</li> <li>Le groupement et les s\u00e9parateurs d\u00e9pendent du Locale.</li> </ul>"},{"location":"fr/module-03/formatting/#1312-valeurs-de-texte-personnalisees-et-echappement","title":"13.1.2 Valeurs de texte personnalis\u00e9es et \u00e9chappement","text":"<p>Certains caract\u00e8res ont une signification particuli\u00e8re dans les cha\u00eenes de format et doivent \u00eatre \u00e9chapp\u00e9s.</p> <ul> <li><code>%%</code> \u2192 signe pourcentage litt\u00e9ral.</li> <li><code>\\n</code>, <code>\\t</code> \u2192 \u00e9chappements Java standards.</li> </ul> <pre><code>String msg = String.format(\"Completion: %d%%%nStatus: OK\", 100);\nSystem.out.println(msg);\n</code></pre> <p>Sortie :</p> <pre><code>Completion: 100%\nStatus: OK\n</code></pre> <p>Note</p> <p>Un seul % sans sp\u00e9cificateur valide provoque une IllegalFormatException \u00e0 l\u2019ex\u00e9cution.</p> <p></p>"},{"location":"fr/module-03/formatting/#132-mise-en-forme-des-nombres","title":"13.2 Mise en forme des nombres","text":""},{"location":"fr/module-03/formatting/#1321-numberformat","title":"13.2.1 NumberFormat","text":"<p><code>NumberFormat</code> est une classe abstraite utilis\u00e9e pour formater et analyser les nombres de mani\u00e8re sensible au locale.</p> <pre><code>NumberFormat nf = NumberFormat.getInstance(Locale.FRANCE);\nSystem.out.println(nf.format(1234567.89));\n</code></pre> <p>Important</p> <ul> <li>Les m\u00e9thodes factory d\u00e9terminent le style de formatage (g\u00e9n\u00e9ral, entier, monnaie, pourcentage, compact, ...).</li> <li>Le formatage d\u00e9pend du <code>Locale</code> fourni.</li> <li><code>NumberFormat</code> (et <code>DecimalFormat</code>) ne sont pas thread-safe.</li> </ul> <p></p>"},{"location":"fr/module-03/formatting/#1322-localisation-des-nombres","title":"13.2.2 Localisation des nombres","text":"<p>La localisation des nombres affecte les s\u00e9parateurs d\u00e9cimaux, les s\u00e9parateurs de groupement et les symboles mon\u00e9taires.</p> <pre><code>NumberFormat nfUS = NumberFormat.getInstance(Locale.US);\nNumberFormat nfIT = NumberFormat.getInstance(Locale.ITALY);\n\nSystem.out.println(nfUS.format(1234.56)); // 1,234.56\nSystem.out.println(nfIT.format(1234.56)); // 1.234,56\n</code></pre> <p></p>"},{"location":"fr/module-03/formatting/#1323-decimalformat-et-numberformat","title":"13.2.3 DecimalFormat et NumberFormat","text":"<p><code>DecimalFormat</code> est une sous-classe concr\u00e8te de <code>NumberFormat</code> qui offre un contr\u00f4le fin de la mise en forme num\u00e9rique \u00e0 l\u2019aide de patterns.</p> <p><code>NumberFormat</code> d\u00e9finit un formatage sensible au locale via des m\u00e9thodes factory, tandis que <code>DecimalFormat</code> permet un contr\u00f4le explicite bas\u00e9 sur des patterns.</p> <pre><code>NumberFormat nf = NumberFormat.getInstance(Locale.US);\nDecimalFormat df = (DecimalFormat) nf;\n</code></pre> <p>Ou directement :</p> <pre><code>DecimalFormat df = new DecimalFormat(\"#,##0.00\");\n</code></pre> <p>Note</p> <ul> <li><code>DecimalFormat</code> est mutable (on peut modifier le pattern, les symboles, etc.).</li> <li><code>DecimalFormat</code> n\u2019est pas thread-safe.</li> <li>Le formatage est sensible au locale via <code>DecimalFormatSymbols</code>.</li> </ul> <p></p>"},{"location":"fr/module-03/formatting/#1324-structure-du-pattern-decimalformat","title":"13.2.4 Structure du pattern DecimalFormat","text":"<p>Un pattern peut contenir une sous-structure positive et une sous-structure n\u00e9gative optionnelle, s\u00e9par\u00e9es par <code>;</code>.</p> <pre><code>#,##0.00;(#,##0.00)\n</code></pre> <p>Note</p> <ul> <li>Premi\u00e8re partie \u2192 nombres positifs.</li> <li>Seconde partie \u2192 nombres n\u00e9gatifs.</li> <li>Si la partie n\u00e9gative est omise, les nombres n\u00e9gatifs utilisent automatiquement un <code>-</code> en t\u00eate.</li> </ul> <p></p>"},{"location":"fr/module-03/formatting/#1325-le-symbole-0-chiffre-obligatoire","title":"13.2.5 Le symbole <code>0</code> (chiffre obligatoire)","text":"<p>Le symbole <code>0</code> force l\u2019affichage d\u2019un chiffre, en compl\u00e9tant avec des z\u00e9ros si n\u00e9cessaire.</p> <pre><code>DecimalFormat df = new DecimalFormat(\"0000.00\");\nSystem.out.println(df.format(12.3));\n</code></pre> <pre><code>0012.30\n</code></pre> <ul> <li>Contr\u00f4le le nombre minimal de chiffres.</li> <li>Compl\u00e8te avec des z\u00e9ros si le nombre contient moins de chiffres.</li> <li>Utile pour des sorties \u00e0 largeur fixe ou align\u00e9es.</li> </ul> <p></p>"},{"location":"fr/module-03/formatting/#1326-le-symbole-chiffre-optionnel","title":"13.2.6 Le symbole <code>#</code> (chiffre optionnel)","text":"<p>Le symbole <code>#</code> affiche un chiffre uniquement s\u2019il existe.</p> <pre><code>DecimalFormat df = new DecimalFormat(\"####.##\");\nSystem.out.println(df.format(12.3));\n</code></pre> <pre><code>12.3\n</code></pre> <ul> <li>Supprime les z\u00e9ros initiaux.</li> <li>Supprime les z\u00e9ros finaux inutiles.</li> <li>Adapt\u00e9 \u00e0 un formatage \u00ab convivial \u00bb.</li> </ul> <p></p>"},{"location":"fr/module-03/formatting/#1327-combiner-0-et","title":"13.2.7 Combiner <code>0</code> et <code>#</code>","text":"<p>Les patterns combinent souvent les deux symboles pour plus de flexibilit\u00e9.</p> <pre><code>DecimalFormat df = new DecimalFormat(\"#,##0.##\");\nSystem.out.println(df.format(12));\nSystem.out.println(df.format(12.5));\nSystem.out.println(df.format(12345.678));\n</code></pre> <pre><code>12\n12.5\n12,345.68\n</code></pre> <p>Explication du pattern :</p> <pre><code>#,##0 . ##\n ^  ^    ^\n |  |    |\n |  |    \u2514\u2500 chiffres fractionnaires optionnels (#)\n |  \u2514\u2500\u2500\u2500\u2500\u2500 chiffre entier obligatoire (0)\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 pattern de groupement (,)\n</code></pre> <ul> <li>Au moins un chiffre entier est garanti (le <code>0</code>).</li> <li>Les chiffres sont regroup\u00e9s par milliers \u00e0 l\u2019aide du s\u00e9parateur de groupement.</li> <li>Les chiffres fractionnaires sont optionnels (jusqu\u2019\u00e0 deux).</li> </ul> <p></p>"},{"location":"fr/module-03/formatting/#1328-separateurs-decimaux-et-de-groupement","title":"13.2.8 S\u00e9parateurs d\u00e9cimaux et de groupement","text":"<p>Dans les patterns :</p> <ul> <li><code>.</code> \u2192 s\u00e9parateur d\u00e9cimal.</li> <li><code>,</code> \u2192 s\u00e9parateur de groupement.</li> </ul> <p>Les symboles effectivement utilis\u00e9s \u00e0 l\u2019ex\u00e9cution d\u00e9pendent du <code>Locale</code> (par exemple, virgule vs point).</p> <p></p>"},{"location":"fr/module-03/formatting/#1329-decimalformatsymbols-symboles-de-format-specifiques-au-locale","title":"13.2.9 DecimalFormatSymbols : symboles de format sp\u00e9cifiques au Locale","text":"<pre><code>DecimalFormatSymbols symbols =\n        DecimalFormatSymbols.getInstance(Locale.FRANCE);\n\nDecimalFormat df =\n        new DecimalFormat(\"#,##0.00\", symbols);\n\nSystem.out.println(df.format(1234.5));\n</code></pre> <pre><code>1 234,50\n</code></pre> <ul> <li>Contr\u00f4le les s\u00e9parateurs d\u00e9cimaux et de groupement.</li> <li>Contr\u00f4le le signe moins et le symbole mon\u00e9taire.</li> <li>Contr\u00f4le les cha\u00eenes NaN et Infinity.</li> </ul>"},{"location":"fr/module-03/formatting/#13210-patterns-speciaux-de-decimalformat","title":"13.2.10 Patterns sp\u00e9ciaux de DecimalFormat","text":"<pre><code>0.###E0   notation scientifique\n###%      pourcentage\n\u00a4#,##0.00 monnaie (\u00a4 est le symbole mon\u00e9taire)\n</code></pre>"},{"location":"fr/module-03/formatting/#13211-regles-et-erreurs-courantes","title":"13.2.11 R\u00e8gles et erreurs courantes","text":"<ul> <li><code>DecimalFormat</code> est une sous-classe de <code>NumberFormat</code>.</li> <li><code>0</code> force les chiffres, <code>#</code> non.</li> <li>Les patterns contr\u00f4lent le formatage, pas le mode d\u2019arrondi (utiliser <code>setRoundingMode()</code>).</li> <li>Le groupement fonctionne uniquement si le s\u00e9parateur (g\u00e9n\u00e9ralement <code>,</code>) est pr\u00e9sent dans le pattern.</li> <li>Le parsing peut r\u00e9ussir partiellement sans erreur si des caract\u00e8res finaux suivent un nombre valide.</li> <li><code>DecimalFormat</code> est mutable et non thread-safe.</li> </ul>"},{"location":"fr/module-03/formatting/#133-analyse-parsing-des-nombres","title":"13.3 Analyse (parsing) des nombres","text":"<p>L\u2019analyse convertit un texte localis\u00e9 en valeurs num\u00e9riques. Par d\u00e9faut, l\u2019analyse est permissive.</p> <pre><code>NumberFormat nf = NumberFormat.getInstance(Locale.FRANCE);\nNumber n = nf.parse(\"12 345,67abc\"); // analyse 12345.67\n</code></pre> <ul> <li>L\u2019analyse s\u2019arr\u00eate au premier caract\u00e8re invalide.</li> <li>Le texte final est ignor\u00e9 sauf v\u00e9rification explicite.</li> </ul> <p></p>"},{"location":"fr/module-03/formatting/#1331-parsing-avec-decimalformat","title":"13.3.1 Parsing avec DecimalFormat","text":"<p><code>DecimalFormat</code> peut \u00e9galement analyser des nombres. L\u2019analyse est permissive par d\u00e9faut.</p> <pre><code>DecimalFormat df = new DecimalFormat(\"#,##0.##\");\nNumber n = df.parse(\"1,234.56abc\");\n</code></pre> <ul> <li>L\u2019analyse s\u2019arr\u00eate au premier caract\u00e8re invalide.</li> <li>Le texte final est ignor\u00e9 s\u2019il est pr\u00e9sent.</li> </ul> <p>Pour imposer une analyse stricte :</p> <pre><code>df.setParseStrict(true);\n</code></pre> <p></p>"},{"location":"fr/module-03/formatting/#1332-compactnumberformat","title":"13.3.2 CompactNumberFormat","text":"<p>La mise en forme compacte abr\u00e8ge les grands nombres pour une meilleure lisibilit\u00e9 humaine.</p> <ul> <li>Prend en charge les styles SHORT et LONG.</li> <li>Utilise des abr\u00e9viations d\u00e9pendantes du locale (par exemple K, M, \u00ab million \u00bb).</li> </ul> <pre><code>NumberFormat cnf =\n        NumberFormat.getCompactNumberInstance(\n                Locale.US, NumberFormat.Style.SHORT);\n\nSystem.out.println(cnf.format(1_200));        // 1.2K\nSystem.out.println(cnf.format(5_000_000));    // 5M\n\nNumberFormat cnf1 =\n        NumberFormat.getCompactNumberInstance(\n                Locale.US, NumberFormat.Style.SHORT);\n\nNumberFormat cnf2 =\n        NumberFormat.getCompactNumberInstance(\n                Locale.US, NumberFormat.Style.LONG);\n\nSystem.out.println(cnf1.format(315_000_000));   // 315M\nSystem.out.println(cnf2.format(315_000_000));   // 315 million\n</code></pre> <p></p>"},{"location":"fr/module-03/formatting/#134-mise-en-forme-des-dates-et-heures","title":"13.4 Mise en forme des dates et heures","text":""},{"location":"fr/module-03/formatting/#1341-datetimeformatter","title":"13.4.1 DateTimeFormatter","text":"<p>Java 21 repose sur <code>java.time</code> et <code>DateTimeFormatter</code> pour la mise en forme moderne des dates et heures.</p> <pre><code>DateTimeFormatter f =\n        DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\");\nSystem.out.println(LocalDateTime.now().format(f));\n</code></pre> <p>Propri\u00e9t\u00e9s principales :</p> <ul> <li>Immuable.</li> <li>Thread-safe.</li> <li>Sensible au locale.</li> </ul> <p></p>"},{"location":"fr/module-03/formatting/#1342-symboles-standard-de-date-et-dheure","title":"13.4.2 Symboles standard de date et d\u2019heure","text":"<pre><code>y   ann\u00e9e\nM   num\u00e9ro du mois (ou nom avec plus de lettres)\nd   jour du mois\nE   nom du jour\nH   heure (0\u201323)\nh   heure (1\u201312)\nm   minute\ns   seconde\na   indicateur AM/PM\nz   fuseau horaire\n</code></pre>"},{"location":"fr/module-03/formatting/#1343-datetimeformat-vs-formatterformat","title":"13.4.3 datetime.format vs formatter.format","text":"<p>Les deux m\u00e9thodes sont fonctionnellement identiques :</p> <pre><code>date.format(formatter);\nformatter.format(date);\n</code></pre> <ul> <li><code>date.format(formatter)</code> \u2192 pr\u00e9f\u00e9r\u00e9 pour la lisibilit\u00e9 (donn\u00e9es d\u2019abord, puis formatage).</li> <li><code>formatter.format(date)</code> \u2192 parfois pratique dans un code fonctionnel ou avec des formatters r\u00e9utilisables.</li> </ul> <p></p>"},{"location":"fr/module-03/formatting/#1344-localisation-des-dates","title":"13.4.4 Localisation des dates","text":"<p>Les styles localis\u00e9s adaptent l\u2019affichage des dates aux normes culturelles.</p> <pre><code>DateTimeFormatter fullIt =\n        DateTimeFormatter\n                .ofLocalizedDate(FormatStyle.FULL)\n                .withLocale(Locale.ITALY);\n\nDateTimeFormatter shortIt =\n        DateTimeFormatter\n                .ofLocalizedDate(FormatStyle.SHORT)\n                .withLocale(Locale.ITALY);\n\nLocalDate today = LocalDate.of(2025, 12, 17);\n\nSystem.out.println(today.format(fullIt));\nSystem.out.println(today.format(shortIt));\n</code></pre> <p>Sortie possible :</p> <pre><code>mercoled\u00ec 17 dicembre 2025\n17/12/25\n</code></pre> <p></p>"},{"location":"fr/module-03/formatting/#135-internationalisation-i18n-et-localisation-l10n","title":"13.5 Internationalisation (i18n) et localisation (l10n)","text":""},{"location":"fr/module-03/formatting/#1351-locales","title":"13.5.1 Locales","text":"<p>Un <code>Locale</code> d\u00e9finit la langue, le pays et une variante optionnelle.</p> <pre><code>Locale l1 = Locale.US;\nLocale l2 = Locale.of(\"fr\", \"FR\");\nLocale l3 = new Locale.Builder()\n        .setLanguage(\"en\")\n        .setRegion(\"US\")\n        .build();\n</code></pre> <p>Formats de Locale :</p> <ul> <li><code>en</code> (it, fr, etc.) : code langue en minuscules.</li> <li><code>en_US</code> (fr_CA, it_IT, etc.) : code langue en minuscules + underscore + code pays en majuscules.</li> </ul> <p></p>"},{"location":"fr/module-03/formatting/#1352-categories-de-locale","title":"13.5.2 Cat\u00e9gories de Locale","text":"<p>Les cat\u00e9gories de Locale s\u00e9parent la mise en forme de la langue de l\u2019interface utilisateur.</p> <p><code>Locale.Category</code> permet \u00e0 Java d\u2019utiliser diff\u00e9rents Locale par d\u00e9faut selon les usages.</p> <p>Il existe deux cat\u00e9gories :</p> Cat\u00e9gorie Utilis\u00e9e pour FORMAT Nombres, dates, monnaie, autre formatage DISPLAY Texte lisible (UI, noms, messages) <p></p>"},{"location":"fr/module-03/formatting/#1353-exemple-reel","title":"13.5.3 Exemple r\u00e9el","text":"<p>Un utilisateur fran\u00e7ais vivant en Allemagne peut souhaiter :</p> <ul> <li>Nombres et dates \u2192 format allemand.</li> <li>Langue de l\u2019interface \u2192 fran\u00e7ais.</li> </ul> <p>Avant Java 7, cela n\u2019\u00e9tait pas possible.</p> <pre><code>Locale.setDefault(Locale.Category.FORMAT, Locale.GERMANY);\nLocale.setDefault(Locale.Category.DISPLAY, Locale.FRANCE);\n</code></pre> <p>Exemples d\u2019effets :</p> Aspect R\u00e9sultat (exemple) Nombres 1.234,56 Dates 31.12.2025 Monnaie \u20ac Texte UI Fran\u00e7ais Noms des mois d\u00e9cembre Noms des pays Allemagne <p></p>"},{"location":"fr/module-03/formatting/#136-properties-et-resource-bundles","title":"13.6 Properties et Resource Bundles","text":"<p>Les resource bundles externalisent le texte et permettent la localisation sans modifier le code.</p> <pre><code>ResourceBundle rb =\n        ResourceBundle.getBundle(\"messages\", Locale.GERMAN);\n\nString msg = rb.getString(\"welcome\");\n</code></pre> <p></p>"},{"location":"fr/module-03/formatting/#1361-regles-de-resolution-des-resource-bundles","title":"13.6.1 R\u00e8gles de r\u00e9solution des Resource Bundles","text":"<p>Java recherche les bundles selon un ordre de repli strict. Par exemple, avec le nom de base <code>messages</code> et le locale <code>de_DE</code> :</p> <ul> <li>messages_de_DE.properties</li> <li>messages_de.properties</li> <li>messages.properties</li> </ul> <p>Si aucun n\u2019est trouv\u00e9 \u2192 <code>MissingResourceException</code>.</p> <p>Note</p> <p>Les fichiers <code>.properties</code> traditionnels sont sp\u00e9cifi\u00e9s en ISO-8859-1 ; les caract\u00e8res non ASCII doivent \u00eatre encod\u00e9s via des \u00e9chappements Unicode (par exemple <code>\\u00E9</code> pour \u00e9), sauf si des m\u00e9canismes de chargement alternatifs sont utilis\u00e9s.</p> <p></p>"},{"location":"fr/module-03/formatting/#137-regles-et-erreurs-courantes","title":"13.7 R\u00e8gles et erreurs courantes","text":"<ul> <li><code>DateTimeFormatter</code> est immuable et thread-safe.</li> <li><code>NumberFormat</code> / <code>DecimalFormat</code> sont mutables et non thread-safe.</li> <li>Modifier le <code>Locale</code> affecte la mani\u00e8re dont les valeurs sont format\u00e9es et analys\u00e9es, et non les valeurs num\u00e9riques ou temporelles sous-jacentes.</li> <li>L\u2019analyse avec <code>NumberFormat</code> ou <code>DecimalFormat</code> peut r\u00e9ussir partiellement sans exception si du texte suppl\u00e9mentaire suit un nombre valide.</li> <li><code>java.time</code> remplace la plupart des usages des anciennes API <code>java.util.Date</code> / <code>Calendar</code> dans le code moderne et \u00e0 l\u2019examen.</li> </ul>"},{"location":"fr/module-03/math/","title":"11. Math\u00e9matiques en Java","text":""},{"location":"fr/module-03/math/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>11.1 API Math<ul> <li>11.1.1 Maximum et minimum entre deux valeurs</li> <li>11.1.2 Math.round</li> <li>11.1.3 Math.ceil (Ceiling)</li> <li>11.1.4 Math.floor (Floor)</li> <li>11.1.5 Math.pow</li> <li>11.1.6 Math.random</li> <li>11.1.7 Math.abs</li> <li>11.1.8 Math.sqrt</li> <li>11.1.9 Tableau r\u00e9capitulatif</li> </ul> </li> <li>11.2 BigInteger et BigDecimal<ul> <li>11.2.1 Pourquoi double et float ne suffisent pas</li> <li>11.2.2 BigInteger \u2014 Entiers \u00e0 pr\u00e9cision arbitraire</li> <li>11.2.3 Cr\u00e9er BigInteger</li> <li>11.2.4 Op\u00e9rations (pas d\u2019op\u00e9rateurs)</li> </ul> </li> </ul>"},{"location":"fr/module-03/math/#111-api-math","title":"11.1 API Math","text":"<p>La classe <code>java.lang.Math</code> fournit un ensemble de m\u00e9thodes statiques utiles pour les op\u00e9rations num\u00e9riques.</p> <p>Ces m\u00e9thodes fonctionnent avec les types num\u00e9riques primitifs.</p> <p>Ci-dessous se trouve un r\u00e9sum\u00e9 des plus fr\u00e9quemment utilis\u00e9es, ainsi que leurs formes surcharg\u00e9es.</p> <p></p>"},{"location":"fr/module-03/math/#1111-maximum-et-minimum-entre-deux-valeurs","title":"11.1.1 Maximum et minimum entre deux valeurs","text":"<p><code>Math.max()</code> et <code>Math.min()</code> comparent les deux valeurs fournies et renvoient le maximum ou le minimum entre elles.</p> <p>Il existe quatre versions surcharg\u00e9es pour chaque m\u00e9thode :</p> <pre><code>public static int min(int x, int y);\npublic static float min(float x, float y);\npublic static long min(long x, long y);\npublic static double min(double x, double y);\n\npublic static int max(int x, int y);\npublic static float max(float x, float y);\npublic static long max(long x, long y);\npublic static double max(double x, double y);\n</code></pre> <ul> <li>Exemple :</li> </ul> <pre><code>System.out.println(Math.max(10.50, 7.5));   // 10.5\nSystem.out.println(Math.min(10, -20));      // -20\n</code></pre> <p></p>"},{"location":"fr/module-03/math/#1112-mathround","title":"11.1.2 <code>Math.round()</code>","text":"<p><code>round()</code> renvoie l\u2019entier le plus proche de son argument, en suivant les r\u00e8gles d\u2019arrondi standard : les valeurs dont la partie fractionnaire est 0.5 et au-dessus sont arrondies vers le haut ; en dessous de 0.5 elles sont arrondies vers le bas (vers l\u2019entier le plus proche).</p> <p>Surcharges - <code>long round(double value)</code> - <code>int round(float value)</code></p> <ul> <li>Exemples :</li> </ul> <pre><code>Math.round(3.2);    // 3   (returns long)\nMath.round(3.6);    // 4\nMath.round(-3.5f);  // -3  (float version returns int)\n</code></pre> <p>Note</p> <ul> <li>La version <code>float</code> renvoie un <code>int</code>.</li> <li>La version <code>double</code> renvoie un <code>long</code>.</li> </ul> <p></p>"},{"location":"fr/module-03/math/#1113-mathceil-ceiling","title":"11.1.3 <code>Math.ceil()</code> (Ceiling)","text":"<p><code>ceil()</code> renvoie la plus petite valeur <code>double</code> qui est sup\u00e9rieure ou \u00e9gale \u00e0 l\u2019argument.</p> <p>Surcharge - <code>double ceil(double value)</code></p> <ul> <li>Exemples :</li> </ul> <pre><code>Math.ceil(3.1);   // 4.0\nMath.ceil(-3.1);  // -3.0\n</code></pre> <p></p>"},{"location":"fr/module-03/math/#1114-mathfloor-floor","title":"11.1.4 <code>Math.floor()</code> (Floor)","text":"<p><code>floor()</code> renvoie la plus grande valeur <code>double</code> qui est inf\u00e9rieure ou \u00e9gale \u00e0 l\u2019argument.</p> <p>Surcharge - <code>double floor(double value)</code></p> <ul> <li>Exemples :</li> </ul> <pre><code>Math.floor(3.9);   // 3.0\nMath.floor(-3.1);  // -4.0\n</code></pre> <p></p>"},{"location":"fr/module-03/math/#1115-mathpow","title":"11.1.5 <code>Math.pow()</code>","text":"<p><code>pow()</code> \u00e9l\u00e8ve une valeur \u00e0 une puissance.</p> <p>Surcharge - <code>double pow(double base, double exponent)</code></p> <ul> <li>Exemples :</li> </ul> <pre><code>Math.pow(2, 3);      // 8.0\nMath.pow(9, 0.5);    // 3.0  (square root)\nMath.pow(10, -1);    // 0.1\n</code></pre> <p></p>"},{"location":"fr/module-03/math/#1116-mathrandom","title":"11.1.6 <code>Math.random()</code>","text":"<p><code>random()</code> renvoie un <code>double</code> dans l\u2019intervalle <code>[0.0, 1.0)</code> (0.0 inclus, 1.0 exclus).</p> <p>Surcharge - <code>double random()</code></p> <ul> <li>Exemples :</li> </ul> <pre><code>double r = Math.random();   // 0.0 &lt;= r &lt; 1.0\n\n// Example: random int 0\u20139\nint x = (int)(Math.random() * 10);\n</code></pre> <p></p>"},{"location":"fr/module-03/math/#1117-mathabs","title":"11.1.7 <code>Math.abs()</code>","text":"<p><code>abs()</code> renvoie la valeur absolue (distance \u00e0 z\u00e9ro).</p> <p>Surcharges - <code>int abs(int value)</code> - <code>long abs(long value)</code> - <code>float abs(float value)</code> - <code>double abs(double value)</code></p> <p></p>"},{"location":"fr/module-03/math/#1118-mathsqrt","title":"11.1.8 <code>Math.sqrt()</code>","text":"<p><code>sqrt()</code> calcule la racine carr\u00e9e et renvoie un <code>double</code>.</p> <pre><code>Math.sqrt(9);    // 3.0\nMath.sqrt(-1);   // NaN (not a number)\n</code></pre> <p></p>"},{"location":"fr/module-03/math/#1119-tableau-recapitulatif","title":"11.1.9 Tableau r\u00e9capitulatif","text":"M\u00e9thode Renvoie Surcharges Notes <code>round()</code> int ou long float, double Entier le plus proche <code>ceil()</code> double double Plus petite valeur &gt;= argument <code>floor()</code> double double Plus grande valeur &lt;= argument <code>pow()</code> double double, double Exponentiation <code>random()</code> double none 0.0 &lt;= r &lt; 1.0 <code>min()/max()</code> m\u00eame type int, long, float, double Compare deux valeurs <code>abs()</code> m\u00eame type int, long, float, double Valeur absolue <code>sqrt()</code> double double Racine carr\u00e9e"},{"location":"fr/module-03/math/#112-biginteger-et-bigdecimal","title":"11.2 BigInteger et BigDecimal","text":"<p>Les classes <code>BigInteger</code> et <code>BigDecimal</code> (dans <code>java.math</code>) fournissent des types num\u00e9riques \u00e0 pr\u00e9cision arbitraire.</p> <p>Elles sont utilis\u00e9es lorsque :</p> <ul> <li>Les types primitifs (<code>int</code>, <code>long</code>, <code>double</code>, etc.) n\u2019ont pas une plage suffisante.</li> <li>Les erreurs d\u2019arrondi en virgule flottante de <code>float</code>/<code>double</code> ne sont pas acceptables (par exemple, dans les calculs financiers).</li> </ul> <p>Les deux sont immutables : chaque op\u00e9ration renvoie une nouvelle instance.</p> <p></p>"},{"location":"fr/module-03/math/#1121-pourquoi-double-et-float-ne-suffisent-pas","title":"11.2.1 Pourquoi <code>double</code> et <code>float</code> ne suffisent pas","text":"<p>Les types en virgule flottante (<code>float</code>, <code>double</code>) utilisent une repr\u00e9sentation binaire. Beaucoup de fractions d\u00e9cimales ne peuvent pas \u00eatre repr\u00e9sent\u00e9es exactement (comme 0.1 ou 0.2), ce qui produit des erreurs d\u2019arrondi :</p> <pre><code>System.out.println(0.1 + 0.2); // 0.30000000000000004 \n</code></pre> <p>Pour des t\u00e2ches comme les calculs financiers, cela est inacceptable.</p> <p><code>BigDecimal</code> r\u00e9sout ce probl\u00e8me en repr\u00e9sentant les nombres \u00e0 l\u2019aide d\u2019un mod\u00e8le d\u00e9cimal avec une \u00e9chelle configurable (nombre de chiffres apr\u00e8s la virgule).</p> <p></p>"},{"location":"fr/module-03/math/#1122-biginteger-entiers-a-precision-arbitraire","title":"11.2.2 BigInteger \u2014 Entiers \u00e0 pr\u00e9cision arbitraire","text":"<p><code>BigInteger</code> repr\u00e9sente des valeurs enti\u00e8res de taille pratiquement quelconque, limit\u00e9e uniquement par la m\u00e9moire disponible.</p> <p></p>"},{"location":"fr/module-03/math/#1123-creer-biginteger","title":"11.2.3 Cr\u00e9er BigInteger","text":"<p>M\u00e9thodes courantes :</p> <p>\u00c0 partir d\u2019un long</p> <pre><code>static BigInteger valueOf(long val);\n</code></pre> <p>\u00c0 partir d\u2019une String</p> <pre><code>BigInteger(String val);        // decimal by default\nBigInteger(String val, int radix);\n</code></pre> <p>Valeur al\u00e9atoire</p> <pre><code>BigInteger(int numBits, Random rnd);\n</code></pre> <ul> <li>Exemples :</li> </ul> <pre><code>import java.math.BigInteger;\nimport java.math.BigDecimal;\nimport java.util.Random;\n\nBigInteger a = BigInteger.valueOf(10L);\n\n// You can pass a long to both types, but a double only to BigDecimal\n\nBigInteger g = BigInteger.valueOf(3000L);\nBigDecimal p = BigDecimal.valueOf(3000L);\nBigDecimal q = BigDecimal.valueOf(3000.00);\n\nBigInteger b = new BigInteger(\"12345678901234567890\"); // decimal string\nBigInteger c = new BigInteger(\"FF\", 16);               // 255 in base 16\nBigInteger r = new BigInteger(128, new Random());      // random 128-bit number\n</code></pre> <p></p>"},{"location":"fr/module-03/math/#1124-operations-pas-doperateurs","title":"11.2.4 Op\u00e9rations (pas d\u2019op\u00e9rateurs !)","text":"<p>Vous ne pouvez pas utiliser les op\u00e9rateurs arithm\u00e9tiques standards (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>) avec <code>BigInteger</code> ou <code>BigDecimal</code>.</p> <p>\u00c0 la place, vous devez appeler des m\u00e9thodes (qui renvoient toutes de nouvelles instances). En voici quelques-unes courantes pour <code>BigInteger</code> :</p> <ul> <li><code>add(BigInteger val)</code></li> <li><code>subtract(BigInteger val)</code></li> <li><code>multiply(BigInteger val)</code></li> <li><code>divide(BigInteger val)</code> \u2013 division enti\u00e8re</li> <li><code>remainder(BigInteger val)</code></li> <li><code>pow(int exponent)</code></li> <li><code>negate()</code></li> <li><code>abs()</code></li> <li><code>gcd(BigInteger val)</code></li> <li> <p><code>compareTo(BigInteger val)</code> \u2013 ordre</p> </li> <li> <p>Exemple :</p> </li> </ul> <pre><code>BigInteger x = new BigInteger(\"100000000000000000000\");\nBigInteger y = new BigInteger(\"3\");\n\nBigInteger sum = x.add(y);        // x + y\nBigInteger prod = x.multiply(y);  // x * y\nBigInteger div = x.divide(y);     // integer division\nBigInteger rem = x.remainder(y);  // modulus\n\nif (x.compareTo(y) &gt; 0) {\n    System.out.println(\"x is larger\");\n}\n</code></pre>"},{"location":"fr/module-03/strings/","title":"9. Cha\u00eenes de caract\u00e8res en Java","text":""},{"location":"fr/module-03/strings/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>9.1 Cha\u00eenes &amp; Text Blocks<ul> <li>9.1.1 Cha\u00eenes<ul> <li>9.1.1.1 Initialiser des cha\u00eenes</li> <li>9.1.1.2 Le String Pool</li> <li>9.1.1.3 Caract\u00e8res sp\u00e9ciaux et s\u00e9quences d\u2019\u00e9chappement</li> <li>9.1.1.4 R\u00e8gles de concat\u00e9nation des cha\u00eenes</li> <li>9.1.1.5 R\u00e8gles de concat\u00e9nation</li> </ul> </li> <li>9.1.2 Text Blocks (depuis Java 15)<ul> <li>9.1.2.1 Mise en forme : espaces essentiels vs incidentels</li> <li>9.1.2.2 Nombre de lignes, lignes vides et retours \u00e0 la ligne</li> <li>9.1.2.3 Text Blocks et caract\u00e8res d\u2019\u00e9chappement</li> <li>9.1.2.4 Erreurs courantes (avec corrections)</li> </ul> </li> </ul> </li> <li>9.2 M\u00e9thodes principales des cha\u00eenes<ul> <li>9.2.1 Indexation des cha\u00eenes</li> <li>9.2.2 M\u00e9thode length</li> <li>9.2.3 R\u00e8gles de bornes : index de d\u00e9but vs index de fin</li> <li>9.2.4 M\u00e9thodes utilisant uniquement l\u2019index de d\u00e9but (inclusif)</li> <li>9.2.5 M\u00e9thodes avec d\u00e9but inclusif / fin exclusive</li> <li>9.2.6 M\u00e9thodes op\u00e9rant sur toute la cha\u00eene</li> <li>9.2.7 Acc\u00e8s aux caract\u00e8res</li> <li>9.2.8 Recherche</li> <li>9.2.9 M\u00e9thodes de remplacement</li> <li>9.2.10 D\u00e9coupage et jonction</li> <li>9.2.11 M\u00e9thodes retournant des tableaux</li> <li>9.2.12 Indentation</li> <li>9.2.13 Exemples suppl\u00e9mentaires</li> </ul> </li> </ul>"},{"location":"fr/module-03/strings/#91-chaines-text-blocks","title":"9.1 Cha\u00eenes &amp; Text Blocks","text":""},{"location":"fr/module-03/strings/#911-chaines","title":"9.1.1 Cha\u00eenes","text":""},{"location":"fr/module-03/strings/#9111-initialiser-des-chaines","title":"9.1.1.1 Initialiser des cha\u00eenes","text":"<p>En Java, une String est un objet de la classe <code>java.lang.String</code>, utilis\u00e9 pour repr\u00e9senter une s\u00e9quence de caract\u00e8res.</p> <p>Les cha\u00eenes sont immutables : une fois cr\u00e9\u00e9es, leur contenu ne peut pas \u00eatre modifi\u00e9. Toute op\u00e9ration qui semble modifier une cha\u00eene en cr\u00e9e en r\u00e9alit\u00e9 une nouvelle.</p> <p>Vous pouvez cr\u00e9er et initialiser des cha\u00eenes de plusieurs fa\u00e7ons :</p> <pre><code>String s1 = \"Hello\";                    // string literal\nString s2 = new String(\"Hello\");        // using constructor (not recommended)\nString s3 = s1.toUpperCase();           // creates a new String (\"HELLO\")\n</code></pre> <p>Note</p> <ul> <li>Les litt\u00e9raux de cha\u00eene sont stock\u00e9s dans le <code>pool de String</code>, une zone m\u00e9moire sp\u00e9ciale utilis\u00e9e pour \u00e9viter de cr\u00e9er des objets cha\u00eene en double.</li> <li>L\u2019utilisation du mot-cl\u00e9 <code>new</code> cr\u00e9e toujours un nouvel objet en dehors du pool.</li> </ul> <p></p>"},{"location":"fr/module-03/strings/#9112-le-string-pool","title":"9.1.1.2 Le String Pool","text":"<p>Comme les objets <code>String</code> sont immuables et largement utilis\u00e9s, ils pourraient facilement occuper une grande quantit\u00e9 de m\u00e9moire dans un programme Java.</p> <p>Pour r\u00e9duire la duplication, Java r\u00e9utilise toutes les cha\u00eenes d\u00e9clar\u00e9es comme litt\u00e9raux (voir l\u2019exemple ci-dessus), en les stockant dans une zone d\u00e9di\u00e9e de la JVM appel\u00e9e String Pool ou Intern Pool.</p> <p>Veuillez consulter le paragraphe : \"6.4.3 String Pool and Equality\" dans le chapitre : Instanciation des types pour une explication et des exemples plus d\u00e9taill\u00e9s.</p> <p></p>"},{"location":"fr/module-03/strings/#9113-caracteres-speciaux-et-sequences-dechappement","title":"9.1.1.3 Caract\u00e8res sp\u00e9ciaux et s\u00e9quences d\u2019\u00e9chappement","text":"<p>Les cha\u00eenes peuvent contenir des caract\u00e8res d\u2019\u00e9chappement, qui permettent d\u2019inclure des symboles sp\u00e9ciaux ou des caract\u00e8res de contr\u00f4le (caract\u00e8res ayant une signification sp\u00e9ciale en Java). Une s\u00e9quence d\u2019\u00e9chappement commence par un backslash <code>\\</code>.</p> <p>Note</p> <p>Table des caract\u00e8res sp\u00e9ciaux &amp; s\u00e9quences d\u2019\u00e9chappement dans les cha\u00eenes</p> Escape Signification Exemple Java R\u00e9sultat <code>\\\"</code> guillemet double <code>\"She said \\\"Hi\\\"\"</code> <code>She said \"Hi\"</code> <code>\\\\</code> backslash <code>\"C:\\\\Users\\\\Alex\"</code> <code>C:\\Users\\Alex</code> <code>\\n</code> nouvelle ligne (LF) <code>\"Hello\\nWorld\"</code> <code>Hello</code> + line break + <code>World</code> <code>\\r</code> retour chariot (CR) <code>\"A\\rB\"</code> <code>CR before B</code> <code>\\t</code> tabulation <code>\"Name\\tAge\"</code> <code>Name    Age</code> <code>\\'</code> guillemet simple <code>\"It\\'s ok\"</code> <code>It's ok</code> <code>\\b</code> retour arri\u00e8re (backspace) <code>\"AB\\bC\"</code> <code>AC</code> (le <code>B</code> est supprim\u00e9 visuellement) <code>\\uXXXX</code> unit\u00e9 de code Unicode <code>\"\\u00A9\"</code> <code>\u00a9</code> <p></p>"},{"location":"fr/module-03/strings/#9114-regles-de-concatenation-des-chaines","title":"9.1.1.4 R\u00e8gles de concat\u00e9nation des cha\u00eenes","text":"<p>Comme introduit dans le chapitre sur Op\u00e9rateurs Java, le symbole <code>+</code> repr\u00e9sente normalement l\u2019addition arithm\u00e9tique lorsqu\u2019il est utilis\u00e9 avec des op\u00e9randes num\u00e9riques.</p> <p>Cependant, lorsqu\u2019il est appliqu\u00e9 aux String, le m\u00eame op\u00e9rateur effectue la concat\u00e9nation de cha\u00eenes \u2014 il cr\u00e9e une nouvelle cha\u00eene en joignant les op\u00e9randes.</p> <p>Comme l\u2019op\u00e9rateur <code>+</code> peut appara\u00eetre dans des expressions o\u00f9 des nombres et des cha\u00eenes sont pr\u00e9sents, Java applique un ensemble sp\u00e9cifique de r\u00e8gles pour d\u00e9terminer si <code>+</code> signifie addition num\u00e9rique ou concat\u00e9nation de cha\u00eenes.</p> <p></p>"},{"location":"fr/module-03/strings/#9115-regles-de-concatenation","title":"9.1.1.5 R\u00e8gles de concat\u00e9nation","text":"<ul> <li>Si les deux op\u00e9randes sont num\u00e9riques, <code>+</code> effectue l\u2019addition num\u00e9rique.</li> <li>Si au moins un op\u00e9rande est une <code>String</code>, l\u2019op\u00e9rateur <code>+</code> effectue la concat\u00e9nation de cha\u00eenes.</li> <li>L\u2019\u00e9valuation se fait strictement de gauche \u00e0 droite, car <code>+</code> est associatif \u00e0 gauche.  </li> </ul> <p>Cela signifie qu\u2019une fois qu\u2019une <code>String</code> appara\u00eet sur le c\u00f4t\u00e9 gauche de l\u2019expression, toutes les op\u00e9rations <code>+</code> suivantes deviennent des concat\u00e9nations.</p> <p>Tip</p> <p>Comme l\u2019\u00e9valuation se fait de gauche \u00e0 droite, la position du premier op\u00e9rande <code>String</code> d\u00e9termine comment le reste de l\u2019expression est \u00e9valu\u00e9.</p> <ul> <li>Exemples</li> </ul> <pre><code>// *** Pure numeric addition\n\nint a = 10 + 20;        // 30\ndouble b = 1.5 + 2.3;   // 3.8\n\n\n\n// *** String concatenation when at least one operand is a String\n\nString s = \"Hello\" + \" World\";  // \"Hello World\"\nString t = \"Value: \" + 10;      // \"Value: 10\"\n\n\n\n// *** Left-to-right evaluation affects the result\n\nSystem.out.println(1 + 2 + \" apples\"); \n// 3 + \" apples\"  \u2192 \"3 apples\"\n\nSystem.out.println(\"apples: \" + 1 + 2); \n// \"apples: 1\" + 2 \u2192 \"apples: 12\"\n\n\n\n// *** Adding parentheses changes the meaning\n\nSystem.out.println(\"apples: \" + (1 + 2)); \n// parentheses force numeric addition \u2192 \"apples: 3\"\n\n\n\n// *** Mixed types with multiple operands\n\nString result = 10 + 20 + \"\" + 30 + 40;\n// (10 + 20) = 30\n// 30 + \"\"  = \"30\"\n// \"30\" + 30 = \"3030\"\nString out = \"3030\" + 40; // \"303040\"\n\nSystem.out.println(1 + 2 + \"3\" + 4 + 5);\n// Step 1: 1 + 2 = 3\n// Step 2: 3 + \"3\" = \"33\"\nString r = \"33\" + 4;  // \"334\"\n// Step 4: \"334\" + 5 = \"3345\"\n\n\n\n// *** null is represented as a string when concatenated\n\nSystem.out.println(\"AB\" + null);\n// ABnull\n</code></pre> <p></p>"},{"location":"fr/module-03/strings/#912-text-blocks-depuis-java-15","title":"9.1.2 Text Blocks (depuis Java 15)","text":"<p>Un text block est un litt\u00e9ral de cha\u00eene multi-ligne introduit pour simplifier l\u2019\u00e9criture de grandes cha\u00eenes (comme du HTML, du JSON ou du code) sans avoir besoin de nombreuses s\u00e9quences d\u2019\u00e9chappement.</p> <p>Un text block commence et se termine par trois guillemets doubles (<code>\"\"\"</code>).</p> <p>Vous pouvez utiliser les text blocks partout o\u00f9 vous utiliseriez des cha\u00eenes.</p> <pre><code>String html = \"\"\"\n    &lt;html&gt;\n        &lt;body&gt;\n            &lt;p&gt;Hello, world!&lt;/p&gt;\n        &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\";\n</code></pre> <p>Note</p> <ul> <li>Les text blocks incluent automatiquement les retours \u00e0 la ligne et l\u2019indentation pour la lisibilit\u00e9. Les newlines sont normalis\u00e9s en <code>\\n</code>.</li> <li>Les guillemets doubles \u00e0 l\u2019int\u00e9rieur du bloc n\u2019ont g\u00e9n\u00e9ralement pas besoin d\u2019\u00eatre \u00e9chapp\u00e9s.</li> <li>Le compilateur interpr\u00e8te le contenu entre les triples guillemets d\u2019ouverture et de fermeture comme la valeur de la cha\u00eene.</li> </ul> <p></p>"},{"location":"fr/module-03/strings/#9121-mise-en-forme-espaces-essentiels-vs-incidentels","title":"9.1.2.1 Mise en forme : espaces essentiels vs incidentels","text":"<ul> <li>Espaces essentiels : espaces et newlines qui font partie du contenu de cha\u00eene voulu.</li> <li>Espaces incidentels : indentation dans le code source que vous ne consid\u00e9rez pas conceptuellement comme faisant partie du texte.</li> </ul> <pre><code>String text = \"\"\"\n        Line 1\n        Line 2\n        Line 3\n        \"\"\";\n</code></pre> <p>Important</p> <ul> <li>Caract\u00e8re le plus \u00e0 gauche (baseline) : la position du premier caract\u00e8re non-espace sur l\u2019ensemble des lignes (ou les <code>\"\"\"</code> de fermeture) d\u00e9finit la baseline d\u2019indentation. Les espaces \u00e0 gauche de cette baseline sont consid\u00e9r\u00e9s comme incidentels et sont supprim\u00e9s.</li> <li>La ligne imm\u00e9diatement apr\u00e8s les <code>\"\"\"</code> d\u2019ouverture n\u2019est pas incluse dans la sortie si elle est vide (mise en forme typique).</li> <li>Le newline avant les <code>\"\"\"</code> de fermeture est inclus dans le contenu.   Dans l\u2019exemple ci-dessus, la cha\u00eene r\u00e9sultante se termine par un newline apr\u00e8s <code>\"Line 3\"</code> : il y a 4 lignes au total.</li> </ul> <p>Sortie avec num\u00e9ros de ligne (montrant la ligne vide finale) :</p> <pre><code>1: Line 1\n2: Line 2\n3: Line 3\n4:\n</code></pre> <p>Pour supprimer le newline final :</p> <ul> <li>Utilisez un backslash de continuation de ligne \u00e0 la fin de la derni\u00e8re ligne de contenu.</li> <li>Placez les triples guillemets de fermeture sur la m\u00eame ligne que le dernier contenu.</li> </ul> <pre><code>String textNoTrail_1 = \"\"\"\n        Line 1\n        Line 2\n        Line 3\\\n        \"\"\";\n\n// OR\n\nString textNoTrail_2 = \"\"\"\n        Line 1\n        Line 2\n        Line 3\"\"\";\n</code></pre> <p></p>"},{"location":"fr/module-03/strings/#9122-nombre-de-lignes-lignes-vides-et-retours-a-la-ligne","title":"9.1.2.2 Nombre de lignes, lignes vides et retours \u00e0 la ligne","text":"<ul> <li>Chaque retour \u00e0 la ligne visible \u00e0 l\u2019int\u00e9rieur du bloc devient <code>\\n</code>.</li> <li>Les lignes vides \u00e0 l\u2019int\u00e9rieur du bloc sont conserv\u00e9es.</li> </ul> <pre><code>String textNoTrail_0 = \"\"\"\n        Line 1  \n        Line 2 \\n\n        Line 3 \n\n        Line 4 \n        \"\"\";\n</code></pre> <p>Sortie :</p> <pre><code>1: Line 1\n2: Line 2\n3:\n4: Line 3\n5:\n6: Line 4\n7:\n</code></pre> <p></p>"},{"location":"fr/module-03/strings/#9123-text-blocks-et-caracteres-dechappement","title":"9.1.2.3 Text Blocks et caract\u00e8res d\u2019\u00e9chappement","text":"<p>Les s\u00e9quences d\u2019\u00e9chappement fonctionnent toujours \u00e0 l\u2019int\u00e9rieur des text blocks lorsque n\u00e9cessaire (par exemple, pour les backslashes ou des caract\u00e8res de contr\u00f4le explicites).</p> <pre><code>String json = \"\"\"\n    {\n      \"name\": \"Alice\",\n      \"path\": \"C:\\\\\\\\Users\\\\\\\\Alice\"\n    }\\\n    \"\"\";\n</code></pre> <p>Vous pouvez \u00e9galement formater un text block en utilisant des placeholders et <code>formatted()</code> :</p> <pre><code>String card = \"\"\"\n    Name: %s\n    Age:  %d\n    \"\"\".formatted(\"Alice\", 30);\n</code></pre> <p></p>"},{"location":"fr/module-03/strings/#9124-erreurs-courantes-avec-corrections","title":"9.1.2.4 Erreurs courantes (avec corrections)","text":"<pre><code>// \u274c Mismatched delimiters / missing closing triple quote\nString bad = \"\"\"\n  Hello\nWorld\";      // ERROR \u2014 not a closing text block\n\n// \u2705 Fix\nString ok = \"\"\"\n  Hello\n  World\n  \"\"\";\n</code></pre> <pre><code>// \u274c Text blocks require a line break after the opening \"\"\"\nString invalid = \"\"\"Hello\"\"\";  // ERROR\n\n// \u2705 Fix\nString valid = \"\"\"\n    Hello\n    \"\"\";\n</code></pre> <pre><code>// \u274c Unescaped trailing backslash at end of a line inside the block\nString wrong = \"\"\"\n    C:\\Users\\Alex\\     // ERROR \u2014 backslash escapes the newline\n    Documents\n    \"\"\";\n\n// \u2705 Fix: escape backslashes, or avoid backslash at end of line\nString correct = \"\"\"\n    C:\\\\Users\\\\Alex\\\\\n    Documents\\\n    \"\"\";\n</code></pre>"},{"location":"fr/module-03/strings/#92-methodes-principales-des-chaines","title":"9.2 M\u00e9thodes principales des cha\u00eenes","text":""},{"location":"fr/module-03/strings/#921-indexation-des-chaines","title":"9.2.1 Indexation des cha\u00eenes","text":"<p>Les cha\u00eenes en Java utilisent une indexation \u00e0 base z\u00e9ro, ce qui signifie :</p> <ul> <li>Le premier caract\u00e8re est \u00e0 l\u2019index <code>0</code></li> <li>Le dernier caract\u00e8re est \u00e0 l\u2019index <code>length() - 1</code></li> <li> <p>Acc\u00e9der \u00e0 un index en dehors de cette plage provoque une <code>StringIndexOutOfBoundsException</code></p> </li> <li> <p>Exemple :</p> </li> </ul> <pre><code>String s = \"Java\";\n// Indexes:  0    1    2    3\n// Chars:    J    a    v    a\n\nchar c = s.charAt(2); // 'v'\n</code></pre> <p></p>"},{"location":"fr/module-03/strings/#922-methode-length","title":"9.2.2 M\u00e9thode <code>length()</code>","text":"<p><code>length()</code> renvoie le nombre de caract\u00e8res dans la cha\u00eene.</p> <pre><code>String s = \"hello\";\nSystem.out.println(s.length());  // 5\n</code></pre> <p>Le dernier index valide est toujours <code>length() - 1</code>.</p> <p></p>"},{"location":"fr/module-03/strings/#923-regles-de-bornes-index-de-debut-vs-index-de-fin","title":"9.2.3 R\u00e8gles de bornes : index de d\u00e9but vs index de fin","text":"<p>De nombreuses m\u00e9thodes de <code>String</code> utilisent deux indices :</p> <ul> <li>Index de d\u00e9but \u2014 inclusif</li> <li>Index de fin \u2014 exclusif</li> </ul> <p>Autrement dit, <code>substring(start, end)</code> inclut les caract\u00e8res depuis l\u2019index <code>start</code> jusqu\u2019\u00e0 (mais sans inclure) l\u2019index <code>end</code>.</p> <ul> <li>L\u2019index de d\u00e9but doit \u00eatre <code>&gt;= 0</code> et <code>&lt;= length() - 1</code></li> <li>L\u2019index de fin peut \u00eatre \u00e9gal \u00e0 <code>length()</code> (la \u201cposition virtuelle\u201d apr\u00e8s le dernier caract\u00e8re).</li> <li>L\u2019index de fin ne doit pas d\u00e9passer <code>length()</code>.</li> <li> <p>L\u2019index de d\u00e9but ne doit jamais \u00eatre sup\u00e9rieur \u00e0 l\u2019index de fin.</p> </li> <li> <p>Exemple :</p> </li> </ul> <pre><code>String s = \"abcdef\";\ns.substring(1, 4); // \"bcd\" (indexes 1,2,3)\n</code></pre> <p>Cette r\u00e8gle s\u2019applique \u00e0 la plupart des m\u00e9thodes bas\u00e9es sur substring.</p> <p></p>"},{"location":"fr/module-03/strings/#924-methodes-utilisant-uniquement-lindex-de-debut-inclusif","title":"9.2.4 M\u00e9thodes utilisant uniquement l\u2019index de d\u00e9but (inclusif)","text":"M\u00e9thode Description Param\u00e8tres R\u00e8gle d\u2019index Exemple substring(int start) Renvoie la sous-cha\u00eene de start \u00e0 la fin start start inclusif \"abcdef\".substring(2) \u2192 \"cdef\" indexOf(String) Premi\u00e8re occurrence \u2014 \u2014 \"Java\".indexOf(\"a\") \u2192 1 indexOf(String, start) Commence la recherche \u00e0 l\u2019index start start inclusif \"banana\".indexOf(\"a\", 2) \u2192 3 lastIndexOf(String) Derni\u00e8re occurrence \u2014 \u2014 \"banana\".lastIndexOf(\"a\") \u2192 5 lastIndexOf(String, fromIndex) Recherche \u00e0 rebours depuis l\u2019index fromIndex fromIndex inclusif \"banana\".lastIndexOf(\"a\", 3) \u2192 3"},{"location":"fr/module-03/strings/#925-methodes-avec-debut-inclusif-fin-exclusive","title":"9.2.5 M\u00e9thodes avec d\u00e9but inclusif / fin exclusive","text":"<p>Ces m\u00e9thodes suivent le m\u00eame comportement de d\u00e9coupage : <code>start</code> inclus, <code>end</code> exclus.</p> M\u00e9thode Description Signature Exemple substring(start, end) Extrait une partie de la cha\u00eene (int start, int end) \"abcdef\".substring(1,4) \u2192 \"bcd\" regionMatches Compare des r\u00e9gions de sous-cha\u00eenes (toffset, other, ooffset, len) \"Hello\".regionMatches(1, \"ell\", 0, 3) \u2192 true getBytes(int srcBegin, int srcEnd, byte[] dst, int dstBegin) Copie des caract\u00e8res dans un tableau de bytes d\u00e9but inclusif, fin exclusive Copie les caract\u00e8res dans [srcBegin, srcEnd) copyValueOf(char[] data, int offset, int count) Cr\u00e9e une nouvelle cha\u00eene offset inclusif ; offset+count exclusif M\u00eame r\u00e8gle que substring <p></p>"},{"location":"fr/module-03/strings/#926-methodes-operant-sur-toute-la-chaine","title":"9.2.6 M\u00e9thodes op\u00e9rant sur toute la cha\u00eene","text":"M\u00e9thode Description Exemple toUpperCase() Version en majuscules \"java\".toUpperCase() \u2192 \"JAVA\" toLowerCase() Version en minuscules \"JAVA\".toLowerCase() \u2192 \"java\" trim() Supprime les espaces en d\u00e9but/fin \"  hi  \".trim() \u2192 \"hi\" strip() Trim compatible Unicode \"  hi\\u2003\".strip() \u2192 \"hi\" stripLeading() Supprime les espaces initiaux \"  hi\".stripLeading() \u2192 \"hi\" stripTrailing() Supprime les espaces finaux \"hi  \".stripTrailing() \u2192 \"hi\" isBlank() Vrai si vide ou uniquement des espaces \"  \".isBlank() \u2192 true isEmpty() Vrai si length == 0 \"\".isEmpty() \u2192 true"},{"location":"fr/module-03/strings/#927-acces-aux-caracteres","title":"9.2.7 Acc\u00e8s aux caract\u00e8res","text":"M\u00e9thode Description Exemple charAt(int index) Renvoie le caract\u00e8re \u00e0 l\u2019index \"Java\".charAt(2) \u2192 'v' codePointAt(int index) Renvoie le point de code Unicode Utile pour les emojis ou les caract\u00e8res au-del\u00e0 du BMP"},{"location":"fr/module-03/strings/#928-recherche","title":"9.2.8 Recherche","text":"M\u00e9thode Description Exemple contains(CharSequence) Test de sous-cha\u00eene \"hello\".contains(\"ell\") \u2192 true startsWith(String) Pr\u00e9fixe \"abcdef\".startsWith(\"abc\") \u2192 true startsWith(String, offset) Pr\u00e9fixe \u00e0 l\u2019index \"abc\".startsWith(\"b\", 1) \u2192 true endsWith(String) Suffixe \"abcdef\".endsWith(\"def\") \u2192 true"},{"location":"fr/module-03/strings/#929-methodes-de-remplacement","title":"9.2.9 M\u00e9thodes de remplacement","text":"M\u00e9thode Description Exemple replace(char old, char new) Remplace des caract\u00e8res \"banana\".replace('a','o') \u2192 \"bonono\" replace(CharSequence old, CharSequence new) Remplace des sous-cha\u00eenes \"ababa\".replace(\"aba\",\"X\") \u2192 \"Xba\" replaceAll(String regex, String replacement) Remplacement regex global \"a1a2\".replaceAll(\"\\d\",\"\") \u2192 \"aa\" replaceFirst(String regex, String replacement) Seulement la premi\u00e8re correspondance regex \"a1a2\".replaceFirst(\"\\d\",\"\") \u2192 \"aa2\""},{"location":"fr/module-03/strings/#9210-decoupage-et-jonction","title":"9.2.10 D\u00e9coupage et jonction","text":"M\u00e9thode Description Exemple split(String regex) D\u00e9coupe par regex \"a,b,c\".split(\",\") \u2192 [\"a\",\"b\",\"c\"] split(String regex, int limit) D\u00e9coupe avec limite limit &lt; 0 conserve toutes les cha\u00eenes vides finales"},{"location":"fr/module-03/strings/#9211-methodes-retournant-des-tableaux","title":"9.2.11 M\u00e9thodes retournant des tableaux","text":"M\u00e9thode Description Exemple toCharArray() Renvoie char[] \"abc\".toCharArray() getBytes() Renvoie byte[] en utilisant l\u2019encodage plateforme/par d\u00e9faut \"\u00e1\".getBytes()"},{"location":"fr/module-03/strings/#9212-indentation","title":"9.2.12 Indentation","text":"M\u00e9thode Description Exemple indent(int numSpaces) Ajoute (positif) ou supprime (n\u00e9gatif) des espaces au d\u00e9but de chaque ligne ; ajoute aussi un retour \u00e0 la ligne final s\u2019il n\u2019est pas d\u00e9j\u00e0 pr\u00e9sent str.indent(-20) stripIndent() Supprime tous les espaces initiaux incidentels de chaque ligne ; n\u2019ajoute pas de retour \u00e0 la ligne final str.stripIndent() <ul> <li>Exemple :</li> </ul> <pre><code>var txtBlock = \"\"\"\n\n                    a\n                      b\n                     c\"\"\";\n\nvar conc = \" a\\n\" + \" b\\n\" + \" c\";\n\nSystem.out.println(\"length: \" + txtBlock.length());\nSystem.out.println(txtBlock);\nSystem.out.println(\"\");\nString stripped1 = txtBlock.stripIndent();\nSystem.out.println(stripped1);\nSystem.out.println(\"length: \" + stripped1.length());\n\nSystem.out.println(\"*********************\");\n\nSystem.out.println(\"length: \" + conc.length());\nSystem.out.println(conc);\nSystem.out.println(\"\");\nString stripped2 = conc.stripIndent();\nSystem.out.println(stripped2);\nSystem.out.println(\"length: \" + stripped2.length());\n</code></pre> <p>Sortie :</p> <pre><code>length: 9\n\na\n  b\n c\n\n\na\n  b\n c\nlength: 9\n*********************\nlength: 8\n a\n b\n c\n\na\nb\nc\nlength: 5\n</code></pre> <p></p>"},{"location":"fr/module-03/strings/#9213-exemples-supplementaires","title":"9.2.13 Exemples suppl\u00e9mentaires","text":"<ul> <li>Exemple 1 \u2014 Extraire <code>[start, end)</code></li> </ul> <pre><code>String s = \"012345\";\nSystem.out.println(s.substring(2, 5));\n// includes 2,3,4 \u2192 prints \"234\"\n</code></pre> <ul> <li>Exemple 2 \u2014 Recherche \u00e0 partir d\u2019un index de d\u00e9but</li> </ul> <pre><code>String s = \"hellohello\";\nint idx = s.indexOf(\"lo\", 5); // search begins at index 5\n</code></pre> <ul> <li>Exemple 3 \u2014 Pi\u00e8ges courants</li> </ul> <pre><code>String s = \"abcd\";\nSystem.out.println(s.substring(1,1)); // \"\" empty string\nSystem.out.println(s.substring(3, 2)); // \u274c Exception: start index (3) &gt; end index (2)\n\nSystem.out.println(\"abcd\".substring(2, 4)); // \"cd\" \u2014 includes indexes 2 and 3; 4 is excluded but legal here\n\nSystem.out.println(\"abcd\".substring(2, 5)); // \u274c StringIndexOutOfBoundsException (end index 5 is invalid)\n</code></pre>"},{"location":"fr/module-04/beyond-classes/","title":"17. Au-del\u00e0 des Classes","text":""},{"location":"fr/module-04/beyond-classes/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>17.1 Interfaces<ul> <li>17.1.1 Ce que les Interfaces Peuvent Contenir</li> <li>17.1.2 Impl\u00e9menter une Interface</li> <li>17.1.3 H\u00e9ritage Multiple</li> <li>17.1.4 H\u00e9ritage des Interfaces et Conflits</li> <li>17.1.5 M\u00e9thodes default</li> <li>17.1.6 M\u00e9thodes static</li> <li>17.1.7 M\u00e9thodes private dans les interfaces</li> </ul> </li> <li>17.2 Types sealed, non-sealed et final<ul> <li>17.2.1 R\u00e8gles</li> </ul> </li> <li>17.3 Enum<ul> <li>17.3.1 D\u00e9finition d\u2019une Enum Simple</li> <li>17.3.2 Enum Complexes avec \u00c9tat et Comportement</li> <li>17.3.3 M\u00e9thodes des Enum</li> <li>17.3.4 R\u00e8gles</li> </ul> </li> <li>17.4 Records (Java 16+)<ul> <li>17.4.1 R\u00e9sum\u00e9 des R\u00e8gles de Base pour les Records</li> <li>17.4.2 Constructeur Long</li> <li>17.4.3 Constructeur Compact</li> <li>17.4.4 Pattern Matching pour les Records</li> <li>17.4.5 Nested Record Patterns et Matching des Records avec var et Generics<ul> <li>17.4.5.1 Nested Record Pattern de Base</li> <li>17.4.5.2 Nested Record Patterns avec var</li> <li>17.4.5.3 Nested Record Patterns et Generics</li> <li>17.4.5.4 Erreurs Courantes avec les Nested Record Patterns</li> </ul> </li> </ul> </li> <li>17.5 Classes Imbriqu\u00e9es en Java<ul> <li>17.5.1 Static Nested Classes<ul> <li>17.5.1.1 Syntaxe et R\u00e8gles d\u2019Acc\u00e8s</li> <li>17.5.1.2 Erreurs Courantes</li> </ul> </li> <li>17.5.2 Inner Classes (Non-Static Nested Classes)<ul> <li>17.5.2.1 Syntaxe et R\u00e8gles d\u2019Acc\u00e8s</li> <li>17.5.2.2 Erreurs Courantes</li> </ul> </li> <li>17.5.3 Classes Locales<ul> <li>17.5.3.1 Caract\u00e9ristiques</li> <li>17.5.3.2 Erreurs Courantes</li> </ul> </li> <li>17.5.4 Classes Anonymes<ul> <li>17.5.4.1 Syntaxe et Utilisation</li> <li>17.5.4.2 Classe Anonyme qui \u00c9tend une Classe</li> </ul> </li> <li>17.5.5 Comparaison des Types de Classes Imbriqu\u00e9es</li> </ul> </li> <li>17.6 Imbrication des Interfaces en Java<ul> <li>17.6.1 O\u00f9 une Interface peut \u00eatre D\u00e9clar\u00e9e</li> <li>17.6.2 Interfaces Imbriqu\u00e9es<ul> <li>17.6.2.1 Interface Imbriqu\u00e9e dans une Classe</li> <li>17.6.2.2 Interface Imbriqu\u00e9e dans une autre Interface</li> </ul> </li> <li>17.6.3 R\u00e8gles d'Acc\u00e8s</li> <li>17.6.4 Types Imbriqu\u00e9s dans les Interfaces</li> <li>17.6.5 R\u00e9sum\u00e9 Essentiel</li> </ul> </li> </ul> <p>Ce chapitre pr\u00e9sente plusieurs m\u00e9canismes avanc\u00e9s de type (type) au-del\u00e0 du design de la Classe en Java : interfaces, enum, classes sealed / non-sealed, records et classes imbriqu\u00e9es.</p> <p></p>"},{"location":"fr/module-04/beyond-classes/#171-interfaces","title":"17.1 Interfaces","text":"<p>Une interface en Java est un type de r\u00e9f\u00e9rence qui d\u00e9finit un contrat de m\u00e9thodes qu\u2019une classe accepte d\u2019impl\u00e9menter.</p> <p>Une <code>interface</code> est implicitement <code>abstract</code> et ne peut pas \u00eatre marqu\u00e9e <code>final</code> : comme pour les classes top-level, une interface peut d\u00e9clarer une visibilit\u00e9 <code>public</code> ou <code>default</code> (package-private).</p> <p>Une classe Java peut impl\u00e9menter un nombre quelconque d\u2019interfaces via le mot-cl\u00e9 <code>implements</code>.</p> <p>Une <code>interface</code> peut \u00e0 son tour \u00e9tendre plusieurs interfaces en utilisant le mot-cl\u00e9 <code>extends</code>.</p> <p>Les interfaces permettent l\u2019abstraction, un couplage faible et l\u2019h\u00e9ritage multiple de type.</p> <p></p>"},{"location":"fr/module-04/beyond-classes/#1711-ce-que-les-interfaces-peuvent-contenir","title":"17.1.1 Ce que les Interfaces Peuvent Contenir","text":"<ul> <li>M\u00e9thodes abstraites (implicitement <code>public</code> et <code>abstract</code>)</li> <li>M\u00e9thodes concr\u00e8tes<ul> <li>M\u00e9thodes default (contiennent du code et sont implicitement <code>public</code>)</li> <li>M\u00e9thodes static (d\u00e9clar\u00e9es <code>static</code>, contiennent du code et sont implicitement <code>public</code>)</li> <li>M\u00e9thodes private (Java 9+) pour la r\u00e9utilisation interne</li> </ul> </li> <li>Constantes \u2192 implicitement <code>public static final</code> et initialis\u00e9es \u00e0 la d\u00e9claration</li> </ul> <pre><code>interface Calculator {\n\n    int add(int a, int b);                 // abstract\n\n    default int mult(int a, int b) {       // default method\n        return a * b;\n    }\n\n    static double pi() { return 3.14; }    // static method\n}\n</code></pre> <p>Warning</p> <p>Puisque les m\u00e9thodes abstraites des interfaces sont implicitement <code>public</code>, vous ne pouvez pas r\u00e9duire le niveau d\u2019acc\u00e8s sur une m\u00e9thode d\u2019impl\u00e9mentation.</p> <p></p>"},{"location":"fr/module-04/beyond-classes/#1712-implementer-une-interface","title":"17.1.2 Impl\u00e9menter une Interface","text":"<pre><code>class BasicCalc implements Calculator {\n    public int add(int a, int b) { return a + b; }\n}\n</code></pre> <p>Note</p> <p>Chaque m\u00e9thode abstraite doit \u00eatre impl\u00e9ment\u00e9e, sauf si la classe est elle-m\u00eame abstraite.</p> <p></p>"},{"location":"fr/module-04/beyond-classes/#1713-heritage-multiple","title":"17.1.3 H\u00e9ritage Multiple","text":"<p>Une classe peut impl\u00e9menter plusieurs interfaces.</p> <pre><code>interface A { void a(); }\ninterface B { void b(); }\n\nclass C implements A, B {\n    public void a() {}\n    public void b() {}\n}\n</code></pre> <p></p>"},{"location":"fr/module-04/beyond-classes/#1714-heritage-des-interfaces-et-conflits","title":"17.1.4 H\u00e9ritage des Interfaces et Conflits","text":"<p>Si deux interfaces fournissent des m\u00e9thodes <code>default</code> avec la m\u00eame signature, la classe qui impl\u00e9mente doit red\u00e9finir (override) la m\u00e9thode.</p> <pre><code>interface X { default void run() { } }\ninterface Y { default void run() { } }\n\nclass Z implements X, Y {\n    public void run() { } // mandatory\n}\n</code></pre> <p>Si vous voulez tout de m\u00eame acc\u00e9der \u00e0 une impl\u00e9mentation particuli\u00e8re de la m\u00e9thode <code>default</code> h\u00e9rit\u00e9e, vous pouvez utiliser la syntaxe suivante :</p> <pre><code>interface X { default int run() { return 1; } }\ninterface Y { default int run() { return 2; } }\n\nclass Z implements X, Y {\n\n    public int useARun(){\n        return Y.super.run();\n    }\n\n}\n</code></pre> <p></p>"},{"location":"fr/module-04/beyond-classes/#1715-methodes-default","title":"17.1.5 M\u00e9thodes <code>default</code>","text":"<p>Une m\u00e9thode <code>default</code> (d\u00e9clar\u00e9e avec le mot-cl\u00e9 <code>default</code>) est une m\u00e9thode qui d\u00e9finit une impl\u00e9mentation et peut \u00eatre red\u00e9finie par une classe qui impl\u00e9mente l\u2019interface.</p> <ul> <li>Une m\u00e9thode default contient du code et est implicitement <code>public</code> ;</li> <li>Une m\u00e9thode default ne peut pas \u00eatre <code>abstract</code>, <code>static</code> ou <code>final</code> ;</li> <li>Comme vu juste au-dessus, si deux interfaces fournissent des m\u00e9thodes default avec la m\u00eame signature, la classe qui impl\u00e9mente doit red\u00e9finir la m\u00e9thode ;</li> <li>Une classe qui impl\u00e9mente peut naturellement s\u2019appuyer sur l\u2019impl\u00e9mentation fournie de la m\u00e9thode <code>default</code> sans la red\u00e9finir ;</li> <li>La m\u00e9thode <code>default</code> peut \u00eatre invoqu\u00e9e sur une instance de la classe qui impl\u00e9mente et NON comme m\u00e9thode <code>static</code> de l\u2019interface contenante ;</li> </ul> <p></p>"},{"location":"fr/module-04/beyond-classes/#1716-methodes-static","title":"17.1.6 M\u00e9thodes <code>static</code>","text":"<ul> <li>Une interface peut fournir des <code>static methods</code> (via le mot-cl\u00e9 <code>static</code>) qui sont implicitement <code>public</code> ;</li> <li>Les m\u00e9thodes static doivent inclure un corps de m\u00e9thode et sont accessibles via le nom de l\u2019interface ;</li> <li>Les m\u00e9thodes static ne peuvent pas \u00eatre <code>abstract</code> ou <code>final</code> ;</li> </ul>"},{"location":"fr/module-04/beyond-classes/#1717-methodes-private-dans-les-interfaces","title":"17.1.7 M\u00e9thodes <code>private</code> dans les interfaces","text":"<p>Parmi toutes les m\u00e9thodes concr\u00e8tes qu\u2019une interface peut impl\u00e9menter, nous avons aussi :</p> <ul> <li>M\u00e9thodes <code>private</code> : visibles uniquement \u00e0 l\u2019int\u00e9rieur de l\u2019interface d\u00e9clarante et qui ne peuvent \u00eatre invoqu\u00e9es que depuis un contexte <code>non-static</code> (m\u00e9thodes <code>default</code> ou autres <code>non-static private methods</code>).</li> <li>M\u00e9thodes <code>private static</code> : visibles uniquement \u00e0 l\u2019int\u00e9rieur de l\u2019interface d\u00e9clarante et qui peuvent \u00eatre invoqu\u00e9es par n\u2019importe quelle m\u00e9thode de l\u2019interface englobante.</li> </ul> <p></p>"},{"location":"fr/module-04/beyond-classes/#172-types-sealed-non-sealed-et-final","title":"17.2 Types sealed, non-sealed et final","text":"<p>Les classes et interfaces <code>sealed</code> (Java 17+) restreignent quelles autres classes (ou interfaces) peuvent les \u00e9tendre ou les impl\u00e9menter.</p> <p>Un <code>sealed type</code> est d\u00e9clar\u00e9 en pla\u00e7ant le modificateur <code>sealed</code> juste avant le mot-cl\u00e9 class (ou interface), et en ajoutant, apr\u00e8s le nom du Type, le mot-cl\u00e9 <code>permits</code> suivi de la liste des types qui peuvent l\u2019\u00e9tendre (ou l\u2019impl\u00e9menter).</p> <pre><code>public sealed class Shape permits Circle, Rectangle { }\n\nfinal class Circle extends Shape { }\n\nnon-sealed class Rectangle extends Shape { }\n</code></pre> <p></p>"},{"location":"fr/module-04/beyond-classes/#1721-regles","title":"17.2.1 R\u00e8gles","text":"<ul> <li>Un type sealed doit d\u00e9clarer tous les sous-types autoris\u00e9s.</li> <li>Un sous-type autoris\u00e9 doit \u00eatre final, sealed ou non-sealed ; puisque les interfaces ne peuvent pas \u00eatre final, elles ne peuvent \u00eatre marqu\u00e9es que <code>sealed</code> ou <code>non-sealed</code> lorsqu\u2019elles \u00e9tendent une interface sealed.</li> <li>Les types sealed doivent \u00eatre d\u00e9clar\u00e9s dans le m\u00eame package (ou module nomm\u00e9) que leurs sous-types directs.</li> </ul>"},{"location":"fr/module-04/beyond-classes/#173-enum","title":"17.3 Enum","text":"<p>Les enum d\u00e9finissent un ensemble fixe de valeurs constantes.</p> <p>Les <code>enum</code> peuvent d\u00e9clarer des <code>attributs</code>, des <code>constructeurs</code> et des <code>m\u00e9thodes</code> comme des classes ordinaires mais ne peuvent pas \u00eatre \u00e9tendues.</p> <p>La liste des valeurs de l\u2019enum doit se terminer par un point-virgule <code>(;)</code> dans le cas des <code>Enum Complexes</code>, mais ce n\u2019est pas obligatoire pour les <code>Enum Simples</code>.</p> <p></p>"},{"location":"fr/module-04/beyond-classes/#1731-definition-dune-enum-simple","title":"17.3.1 D\u00e9finition d\u2019une Enum <code>Simple</code>","text":"<pre><code>enum Day { MON, TUE, WED, THU, FRI, SAT, SUN } // point-virgule omis\n</code></pre>"},{"location":"fr/module-04/beyond-classes/#1732-enum-complexes-avec-etat-et-comportement","title":"17.3.2 Enum <code>Complexes</code> avec \u00c9tat et Comportement","text":"<pre><code>enum Level {\n    LOW(1), MEDIUM(5), HIGH(10); // point-virgule obligatoire\n\n    private int code; \n\n    Level(int code) { this.code = code; }\n\n    public int getCode() { return code; }\n}\n\npublic static void main(String[] args) {\n    Level.MEDIUM.getCode();     // invoking a method\n}\n</code></pre>"},{"location":"fr/module-04/beyond-classes/#1733-methodes-des-enum","title":"17.3.3 M\u00e9thodes des Enum","text":"<ul> <li><code>values()</code> \u2013 renvoie un tableau de toutes les valeurs constantes utilisables, par exemple, dans une boucle <code>for-each</code></li> <li><code>valueOf(String)</code> \u2013 renvoie la constante par son nom</li> <li><code>ordinal()</code> \u2013 index (int) de la constante</li> </ul>"},{"location":"fr/module-04/beyond-classes/#1734-regles","title":"17.3.4 R\u00e8gles","text":"<ul> <li>Les constructeurs d\u2019enum sont implicitement <code>private</code> ;</li> <li>Les enum peuvent contenir des m\u00e9thodes <code>static</code> et <code>instance</code> ;</li> <li>Les enum peuvent impl\u00e9menter des <code>interfaces</code> ;</li> </ul>"},{"location":"fr/module-04/beyond-classes/#174-records-java-16","title":"17.4 Records (Java 16+)","text":"<p>Un record est une classe sp\u00e9ciale con\u00e7ue pour mod\u00e9liser des donn\u00e9es immuables : ils sont en effet implicitement final.</p> <p>Vous ne pouvez pas \u00e9tendre un record, mais il est permis d\u2019impl\u00e9menter une interface normale ou sealed.</p> <p>Il fournit automatiquement :</p> <ul> <li>champs private final pour chaque composant</li> <li>constructeur avec des param\u00e8tres dans le m\u00eame ordre que la d\u00e9claration du record ;</li> <li>getters (portant le nom des attributs)</li> <li><code>equals()</code>, <code>hashCode()</code>, <code>toString()</code> : il est \u00e9galement permis de red\u00e9finir (override) ces m\u00e9thodes</li> <li>Les Records peuvent inclure <code>nested classes</code>, <code>interfaces</code>, <code>records</code>, <code>enums</code> et <code>annotations</code></li> </ul> <pre><code>public record Point(int x, int y) { }\n\nvar element = new Point(11, 22);\n\nSystem.out.println(element.x);\nSystem.out.println(element.y);\n</code></pre> <p>Si vous avez besoin de validation ou de transformation suppl\u00e9mentaire des champs fournis, vous pouvez d\u00e9finir un <code>constructeur long</code> ou un <code>constructeur compact</code>.</p> <p></p>"},{"location":"fr/module-04/beyond-classes/#1741-resume-des-regles-de-base-pour-les-records","title":"17.4.1 R\u00e9sum\u00e9 des R\u00e8gles de Base pour les Records","text":"<p>Un record peut \u00eatre d\u00e9clar\u00e9 \u00e0 trois emplacements :</p> <ul> <li>Comme record top-level (directement dans un package)</li> <li>Comme record member (\u00e0 l\u2019int\u00e9rieur d\u2019une classe ou d\u2019une interface)</li> <li>Comme record local (\u00e0 l\u2019int\u00e9rieur d\u2019une m\u00e9thode)</li> </ul> <p>Toutes les classes record <code>member</code> et <code>local</code> sont implicitement <code>static</code>.</p> <ul> <li>Un record member peut d\u00e9clarer <code>static</code> de mani\u00e8re redondante.</li> <li>Un record local ne doit pas d\u00e9clarer <code>static</code> explicitement.</li> </ul> <p>Chaque classe record est implicitement <code>final</code>.</p> <ul> <li>D\u00e9clarer <code>final</code> explicitement est autoris\u00e9 mais redondant.</li> <li>Un record ne peut pas \u00eatre d\u00e9clar\u00e9 <code>abstract</code>, <code>sealed</code> ou <code>non-sealed</code>.</li> </ul> <p>La superclasse directe de chaque record est <code>java.lang.Record</code>.</p> <ul> <li>Un record ne peut pas d\u00e9clarer de clause <code>extends</code>.</li> <li>Un record ne peut \u00e9tendre aucune autre classe.</li> </ul> <p>La s\u00e9rialisation des records diff\u00e8re de celle des classes s\u00e9rialisables ordinaires.</p> <ul> <li>Lors de la d\u00e9s\u00e9rialisation, le constructeur canonique est invoqu\u00e9.</li> </ul> <p>Le corps d\u2019un record peut contenir :</p> <ul> <li>Des constructeurs</li> <li>Des m\u00e9thodes</li> <li>Des champs statiques</li> <li>Des blocs d\u2019initialisation statiques</li> </ul> <p>Le corps d\u2019un record NE doit PAS contenir :</p> <ul> <li>Des d\u00e9clarations de champs d\u2019instance</li> <li>Des blocs d\u2019initialisation d\u2019instance</li> <li>Des m\u00e9thodes <code>abstract</code></li> <li>Des m\u00e9thodes <code>native</code></li> </ul> <p></p>"},{"location":"fr/module-04/beyond-classes/#1742-constructeur-long","title":"17.4.2 Constructeur Long","text":"<pre><code>public record Person(String name, int age) {\n\n    public Person (String name, int age){\n        if (age &lt; 0) throw new IllegalArgumentException();\n        this.name = name;\n        this.age = age;\n    }\n}\n</code></pre> <p>Vous pouvez aussi d\u00e9finir des constructeurs en surcharge (overload), \u00e0 condition qu\u2019ils d\u00e9l\u00e8guent finalement au constructeur canonique via <code>this(...)</code> :</p> <pre><code>public record Point(int x, int y) {\n\n    // Overloaded constructor (NOT canonical)\n    public Point(int value) {\n        this(value, value); // doit invoquer, comme premi\u00e8re instruction, un autre constructeur surcharg\u00e9 et, en derni\u00e8re instance, le constructeur canonique.\n    }\n}\n</code></pre> <p>Note</p> <ul> <li>Le compilateur n\u2019ins\u00e9rera pas de constructeur si vous en fournissez manuellement un avec la m\u00eame liste de param\u00e8tres dans l\u2019ordre d\u00e9fini ;</li> <li>Dans ce cas, vous devez d\u00e9finir explicitement chaque champ manuellement ;</li> </ul> <p></p>"},{"location":"fr/module-04/beyond-classes/#1743-constructeur-compact","title":"17.4.3 Constructeur Compact","text":"<p>Vous pouvez d\u00e9finir un <code>constructeur compact</code> qui initialise implicitement tous les champs, tout en vous permettant d\u2019effectuer des validations et des transformations sur des champs sp\u00e9cifiques.</p> <p>Java ex\u00e9cutera le constructeur complet, initialisant tous les champs, apr\u00e8s que le constructeur compact a termin\u00e9.</p> <pre><code>public record Person(String name, int age) {\n\n    public Person {\n        if (age &lt; 0) throw new IllegalArgumentException();\n\n        name = name.toUpperCase(); // This transformation is still (at this level of initialization) on the input parameter.\n\n        // this.name = name; // \u274c Does not compile.\n    }   \n}\n</code></pre> <p>Warning</p> <ul> <li>Si vous essayez de modifier un attribut de Record dans un Constructeur Compact, votre code ne compilera pas</li> </ul> <p></p>"},{"location":"fr/module-04/beyond-classes/#1744-pattern-matching-pour-les-records","title":"17.4.4 Pattern Matching pour les Records","text":"<p>Quand vous utilisez le pattern matching avec <code>instanceof</code> ou avec <code>switch</code>, un record pattern doit sp\u00e9cifier :</p> <ul> <li>Le type du record ;</li> <li>Un pattern pour chaque champ du record (correspondant au bon nombre de composants, et avec des types compatibles) ;</li> </ul> <p>Exemple record :</p> <pre><code>Object obj = new Point(3, 5);\n\nif (obj instanceof Point(int a, int b)) {\n    System.out.println(a + b);   // 8\n}\n</code></pre> <p></p>"},{"location":"fr/module-04/beyond-classes/#1745-nested-record-patterns-et-matching-des-records-avec-var-et-generics","title":"17.4.5 Nested Record Patterns et Matching des Records avec <code>var</code> et Generics","text":"<p>Les nested record patterns permettent de d\u00e9structurer des records qui contiennent d\u2019autres records ou des types complexes, en extrayant r\u00e9cursivement des valeurs directement dans le pattern.</p> <p>Ils combinent la puissance de la d\u00e9construction des <code>record</code> avec le pattern matching, vous donnant une mani\u00e8re concise et expressive de naviguer dans des structures de donn\u00e9es hi\u00e9rarchiques.</p> <p></p>"},{"location":"fr/module-04/beyond-classes/#17451-nested-record-pattern-de-base","title":"17.4.5.1 Nested Record Pattern de Base","text":"<p>Si un record contient un autre record, vous pouvez d\u00e9structurer les deux en une seule fois :</p> <pre><code>record Address(String city, String country) {}\nrecord Person(String name, Address address) {}\n\nvoid printInfo(Object obj) {\n\n    switch (obj) {\n        case Person(String n, Address(String c, String co)) -&gt; System.out.println(n + \" lives in \" + c + \", \" + co);\n        default -&gt; System.out.println(\"Unknown\");\n    }\n}\n</code></pre> <p>Dans l\u2019exemple ci-dessus, le pattern <code>Person</code> inclut un pattern <code>Address</code> imbriqu\u00e9.</p> <p>Les deux sont appari\u00e9s structurellement.</p> <p></p>"},{"location":"fr/module-04/beyond-classes/#17452-nested-record-patterns-avec-var","title":"17.4.5.2 Nested Record Patterns avec <code>var</code>","text":"<p>Au lieu de sp\u00e9cifier des types exacts pour chaque champ, vous pouvez utiliser <code>var</code> dans le pattern pour laisser le compilateur inf\u00e9rer le type.</p> <pre><code>    switch (obj) {\n        case Person(var name, Address(var city, var country)) -&gt; System.out.println(name + \" \u2014 \" + city + \", \" + country);\n    }\n</code></pre> <p><code>var</code> dans les patterns fonctionne comme <code>var</code> dans les variables locales : cela signifie \"inf\u00e9rer le type\".</p> <p>Warning</p> <ul> <li>Vous avez toujours besoin du type du record englobant (Person, Address) ;</li> <li>seuls les types des champs peuvent \u00eatre remplac\u00e9s par <code>var</code>.</li> </ul> <p></p>"},{"location":"fr/module-04/beyond-classes/#17453-nested-record-patterns-et-generics","title":"17.4.5.3 Nested Record Patterns et Generics","text":"<p>Les record patterns fonctionnent aussi avec des records g\u00e9n\u00e9riques.</p> <pre><code>record Box&lt;T&gt;(T value) {}\nrecord Wrapper(Box&lt;String&gt; box) {}\n\nstatic void test(Object o) {\n    switch (o) {\n        case Wrapper(Box&lt;String&gt;(var v)) -&gt; System.out.println(\"Boxed string: \" + v);\n        default -&gt; System.out.println(\"Something else\");\n    }\n}\n</code></pre> <p>Dans cet exemple :</p> <ul> <li>Le pattern exige exactement <code>Box&lt;String&gt;</code>, pas <code>Box&lt;Integer&gt;</code>.</li> <li>Dans le pattern, <code>var v</code> capture la valeur g\u00e9n\u00e9rique unboxed.</li> </ul> <p></p>"},{"location":"fr/module-04/beyond-classes/#17454-erreurs-courantes-avec-les-nested-record-patterns","title":"17.4.5.4 Erreurs Courantes avec les Nested Record Patterns","text":"<p>Structure de record non correspondante</p> <pre><code>// \u274c ERROR: pattern does not match record structure\ncase Person(var n, var city) -&gt; ...\n</code></pre> <p><code>Person</code> a 2 champs, mais l\u2019un d\u2019eux est un record. Vous devez d\u00e9structurer correctement.</p> <p>Nombre incorrect de composants</p> <pre><code>// \u274c ERROR: Address has 2 components, not 1\ncase Person(var n, Address(var onlyCity)) -&gt; ...\n</code></pre> <p>Incompatibilit\u00e9 g\u00e9n\u00e9rique</p> <pre><code>// \u274c ERROR: expecting Box&lt;String&gt; but found Box&lt;Integer&gt;\ncase Wrapper(Box&lt;Integer&gt;(var v)) -&gt; ...\n</code></pre> <p>Placement ill\u00e9gal de <code>var</code></p> <pre><code>// \u274c var cannot replace the record type itself\ncase var(Person(var n, var a)) -&gt; ...\n</code></pre> <p>Note</p> <ul> <li><code>var</code> ne peut pas remplacer l\u2019ensemble du pattern, seulement les composants individuels.</li> </ul> <p></p>"},{"location":"fr/module-04/beyond-classes/#175-classes-imbriquees-en-java","title":"17.5 Classes Imbriqu\u00e9es en Java","text":"<p>Java supporte plusieurs types de classes imbriqu\u00e9es \u2014 des classes d\u00e9clar\u00e9es \u00e0 l\u2019int\u00e9rieur d\u2019une autre classe.</p> <p>Ce sont des outils fondamentaux pour l\u2019encapsulation, l\u2019organisation du code, les patterns d\u2019event-handling et la repr\u00e9sentation de hi\u00e9rarchies logiques.</p> <p>Une classe imbriqu\u00e9e appartient toujours \u00e0 une classe englobante et a des r\u00e8gles particuli\u00e8res d\u2019accessibilit\u00e9 et d\u2019instanciation selon sa cat\u00e9gorie.</p> <p>Java d\u00e9finit quatre types de classes imbriqu\u00e9es :</p> <ul> <li>Static Nested Classes \u2013 d\u00e9clar\u00e9es avec <code>static</code> \u00e0 l\u2019int\u00e9rieur d\u2019une autre classe.</li> <li>Inner Classes (non-static nested classes).</li> <li>Local Classes \u2013 d\u00e9clar\u00e9es dans un bloc (m\u00e9thode, constructeur ou initializer).</li> <li>Anonymous Classes \u2013 classes sans nom cr\u00e9\u00e9es inline, g\u00e9n\u00e9ralement pour red\u00e9finir une m\u00e9thode ou impl\u00e9menter une interface.</li> </ul> <p>Warning</p> <ul> <li><code>static</code> s\u2019applique uniquement aux classes membres imbriqu\u00e9es</li> <li>Les classes <code>Top-level</code> \u2192 ne peuvent pas \u00eatre static</li> <li>Les classes <code>Local</code> (d\u00e9clar\u00e9es dans les m\u00e9thodes) \u2192 ne peuvent pas \u00eatre static</li> <li>Les classes <code>Anonymous</code> \u2192 ne peuvent pas \u00eatre static</li> <li>Une classe <code>static nested</code> ne peut pas acc\u00e9der aux membres d\u2019instance sans une r\u00e9f\u00e9rence explicite \u00e0 un objet externe.</li> </ul> <p></p>"},{"location":"fr/module-04/beyond-classes/#1751-static-nested-classes","title":"17.5.1 Static Nested Classes","text":"<p>Une static nested class se comporte comme une classe top-level dont le namespace est \u00e0 l\u2019int\u00e9rieur de sa classe englobante. Elle ne peut pas acc\u00e9der aux membres d\u2019instance de la classe externe mais peut acc\u00e9der aux membres statiques. Elle ne conserve pas de r\u00e9f\u00e9rence vers une instance de la classe englobante. Une classe imbriqu\u00e9e <code>static</code> peut contenir des variables membres non statiques.</p> <p></p>"},{"location":"fr/module-04/beyond-classes/#17511-syntaxe-et-regles-dacces","title":"17.5.1.1 Syntaxe et R\u00e8gles d\u2019Acc\u00e8s","text":"<ul> <li>D\u00e9clar\u00e9e via <code>static class</code> \u00e0 l\u2019int\u00e9rieur d\u2019une autre classe.</li> <li>Peut acc\u00e9der uniquement aux membres static de la classe externe.</li> <li>N\u2019a pas de r\u00e9f\u00e9rence implicite vers l\u2019instance englobante.</li> <li>Peut \u00eatre instanci\u00e9e sans instance externe.</li> </ul> <pre><code>class Outer {\n    static int version = 1;\n\n    static class Nested {\n        void print() {\n            System.out.println(\"Version: \" + version); // OK: accessing static member\n        }\n    }\n}\n\nclass Test {\n    public static void main(String[] args) {\n        Outer.Nested n = new Outer.Nested(); // No Outer instance required\n        n.print();\n    }\n}\n</code></pre>"},{"location":"fr/module-04/beyond-classes/#17512-erreurs-courantes","title":"17.5.1.2 Erreurs Courantes","text":"<ul> <li>Les static nested classes ne peuvent pas acc\u00e9der aux variables d\u2019instance :</li> </ul> <pre><code>class Outer {\n    int x = 10;\n    static class Nested {\n        void test() {\n            // System.out.println(x); // \u274c Compile error\n        }\n    }\n}\n</code></pre>"},{"location":"fr/module-04/beyond-classes/#1752-inner-classes-non-static-nested-classes","title":"17.5.2 Inner Classes (Non-Static Nested Classes)","text":"<p>Une inner class est associ\u00e9e \u00e0 une instance de la classe externe et peut acc\u00e9der \u00e0 tous les membres de la classe externe, y compris ceux private.</p> <p></p>"},{"location":"fr/module-04/beyond-classes/#17521-syntaxe-et-regles-dacces","title":"17.5.2.1 Syntaxe et R\u00e8gles d\u2019Acc\u00e8s","text":"<ul> <li>D\u00e9clar\u00e9e sans <code>static</code>.</li> <li>Poss\u00e8de une r\u00e9f\u00e9rence implicite vers l\u2019instance englobante.</li> <li>Peut acc\u00e9der aux membres statiques et aux membres d\u2019instance de la classe externe.</li> <li>Comme elle n\u2019est pas statique, elle doit \u00eatre cr\u00e9\u00e9e via une instance de la classe englobante.</li> </ul> <pre><code>class Outer {\n    private int value = 100;\n\n    class Inner {\n        void print() {\n            System.out.println(\"Value = \" + value); // OK: accessing private\n        }\n    }\n\n    void make() {\n        Inner i = new Inner(); // OK inside the outer class\n        i.print();\n    }\n}\n\nclass Test {\n    public static void main(String[] args) {\n        Outer o = new Outer();\n        Outer.Inner i = o.new Inner(); // MUST be created from an instance\n        i.print();\n    }\n}\n</code></pre>"},{"location":"fr/module-04/beyond-classes/#17522-erreurs-courantes","title":"17.5.2.2 Erreurs Courantes","text":"<ul> <li>Les inner classes ne peuvent pas d\u00e9clarer de membres statiques sauf les static final constants.</li> </ul> <pre><code>class Outer {\n    class Inner {\n        // static int x = 10;     // \u274c Compile error\n        static final int OK = 10; // \u2714 Allowed (constant)\n    }\n}\n</code></pre> <p>Warning</p> <ul> <li>Instancier une inner class SANS instance externe est ill\u00e9gal.</li> </ul> <p></p>"},{"location":"fr/module-04/beyond-classes/#1753-classes-locales","title":"17.5.3 Classes Locales","text":"<p>Une classe locale est une classe imbriqu\u00e9e d\u00e9finie \u00e0 l\u2019int\u00e9rieur d\u2019un bloc \u2014 le plus souvent une m\u00e9thode.</p> <p>Elle n\u2019a pas de modificateur d\u2019acc\u00e8s et n\u2019est visible qu\u2019\u00e0 l\u2019int\u00e9rieur du bloc o\u00f9 elle est d\u00e9clar\u00e9e.</p> <p></p>"},{"location":"fr/module-04/beyond-classes/#17531-caracteristiques","title":"17.5.3.1 Caract\u00e9ristiques","text":"<ul> <li>D\u00e9clar\u00e9e \u00e0 l\u2019int\u00e9rieur d\u2019une m\u00e9thode, d\u2019un constructeur ou d\u2019un initializer.</li> <li>Peut acc\u00e9der aux membres de la classe externe.</li> <li>Peut acc\u00e9der aux variables locales si elles sont effectively final.</li> <li>Ne peut pas d\u00e9clarer de membres statiques (sauf static final constants).</li> </ul> <pre><code>class Outer {\n    void compute() {\n        int base = 5; // must be effectively final\n\n        class Local {\n            void show() {\n                System.out.println(base); // OK\n            }\n        }\n\n        new Local().show();\n    }\n}\n</code></pre>"},{"location":"fr/module-04/beyond-classes/#17532-erreurs-courantes","title":"17.5.3.2 Erreurs Courantes","text":"<ul> <li><code>base</code> doit \u00eatre effectively final ; le modifier casse la compilation.</li> </ul> <pre><code>void compute() {\n    int base = 5;\n    base++; // \u274c Now base is NOT effectively final\n    class Local {}\n}\n</code></pre>"},{"location":"fr/module-04/beyond-classes/#1754-classes-anonymes","title":"17.5.4 Classes Anonymes","text":"<p>Une classe anonyme est une classe one-off cr\u00e9\u00e9e inline, g\u00e9n\u00e9ralement pour impl\u00e9menter une interface ou red\u00e9finir une m\u00e9thode sans nommer une nouvelle classe.</p> <p></p>"},{"location":"fr/module-04/beyond-classes/#17541-syntaxe-et-utilisation","title":"17.5.4.1 Syntaxe et Utilisation","text":"<ul> <li>Cr\u00e9\u00e9e via <code>new</code> + type + body.</li> <li>Ne peut pas avoir de constructeurs (pas de nom).</li> <li>Souvent utilis\u00e9e pour event handling, callbacks, comparators.</li> </ul> <pre><code>Runnable r = new Runnable() {\n    @Override\n    public void run() {\n        System.out.println(\"Anonymous running\");\n    }\n};\n</code></pre>"},{"location":"fr/module-04/beyond-classes/#17542-classe-anonyme-qui-etend-une-classe","title":"17.5.4.2 Classe Anonyme qui \u00c9tend une Classe","text":"<pre><code>Button b = new Button(\"Click\");\nb.onClick(new ClickHandler() {\n    @Override\n    public void handle() {\n        System.out.println(\"Handled!\");\n    }\n});\n</code></pre>"},{"location":"fr/module-04/beyond-classes/#1755-comparaison-des-types-de-classes-imbriquees","title":"17.5.5 Comparaison des Types de Classes Imbriqu\u00e9es","text":"<p>Un tableau rapide qui r\u00e9sume tous les types de classes imbriqu\u00e9es.</p> Type A une Instance Externe ? Peut Acc\u00e9der aux Membres d\u2019Instance Externe ? Peut Avoir des Membres Statiques ? Usage Typique Static Nested Non Non Oui Namespacing, helpers Inner Class Oui Oui Non (sauf constantes) Comportement li\u00e9 \u00e0 l\u2019objet Local Class Oui Oui Non Classes temporaires avec scope Anonymous Class Oui Oui Non Personnalisation inline <p></p>"},{"location":"fr/module-04/beyond-classes/#176-imbrication-des-interfaces-en-java","title":"17.6 Imbrication des Interfaces en Java","text":"<p>En Java, une interface peut \u00eatre d\u00e9clar\u00e9e \u00e0 diff\u00e9rents emplacements et suit des r\u00e8gles sp\u00e9cifiques concernant l\u2019imbrication et les membres autoris\u00e9s.</p> <p></p>"},{"location":"fr/module-04/beyond-classes/#1761-ou-une-interface-peut-etre-declaree","title":"17.6.1 O\u00f9 une Interface peut \u00eatre D\u00e9clar\u00e9e","text":"<p>Une interface peut \u00eatre :</p> <ul> <li>Top-level (directement dans un package)</li> <li>Interface membre imbriqu\u00e9e (d\u00e9clar\u00e9e \u00e0 l\u2019int\u00e9rieur d\u2019une classe ou d\u2019une autre interface)</li> <li>Interface locale \u274c (non autoris\u00e9e)</li> <li>Interface anonyme \u274c (n\u2019existe pas comme d\u00e9claration, seulement des impl\u00e9mentations anonymes)</li> </ul> <p>En Java, il n\u2019est pas permis de d\u00e9clarer une interface locale (c\u2019est-\u00e0-dire \u00e0 l\u2019int\u00e9rieur d\u2019une m\u00e9thode ou d\u2019un bloc). Les interfaces peuvent \u00eatre uniquement <code>top-level</code> ou <code>member</code>.</p> <p></p>"},{"location":"fr/module-04/beyond-classes/#1762-interfaces-imbriquees","title":"17.6.2 Interfaces Imbriqu\u00e9es","text":"<p>Une interface imbriqu\u00e9e peut \u00eatre d\u00e9clar\u00e9e dans :</p> <p></p>"},{"location":"fr/module-04/beyond-classes/#17621-interface-imbriquee-dans-une-classe","title":"17.6.2.1 Interface Imbriqu\u00e9e dans une Classe","text":"<ul> <li>Elle est implicitement <code>static</code></li> <li>Elle ne peut pas \u00eatre d\u00e9clar\u00e9e <code>non-static</code></li> <li> <p>Elle peut \u00eatre d\u00e9clar\u00e9e <code>public</code>, <code>protected</code>, <code>private</code> ou <code>package-private</code></p> </li> <li> <p>Exemple :</p> </li> </ul> <pre><code>class Outer {\n    interface InnerInterface {\n        void test();\n    }\n}\n</code></pre> <p>Le mot-cl\u00e9 <code>static</code> est implicite :</p> <pre><code>class Outer {\n    static interface InnerInterface {   // autoris\u00e9 mais redondant\n        void test();\n    }\n}\n</code></pre> <p></p>"},{"location":"fr/module-04/beyond-classes/#17622-interface-imbriquee-dans-une-autre-interface","title":"17.6.2.2 Interface Imbriqu\u00e9e dans une autre Interface","text":"<ul> <li>Elle est implicitement <code>public</code> et <code>static</code></li> <li>Elle ne peut pas \u00eatre <code>private</code> ou <code>protected</code></li> </ul> <pre><code>interface A {\n    interface B {\n        void test();\n    }\n}\n</code></pre>"},{"location":"fr/module-04/beyond-classes/#1763-regles-dacces","title":"17.6.3 R\u00e8gles dAcc\u00e8s","text":"<p>Une <code>interface imbriqu\u00e9e</code> :</p> <ul> <li>N\u2019a pas de r\u00e9f\u00e9rence implicite \u00e0 une instance de la classe englobante</li> <li>Ne peut pas acc\u00e9der directement aux membres d\u2019instance de la classe englobante</li> <li>Peut acc\u00e9der uniquement aux membres <code>static</code> de la classe englobante</li> </ul> <p></p>"},{"location":"fr/module-04/beyond-classes/#1764-types-imbriques-dans-les-interfaces","title":"17.6.4 Types Imbriqu\u00e9s dans les Interfaces","text":"<p>Une interface peut contenir :</p> <ul> <li>Des classes imbriqu\u00e9es (implicitement <code>public static</code>)</li> <li>Des records imbriqu\u00e9s (implicitement <code>public static</code>)</li> <li>Des enums imbriqu\u00e9s (implicitement <code>public static</code>)</li> <li>D\u2019autres interfaces imbriqu\u00e9es (implicitement <code>public static</code>)</li> </ul> <p></p>"},{"location":"fr/module-04/beyond-classes/#1765-resume-essentiel","title":"17.6.5 R\u00e9sum\u00e9 Essentiel","text":"<ul> <li>Les interfaces imbriqu\u00e9es sont toujours <code>static</code></li> <li>Les interfaces locales n\u2019existent pas</li> <li>Les champs sont toujours <code>public static final</code></li> <li>Les m\u00e9thodes sont implicitement <code>public abstract</code> (sauf default/static/private)</li> <li>Elles peuvent contenir d\u2019autres types imbriqu\u00e9s</li> </ul>"},{"location":"fr/module-04/class-loading/","title":"15. Chargement des Classes, Initialisation et Construction des Objets","text":""},{"location":"fr/module-04/class-loading/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>15.1 Zones M\u00e9moire Java Pertinentes pour l\u2019Initialisation des Classes et des Objets</li> <li>15.2 Chargement des Classes avec H\u00e9ritage<ul> <li>15.2.1 Ordre de Chargement des Classes</li> <li>15.2.2 Que se Passe-t-il Pendant le Chargement d\u2019une Classe</li> </ul> </li> <li>15.3 Cr\u00e9ation d\u2019Objets avec H\u00e9ritage<ul> <li>15.3.1 Ordre Complet de Cr\u00e9ation des Instances</li> </ul> </li> <li>15.4 Exemple Complet : Initialisation Statique + d\u2019Instance \u00e0 Travers l\u2019H\u00e9ritage</li> <li>15.5 Diagramme de Visualisation</li> <li>15.6 R\u00e8gles Cl\u00e9s</li> <li>15.7 Tableau R\u00e9capitulatif</li> </ul> <p>En Java, comprendre comment les classes sont charg\u00e9es, comment les membres statiques et d\u2019instance sont initialis\u00e9s, et comment les constructeurs s\u2019ex\u00e9cutent \u2014 en particulier avec l\u2019h\u00e9ritage \u2014 est essentiel pour ma\u00eetriser le langage.</p> <p>Ce chapitre fournit une explication unifi\u00e9e et claire de :</p> <ul> <li>Comment une classe est charg\u00e9e en m\u00e9moire  </li> <li>Comment les variables statiques et les blocs statiques sont ex\u00e9cut\u00e9s  </li> <li>Comment les objets sont cr\u00e9\u00e9s \u00e9tape par \u00e9tape  </li> <li>Comment les constructeurs s\u2019ex\u00e9cutent dans une cha\u00eene d\u2019h\u00e9ritage  </li> <li>Comment diff\u00e9rentes zones m\u00e9moire (Heap, Stack, Method Area) participent  </li> </ul> <p></p>"},{"location":"fr/module-04/class-loading/#151-zones-memoire-java-pertinentes-pour-linitialisation-des-classes-et-des-objets","title":"15.1 Zones M\u00e9moire Java Pertinentes pour l\u2019Initialisation des Classes et des Objets","text":"<p>Avant de comprendre l\u2019ordre d\u2019initialisation, il est utile de rappeler les trois principales zones m\u00e9moire impliqu\u00e9es :</p> <ul> <li>Method Area (aussi appel\u00e9e Class Area) \u2014 stocke les m\u00e9tadonn\u00e9es des classes, les variables statiques et les blocs d\u2019initialisation statique.  </li> <li>Heap \u2014 stocke tous les objets et les champs d\u2019instance.  </li> <li>Stack \u2014 stocke les appels de m\u00e9thodes, les variables locales et les r\u00e9f\u00e9rences.  </li> </ul> <p>Note</p> <p>Les membres statiques appartiennent \u00e0 la classe et sont cr\u00e9\u00e9s une seule fois dans la Method Area. Les membres d\u2019instance appartiennent \u00e0 chaque objet et vivent dans le Heap.</p> <p></p>"},{"location":"fr/module-04/class-loading/#152-chargement-des-classes-avec-heritage","title":"15.2 Chargement des Classes (avec H\u00e9ritage)","text":"<p>Quand un programme Java d\u00e9marre, la JVM charge les classes \u00e0 la demande.</p> <p>Quand une classe est r\u00e9f\u00e9renc\u00e9e pour la premi\u00e8re fois (par exemple via <code>new</code> ou en acc\u00e9dant \u00e0 un membre statique), toute sa cha\u00eene d\u2019h\u00e9ritage doit d\u2019abord \u00eatre charg\u00e9e.</p> <p></p>"},{"location":"fr/module-04/class-loading/#1521-ordre-de-chargement-des-classes","title":"15.2.1 Ordre de Chargement des Classes","text":"<p>\u00c9tant donn\u00e9e une hi\u00e9rarchie de classes :</p> <pre><code>class A { ... }\nclass B extends A { ... }\nclass C extends B { ... }\n</code></pre> <p>Si le code ex\u00e9cute :</p> <pre><code>public static void main(String[] args) {\n    new C();\n}\n</code></pre> <p>Alors le chargement des classes se d\u00e9roule dans cet ordre strict :</p> <ul> <li>Charger la classe A  </li> <li>Initialiser les variables statiques de A (valeurs par d\u00e9faut \u2192 explicites)  </li> <li>Ex\u00e9cuter les blocs d\u2019initialisation statique de A (du haut vers le bas)  </li> <li>Charger la classe B et r\u00e9p\u00e9ter la m\u00eame logique  </li> <li>Charger la classe C et r\u00e9p\u00e9ter la m\u00eame logique  </li> </ul> <p></p>"},{"location":"fr/module-04/class-loading/#1522-que-se-passe-t-il-pendant-le-chargement-dune-classe","title":"15.2.2 Que se Passe-t-il Pendant le Chargement d\u2019une Classe","text":"<ul> <li>\u00c9tape 1 : Les variables statiques sont allou\u00e9es (d\u2019abord avec les valeurs par d\u00e9faut).  </li> <li>\u00c9tape 2 : Les initialisations statiques explicites s\u2019ex\u00e9cutent.  </li> <li>\u00c9tape 3 : Les blocs d\u2019initialisation statique s\u2019ex\u00e9cutent dans l\u2019ordre du code source.  </li> </ul> <p>Note</p> <p>Apr\u00e8s ces \u00e9tapes, la classe est compl\u00e8tement pr\u00eate et peut maintenant \u00eatre utilis\u00e9e (instanci\u00e9e ou r\u00e9f\u00e9renc\u00e9e).</p> <p></p>"},{"location":"fr/module-04/class-loading/#153-creation-dobjets-avec-heritage","title":"15.3 Cr\u00e9ation d\u2019Objets (avec H\u00e9ritage)","text":"<p>Quand le mot-cl\u00e9 <code>new</code> est utilis\u00e9, la cr\u00e9ation d\u2019instance suit une s\u00e9quence stricte et pr\u00e9visible impliquant toutes les classes parentes.</p> <p></p>"},{"location":"fr/module-04/class-loading/#1531-ordre-complet-de-creation-des-instances","title":"15.3.1 Ordre Complet de Cr\u00e9ation des Instances","text":"<ul> <li>1. La m\u00e9moire est allou\u00e9e dans le Heap pour le nouvel objet (les champs re\u00e7oivent des valeurs par d\u00e9faut).  </li> <li>2. La cha\u00eene des constructeurs s\u2019ex\u00e9cute du parent vers l\u2019enfant \u2014 le sommet de la hi\u00e9rarchie s\u2019ex\u00e9cute en premier, puis chaque sous-classe.  </li> <li>3. Les variables d\u2019instance re\u00e7oivent leurs initialisations explicites.  </li> <li>4. Les blocs d\u2019initialisation d\u2019instance s\u2019ex\u00e9cutent.  </li> <li>5. Le corps du constructeur s\u2019ex\u00e9cute : pour chaque classe dans la cha\u00eene d\u2019h\u00e9ritage, les \u00e9tapes 3\u20135 (initialisation des champs, blocs d\u2019instance, corps du constructeur) s\u2019appliquent du parent vers l\u2019enfant.  </li> </ul>"},{"location":"fr/module-04/class-loading/#154-exemple-complet-initialisation-statique-dinstance-a-travers-lheritage","title":"15.4 Exemple Complet : Initialisation Statique + d\u2019Instance \u00e0 Travers l\u2019H\u00e9ritage","text":"<p>Consid\u00e9rons la hi\u00e9rarchie suivante \u00e0 trois niveaux :</p> <pre><code>class A {\n    static int sa = init(\"A static var\");\n\n    static {\n        System.out.println(\"A static block\");\n    }\n\n    int ia = init(\"A instance var\");\n\n    {\n        System.out.println(\"A instance block\");\n    }\n\n    A() {\n        System.out.println(\"A constructor\");\n    }\n\n    static int init(String msg) {\n        System.out.println(msg);\n        return 0;\n    }\n}\n\nclass B extends A {\n    static int sb = init(\"B static var\");\n\n    static {\n        System.out.println(\"B static block\");\n    }\n\n    int ib = init(\"B instance var\");\n\n    {\n        System.out.println(\"B instance block\");\n    }\n\n    B() {\n        System.out.println(\"B constructor\");\n    }\n}\n\nclass C extends B {\n    static int sc = init(\"C static var\");\n\n    static {\n        System.out.println(\"C static block\");\n    }\n\n    int ic = init(\"C instance var\");\n\n    {\n        System.out.println(\"C instance block\");\n    }\n\n    C() {\n        System.out.println(\"C constructor\");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        new C();\n    }\n}\n</code></pre> <p>Sortie</p> <pre><code>A static var\nA static block\nB static var\nB static block\nC static var\nC static block\nA instance var\nA instance block\nA constructor\nB instance var\nB instance block\nB constructor\nC instance var\nC instance block\nC constructor\n</code></pre> <p></p>"},{"location":"fr/module-04/class-loading/#155-diagramme-de-visualisation","title":"15.5 Diagramme de Visualisation","text":"<pre><code>            CHARGEMENT DES CLASSES (du haut vers le bas)\n\n                A  ---&gt;  B  ---&gt;  C\n                |         |         |\n      variables statiques + blocs statiques ex\u00e9cut\u00e9s dans l\u2019ordre\n\n-------------------------------------------------------\n\n            CR\u00c9ATION DE L\u2019OBJET (du parent vers l\u2019enfant)\n\n new C() \n    |\n    +--&gt; allocation m\u00e9moire pour C (valeurs par d\u00e9faut)\n    +--&gt; appel du constructeur B()\n            |\n            +--&gt; appel du constructeur A()\n                    |\n                    +--&gt; initialise les variables d\u2019instance de A\n                    +--&gt; ex\u00e9cute les blocs d\u2019instance de A\n                    +--&gt; ex\u00e9cute le constructeur A\n            +--&gt; initialise les variables d\u2019instance de B\n            +--&gt; ex\u00e9cute les blocs d\u2019instance de B\n            +--&gt; ex\u00e9cute le constructeur B\n    +--&gt; initialise les variables d\u2019instance de C\n    +--&gt; ex\u00e9cute les blocs d\u2019instance de C\n    +--&gt; ex\u00e9cute le constructeur C\n</code></pre>"},{"location":"fr/module-04/class-loading/#156-regles-cles","title":"15.6 R\u00e8gles Cl\u00e9s","text":"<ul> <li>L\u2019initialisation statique se produit une seule fois par classe.  </li> <li>Les initialisateurs statiques s\u2019ex\u00e9cutent dans l\u2019ordre parent \u2192 enfant.  </li> <li>L\u2019initialisation d\u2019instance se produit chaque fois qu\u2019un objet est cr\u00e9\u00e9.  </li> <li>Pour chaque classe dans la cha\u00eene d\u2019h\u00e9ritage, les champs d\u2019instance et les blocs d\u2019instance s\u2019ex\u00e9cutent avant le corps du constructeur de cette classe.  </li> <li>Globalement, l\u2019initialisation des champs/blocs d\u2019instance et les constructeurs s\u2019ex\u00e9cutent du parent vers l\u2019enfant.  </li> <li>Les constructeurs appellent toujours le constructeur du parent (explicitement ou implicitement).  </li> </ul>"},{"location":"fr/module-04/class-loading/#157-tableau-recapitulatif","title":"15.7 Tableau R\u00e9capitulatif","text":"STATIQUE (Niveau Classe) INSTANCE (Niveau Objet) Une seule fois Se produit \u00e0 chaque <code>new</code> Ex\u00e9cut\u00e9 parent \u2192 enfant Initialisation d\u2019instance et constructeurs parent \u2192 enfant variables statiques (d\u00e9faut \u2192 explicites) variables d\u2019instance (d\u00e9faut \u2192 explicites) blocs statiques blocs d\u2019instance + constructeur"},{"location":"fr/module-04/exceptions/","title":"19. Exceptions et Gestion des Erreurs","text":""},{"location":"fr/module-04/exceptions/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>19.1 Hi\u00e9rarchie et types dexceptions<ul> <li>19.1.1 Throwable</li> <li>19.1.2 Error (unchecked)</li> <li>19.1.3 Exceptions Checked (<code>Exception</code>)</li> <li>19.1.4 Exceptions Unchecked (<code>RuntimeException</code>)</li> </ul> </li> <li>19.2 D\u00e9clarer et lancer des exceptions<ul> <li>19.2.1 D\u00e9clarer des exceptions avec throws</li> <li>19.2.2 Lancer des exceptions</li> </ul> </li> <li>19.3 Red\u00e9finition de m\u00e9thodes et r\u00e8gles sur les exceptions</li> <li>19.4 Gestion des exceptions: try, catch, finally<ul> <li>19.4.1 Syntaxe de base try-catch</li> <li>19.4.2 Plusieurs blocs catch</li> <li>19.4.3 Multi-catch Java-7</li> <li>19.4.4 Bloc finally</li> </ul> </li> <li>19.5 Gestion automatique des ressources try-with-resources<ul> <li>19.5.1 Syntaxe de base</li> <li>19.5.2 D\u00e9clarer plusieurs ressources</li> <li>19.5.3 Port\u00e9e des ressources</li> </ul> </li> <li>19.6 Exceptions supprim\u00e9es</li> <li>19.7 R\u00e9sum\u00e9 des exceptions</li> </ul> <p>Les <code>Exceptions</code> constituent le m\u00e9canisme structur\u00e9 de Java pour g\u00e9rer les conditions anormales \u00e0 runtime. Elles permettent de s\u00e9parer le flux normal d'ex\u00e9cution de la logique de gestion des erreurs, am\u00e9liorant la robustesse, la lisibilit\u00e9 et l'exactitude du programme.</p> <p></p>"},{"location":"fr/module-04/exceptions/#191-hierarchie-et-types-dexceptions","title":"19.1 Hi\u00e9rarchie et types dexceptions","text":"<p>Toutes les exceptions d\u00e9rivent de <code>Throwable</code>. La hi\u00e9rarchie d\u00e9finit quelles conditions sont r\u00e9cup\u00e9rables, lesquelles doivent \u00eatre d\u00e9clar\u00e9es, et lesquelles repr\u00e9sentent des d\u00e9faillances syst\u00e8me fatales.</p> <pre><code>java.lang.Object\n\u2514\u2500\u2500 java.lang.Throwable\n    \u251c\u2500\u2500 java.lang.Error\n    \u2514\u2500\u2500 java.lang.Exception\n        \u2514\u2500\u2500 java.lang.RuntimeException\n</code></pre> <p></p>"},{"location":"fr/module-04/exceptions/#1911-throwable","title":"19.1.1 Throwable","text":"<ul> <li>Classe de base pour toutes les erreurs et exceptions</li> <li>Fournit message, cause et stack trace</li> <li>Seuls <code>Throwable</code> et ses sous-classes peuvent \u00eatre lanc\u00e9s ou captur\u00e9s</li> </ul>"},{"location":"fr/module-04/exceptions/#1912-error-unchecked","title":"19.1.2 Error (unchecked)","text":"<ul> <li>Repr\u00e9sente des probl\u00e8mes graves de la JVM ou du syst\u00e8me</li> <li>Non destin\u00e9 \u00e0 \u00eatre captur\u00e9 ou g\u00e9r\u00e9</li> <li>Exemples: <code>OutOfMemoryError</code>, <code>StackOverflowError</code></li> </ul> <p>Note</p> <p>Les erreurs indiquent des conditions dont l'application ne peut g\u00e9n\u00e9ralement pas se remettre.</p> <p></p>"},{"location":"fr/module-04/exceptions/#1913-exceptions-checked-exception","title":"19.1.3 Exceptions Checked (<code>Exception</code>)","text":"<ul> <li>Sous-classes de <code>Exception</code> \u00e0 lexclusion de <code>RuntimeException</code></li> <li>Repr\u00e9sentent des conditions que l'application peut vouloir g\u00e9rer</li> <li>Doivent \u00eatre soit captur\u00e9es soit d\u00e9clar\u00e9es</li> <li>Exemples: <code>IOException</code>, <code>SQLException</code></li> </ul>"},{"location":"fr/module-04/exceptions/#1914-exceptions-unchecked-runtimeexception","title":"19.1.4 Exceptions Unchecked (<code>RuntimeException</code>)","text":"<ul> <li>Sous-classes de <code>RuntimeException</code></li> <li>Ne doivent pas obligatoirement \u00eatre d\u00e9clar\u00e9es ou captur\u00e9es</li> <li>Repr\u00e9sentent g\u00e9n\u00e9ralement des erreurs de programmation</li> <li>Exemples: <code>NullPointerException</code>, <code>IllegalArgumentException</code></li> </ul>"},{"location":"fr/module-04/exceptions/#192-declarer-et-lancer-des-exceptions","title":"19.2 D\u00e9clarer et lancer des exceptions","text":""},{"location":"fr/module-04/exceptions/#1921-declarer-des-exceptions-avec-throws","title":"19.2.1 D\u00e9clarer des exceptions avec throws","text":"<p>Une m\u00e9thode d\u00e9clare les exceptions checked avec la clause <code>throws</code>. Cela fait partie du contrat API de la m\u00e9thode.</p> <pre><code>void readFile(Path p) throws IOException {\n    Files.readString(p);\n}\n</code></pre> <p>Note</p> <p>Seules les exceptions checked doivent \u00eatre d\u00e9clar\u00e9es. Les exceptions unchecked peuvent l'\u00eatre, mais sont g\u00e9n\u00e9ralement omises.</p> <p></p>"},{"location":"fr/module-04/exceptions/#1922-lancer-des-exceptions","title":"19.2.2 Lancer des exceptions","text":"<p>Les exceptions sont cr\u00e9\u00e9es avec <code>new</code> et lanc\u00e9es explicitement avec <code>throw</code>.</p> <pre><code>if (value &lt; 0) {\n    throw new IllegalArgumentException(\"value must be &gt;= 0\");\n}\n</code></pre> <ul> <li><code>throw</code> lance exactement une instance dexception</li> <li><code>throws</code> d\u00e9clare les exceptions possibles dans la signature de la m\u00e9thode</li> </ul> <p></p>"},{"location":"fr/module-04/exceptions/#193-redefinition-de-methodes-et-regles-sur-les-exceptions","title":"19.3 Red\u00e9finition de m\u00e9thodes et r\u00e8gles sur les exceptions","text":"<p>Lors de la red\u00e9finition dune m\u00e9thode, les r\u00e8gles sur les exceptions sont strictement appliqu\u00e9es. - Une m\u00e9thode red\u00e9finie peut lancer moins d'exceptions checked ou des exceptions plus sp\u00e9cifiques - Elle peut lancer n'importe quelles exceptions unchecked - Elle ne peut lancer aucune nouvelle exception checked plus large</p> <pre><code>class Parent {\n    void work() throws IOException {}\n}\n\nclass Child extends Parent {\n    @Override\n    void work() throws FileNotFoundException {} // OK\n}\n</code></pre> <p>Note</p> <p>Modifier uniquement les exceptions unchecked ne viole jamais le contrat de red\u00e9finition.</p> <p></p>"},{"location":"fr/module-04/exceptions/#194-gestion-des-exceptions-try-catch-finally","title":"19.4 Gestion des exceptions: try, catch, finally","text":""},{"location":"fr/module-04/exceptions/#1941-syntaxe-de-base-try-catch","title":"19.4.1 Syntaxe de base try-catch","text":"<pre><code>try {\n    riskyOperation();\n} catch (IOException e) {\n    handle(e);\n}\n</code></pre> <ul> <li>Un bloc <code>try</code> doit \u00eatre suivi d'au moins un <code>catch</code> ou d'un <code>finally</code></li> <li>Les <code>catch</code> sont \u00e9valu\u00e9s de haut en bas</li> </ul>"},{"location":"fr/module-04/exceptions/#1942-plusieurs-blocs-catch","title":"19.4.2 Plusieurs blocs catch","text":"<pre><code>try {\n    process();\n} catch (FileNotFoundException e) {\n    recover();\n} catch (IOException e) {\n    log();\n}\n</code></pre> <p>Note</p> <p>Les exceptions plus sp\u00e9cifiques doivent pr\u00e9c\u00e9der les plus g\u00e9n\u00e9rales, sinon la compilation \u00e9choue. Si un <code>catch</code> pour une superclasse pr\u00e9c\u00e8de celui d'une sous-classe, ce dernier devient inatteignable.</p> <p></p>"},{"location":"fr/module-04/exceptions/#1943-multi-catch-java-7","title":"19.4.3 Multi-catch Java-7","text":"<pre><code>try {\n    process();\n} catch (IOException | SQLException e) {\n    log(e);\n}\n</code></pre> <ul> <li>Les types d'exception doivent \u00eatre non li\u00e9s (pas parent/enfant)</li> <li>La variable captur\u00e9e est implicitement <code>final</code></li> </ul>"},{"location":"fr/module-04/exceptions/#1944-bloc-finally","title":"19.4.4 Bloc finally","text":"<p>Le bloc <code>finally</code> s'ex\u00e9cute qu'il y ait exception ou non, sauf en cas d'arr\u00eat extr\u00eame de la JVM.</p> <pre><code>try {\n    open();\n} finally {\n    close();\n}\n</code></pre> <ul> <li>Utilis\u00e9 pour la logique de nettoyage</li> <li>S'ex\u00e9cute m\u00eame si <code>return</code> est utilis\u00e9 dans try ou catch</li> </ul> <p>Note</p> <p>Un bloc <code>finally</code> peut \u00e9craser une valeur de retour ou avaler une exception. Cela est d\u00e9conseill\u00e9 car cela complique le flux de contr\u00f4le.</p> <p></p>"},{"location":"fr/module-04/exceptions/#195-gestion-automatique-des-ressources-try-with-resources","title":"19.5 Gestion automatique des ressources try-with-resources","text":"<p>Le <code>try-with-resources</code> permet la fermeture automatique des ressources impl\u00e9mentant <code>AutoCloseable</code>. Il \u00e9limine le besoin d'un bloc <code>finally</code> explicite dans la plupart des cas.</p> <p></p>"},{"location":"fr/module-04/exceptions/#1951-syntaxe-de-base","title":"19.5.1 Syntaxe de base","text":"<pre><code>try (BufferedReader br = Files.newBufferedReader(path)) {\n    return br.readLine();\n}\n</code></pre> <ul> <li>Les ressources sont ferm\u00e9es automatiquement</li> <li>La fermeture a lieu m\u00eame en cas d'exception</li> <li>Les ressources sont ferm\u00e9es avant l\u2019ex\u00e9cution de tout bloc <code>catch</code> ou <code>finally</code>.</li> </ul> <pre><code>try (Resource a = new Resource()) {\n    a.read();\n} finally {\n    a.close();  // \u274c Compile-time error: a est hors de port\u00e9e ici\n}\n</code></pre>"},{"location":"fr/module-04/exceptions/#1952-declarer-plusieurs-ressources","title":"19.5.2 D\u00e9clarer plusieurs ressources","text":"<pre><code>try (InputStream in = Files.newInputStream(p);\n        OutputStream out = Files.newOutputStream(q)) {\n    in.transferTo(out);\n}\n</code></pre> <ul> <li>Les ressources sont ferm\u00e9es en ordre inverse de d\u00e9claration</li> </ul>"},{"location":"fr/module-04/exceptions/#1953-portee-des-ressources","title":"19.5.3 Port\u00e9e des ressources","text":"<ul> <li>Les ressources sont visibles uniquement dans le bloc <code>try</code></li> <li>Elles sont implicitement <code>final</code></li> <li>Depuis Java 9, on peut d\u00e9clarer les ressources avant le try-with-resources si elles sont <code>final</code> ou effectivement finales</li> </ul> <pre><code>final var firstWriter = Files.newBufferedWriter(filePath);\n\ntry (firstWriter; var secondWriter = Files.newBufferedWriter(filePath)) {\n    // CODE\n}\n</code></pre> <p>Note</p> <p>Tenter de r\u00e9affecter une variable ressource provoque une erreur de compilation.</p> <pre><code>Resource a = new Resource();\ntry(a){ // since Java 9\n  ...\n}finally{\n   a.close(); // ce code compile, mais la ressource r\u00e9f\u00e9renc\u00e9e par la r\u00e9f\u00e9rence `a` a d\u00e9j\u00e0 \u00e9t\u00e9 ferm\u00e9e.\n}\n</code></pre> <p></p>"},{"location":"fr/module-04/exceptions/#196-exceptions-supprimees","title":"19.6 Exceptions supprim\u00e9es","text":"<p>Lorsque le bloc <code>try</code> et la m\u00e9thode <code>close()</code> d'une ressource lancent tous deux une exception, Java conserve l'exception principale et supprime les autres.</p> <pre><code>try (BadResource r = new BadResource()) {\n    throw new RuntimeException(\"main\");\n}\n</code></pre> <p>Si <code>close()</code> lance aussi une exception, elle devient supprim\u00e9e.</p> <pre><code>catch (Exception e) {\n    for (Throwable t : e.getSuppressed()) {\n        System.out.println(t);\n    }\n}\n</code></pre> <ul> <li>L'exeption principale est lanc\u00e9e</li> <li>Les exceptions secondaires sont accessibles via <code>getSuppressed()</code></li> </ul> <p></p>"},{"location":"fr/module-04/exceptions/#197-resume-des-exceptions","title":"19.7 R\u00e9sum\u00e9 des exceptions","text":"<ul> <li>Les exceptions checked doivent \u00eatre captur\u00e9es ou d\u00e9clar\u00e9es</li> <li>Les m\u00e9thodes red\u00e9finies ne peuvent pas \u00e9largir les exceptions checked</li> <li>Utiliser multi-catch pour une logique de gestion commune</li> <li>Pr\u00e9f\u00e9rer try-with-resources au nettoyage via finally</li> <li>Les ressources se ferment en ordre inverse</li> <li>Les exceptions supprim\u00e9es pr\u00e9servent le contexte complet de d\u00e9faillance</li> </ul>"},{"location":"fr/module-04/generics/","title":"18. Generics en Java","text":""},{"location":"fr/module-04/generics/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>18.1 Bases des Types G\u00e9n\u00e9riques</li> <li>18.2 Pourquoi les Generics Existent</li> <li>18.3 M\u00e9thodes G\u00e9n\u00e9riques</li> <li>18.4 Type Erasure<ul> <li>18.4.1 Comment Fonctionne la Type Erasure</li> <li>18.4.2 Erasure des Param\u00e8tres de Type Sans Bound</li> <li>18.4.3 Erasure des Param\u00e8tres de Type Avec Bound</li> <li>18.4.4 Bounds Multiples: Le Premier Bound D\u00e9termine l\u2019Erasure</li> <li>18.4.5 Pourquoi Seulement le Premier Bound Devient le Type \u00e0 Runtime</li> <li>18.4.6 Un Exemple Plus Complexe</li> <li>18.4.7 Red\u00e9finition (Overriding) et G\u00e9n\u00e9riques<ul> <li>18.4.7.1 Comment le compilateur valide une red\u00e9finition</li> <li>18.4.7.2 Param\u00e8tres g\u00e9n\u00e9riques et red\u00e9finition</li> <li>18.4.7.3 Red\u00e9finition valide \u2014 Suppression de la sp\u00e9cificit\u00e9 g\u00e9n\u00e9rique</li> <li>18.4.7.4 Red\u00e9finition invalide \u2014 Ajout de sp\u00e9cificit\u00e9 g\u00e9n\u00e9rique</li> <li>18.4.7.5 Red\u00e9finition valide \u2014 Param\u00e9trage identique</li> <li>18.4.7.6 Red\u00e9finition invalide \u2014 Changement d\u2019argument g\u00e9n\u00e9rique</li> <li>18.4.7.7 Pourquoi cette r\u00e8gle existe</li> <li>18.4.7.8 Mod\u00e8le mental</li> <li>18.4.7.9 R\u00e8gles r\u00e9capitulatives</li> </ul> </li> <li>18.4.8 Surcharge d\u2019une M\u00e9thode G\u00e9n\u00e9rique \u2014 Pourquoi Certaines Surcharges Sont Impossibles</li> <li>18.4.9 Surcharge d\u2019une M\u00e9thode G\u00e9n\u00e9rique H\u00e9rit\u00e9e d\u2019une Classe Parent</li> <li>18.4.10 Retourner des Types G\u00e9n\u00e9riques \u2014 R\u00e8gles et Restrictions</li> <li>18.4.11 R\u00e9capitulatif des R\u00e8gles d\u2019Erasure</li> </ul> </li> <li>18.5 Bounds sur les Param\u00e8tres de Type<ul> <li>18.5.1 Upper Bounds: extends</li> <li>18.5.2 Bounds Multiples</li> <li>18.5.3 Wildcard: ?, ? extends, ? super<ul> <li>18.5.3.1 Wildcard Non Limit\u00e9e</li> <li>18.5.3.2 Wildcard avec Upper Bound extends</li> <li>18.5.3.3 Wildcard avec Lower Bound super</li> </ul> </li> </ul> </li> <li>18.6 Generics et H\u00e9ritage</li> <li>18.7 Type Inference (Op\u00e9rateur Diamond)</li> <li>18.8 Raw Types (Compatibilit\u00e9 Legacy)</li> <li>18.9 Tableaux G\u00e9n\u00e9riques (Non Autoris\u00e9s)</li> <li>18.10 Bounded Type Inference</li> <li>18.11 Wildcard vs Param\u00e8tres de Type</li> <li>18.12 R\u00e8gle PECS (Producer Extends, Consumer Super)</li> <li>18.13 Pi\u00e8ges Communs</li> <li>18.14 Tableau R\u00e9capitulatif des Wildcards</li> <li>18.15 R\u00e9capitulatif des Concepts</li> <li>18.16 Exemple Complet</li> </ul> <p>Java <code>Generics</code> permettent de cr\u00e9er des classes, des interfaces et des m\u00e9thodes qui travaillent avec des types sp\u00e9cifi\u00e9s par l\u2019utilisateur, en garantissant que seuls des objets du type correct sont utilis\u00e9s.</p> <p>Tous les contr\u00f4les de type sont effectu\u00e9s par le compilateur \u00e0 compile-time.</p> <p>Pendant la compilation, le compilateur v\u00e9rifie les types puis supprime les informations g\u00e9n\u00e9riques (processus identifi\u00e9 comme type erasure), en les rempla\u00e7ant par les types r\u00e9els ou par Object lorsque n\u00e9cessaire.</p> <p>Le bytecode r\u00e9sultant ne contient pas de generics: il contient seulement les types concrets et, si n\u00e9cessaire, des casts ins\u00e9r\u00e9s automatiquement par le compilateur.</p> <p>De cette mani\u00e8re, les erreurs de type sont intercept\u00e9es avant l\u2019ex\u00e9cution, rendant le code plus s\u00fbr, lisible et r\u00e9utilisable.</p> <p>Les Generics s\u2019appliquent \u00e0: - <code>Classes</code> - <code>Interfaces</code> - <code>M\u00e9thodes</code> (m\u00e9thodes g\u00e9n\u00e9riques) - <code>Constructeurs</code></p> <p></p>"},{"location":"fr/module-04/generics/#181-bases-des-types-generiques","title":"18.1 Bases des Types G\u00e9n\u00e9riques","text":"<p>Une classe ou interface g\u00e9n\u00e9rique introduit un ou plusieurs param\u00e8tres de type, encadr\u00e9s par des chevrons.</p> <pre><code>class Box&lt;T&gt; {\n    private T value;\n    void set(T v) { value = v; }\n    T get()       { return value; }\n}\n\nBox&lt;String&gt; b = new Box&lt;&gt;();\n\nb.set(\"hello\");\n\nString x = b.get(); // aucun cast n\u00e9cessaire\n</code></pre> <p>Plusieurs param\u00e8tres de type sont permis:</p> <pre><code>class Pair&lt;K, V&gt; {\n    K key;\n    V value;\n}\n</code></pre> <p></p>"},{"location":"fr/module-04/generics/#182-pourquoi-les-generics-existent","title":"18.2 Pourquoi les Generics Existent","text":"<pre><code>List list = new ArrayList();          // pre-generics\nlist.add(\"hi\");\n\nInteger x = (Integer) list.get(0);    // ClassCastException \u00e0 runtime\n</code></pre> <p>Avec les generics:</p> <pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"hi\");\n\nString x = list.get(0);               // type-safe, aucun cast\n</code></pre> <p></p>"},{"location":"fr/module-04/generics/#183-methodes-generiques","title":"18.3 M\u00e9thodes G\u00e9n\u00e9riques","text":"<p>Une m\u00e9thode g\u00e9n\u00e9rique introduit ses propres param\u00e8tres de type, ind\u00e9pendants de la classe.</p> <pre><code>class Util {\n\n    static &lt;T&gt; T pick(T a, T b) { return a; }\n\n}\n\nString s = Util.&lt;String&gt;pick(\"A\", \"B\"); // explicite\nString t = Util.pick(\"A\", \"B\");         // l\u2019inf\u00e9rence fonctionne\n</code></pre> <p></p>"},{"location":"fr/module-04/generics/#184-type-erasure","title":"18.4 Type Erasure","text":"<p>La <code>Type erasure</code> est le processus par lequel le compilateur Java supprime toutes les informations sur les types g\u00e9n\u00e9riques avant de g\u00e9n\u00e9rer le bytecode.</p> <p>Cela garantit la compatibilit\u00e9 avec les JVM pr\u00e9c\u00e9dentes \u00e0 Java 5.</p> <p>\u00c0 <code>compile time</code>, les generics sont compl\u00e8tement contr\u00f4l\u00e9s: bounds sur les types, variance, surcharge de m\u00e9thodes g\u00e9n\u00e9riques, etc.</p> <p>Cependant, \u00e0 runtime, toutes les informations g\u00e9n\u00e9riques disparaissent.</p> <p></p>"},{"location":"fr/module-04/generics/#1841-comment-fonctionne-la-type-erasure","title":"18.4.1 Comment Fonctionne la Type Erasure","text":"<ul> <li>Remplacer toutes les variables de type (comme <code>T</code>) par leur type erasure.</li> <li>Ins\u00e9rer des casts lorsque n\u00e9cessaire.</li> <li>Supprimer tous les arguments de type g\u00e9n\u00e9rique (ex. <code>List&lt;String&gt;</code> \u2192 <code>List</code>).</li> </ul>"},{"location":"fr/module-04/generics/#1842-erasure-des-parametres-de-type-sans-bound","title":"18.4.2 Erasure des Param\u00e8tres de Type Sans Bound","text":"<p>Si une variable de type n\u2019a pas de bound:</p> <pre><code>class Box&lt;T&gt; {\n    T value;\n    T get() { return value; }\n}\n</code></pre> <p>L\u2019erasure de <code>T</code> est <code>Object</code>.</p> <pre><code>class Box {\n    Object value;\n    Object get() { return value; }\n}\n</code></pre> <p></p>"},{"location":"fr/module-04/generics/#1843-erasure-des-parametres-de-type-avec-bound","title":"18.4.3 Erasure des Param\u00e8tres de Type Avec Bound","text":"<p>Si le param\u00e8tre de type a un bound:</p> <pre><code>class TaskRunner&lt;T extends Runnable&gt; {\n\n    void run(T task) { task.run(); }\n\n}\n</code></pre> <p>Alors l\u2019erasure de <code>T</code> est le premier bound trouv\u00e9 par le compilateur: dans ce cas sp\u00e9cifique <code>Runnable</code>.</p> <pre><code>class TaskRunner {\n    void run(Runnable task) { task.run(); }\n}\n</code></pre> <p></p>"},{"location":"fr/module-04/generics/#1844-bounds-multiples-le-premier-bound-determine-lerasure","title":"18.4.4 Bounds Multiples: Le Premier Bound D\u00e9termine l\u2019Erasure","text":"<p>Java permet des bounds multiples:</p> <pre><code>&lt;T extends Runnable &amp; Serializable &amp; Cloneable&gt;\n</code></pre> <p>Important</p> <p>L\u2019erasure de <code>T</code> est toujours le premier bound, qui doit \u00eatre une classe ou une interface.</p> <p>Puisque <code>Runnable</code> est le premier bound, le compilateur effectue l\u2019erasure de <code>T</code> \u00e0 <code>Runnable</code>.</p> <ul> <li>Exemple avec Bounds Multiples (Enti\u00e8rement D\u00e9velopp\u00e9)</li> </ul> <pre><code>public static &lt;T extends Runnable &amp; Serializable &amp; Cloneable&gt;\nvoid runAll(List&lt;T&gt; list) {\n    for (T t : list) {\n        t.run();\n    }\n}\n</code></pre> <p>Version avec Erasure</p> <pre><code>public static void runAll(List list) {\n    for (Object obj : list) {\n        Runnable t = (Runnable) obj;   // cast ins\u00e9r\u00e9 par le compilateur\n        t.run();\n    }\n}\n</code></pre> <p>Que se passe-t-il avec les autres bounds (Serializable, Cloneable)?</p> <ul> <li>Ils sont appliqu\u00e9s seulement \u00e0 compile time.</li> <li>Ils n\u2019apparaissent PAS dans le bytecode.</li> <li>Aucune interface suppl\u00e9mentaire n\u2019est associ\u00e9e au type avec erasure.</li> </ul> <p></p>"},{"location":"fr/module-04/generics/#1845-pourquoi-seulement-le-premier-bound-devient-le-type-a-runtime","title":"18.4.5 Pourquoi Seulement le Premier Bound Devient le Type \u00e0 Runtime?","text":"<p>Parce que la JVM doit op\u00e9rer en utilisant un seul type de r\u00e9f\u00e9rence concret pour chaque variable ou param\u00e8tre.</p> <p>Les instructions bytecode \u00e0 runtime comme <code>invokevirtual</code> exigent une seule classe ou interface, pas un type compos\u00e9 comme \u201cRunnable &amp; Serializable &amp; Cloneable\u201d.</p> <p>Note</p> <p>Java s\u00e9lectionne le premier bound comme type \u00e0 runtime, et utilise les bounds restants seulement pour la validation \u00e0 compile-time.</p> <p></p>"},{"location":"fr/module-04/generics/#1846-un-exemple-plus-complexe","title":"18.4.6 Un Exemple Plus Complexe","text":"<pre><code>interface A { void a(); }\ninterface B { void b(); }\n\nclass C implements A, B {\n    public void a() {}\n    public void b() {}\n}\n\nclass Demo&lt;T extends A &amp; B&gt; {\n    void test(T value) {\n        value.a();\n        value.b();\n    }\n}\n</code></pre> <p>Version avec Erasure</p> <pre><code>class Demo {\n    void test(A value) {\n        value.a();\n        // value.b();   // \u274c non disponible apr\u00e8s l\u2019erasure: le type est A, pas B\n    }\n}\n</code></pre> <p>Note</p> <p>Le compilateur peut ins\u00e9rer des casts suppl\u00e9mentaires ou des m\u00e9thodes bridge dans des sc\u00e9narios d\u2019h\u00e9ritage plus complexes, mais l\u2019erasure utilise toujours seulement le premier bound (A dans ce cas).</p> <p></p>"},{"location":"fr/module-04/generics/#1847-redefinition-overriding-et-generiques","title":"18.4.7 Red\u00e9finition (Overriding) et G\u00e9n\u00e9riques","text":"<p>Lorsque les g\u00e9n\u00e9riques interagissent avec l\u2019h\u00e9ritage, deux r\u00e8gles fondamentales doivent \u00eatre clairement comprises :</p> <p>Important</p> <p>La red\u00e9finition est v\u00e9rifi\u00e9e apr\u00e8s l\u2019effacement des types (type erasure). La compatibilit\u00e9 des types est v\u00e9rifi\u00e9e avant l\u2019effacement.</p> <p>Ces deux \u00e9tapes expliquent pourquoi certaines m\u00e9thodes red\u00e9finissent correctement, tandis que d\u2019autres provoquent des erreurs de compilation.</p> <p></p>"},{"location":"fr/module-04/generics/#18471-comment-le-compilateur-valide-une-redefinition","title":"18.4.7.1 Comment le compilateur valide une red\u00e9finition","text":"<p>Lorsqu\u2019une sous-classe d\u00e9clare une m\u00e9thode qui pourrait red\u00e9finir une m\u00e9thode de la superclasse, le compilateur effectue deux v\u00e9rifications :</p> <ol> <li>Avant l\u2019effacement    La m\u00e9thode doit \u00eatre compatible avec celle de la classe parente :</li> <li>M\u00eame nom</li> <li>M\u00eame types de param\u00e8tres (y compris les arguments g\u00e9n\u00e9riques)</li> <li> <p>Type de retour compatible (covariance autoris\u00e9e)</p> </li> <li> <p>Apr\u00e8s l\u2019effacement    Les signatures effac\u00e9es doivent correspondre exactement.</p> </li> </ol> <p>Les deux conditions doivent \u00eatre satisfaites.</p> <p></p>"},{"location":"fr/module-04/generics/#18472-parametres-generiques-et-redefinition","title":"18.4.7.2 Param\u00e8tres g\u00e9n\u00e9riques et red\u00e9finition","text":"<p>Les arguments de type g\u00e9n\u00e9rique font partie de la signature de la m\u00e9thode \u00e0 la compilation, mais disparaissent apr\u00e8s l\u2019effacement.</p> <p>Par cons\u00e9quent :</p> <ul> <li>Il est permis d\u2019effacer l\u2019information g\u00e9n\u00e9rique dans la m\u00e9thode red\u00e9finie</li> <li>Il est interdit d\u2019ajouter une nouvelle sp\u00e9cificit\u00e9 g\u00e9n\u00e9rique</li> <li>Si les deux m\u00e9thodes utilisent des types param\u00e9tr\u00e9s, ils doivent correspondre exactement</li> </ul> <p></p>"},{"location":"fr/module-04/generics/#18473-redefinition-valide-suppression-de-la-specificite-generique","title":"18.4.7.3 Red\u00e9finition valide \u2014 Suppression de la sp\u00e9cificit\u00e9 g\u00e9n\u00e9rique","text":"<pre><code>class Parent {\n    void process(Set&lt;Integer&gt; data) {}\n}\n\nclass Child extends Parent {\n    @Override\n    void process(Set data) {}   // \u2714 autoris\u00e9 (type brut)\n}\n</code></pre> <p>Explication :</p> <ul> <li>Avant l\u2019effacement : <code>Set</code> est compatible par affectation avec <code>Set&lt;Integer&gt;</code></li> <li>Apr\u00e8s l\u2019effacement : les deux deviennent <code>Set</code></li> </ul> <p>\u2714 Red\u00e9finition valide.</p> <p></p>"},{"location":"fr/module-04/generics/#18474-redefinition-invalide-ajout-de-specificite-generique","title":"18.4.7.4 Red\u00e9finition invalide \u2014 Ajout de sp\u00e9cificit\u00e9 g\u00e9n\u00e9rique","text":"<pre><code>class Parent {\n    void process(Set data) {}\n}\n\nclass Child extends Parent {\n    void process(Set&lt;Integer&gt; data) {}   // \u274c erreur de compilation\n}\n</code></pre> <p>Explication :</p> <ul> <li>Avant l\u2019effacement : <code>Set&lt;Integer&gt;</code> n\u2019est PAS compatible par affectation avec <code>Set</code></li> <li>Le compilateur rejette la m\u00e9thode avant m\u00eame d\u2019appliquer l\u2019effacement</li> </ul> <p></p>"},{"location":"fr/module-04/generics/#18475-redefinition-valide-parametrage-identique","title":"18.4.7.5 Red\u00e9finition valide \u2014 Param\u00e9trage identique","text":"<pre><code>class Parent {\n    void process(Set&lt;Integer&gt; data) {}\n}\n\nclass Child extends Parent {\n    @Override\n    void process(Set&lt;Integer&gt; data) {}   // \u2714 correspondance exacte\n}\n</code></pre> <p>Les deux v\u00e9rifications r\u00e9ussissent : - Compatible avant l\u2019effacement - Identique apr\u00e8s l\u2019effacement</p> <p></p>"},{"location":"fr/module-04/generics/#18476-redefinition-invalide-changement-dargument-generique","title":"18.4.7.6 Red\u00e9finition invalide \u2014 Changement d\u2019argument g\u00e9n\u00e9rique","text":"<pre><code>class Parent {\n    void process(Set&lt;Integer&gt; data) {}\n}\n\nclass Child extends Parent {\n    void process(Set&lt;String&gt; data) {}   // \u274c erreur de compilation\n}\n</code></pre> <p>Explication :</p> <ul> <li>Avant l\u2019effacement : <code>Set&lt;String&gt;</code> n\u2019est pas compatible avec <code>Set&lt;Integer&gt;</code></li> <li>Apr\u00e8s l\u2019effacement : les deux deviennent <code>Set</code></li> <li>Collision + incompatibilit\u00e9 \u2192 erreur de compilation</li> </ul> <p></p>"},{"location":"fr/module-04/generics/#18477-pourquoi-cette-regle-existe","title":"18.4.7.7 Pourquoi cette r\u00e8gle existe","text":"<p>Java doit garantir :</p> <ul> <li>La s\u00fbret\u00e9 des types \u00e0 la compilation</li> <li>Le polymorphisme \u00e0 l\u2019ex\u00e9cution apr\u00e8s effacement</li> </ul> <p>Comme les g\u00e9n\u00e9riques disparaissent \u00e0 l\u2019ex\u00e9cution, la JVM ne voit que les signatures effac\u00e9es. Le compilateur doit donc assurer la compatibilit\u00e9 avant l\u2019effacement et la coh\u00e9rence apr\u00e8s l\u2019effacement.</p> <p></p>"},{"location":"fr/module-04/generics/#18478-modele-mental","title":"18.4.7.8 Mod\u00e8le mental","text":"<p>Consid\u00e9rez la red\u00e9finition avec g\u00e9n\u00e9riques comme une v\u00e9rification en deux phases :</p> <pre><code>Phase 1 \u2192 Les types au niveau source sont-ils compatibles ?\nPhase 2 \u2192 Les signatures effac\u00e9es correspondent-elles ?\n</code></pre> <p>Si l\u2019une des phases \u00e9choue \u2192 erreur de compilation.</p> <p></p>"},{"location":"fr/module-04/generics/#18479-regles-recapitulatives","title":"18.4.7.9 R\u00e8gles r\u00e9capitulatives","text":"<ul> <li>La red\u00e9finition est valid\u00e9e apr\u00e8s l\u2019effacement</li> <li>La compatibilit\u00e9 est valid\u00e9e avant l\u2019effacement</li> <li>Il est possible d\u2019effacer l\u2019information g\u00e9n\u00e9rique dans la sous-classe</li> <li>Il est interdit d\u2019introduire une nouvelle sp\u00e9cificit\u00e9 g\u00e9n\u00e9rique</li> <li>Si les deux m\u00e9thodes sont param\u00e9tr\u00e9es, les arguments doivent correspondre exactement</li> <li>Apr\u00e8s l\u2019effacement, les signatures doivent \u00eatre identiques</li> </ul> <p>Cela explique pourquoi certaines m\u00e9thodes qui semblent \u00eatre des surcharges sont rejet\u00e9es : apr\u00e8s l\u2019effacement, elles entrent en collision, et si elles ne constituent pas une red\u00e9finition valide, le compilateur les bloque.</p> <p></p>"},{"location":"fr/module-04/generics/#1848-surcharge-dune-methode-generique-pourquoi-certaines-surcharges-sont-impossibles","title":"18.4.8 Surcharge d\u2019une M\u00e9thode G\u00e9n\u00e9rique \u2014 Pourquoi Certaines Surcharges Sont Impossibles","text":"<p>Quand Java compile du code g\u00e9n\u00e9rique, il applique la type erasure: les param\u00e8tres de type comme T sont supprim\u00e9s, et le compilateur les remplace par leur type erasure (habituellement Object ou le premier bound).</p> <p>Pour cette raison, deux m\u00e9thodes qui semblent diff\u00e9rentes au niveau source peuvent devenir identiques apr\u00e8s l\u2019erasure.</p> <p>Si les <code>signature</code> avec erasure sont les m\u00eames, Java ne peut pas les distinguer, donc le code ne compile pas.</p> <ul> <li>Exemple: Deux M\u00e9thodes qui S\u2019effondrent sur la M\u00eame <code>Signature</code></li> </ul> <pre><code>public class Demo {\n    public void testInput(List&lt;Object&gt; inputParam) {}\n\n    // public void testInput(List&lt;String&gt; inputParam) {}   // \u274c Erreur de compilation: apr\u00e8s l\u2019erasure, les deux deviennent testInput(List)\n}\n</code></pre> <p>Explication</p> <pre><code>List&lt;Object&gt; et List&lt;String&gt; sont tous deux effac\u00e9s en List.\n</code></pre> <p>\u00c0 runtime les deux m\u00e9thodes appara\u00eetraient comme:</p> <pre><code>void testInput(List inputParam)\n</code></pre> <p>Java ne permet pas deux m\u00e9thodes avec des signatures identiques dans la m\u00eame classe, donc la surcharge est rejet\u00e9e \u00e0 compile time.</p> <p></p>"},{"location":"fr/module-04/generics/#1849-surcharge-dune-methode-generique-heritee-dune-classe-parent","title":"18.4.9 Surcharge d\u2019une M\u00e9thode G\u00e9n\u00e9rique H\u00e9rit\u00e9e d\u2019une Classe Parent","text":"<p>La m\u00eame r\u00e8gle s\u2019applique quand une subclass tente d\u2019introduire une m\u00e9thode qui, apr\u00e8s erasure, a la m\u00eame signature qu\u2019une dans la superclass.</p> <pre><code>public class SubDemo extends Demo {\n    public void testInput(List&lt;Integer&gt; inputParam) {} \n    // \u274c Erreur de compilation: erasure \u2192 testInput(List), identique au parent\n}\n</code></pre> <p>Encore une fois, le compilateur rejette la surcharge parce que les signatures avec erasure entrent en collision.</p> <p>Quand la Surcharge Fonctionne</p> <p>L\u2019erasure supprime seulement les param\u00e8tres g\u00e9n\u00e9riques, pas la classe r\u00e9elle utilis\u00e9e comme param\u00e8tre de m\u00e9thode.</p> <p>Donc, si deux param\u00e8tres diff\u00e8rent dans le type raw (non g\u00e9n\u00e9rique), la surcharge est l\u00e9gale.</p> <pre><code>public class Demo {\n    public void testInput(List&lt;Object&gt; inputParam) {}\n    public void testInput(ArrayList&lt;String&gt; inputParam) {}  // \u2714 Compile\n}\n</code></pre> <p>Pourquoi \u00e7a fonctionne</p> <p>M\u00eame si <code>ArrayList&lt;String&gt;</code> devient <code>ArrayList</code>, et <code>List&lt;Object&gt;</code> devient <code>List</code>, ce sont des classes diff\u00e9rentes (ArrayList vs List), donc les signatures restent distinctes:</p> <pre><code>void testInput(List inputParam)\nvoid testInput(ArrayList inputParam)\n</code></pre> <p>Aucune collision \u2192 surcharge l\u00e9gale.</p> <p></p>"},{"location":"fr/module-04/generics/#18410-retourner-des-types-generiques-regles-et-restrictions","title":"18.4.10 Retourner des Types G\u00e9n\u00e9riques \u2014 R\u00e8gles et Restrictions","text":"<p>Quand on retourne une valeur depuis une m\u00e9thode, Java suit une r\u00e8gle rigide:</p> <p>Le type de retour d\u2019une m\u00e9thode en overriding doit \u00eatre un sous-type du type de retour du parent, et tout argument g\u00e9n\u00e9rique doit rester type-compatible (m\u00eame s\u2019il est effac\u00e9 \u00e0 runtime).</p> <p>Cela confond souvent les programmeurs, parce que les generics sur les types de retour causent des conflits similaires \u00e0 ceux des param\u00e8tres.</p> <p>Points Cl\u00e9s: - La covariance du type de retour s\u2019applique seulement au type raw, pas aux arguments g\u00e9n\u00e9riques. - Les arguments g\u00e9n\u00e9riques doivent rester compatibles apr\u00e8s l\u2019erasure (ils doivent co\u00efncider). - Deux m\u00e9thodes ne peuvent pas diff\u00e9rer seulement par le param\u00e8tre g\u00e9n\u00e9rique dans le type de retour.</p> <p>Exemple: substitution Ill\u00e9gale du Type de Retour \u00e0 Cause d\u2019Incompatibilit\u00e9 G\u00e9n\u00e9rique</p> <pre><code>class A {\n    List&lt;String&gt; getData() { return null; }\n}\n\nclass B extends A {\n    // List&lt;Integer&gt; n\u2019est pas un type de retour covariant de List&lt;String&gt;\n    // \u274c Erreur de compilation\n    List&lt;Integer&gt; getData() { return null; }\n}\n</code></pre> <p>Explication:</p> <p>M\u00eame si les generics sont effac\u00e9s, Java impose quand m\u00eame la type safety au niveau source:</p> <pre><code>List&lt;Integer&gt; n\u2019est pas un sous-type de List&lt;String&gt;.\n</code></pre> <p>Les deux deviennent List, mais Java rejette l\u2019override qui casse la compatibilit\u00e9 de type.</p> <ul> <li>Exemple: Type de Retour Covariant L\u00e9gal</li> </ul> <pre><code>class A {\n    Collection&lt;String&gt; getData() { return null; }\n}\n\nclass B extends A {\n    List&lt;String&gt; getData() { return null; }  // \u2714 List est un sous-type de Collection\n}\n</code></pre> <p>Ceci est permis parce que: - Les types raw sont covariants (List \u00e9tend Collection). - Les arguments g\u00e9n\u00e9riques co\u00efncident (String vs String).</p> <p>- - Exemple: Surcharge Ill\u00e9gale Bas\u00e9e Seulement sur le Type de Retour</p> <pre><code>class Demo {\n    List&lt;String&gt; getList() { return null; }\n\n    // List&lt;Integer&gt; getList() { return null; }  \n    // \u274c Erreur de compilation: le type de retour seul ne distingue pas les m\u00e9thodes\n}\n</code></pre> <p>Java n\u2019utilise pas le type de retour pour distinguer les m\u00e9thodes en surcharge.</p> <p></p>"},{"location":"fr/module-04/generics/#18411-recapitulatif-des-regles-derasure","title":"18.4.11 R\u00e9capitulatif des R\u00e8gles d\u2019Erasure","text":"<ul> <li><code>T sans bound</code> \u2192 erasure \u00e0 Object.</li> <li><code>T extends X</code> \u2192 erasure \u00e0 X.</li> <li><code>T extends X &amp; Y &amp; Z</code> \u2192 erasure \u00e0 X.</li> <li>Tous les param\u00e8tres g\u00e9n\u00e9riques sont effac\u00e9s dans les signatures des m\u00e9thodes.</li> <li>Des casts sont ins\u00e9r\u00e9s pour pr\u00e9server la typisation \u00e0 compile-time.</li> <li>Des m\u00e9thodes bridge peuvent \u00eatre g\u00e9n\u00e9r\u00e9es pour pr\u00e9server le polymorphisme.</li> </ul>"},{"location":"fr/module-04/generics/#185-bounds-sur-les-parametres-de-type","title":"18.5 Bounds sur les Param\u00e8tres de Type","text":""},{"location":"fr/module-04/generics/#1851-upper-bounds-extends","title":"18.5.1 Upper Bounds: extends","text":"<p><code>&lt;T extends Number&gt;</code> signifie T doit \u00eatre Number ou une sous-classe.</p> <pre><code>class Stats&lt;T extends Number&gt; {\n    T num;\n    Stats(T num) { this.num = num; }\n}\n</code></pre> <p></p>"},{"location":"fr/module-04/generics/#1852-bounds-multiples","title":"18.5.2 Bounds Multiples","text":"<p>Syntaxe: <code>T extends Class &amp; Interface1 &amp; Interface2 ...</code> La classe doit appara\u00eetre en premier.</p> <pre><code>class C&lt;T extends Number &amp; Comparable&lt;T&gt;&gt; { }\n</code></pre> <p></p>"},{"location":"fr/module-04/generics/#1853-wildcard-extends-super","title":"18.5.3 Wildcard: <code>?</code>, <code>? extends</code>, <code>? super</code>","text":""},{"location":"fr/module-04/generics/#18531-wildcard-non-limitee","title":"18.5.3.1 Wildcard Non Limit\u00e9e <code>?</code>","text":"<p>\u00c0 utiliser quand on veut accepter une liste de type inconnu:</p> <pre><code>void printAll(List&lt;?&gt; list) { ... }\n</code></pre> <p></p>"},{"location":"fr/module-04/generics/#18532-wildcard-avec-upper-bound-extends","title":"18.5.3.2 Wildcard avec Upper Bound <code>? extends</code>","text":"<pre><code>List&lt;? extends Number&gt; nums = List.of(1, 2, 3);\n\nNumber n = nums.get(0);   // OK\n// nums.add(5);           // \u274c on ne peut pas ajouter: type safety\n</code></pre> <p>Tu ne peux pas ajouter des \u00e9l\u00e9ments (sauf null) \u00e0 <code>? extends</code> parce que tu ne connais pas le sous-type exact.</p> <p></p>"},{"location":"fr/module-04/generics/#18533-wildcard-avec-lower-bound-super","title":"18.5.3.3 Wildcard avec Lower Bound <code>? super</code>","text":"<p><code>&lt;? super Integer&gt;</code> signifie le type doit \u00eatre Integer ou une superclasse de Integer.</p> <pre><code>List&lt;? super Integer&gt; list = new ArrayList&lt;Number&gt;();\nlist.add(10);    // OK\n\nObject o = list.get(0); // retourne Object (supertype commun minimal)\n</code></pre> <p>IMPORTANT</p> <p><code>super</code> accepte l\u2019insertion</p> <p><code>extends</code> accepte l\u2019extraction.</p> <p></p>"},{"location":"fr/module-04/generics/#186-generics-et-heritage","title":"18.6 Generics et H\u00e9ritage","text":"<p>I generics ne participent PAS \u00e0 l\u2019h\u00e9ritage. Un <code>List&lt;String&gt;</code> n\u2019est pas un sous-type de <code>List&lt;Object&gt;</code>; les types param\u00e9tr\u00e9s sont invariants.</p> <pre><code>List&lt;String&gt; ls = new ArrayList&lt;&gt;();\nList&lt;Object&gt; lo = ls;      // \u274c erreur de compilation\n</code></pre> <p>Au contraire:</p> <pre><code>List&lt;? extends Object&gt; ok = ls;   // fonctionne\n</code></pre> <p></p>"},{"location":"fr/module-04/generics/#187-type-inference-operateur-diamond","title":"18.7 Type Inference (Op\u00e9rateur Diamond)","text":"<pre><code>Map&lt;String, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();\n</code></pre> <p>Le compilateur d\u00e9duit les arguments g\u00e9n\u00e9riques \u00e0 partir de l\u2019affectation.</p> <p></p>"},{"location":"fr/module-04/generics/#188-raw-types-compatibilite-legacy","title":"18.8 Raw Types (Compatibilit\u00e9 Legacy)","text":"<p>Un raw type d\u00e9sactive les generics, r\u00e9introduisant des comportements non s\u00fbrs.</p> <pre><code>List raw = new ArrayList();\nraw.add(\"x\");\nraw.add(10);   // permis, mais non s\u00fbr\n</code></pre> <p>Les raw types devraient \u00eatre \u00e9vit\u00e9s.</p> <p></p>"},{"location":"fr/module-04/generics/#189-tableaux-generiques-non-autorises","title":"18.9 Tableaux G\u00e9n\u00e9riques (Non Autoris\u00e9s)","text":"<p>Tu ne peux pas cr\u00e9er des tableaux de types param\u00e9tr\u00e9s:</p> <pre><code>List&lt;String&gt;[] arr = new List&lt;String&gt;[10];   // \u274c erreur de compilation\n</code></pre> <p>Parce que les tableaux appliquent la type safety \u00e0 runtime tandis que les generics se basent seulement sur des contr\u00f4les \u00e0 compile-time.</p> <p></p>"},{"location":"fr/module-04/generics/#1810-bounded-type-inference","title":"18.10 Bounded Type Inference","text":"<pre><code>static &lt;T extends Number&gt; T identity(T x) { return x; }\n\nint v = identity(10);   // OK\n// String s = identity(\"x\"); // \u274c n\u2019est pas un Number\n</code></pre>"},{"location":"fr/module-04/generics/#1811-wildcard-vs-parametres-de-type","title":"18.11 Wildcard vs Param\u00e8tres de Type","text":"<p>Utilise les wildcards quand tu as besoin de flexibilit\u00e9 dans les param\u00e8tres. Utilise les param\u00e8tres de type quand la m\u00e9thode doit retourner ou maintenir des informations de type.</p> <ul> <li>Exemple \u2014 wildcard trop faible:</li> </ul> <pre><code>List&lt;?&gt; copy(List&lt;?&gt; list) {\n   return list;  // perd des informations de type\n}\n</code></pre> <p>Mieux:</p> <pre><code>&lt;T&gt; List&lt;T&gt; copy(List&lt;T&gt; list) {\n    return list;\n}\n</code></pre> <p></p>"},{"location":"fr/module-04/generics/#1812-regle-pecs-producer-extends-consumer-super","title":"18.12 R\u00e8gle PECS (Producer Extends, Consumer Super)","text":"<p>Utilise ? extends quand le param\u00e8tre produit des valeurs. Utilise ? super quand le param\u00e8tre consomme des valeurs.</p> <pre><code>List&lt;? extends Number&gt; listExtends = List.of(1, 2, 3);\nList&lt;? super Integer&gt; listSuper = new ArrayList&lt;Number&gt;();\n\n// ? extends \u2192 lecture s\u00fbre\nNumber n = listExtends.get(0);\n\n// ? super \u2192 \u00e9criture s\u00fbre\nlistSuper.add(10);\n</code></pre> <p></p>"},{"location":"fr/module-04/generics/#1813-pieges-communs","title":"18.13 Pi\u00e8ges Communs","text":"<ul> <li>Trier des listes avec wildcard: <code>List&lt;? extends Number&gt;</code> ne peut pas accepter d\u2019insertions.</li> <li>Mal comprendre que <code>List&lt;Object&gt;</code> N\u2019EST PAS un supertype de List. <li>Oublier que les tableaux g\u00e9n\u00e9riques sont ill\u00e9gaux.</li> <li>Penser que les types g\u00e9n\u00e9riques sont pr\u00e9serv\u00e9s \u00e0 runtime (ils sont effac\u00e9s).</li> <li>Essayer de surcharger des m\u00e9thodes en utilisant seulement des param\u00e8tres de type diff\u00e9rents.</li>"},{"location":"fr/module-04/generics/#1814-tableau-recapitulatif-des-wildcards","title":"18.14 Tableau R\u00e9capitulatif des Wildcards","text":"Syntaxe Signification <code>?</code> type inconnu (lecture seule sauf m\u00e9thodes Object) <code>? extends T</code> lire T en s\u00e9curit\u00e9, on ne peut pas ajouter (sauf null) <code>? super T</code> on peut ajouter T, la lecture retourne Object"},{"location":"fr/module-04/generics/#1815-recapitulatif-des-concepts","title":"18.15 R\u00e9capitulatif des Concepts","text":"<pre><code>Generics = type safety \u00e0 compile-time\nBounds = limitent les types l\u00e9gaux\nWildcard = flexibilit\u00e9 dans les param\u00e8tres\nType Inference = le compilateur d\u00e9duit les types\nType Erasure = les generics disparaissent \u00e0 runtime\nBridge Methods = maintiennent le polymorphisme\n</code></pre>"},{"location":"fr/module-04/generics/#1816-exemple-complet","title":"18.16 Exemple Complet","text":"<pre><code>class Repository&lt;T extends Number&gt; {\n    private final List&lt;T&gt; store = new ArrayList&lt;&gt;();\n\n    void add(T value) { store.add(value); }\n\n    T first() { return store.isEmpty() ? null : store.get(0); }\n\n    // m\u00e9thode g\u00e9n\u00e9rique avec wildcard\n    static double sum(List&lt;? extends Number&gt; list) {\n        double total = 0;\n        for (Number n : list) total += n.doubleValue();\n        return total;\n    }\n}\n</code></pre>"},{"location":"fr/module-04/inheritance/","title":"16. H\u00e9ritage en Java","text":""},{"location":"fr/module-04/inheritance/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>16.1 D\u00e9finition G\u00e9n\u00e9rale de l\u2019H\u00e9ritage</li> <li>16.2 H\u00e9ritage Simple et java.lang.Object</li> <li>16.3 H\u00e9ritage Transitif</li> <li>16.4 Ce Qui Est H\u00e9rit\u00e9, Bref Rappel</li> <li>16.5 Modificateurs de Classe qui Influencent l\u2019H\u00e9ritage</li> <li>16.6 R\u00e9f\u00e9rences this et super<ul> <li>16.6.1 La R\u00e9f\u00e9rence this</li> <li>16.6.2 La R\u00e9f\u00e9rence super</li> </ul> </li> <li>16.7 D\u00e9clarer des Constructeurs dans une cha\u00eene h\u00e9r\u00e9ditaire</li> <li>16.8 Constructeur no-arg par D\u00e9faut</li> <li>16.9 Utiliser this et Constructor Overloading</li> <li>16.10 Appeler le Constructeur du Parent en utilisant super</li> <li>16.11 Conseils et Pi\u00e8ges sur le Constructeur par D\u00e9faut</li> <li>16.12 super se R\u00e9f\u00e8re Toujours au Parent le plus direct</li> <li>16.13 H\u00e9riter des Membres<ul> <li>16.13.1 Method Overriding<ul> <li>16.13.1.1 D\u00e9finition et R\u00f4le dans l\u2019H\u00e9ritage</li> <li>16.13.1.2 Utiliser super pour appeler l\u2019Impl\u00e9mentation du Parent</li> <li>16.13.1.3 R\u00e8gles de Overriding Instance Methods</li> <li>16.13.1.4 Masquer Static Methods Method Hiding</li> </ul> </li> <li>16.13.2 Abstract Classes<ul> <li>16.13.2.1 D\u00e9finition et But</li> <li>16.13.2.2 R\u00e8gles pour les Abstract Classes</li> </ul> </li> <li>16.13.3 Cr\u00e9er des Objets Immutables<ul> <li>16.13.3.1 Qu\u2019est-ce qu\u2019un Objet Immutable</li> <li>16.13.3.2 Lignes Directrices pour Concevoir des Classes Immutable</li> </ul> </li> </ul> </li> </ul> <p>L'<code>Inheritance</code> (H\u00e9ritage) est l\u2019un des piliers fondamentaux de l'Object-Oriented Programming.</p> <p>Elle permet \u00e0 une classe <code>fille</code> ( child ), la subclass, d\u2019acqu\u00e9rir l\u2019\u00e9tat et le comportement d\u2019une autre classe <code>g\u00e9nitrice</code> ( parent ), la superclass, en cr\u00e9ant des relations hi\u00e9rarchiques qui promeuvent la r\u00e9utilisation du code, la sp\u00e9cialisation et le polymorphisme.</p> <p></p>"},{"location":"fr/module-04/inheritance/#161-definition-generale-de-lheritage","title":"16.1 D\u00e9finition G\u00e9n\u00e9rale de l\u2019H\u00e9ritage","text":"<p>L\u2019h\u00e9ritage permet \u00e0 une classe d\u2019en \u00e9tendre une autre, en obtenant automatiquement ses <code>attributs</code> et ses <code>m\u00e9thodes</code> accessibles.</p> <p>La classe qui \u00e9tend peut ajouter de nouvelles fonctionnalit\u00e9s ou red\u00e9finir (faire <code>override</code>) les comportements existants, en cr\u00e9ant des versions plus sp\u00e9cialis\u00e9es de sa propre classe parent.</p> <p>Note</p> <p>L\u2019H\u00e9ritage exprime une relation \u201cis-a\u201d (est-un) : un Chien is a (est-un) Animal.</p> <p></p>"},{"location":"fr/module-04/inheritance/#162-heritage-simple-et-javalangobject","title":"16.2 H\u00e9ritage Simple et java.lang.Object","text":"<p>Java supporte la single inheritance, ce qui signifie que chaque classe peut \u00e9tendre une seule superclasse directe.</p> <p>Toutes les classes h\u00e9ritent en derni\u00e8re analyse de <code>java.lang.Object</code>, qui se trouve au sommet de la hi\u00e9rarchie.</p> <p>Cela garantit que tous les objets Java partagent un comportement minimal commun (par exemple les m\u00e9thodes <code>toString()</code>, <code>equals()</code>, <code>hashCode()</code>).</p> <pre><code>class Animal { }\nclass Dog extends Animal { }\n\n// All classes implicitly extend Object\nSystem.out.println(new Dog() instanceof Object); // true\n</code></pre> <p></p>"},{"location":"fr/module-04/inheritance/#163-heritage-transitif","title":"16.3 H\u00e9ritage Transitif","text":"<p>L\u2019<code>Inheritance</code> est transitif.</p> <p>Si la classe <code>C</code> \u00e9tend <code>B</code> et <code>B</code> \u00e9tend <code>A</code>, alors <code>C</code> h\u00e9rite effectivement des membres accessibles \u00e0 la fois de <code>B</code> et de <code>A</code>.</p> <pre><code>class A { }\nclass B extends A { }\nclass C extends B { } // C inherits from both A and B\n</code></pre> <p></p>"},{"location":"fr/module-04/inheritance/#164-ce-qui-est-herite-bref-promemoria","title":"16.4 Ce Qui Est H\u00e9rit\u00e9, Bref Promemoria","text":"<p>Une subclass h\u00e9rite de tous les membres accessibles de la classe g\u00e9nitrice.</p> <p>Cependant, sp\u00e9cifiquement, cela d\u00e9pend des <code>access modifiers</code>.</p> <ul> <li>public \u2192 toujours h\u00e9rit\u00e9</li> <li>protected \u2192 h\u00e9rit\u00e9 si accessible via r\u00e8gles de package ou subclass</li> <li>default (package-private) \u2192 h\u00e9rit\u00e9 seulement dans le m\u00eame package</li> <li>private \u2192 NON h\u00e9rit\u00e9</li> </ul> <p>Note</p> <p>( Faire r\u00e9f\u00e9rence au Paragraphe \"Access Modifiers\" dans le Chapitre: Briques de base du langage Java )</p> <p></p>"},{"location":"fr/module-04/inheritance/#165-modificateurs-de-classe-qui-influencent-lheritage","title":"16.5 Modificateurs de Classe qui influencent l\u2019H\u00e9ritage","text":"<p>Certains modificateurs au niveau de la classe d\u00e9terminent si une classe peut \u00eatre \u00e9tendue.</p> Modifier Signification Effet sur l\u2019H\u00e9ritage <code>final</code> La classe ne peut pas \u00eatre \u00e9tendue Inheritance STOP <code>abstract</code> La classe ne peut pas \u00eatre instanci\u00e9e Doit \u00eatre \u00e9tendue <code>sealed</code> Permet seulement une liste fixe de subclass Restreint l\u2019inheritance <code>non-sealed</code> Subclass d\u2019une sealed class qui rouvre l\u2019inheritance Inheritance permis <code>static</code> S\u2019applique seulement aux nested classes Se comporte comme une top-level class \u00e0 l\u2019int\u00e9rieur de sa classe conteneur <p>Note</p> <p>Une classe <code>static</code> en Java peut exister seulement comme static nested class.</p> <p></p>"},{"location":"fr/module-04/inheritance/#166-references-this-et-super","title":"16.6 R\u00e9f\u00e9rences <code>this</code> et <code>super</code>","text":""},{"location":"fr/module-04/inheritance/#1661-la-reference-this","title":"16.6.1 La R\u00e9f\u00e9rence <code>this</code>","text":"<p>La r\u00e9f\u00e9rence <code>this</code> se r\u00e9f\u00e8re \u00e0 l\u2019instance courante de l\u2019objet et permet de lever l\u2019ambigu\u00eft\u00e9 d\u2019acc\u00e8s aux membres courants et h\u00e9rit\u00e9s.</p> <p>Java utilise une r\u00e8gle de granular scope: - Si une variable de m\u00e9thode/locale a le m\u00eame nom qu\u2019un <code>instance field</code>, celle locale \u201cmasque\u201d l'attribut d\u2019instance. - Il est n\u00e9cessaire d\u2019utiliser <code>this.fieldName</code> pour acc\u00e9der donc \u00e0 l\u2019attribut d\u2019instance.</p> <pre><code>public class Person {\n    String name;\n\n    public Person(String name) {\n        this.name = name;\n    }\n}\n</code></pre> <p>Si les noms diff\u00e8rent, <code>this</code> est optionnel.</p> <pre><code>public class Person {\n    String name;\n\n    public Person(String n) {\n        name = n;\n    }\n}\n</code></pre> <p>Warning</p> <p><code>this</code> NE peut PAS \u00eatre utilis\u00e9 \u00e0 l\u2019int\u00e9rieur de m\u00e9thodes statiques parce que, dans ce contexte, aucune instance n\u2019existe.</p> <p></p>"},{"location":"fr/module-04/inheritance/#1662-la-reference-super","title":"16.6.2 La R\u00e9f\u00e9rence <code>super</code>","text":"<p>La r\u00e9f\u00e9rence <code>super</code> donne acc\u00e8s aux membres de la classe g\u00e9nitrice (parent) directe.</p> <p>Utile quand: - Le parent (genitore) et le child (figlio) d\u00e9finissent un attribut/m\u00e9thode avec le m\u00eame nom; voir section: H\u00e9riter des Membres - Parent et child d\u00e9finissent un attribut avec le m\u00eame nom \u2192 <code>variable hiding</code> (deux copies) - Parent et child d\u00e9finissent une m\u00e9thode avec la m\u00eame signature \u2192 <code>method overriding</code> - On veut appeler explicitement l\u2019impl\u00e9mentation h\u00e9rit\u00e9e</p> <pre><code>class Parent { int value = 10; }\n\nclass Child extends Parent {\n    int value = 20;\n\n    void printBoth() {\n        System.out.println(value);      // child value\n        System.out.println(super.value); // parent value\n    }\n}\n</code></pre> <p>Note</p> <p><code>super</code> NE peut PAS \u00eatre utilis\u00e9 dans des contextes statiques.</p> <p></p>"},{"location":"fr/module-04/inheritance/#167-declarer-des-constructeurs-dans-une-chaine-hereditaire","title":"16.7 D\u00e9clarer des Constructeurs dans une cha\u00eene h\u00e9r\u00e9ditaire","text":"<p>Un <code>constructeur</code> initialise un objet nouvellement cr\u00e9\u00e9.</p> <p>Les constructeurs ne sont jamais h\u00e9rit\u00e9s, mais chaque constructeur de subclass doit s\u2019assurer que la classe parent soit initialis\u00e9e.</p> <p>Les <code>constructeurs</code> sont des m\u00e9thodes sp\u00e9ciales avec un nom qui correspond au nom de la classe et qui ne d\u00e9clarent aucun return type.</p> <p>Une classe peut d\u00e9finir plusieurs constructeurs (constructor overloading), chacun avec une <code>signature</code> unique.</p> <p>On peut d\u00e9clarer explicitement un <code>no-arg constructor</code> ou n\u2019importe quel constructeur sp\u00e9cifique ou, si on ne le fait pas, Java cr\u00e9era implicitement un <code>default no-arg constructor</code>.</p> <p>Si on d\u00e9clare explicitement un constructeur, le compilateur Java n\u2019inclura aucun <code>default no-arg constructor</code>: cette r\u00e8gle s\u2019applique ind\u00e9pendamment \u00e0 chaque classe dans la hi\u00e9rarchie.</p> <p>Une classe parent continue d\u2019avoir son propre constructeur par d\u00e9faut \u00e0 moins qu\u2019elle n\u2019en d\u00e9finisse aussi un.</p> <p></p>"},{"location":"fr/module-04/inheritance/#168-constructeur-no-arg-par-defaut","title":"16.8 Constructeur <code>no-arg</code> par D\u00e9faut","text":"<p>Si une classe ne d\u00e9clare aucun constructeur, Java ins\u00e8re automatiquement un default no-argument constructor.</p> <p>Ce constructeur invoquera le constructeur <code>super()</code> du parent direct, implicitement: le compilateur Java ins\u00e8re implicitement un appel au no-arg constructor <code>super()</code>.</p> <pre><code>class Parent { }\n\nclass Child extends Parent {\n    // Compiler inserts:\n    // Child() { super(); }\n}\n</code></pre> <p></p>"},{"location":"fr/module-04/inheritance/#169-utiliser-this-et-constructor-overloading","title":"16.9 Utiliser <code>this()</code> et Constructor Overloading","text":"<p>this() invoque un autre constructeur dans la m\u00eame classe.</p> <p>R\u00e8gles: - Doit \u00eatre la premi\u00e8re instruction dans le constructeur - Ne peut pas \u00eatre combin\u00e9 avec <code>super()</code> - Une seule invocation \u00e0 <code>this()</code> est autoris\u00e9e dans un constructeur - Utilis\u00e9 pour centraliser l\u2019initialisation</p> <pre><code>class Car {\n    int year;\n    String model;\n\n    Car() {\n        this(2020, \"Unknown\");\n    }\n\n    Car(int year, String model) {\n        this.year = year;\n        this.model = model;\n    }\n}\n</code></pre> <p></p>"},{"location":"fr/module-04/inheritance/#1610-appeler-le-constructeur-du-parent-en-utilisant-super","title":"16.10 Appeler le Constructeur du Parent en utilisant <code>super()</code>","text":"<p>Chaque constructeur doit appeler un constructeur de la superclasse, explicitement ou implicitement.</p> <p>L\u2019appel \u00e0 <code>super()</code> doit appara\u00eetre comme premi\u00e8re instruction dans le constructeur (\u00e0 moins qu\u2019il ne soit remplac\u00e9 par <code>this()</code>).</p> <pre><code>class Parent {\n    Parent() { System.out.println(\"Parent constructor\"); }\n}\n\nclass Child extends Parent {\n    Child() {\n        super(); // optional, compiler would insert it\n        System.out.println(\"Child constructor\");\n    }\n}\n</code></pre> <p></p>"},{"location":"fr/module-04/inheritance/#1611-conseils-et-pieges-sur-le-constructeur-par-defaut","title":"16.11 Conseils et Pi\u00e8ges sur le Constructeur par D\u00e9faut","text":"<ul> <li>Si la classe parent n\u2019a pas de no-arg constructor, la classe fille DOIT invoquer le sp\u00e9cifique <code>super(args)</code> explicitement.</li> <li>Si la classe fille ne d\u00e9finit aucun constructeur, Java ne cr\u00e9e pas automatiquement un constructeur par d\u00e9faut pour celle-ci.</li> <li>Si on oublie d\u2019appeler explicitement un <code>parent constructor</code> existant, le compilateur ins\u00e8re <code>super()</code> \u2014 lequel pourrait ne pas exister.</li> </ul> <pre><code>class Parent {\n    Parent(int x) { }\n}\n\nclass Child extends Parent {\n    // ERROR \u2192 compiler inserts super(), but Parent() does not exist\n    Child() { }\n}\n</code></pre>"},{"location":"fr/module-04/inheritance/#1612-super-se-refere-toujours-au-parent-le-plus-direct","title":"16.12 <code>super()</code> se R\u00e9f\u00e8re Toujours au Parent le plus direct","text":"<p>M\u00eame dans de longues cha\u00eenes h\u00e9r\u00e9ditaires, <code>super()</code> invoque toujours (et seulement) le constructeur de la classe g\u00e9nitrice imm\u00e9diate.</p> <pre><code>class A { \n    A() { System.out.println(\"A\"); } \n}\nclass B extends A { \n    B() { System.out.println(\"B\"); } \n}\nclass C extends B {\n    C() {\n        super(); // Calls B(), not A()\n        System.out.println(\"C\");\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>A\nB\nC\n</code></pre> <p></p>"},{"location":"fr/module-04/inheritance/#1613-heriter-des-membres","title":"16.13 H\u00e9riter des Membres","text":"<p>En Java, l\u2019acc\u00e8s aux champs et les appels de m\u00e9thodes statiques sont r\u00e9solus \u00e0 la compilation, tandis que les appels de m\u00e9thodes d\u2019instance sont r\u00e9solus \u00e0 l\u2019ex\u00e9cution.</p> <p>La distinction essentielle est la suivante :</p> <ul> <li>La <code>variable</code> ou la <code>m\u00e9thode statique</code> utilis\u00e9e d\u00e9pend du type d\u00e9clar\u00e9 de la r\u00e9f\u00e9rence.</li> <li>La <code>m\u00e9thode d\u2019instance</code> ex\u00e9cut\u00e9e d\u00e9pend du type r\u00e9el de l\u2019objet \u00e0 l\u2019ex\u00e9cution.</li> </ul> <p>Exemple : <code>Acc\u00e8s aux Champs</code> (Non Polymorphique)</p> <p>Les champs sont r\u00e9solus en fonction du type d\u00e9clar\u00e9 de la r\u00e9f\u00e9rence, et non du type r\u00e9el de l\u2019objet.</p> <pre><code>class Parent {\n    String name = \"Parent\";\n}\n\nclass Child extends Parent {\n    String name = \"Child\";\n}\n\nParent p = new Child();\nSystem.out.println(p.name);   // Output: Parent\n</code></pre> <p>Explication :</p> <ul> <li>La r\u00e9f\u00e9rence <code>p</code> est d\u00e9clar\u00e9e de type <code>Parent</code>.</li> <li>L\u2019acc\u00e8s aux champs est d\u00e9termin\u00e9 \u00e0 la compilation.</li> <li>Par cons\u00e9quent, <code>Parent.name</code> est utilis\u00e9, m\u00eame si l\u2019objet est un <code>Child</code>.</li> </ul> <p>Les champs ne sont pas polymorphiques.</p> <p>Exemple : <code>M\u00e9thodes Statiques</code> (Non Polymorphiques)</p> <p>Les m\u00e9thodes statiques sont \u00e9galement r\u00e9solues en utilisant le type d\u00e9clar\u00e9 de la r\u00e9f\u00e9rence.</p> <pre><code>class Parent {\n    static void print() {\n        System.out.println(\"Parent static\");\n    }\n}\n\nclass Child extends Parent {\n    static void print() {\n        System.out.println(\"Child static\");\n    }\n}\n\nParent p = new Child();\np.print();   // Output: Parent static\n</code></pre> <p>Explication :</p> <ul> <li>Les m\u00e9thodes statiques sont li\u00e9es (binding) \u00e0 la compilation.</li> <li>La m\u00e9thode choisie d\u00e9pend du type de la r\u00e9f\u00e9rence (<code>Parent</code>), et non du type r\u00e9el de l\u2019objet.</li> </ul> <p>Ce m\u00e9canisme s\u2019appelle le method hiding, et non l\u2019override.</p> <p>Exemple : <code>M\u00e9thodes d\u2019Instance</code> (Polymorphiques)</p> <p>Les m\u00e9thodes d\u2019instance sont r\u00e9solues \u00e0 l\u2019ex\u00e9cution en fonction du type r\u00e9el de l\u2019objet.</p> <pre><code>class Parent {\n    void print() {\n        System.out.println(\"Parent instance\");\n    }\n}\n\nclass Child extends Parent {\n    @Override\n    void print() {\n        System.out.println(\"Child instance\");\n    }\n}\n\nParent p = new Child();\np.print();   // Output: Child instance\n</code></pre> <p>Explication :</p> <ul> <li>Le type de la r\u00e9f\u00e9rence est <code>Parent</code>.</li> <li>L\u2019objet r\u00e9el est de type <code>Child</code>.</li> <li>Java utilise le dynamic dispatch.</li> <li>Par cons\u00e9quent, <code>Child.print()</code> est ex\u00e9cut\u00e9.</li> </ul> <p>Les m\u00e9thodes d\u2019instance sont polymorphiques.</p> <p></p>"},{"location":"fr/module-04/inheritance/#16131-method-overriding","title":"16.13.1 Method Overriding","text":"<p>Le <code>method overriding</code> est un concept fondamental de l\u2019h\u00e9ritage: il permet \u00e0 une classe fille de fournir une nouvelle impl\u00e9mentation pour une m\u00e9thode d\u00e9j\u00e0 d\u00e9finie dans une de ses classes parent.</p> <p>\u00c0 runtime, la version de la m\u00e9thode ex\u00e9cut\u00e9e d\u00e9pend du type r\u00e9el de l\u2019objet, pas du particulier <code>reference type</code>.</p> <p>Ce comportement est appel\u00e9 dynamic dispatch et c\u2019est ce qui rend possible le polymorphisme en Java.</p> <p></p>"},{"location":"fr/module-04/inheritance/#161311-definition-et-role-dans-lheritage","title":"16.13.1.1 D\u00e9finition et R\u00f4le dans l\u2019H\u00e9ritage","text":"<p>Une m\u00e9thode dans une subclass fait override d\u2019une m\u00e9thode d\u2019une de ses superclass si: - la m\u00e9thode de la superclass est <code>m\u00e9thode d\u2019instance</code> (non statique); - la m\u00e9thode de la subclass a le m\u00eame nom, la m\u00eame liste de param\u00e8tres et un return type qui est du m\u00eame type ou d\u2019un sous-type du return type dans la m\u00e9thode h\u00e9rit\u00e9e; - les deux m\u00e9thodes sont accessibles (non priv\u00e9es) et la m\u00e9thode de la subclass n\u2019est pas moins visible que celle de la superclass. - La m\u00e9thode en overriding ne peut pas d\u00e9clarer de nouvelles ou plus larges checked exceptions.</p> <p>L\u2019Overriding est utilis\u00e9 pour sp\u00e9cialiser le comportement: une subclass peut adapter ou affiner le comportement de la classe parent, tout en pouvant \u00eatre utilis\u00e9e via une r\u00e9f\u00e9rence du type parent.</p> <pre><code>class Animal {\n    void speak() {\n        System.out.println(\"Some generic animal sound\");\n    }\n}\n\nclass Dog extends Animal {\n\n    @Override\n    void speak() {\n        System.out.println(\"Woof!\");\n    }\n}\n\npublic class TestOverride {\n    public static void main(String[] args) {\n        Animal a = new Dog(); // reference type = Animal, object type = Dog\n        a.speak(); // prints \"Woof!\" (Dog implementation)\n    }\n}\n</code></pre> <p></p>"},{"location":"fr/module-04/inheritance/#161312-utiliser-super-pour-appeler-limplementation-du-parent","title":"16.13.1.2 Utiliser super pour appeler l\u2019Impl\u00e9mentation du Parent","text":"<p>Quand une subclass fait override d\u2019une m\u00e9thode, elle peut quand m\u00eame acc\u00e9der \u00e0 l\u2019impl\u00e9mentation \"originelle\" de la superclass, via la r\u00e9f\u00e9rence <code>super</code>.</p> <p>Cela est utile si on veut r\u00e9utiliser ou \u00e9tendre le comportement d\u00e9fini dans la classe parent.</p> <pre><code>class Person {\n    void introduce() {\n        System.out.println(\"I am a person.\");\n    }\n}\n\nclass Student extends Person {\n    @Override\n    void introduce() {\n        super.introduce(); // calls Person.introduce()\n        System.out.println(\"I am also a student.\");\n    }\n}\n</code></pre> <p>Si la classe parent et la classe child d\u00e9clarent toutes deux un membre (attribut ou m\u00e9thode) avec le m\u00eame nom, le child peut acc\u00e9der aux deux: - la version en overriding (default) - la version du parent via <code>super</code></p> <pre><code>class Base {\n    int value = 10;\n\n    void show() {\n        System.out.println(\"Base value = \" + value);\n    }\n}\n\nclass Derived extends Base {\n    int value = 20; // hides Base.value\n\n    @Override\n    void show() {\n        System.out.println(\"Derived value = \" + value);          // 20\n        System.out.println(\"Base value via super = \" + super.value); // 10\n    }\n}\n</code></pre> <p></p>"},{"location":"fr/module-04/inheritance/#161313-regles-de-overriding-instance-methods","title":"16.13.1.3 R\u00e8gles de Overriding (Instance Methods)","text":"<ul> <li>M\u00eame signature (signature): m\u00eame nom de m\u00e9thode, m\u00eames types et ordre des param\u00e8tres.</li> <li>return type covariant: la m\u00e9thode en overriding peut restituer (retourner) le m\u00eame type du parent, ou un subtype du return type du parent.</li> <li>Accessibilit\u00e9: la m\u00e9thode en overriding ne peut pas \u00eatre moins accessible que la m\u00e9thode originelle (par exemple, on ne peut pas passer de <code>public</code> \u00e0 <code>protected</code> ou <code>private</code>). Elle peut seulement maintenir la m\u00eame visibilit\u00e9 ou l\u2019augmenter.</li> <li>Checked exceptions: la m\u00e9thode en overriding ne peut pas d\u00e9clarer de nouvelles ou plus larges <code>checked exceptions</code> par rapport au <code>parent method</code>; elle peut en d\u00e9clarer moins, d\u00e9clarer des checked exceptions plus sp\u00e9cifiques ou, \u00e9ventuellement, les enlever compl\u00e8tement.</li> <li>Unchecked exceptions: elles peuvent \u00eatre ajout\u00e9es ou enlev\u00e9es sans restrictions.</li> <li>final methods: elles ne peuvent pas participer \u00e0 l'<code>override</code>.</li> </ul> <pre><code>class Parent {\n    Number getValue() throws Exception {\n        return 42;\n    }\n}\n\nclass Child extends Parent {\n@Override\n    // Covariant return type: Integer is a subclass of Number\n    Integer getValue() throws RuntimeException {\n        return 100;\n    }\n}\n</code></pre>"},{"location":"fr/module-04/inheritance/#161314-masquer-static-methods-method-hiding","title":"16.13.1.4 Masquer Static Methods (Method Hiding)","text":"<p>Les m\u00e9thodes statiques ne participent pas \u00e0 l'<code>overriding</code>; elles sont au contraire, \u00e9ventuellement, masqu\u00e9es (hidden).</p> <p>Si une subclass d\u00e9finit un static method avec la m\u00eame signature d\u2019un static method de la classe parent, la m\u00e9thode statique de la subclass masque celle de la classe g\u00e9nitrice.</p> <p>Si l\u2019une des m\u00e9thodes est marqu\u00e9e comme <code>static</code> et l\u2019autre non, le code ne compilera pas.</p> <p>La s\u00e9lection de la m\u00e9thode pour les m\u00e9thodes statiques arrive \u00e0 compile time et est bas\u00e9e sur le <code>reference type</code>: pas sur l\u2019<code>object type</code>.</p> <pre><code>class A {\n    static void show() {\n        System.out.println(\"A.show()\");\n    }\n}\n\nclass B extends A {\n    static void show() {\n        System.out.println(\"B.show()\");\n    }\n}\n\npublic class TestStatic {\n    public static void main(String[] args) {\n        A a = new B();\n        B b = new B();\n\n        a.show(); // A.show()  (reference type A)\n        b.show(); // B.show()  (reference type B)\n    }\n}\n</code></pre> <p>Important</p> <ul> <li>m\u00e9thodes statiques final ne peuvent pas \u00eatre <code>hidden</code> (masqu\u00e9es); m\u00e9thodes d\u2019instance d\u00e9clar\u00e9es final ne peuvent pas \u00eatre <code>overriden</code>.</li> <li>Si on essaye de les red\u00e9finir dans une subclass, le code ne compilera pas.</li> </ul> <p></p>"},{"location":"fr/module-04/inheritance/#16132-abstract-classes","title":"16.13.2 Abstract Classes","text":""},{"location":"fr/module-04/inheritance/#161321-definition-et-but","title":"16.13.2.1 D\u00e9finition et But","text":"<p>Une abstract class est une classe qui ne peut pas \u00eatre instanci\u00e9e directement et est destin\u00e9e \u00e0 \u00eatre \u00e9tendue.</p> <p>Elle peut contenir: - m\u00e9thodes abstract (d\u00e9clar\u00e9es sans body); - m\u00e9thodes concr\u00e8tes (avec impl\u00e9mentation); - attributs, constructeurs, membres statiques, et aussi static initializers.</p> <p>Les abstract classes sont utilis\u00e9es quand on veut d\u00e9finir un comportement commun (et un contrat) de base, mais laisser certains d\u00e9tails \u00e0 impl\u00e9menter aux subclasses concr\u00e8tes.</p> <p></p>"},{"location":"fr/module-04/inheritance/#161322-regles-pour-les-abstract-classes","title":"16.13.2.2 R\u00e8gles pour les Abstract Classes","text":"<ul> <li>Une classe avec au moins une m\u00e9thode abstraite doit \u00eatre d\u00e9clar\u00e9e <code>abstract</code>.</li> <li>Une <code>abstract class</code> ne peut pas \u00eatre instanci\u00e9e directement.</li> <li>Les m\u00e9thodes abstraites n\u2019ont pas de body et terminent avec un point-virgule.</li> <li>Les abstract methods ne peuvent pas \u00eatre <code>final</code>, <code>static</code> ou <code>private</code>, parce qu\u2019elles doivent \u00eatre red\u00e9finissables <code>overridable</code>.</li> <li>La premi\u00e8re subclass concr\u00e8te (non-abstract) dans la hi\u00e9rarchie, doit impl\u00e9menter tous les <code>abstract methods</code> h\u00e9rit\u00e9s, sinon elle doit \u00eatre d\u00e9clar\u00e9e elle aussi <code>abstract</code>.</li> </ul> <pre><code>abstract class Shape {\n\n    abstract double area(); // must be implemented by concrete subclasses\n\n    void describe() {\n        System.out.println(\"I am a shape.\");\n    }\n\n    Shape() {\n        System.out.println(\"Shape constructor\");\n    }\n}\n\nclass Circle extends Shape {\n    private final double radius;\n\n    Circle(double radius) {\n        this.radius = radius;\n    }\n\n    @Override\n    double area() {\n        return Math.PI * radius * radius;\n    }\n}\n</code></pre> <p>Note</p> <ul> <li>Bien qu\u2019une <code>abstract class</code> ne puisse pas \u00eatre instanci\u00e9e, ses constructeurs sont quand m\u00eame appel\u00e9s quand on cr\u00e9e des instances de classes filles concr\u00e8tes.</li> <li>Le flux des instanciations, dans la <code>cha\u00eene h\u00e9r\u00e9ditaire</code>, part toujours du sommet de la hi\u00e9rarchie et se d\u00e9place vers le bas.</li> </ul> <p></p>"},{"location":"fr/module-04/inheritance/#16133-creer-des-objets-immutables","title":"16.13.3 Cr\u00e9er des Objets Immutables","text":""},{"location":"fr/module-04/inheritance/#161331-quest-ce-quun-objet-immutable","title":"16.13.3.1 Qu\u2019est-ce qu\u2019un Objet <code>Immutable</code>","text":"<p>Un objet est immutable si, apr\u00e8s qu\u2019il a \u00e9t\u00e9 cr\u00e9\u00e9, son \u00e9tat ne peut pas changer.</p> <p>Tous les attributs qui repr\u00e9sentent son \u00e9tat, restent constants pour l'ensemble du cycle de vie de cet objet.</p> <p>Les <code>immutable objects</code> sont simples \u00e0 comprendre, intrins\u00e8quement <code>thread safe</code> (si con\u00e7us correctement), et largement utilis\u00e9s dans la Java Standard Library (par exemple <code>String</code>, wrapper classes comme <code>Integer</code>, et beaucoup de classes dans <code>java.time</code>).</p> <p></p>"},{"location":"fr/module-04/inheritance/#161332-lignes-directrices-pour-concevoir-des-classes-immutable","title":"16.13.3.2 Lignes Directrices pour Concevoir des Classes Immutable","text":"<ul> <li>D\u00e9clarer une classe final afin qu\u2019elle ne puisse pas \u00eatre \u00e9tendue (ou bien rendre tous les constructeurs priv\u00e9s et fournir des factory methods prot\u00e9g\u00e9s).</li> <li>Rendre tous les attributs qui repr\u00e9sentent son \u00e9tat private et final.</li> <li>Ne fournir aucune m\u00e9thode <code>mutator</code> (setter).</li> <li>Initialiser tous les attributs dans les constructeurs (ou dans les factory methods) et ne jamais les exposer de fa\u00e7on <code>mutable</code>.</li> <li>Si un attribut se r\u00e9f\u00e8re \u00e0 un objet mutable, faire des defensive copies (copies d\u00e9fensives) en phase de construction et quand on le restitue via des <code>getters</code>.</li> </ul> <pre><code>import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic final class Person {\n    private final String name; // String is immutable\n    private final int age;\n    private final List&lt;String&gt; hobbies; // List is mutable, we must protect it\n\n    public Person(String name, int age, List&lt;String&gt; hobbies) {\n        this.name = name;\n        this.age = age;\n        // Defensive copy on input\n        this.hobbies = new ArrayList&lt;&gt;(hobbies);\n    }\n\n    public String getName() {\n        return name; // safe (String is immutable)\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public List&lt;String&gt; getHobbies() {\n        // Defensive copy or unmodifiable view on output\n        return Collections.unmodifiableList(hobbies);\n    }\n}\n</code></pre> <p>Dans cet exemple: - <code>Person</code> est final: elle ne peut pas \u00eatre \u00e9tendue et son comportement ne peut pas \u00eatre alt\u00e9r\u00e9 via <code>inheritance</code>. - Tous les attributs sont <code>private</code> et <code>final</code>, d\u00e9finis une seule fois dans le constructeur. - La liste des <code>hobbies</code> est copi\u00e9e d\u00e9fensivement dans la phase de construction et wrapp\u00e9e comme <code>unmodifiable</code> (non modifiable) dans la <code>m\u00e9thode getter</code>, afin qu\u2019aucun code externe ne puisse modifier l\u2019\u00e9tat interne.</p> <p>Concevoir des <code>immutable objects</code> est particuli\u00e8rement important dans des contextes multithread et quand on passe des objets \u00e0 travers les diff\u00e9rents layers d\u2019une application.</p>"},{"location":"fr/module-04/methods-attributes/","title":"14. M\u00e9thodes, Attributs et Variables","text":""},{"location":"fr/module-04/methods-attributes/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>14.1 M\u00e9thodes<ul> <li>14.1.1 Composants obligatoires d\u2019une m\u00e9thode<ul> <li>14.1.1.1 Modificateurs d\u2019acc\u00e8s</li> <li>14.1.1.2 Type de retour</li> <li>14.1.1.3 Nom de la m\u00e9thode</li> <li>14.1.1.4 Signature de la m\u00e9thode</li> <li>14.1.1.5 Corps de la m\u00e9thode</li> </ul> </li> <li>14.1.2 Modificateurs optionnels</li> <li>14.1.3 D\u00e9clarer des m\u00e9thodes</li> </ul> </li> <li>14.2 Java est un langage Pass-by-Value</li> <li>14.3 Surcharge des m\u00e9thodes<ul> <li>14.3.1 Appeler des m\u00e9thodes surcharg\u00e9es<ul> <li>14.3.1.1 La correspondance exacte l\u2019emporte</li> <li>14.3.1.2 S\u2019il n\u2019existe pas de correspondance exacte Java choisit le type compatible le plus sp\u00e9cifique</li> <li>14.3.1.3 L\u2019\u00e9largissement des primitifs bat le boxing</li> <li>14.3.1.4 Le boxing bat les varargs</li> <li>14.3.1.5 Pour les r\u00e9f\u00e9rences Java choisit le type de r\u00e9f\u00e9rence le plus sp\u00e9cifique</li> <li>14.3.1.6 Lorsqu\u2019il n\u2019y a pas de plus sp\u00e9cifique non ambigu l\u2019appel est une erreur de compilation</li> <li>14.3.1.7 Surcharges mixtes primitifs + wrappers</li> <li>14.3.1.8 Quand les primitifs se m\u00e9langent avec les types de r\u00e9f\u00e9rence</li> <li>14.3.1.9 Quand Object gagne</li> <li>14.3.1.10 Tableau r\u00e9capitulatif de la r\u00e9solution de surcharge</li> </ul> </li> </ul> </li> <li>14.4 Variables locales et d\u2019instance<ul> <li>14.4.1 Variables d\u2019instance</li> <li>14.4.2 Variables locales<ul> <li>14.4.2.1 Variables locales effectivement final</li> <li>14.4.2.2 Param\u00e8tres comme effectivement final</li> </ul> </li> </ul> </li> <li>14.5 Varargs listes d\u2019arguments \u00e0 longueur variable</li> <li>14.6 M\u00e9thodes statiques, variables statiques et initialiseurs statiques<ul> <li>14.6.1 Variables statiques (variables de classe)</li> <li>14.6.2 M\u00e9thodes statiques</li> <li>14.6.3 Blocs d\u2019initialisation statique</li> <li>14.6.4 Ordre d\u2019initialisation statique vs instance</li> <li>14.6.5 Acc\u00e8s aux membres statiques<ul> <li>14.6.5.1 Utiliser le nom de la classe</li> <li>14.6.5.2 Via une r\u00e9f\u00e9rence d\u2019instance</li> </ul> </li> <li>14.6.6 Statique et h\u00e9ritage</li> <li>14.6.7 Pi\u00e8ges courants</li> </ul> </li> </ul> <p>Ce chapitre introduit des concepts fondamentaux de la Programmation Orient\u00e9e Objet (OOP) en Java, en commen\u00e7ant par les m\u00e9thodes, le passage des param\u00e8tres, la surcharge, les variables locales vs. d\u2019instance et les varargs.</p> <p></p>"},{"location":"fr/module-04/methods-attributes/#141-methodes","title":"14.1 M\u00e9thodes","text":"<p>Les <code>m\u00e9thodes</code> repr\u00e9sentent les op\u00e9rations/comportements qui peuvent \u00eatre effectu\u00e9s par un type de donn\u00e9es particulier (une classe).</p> <p>Elles d\u00e9crivent ce que l\u2019objet peut faire et comment il interagit avec son \u00e9tat interne et le monde ext\u00e9rieur.</p> <p>Une <code>d\u00e9claration de m\u00e9thode</code> est compos\u00e9e de composants obligatoires et optionnels.</p> <p></p>"},{"location":"fr/module-04/methods-attributes/#1411-composants-obligatoires-dune-methode","title":"14.1.1 Composants obligatoires d\u2019une m\u00e9thode","text":""},{"location":"fr/module-04/methods-attributes/#14111-modificateurs-dacces","title":"14.1.1.1 Modificateurs d\u2019acc\u00e8s","text":"<p>Les <code>modificateurs d\u2019acc\u00e8s</code> contr\u00f4lent la visibilit\u00e9, pas le comportement. ( Se r\u00e9f\u00e9rer au paragraphe \"Access Modifiers\" dans le chapitre : 2. Basic Language Java Building Blocks )</p> <p></p>"},{"location":"fr/module-04/methods-attributes/#14112-type-de-retour","title":"14.1.1.2 Type de retour","text":"<p>Appara\u00eet imm\u00e9diatement avant le nom de la m\u00e9thode.</p> <ul> <li>Si la m\u00e9thode retourne une valeur \u2192 le type de retour sp\u00e9cifie le type de la valeur.</li> <li>Si la m\u00e9thode ne retourne pas de valeur \u2192 le mot-cl\u00e9 <code>void</code> doit \u00eatre utilis\u00e9.</li> <li>Une m\u00e9thode avec un type de retour non void doit contenir au moins une instruction <code>return valeur;</code>.</li> <li>Une m\u00e9thode <code>void</code> peut :</li> <li> <ul> <li>omettre une instruction return</li> </ul> </li> <li> <ul> <li>inclure <code>return;</code> (sans aucune valeur)</li> </ul> </li> </ul> <p></p>"},{"location":"fr/module-04/methods-attributes/#14113-nom-de-la-methode","title":"14.1.1.3 Nom de la m\u00e9thode","text":"<p>Suit les m\u00eames r\u00e8gles que les identificateurs ( Se r\u00e9f\u00e9rer au chapitre : 3. Java Naming Rules ).</p> <p></p>"},{"location":"fr/module-04/methods-attributes/#14114-signature-de-la-methode","title":"14.1.1.4 Signature de la m\u00e9thode","text":"<p>La signature de la m\u00e9thode en Java inclut :</p> <ul> <li>le nom de la m\u00e9thode</li> <li>la liste des types de param\u00e8tres (types + ordre)</li> </ul> <p>Note</p> <p>Les noms des param\u00e8tres NE font PAS partie de la signature, seuls les types et l\u2019ordre comptent.</p> <ul> <li>Exemple de signatures distinctes :</li> </ul> <pre><code>void process(int x)\nvoid process(int x, int y)\nvoid process(int x, String y)\n</code></pre> <ul> <li>Exemple de m\u00eame signature (surcharge ill\u00e9gale) :</li> </ul> <pre><code>// \u274c m\u00eame signature : seuls les noms des param\u00e8tres diff\u00e8rent\nvoid m(int a)\nvoid m(int b)\n</code></pre> <p></p>"},{"location":"fr/module-04/methods-attributes/#14115-corps-de-la-methode","title":"14.1.1.5 Corps de la m\u00e9thode","text":"<p>Un bloc <code>{ }</code> contenant z\u00e9ro ou plusieurs instructions. Si la m\u00e9thode est <code>abstract</code>, le corps doit \u00eatre omis.</p> <p></p>"},{"location":"fr/module-04/methods-attributes/#1412-modificateurs-optionnels","title":"14.1.2 Modificateurs optionnels","text":"<p>Les modificateurs optionnels de m\u00e9thode incluent :</p> <ul> <li><code>static</code></li> <li><code>abstract</code></li> <li><code>final</code></li> <li><code>default</code> (m\u00e9thodes d\u2019interface)</li> <li><code>synchronized</code></li> <li><code>native</code></li> <li><code>strictfp</code></li> </ul> <p>R\u00e8gles :</p> <ul> <li>Les modificateurs optionnels peuvent appara\u00eetre dans n\u2019importe quel ordre.</li> <li> <p>Tous les modificateurs doivent appara\u00eetre avant le type de retour.</p> </li> <li> <p>Exemple :</p> </li> </ul> <pre><code>public static final int compute() {\n    return 10;\n}\n</code></pre> <p></p>"},{"location":"fr/module-04/methods-attributes/#1413-declarer-des-methodes","title":"14.1.3 D\u00e9clarer des m\u00e9thodes","text":"<pre><code>public final synchronized String formatValue(int x, double y) throws IOException {\n    return \"Result: \" + x + \", \" + y;\n}\n</code></pre> <p>D\u00e9composition :</p> Partie Signification public modificateur d\u2019acc\u00e8s final ne peut pas \u00eatre red\u00e9finie synchronized modificateur de contr\u00f4le des threads String type de retour formatValue nom de la m\u00e9thode (int x, double y) liste des param\u00e8tres throws IOException liste des exceptions method body impl\u00e9mentation <p></p>"},{"location":"fr/module-04/methods-attributes/#142-java-est-un-langage-pass-by-value","title":"14.2 Java est un langage \u00ab Pass-by-Value \u00bb","text":"<p>Java utilise uniquement le pass-by-value, sans exception.</p> <p>Cela signifie :</p> <ul> <li>Pour les types primitifs \u2192 la m\u00e9thode re\u00e7oit une copie de la valeur.</li> <li>Pour les types r\u00e9f\u00e9rence \u2192 la m\u00e9thode re\u00e7oit une copie de la r\u00e9f\u00e9rence, ce qui signifie :</li> <li> <ul> <li>la r\u00e9f\u00e9rence elle-m\u00eame ne peut pas \u00eatre modifi\u00e9e par la m\u00e9thode</li> </ul> </li> <li> <ul> <li>l\u2019objet peut \u00eatre modifi\u00e9 via cette r\u00e9f\u00e9rence</li> </ul> </li> <li> <p>Exemple :</p> </li> </ul> <pre><code>void modify(int a, StringBuilder b) {\n    a = 50;           // modification de la *copie* \u2192 aucun effet \u00e0 l\u2019ext\u00e9rieur\n    b.append(\"!\");    // modification de l\u2019*objet* \u2192 visible \u00e0 l\u2019ext\u00e9rieur\n}\n</code></pre> <pre><code>public static void main(String[] args) {\n\n    int num1 = 11;\n    methodTryModif(num1);\n    System.out.println(num1);\n\n}\n\npublic static void methodTryModif(int num1){    \n    num1 = 10;  // cette nouvelle affectation concerne uniquement le param\u00e8tre du m\u00e9thode qui, accidentellement, porte le m\u00eame nom que la variable externe.\n}\n</code></pre> <p></p>"},{"location":"fr/module-04/methods-attributes/#143-surcharge-des-methodes","title":"14.3 Surcharge des m\u00e9thodes","text":"<p>La surcharge des m\u00e9thodes signifie m\u00eame nom de m\u00e9thode, signature diff\u00e9rente.</p> <p>Deux m\u00e9thodes sont consid\u00e9r\u00e9es comme surcharg\u00e9es si elles diff\u00e8rent par :</p> <ul> <li>le nombre de param\u00e8tres</li> <li>les types des param\u00e8tres</li> <li>l\u2019ordre des param\u00e8tres</li> </ul> <p>La surcharge NE d\u00e9pend PAS de :</p> <ul> <li>le type de retour</li> <li>le modificateur d\u2019acc\u00e8s</li> <li> <p>les exceptions</p> </li> <li> <p>Exemple :</p> </li> </ul> <pre><code>void print(int x)\nvoid print(double x)\nvoid print(int x, int y)\n</code></pre> <p>M\u00e9thode surcharg\u00e9e ill\u00e9gale :</p> <pre><code>// \u274c Le type de retour ne compte pas dans la surcharge\nint compute(int x)\ndouble compute(int x)\n</code></pre> <p></p>"},{"location":"fr/module-04/methods-attributes/#1431-appeler-des-methodes-surchargees","title":"14.3.1 Appeler des m\u00e9thodes surcharg\u00e9es","text":"<p>Lorsque plusieurs m\u00e9thodes surcharg\u00e9es sont disponibles, Java applique la r\u00e9solution de surcharge pour d\u00e9cider quelle m\u00e9thode appeler.</p> <p>Le compilateur s\u00e9lectionne la m\u00e9thode dont les types de param\u00e8tres sont les plus sp\u00e9cifiques et compatibles avec les arguments fournis.</p> <p>La r\u00e9solution de surcharge a lieu au moment de la compilation (contrairement \u00e0 l\u2019overriding, qui est bas\u00e9 sur l\u2019ex\u00e9cution).</p> <p>Java suit ces r\u00e8gles :</p> <p></p>"},{"location":"fr/module-04/methods-attributes/#14311-la-correspondance-exacte-lemporte","title":"14.3.1.1 La correspondance exacte l\u2019emporte","text":"<p>Si un argument correspond exactement \u00e0 un param\u00e8tre de m\u00e9thode, cette m\u00e9thode est choisie.</p> <pre><code>void call(int x)    { System.out.println(\"int\"); }\nvoid call(long x)   { System.out.println(\"long\"); }\n\ncall(5); // affiche : int (correspondance exacte pour int)\n</code></pre> <p></p>"},{"location":"fr/module-04/methods-attributes/#14312-sil-nexiste-pas-de-correspondance-exacte-java-choisit-le-type-compatible-le-plus-specifique","title":"14.3.1.2 \u2014 S\u2019il n\u2019existe pas de correspondance exacte, Java choisit le type compatible le plus sp\u00e9cifique","text":"<p>Java pr\u00e9f\u00e8re :</p> <ul> <li>l\u2019\u00e9largissement plut\u00f4t que l\u2019autoboxing</li> <li>l\u2019autoboxing plut\u00f4t que les varargs</li> <li> <p>le type de r\u00e9f\u00e9rence plus large uniquement si un type plus sp\u00e9cifique n\u2019est pas disponible</p> </li> <li> <p>Exemple avec des primitifs num\u00e9riques :</p> </li> </ul> <pre><code>void test(long x)   { System.out.println(\"long\"); }\nvoid test(float x)  { System.out.println(\"float\"); }\n\ntest(5);  // litt\u00e9ral int : peut \u00eatre \u00e9largi en long ou float\n          // mais long est plus sp\u00e9cifique que float pour les types entiers\n          // Output : long\n</code></pre> <p></p>"},{"location":"fr/module-04/methods-attributes/#14313-lelargissement-des-primitifs-bat-le-boxing","title":"14.3.1.3 \u2014 L\u2019\u00e9largissement des primitifs bat le boxing","text":"<p>Si un argument primitif peut \u00eatre soit \u00e9largi soit autobox\u00e9, Java choisit l\u2019\u00e9largissement.</p> <pre><code>void m(int x)       { System.out.println(\"int\"); }\nvoid m(Integer x)   { System.out.println(\"Integer\"); }\n\nbyte b = 10;\nm(b);               // byte \u2192 int (\u00e9largissement) l\u2019emporte\n                    // Output : int\n</code></pre> <p></p>"},{"location":"fr/module-04/methods-attributes/#14314-le-boxing-bat-les-varargs","title":"14.3.1.4 \u2014 Le boxing bat les varargs","text":"<pre><code>void show(Integer x)    { System.out.println(\"Integer\"); }\nvoid show(int... x)     { System.out.println(\"varargs\"); }\n\nshow(5);                // int \u2192 Integer (boxing) pr\u00e9f\u00e9r\u00e9\n                        // Output : Integer\n</code></pre>"},{"location":"fr/module-04/methods-attributes/#14315-pour-les-references-java-choisit-le-type-de-reference-le-plus-specifique","title":"14.3.1.5 \u2014 Pour les r\u00e9f\u00e9rences, Java choisit le type de r\u00e9f\u00e9rence le plus sp\u00e9cifique","text":"<pre><code>void ref(Object o)      { System.out.println(\"Object\"); }\nvoid ref(String s)      { System.out.println(\"String\"); }\n\nref(\"abc\");             // \"abc\" est une String \u2192 plus sp\u00e9cifique que Object\n                        // Output : String\n</code></pre> <p>Plus sp\u00e9cifique signifie plus bas dans la hi\u00e9rarchie d\u2019h\u00e9ritage.</p> <p></p>"},{"location":"fr/module-04/methods-attributes/#14316-lorsquil-ny-a-pas-de-plus-specifique-non-ambigu-lappel-est-une-erreur-de-compilation","title":"14.3.1.6 \u2014 Lorsqu\u2019il n\u2019y a pas de \u00ab plus sp\u00e9cifique \u00bb non ambigu, l\u2019appel est une erreur de compilation","text":"<p>Exemple avec des classes s\u0153urs :</p> <pre><code>void check(Number n)      { System.out.println(\"Number\"); }\nvoid check(String s)      { System.out.println(\"String\"); }\n\ncheck(null);    // String et Number acceptent null\n                // String est plus sp\u00e9cifique car c\u2019est une classe concr\u00e8te\n                // Output : String\n</code></pre> <p>Mais si deux classes non li\u00e9es entrent en concurrence :</p> <pre><code>void run(String s)   { }\nvoid run(Integer i)  { }\n\nrun(null);  // \u274c Erreur \u00e0 la compilation : appel de m\u00e9thode ambigu\n</code></pre> <p></p>"},{"location":"fr/module-04/methods-attributes/#14317-surcharges-mixtes-primitifs-wrappers","title":"14.3.1.7 \u2014 Surcharges mixtes primitifs + wrappers","text":"<p>Java \u00e9value l\u2019\u00e9largissement, le boxing et les varargs dans cet ordre :</p> <p><code>\u00e9largissement \u2192 boxing \u2192 varargs</code></p> <ul> <li>Exemple :</li> </ul> <pre><code>void mix(long x)        { System.out.println(\"long\"); }\nvoid mix(Integer x)     { System.out.println(\"Integer\"); }\nvoid mix(int... x)      { System.out.println(\"varargs\"); }\n\nshort s = 5;\nmix(s);   // short \u2192 int \u2192 long  (\u00e9largissement)\n          // boxing et varargs ignor\u00e9s\n          // Output : long\n</code></pre> <p></p>"},{"location":"fr/module-04/methods-attributes/#14318-quand-les-primitifs-se-melangent-avec-les-types-de-reference","title":"14.3.1.8 \u2014 Quand les primitifs se m\u00e9langent avec les types de r\u00e9f\u00e9rence","text":"<pre><code>void fun(Object o)     { System.out.println(\"Object\"); }\nvoid fun(int x)        { System.out.println(\"int\"); }\n\nfun(10);                // la correspondance primitive exacte l\u2019emporte\n                        // Output : int\n\nInteger i = 10;\nfun(i);                 // r\u00e9f\u00e9rence accept\u00e9e \u2192 Object\n                        // Output : Object\n</code></pre>"},{"location":"fr/module-04/methods-attributes/#14319-quand-object-gagne","title":"14.3.1.9 \u2014 Quand Object gagne","text":"<pre><code>void fun(List&lt;String&gt; o)    { System.out.println(\"O\"); }\nvoid fun(CharSequence x)    { System.out.println(\"X\"); }\nvoid fun(Object y)          { System.out.println(\"Y\"); }\n\nfun(LocalDate.now());       // Output : Y\n</code></pre>"},{"location":"fr/module-04/methods-attributes/#143110-tableau-recapitulatif-resolution-de-la-surcharge","title":"14.3.1.10 Tableau r\u00e9capitulatif (R\u00e9solution de la surcharge)","text":"Situation R\u00e8gle Correspondance exacte Toujours choisie \u00c9largissement primitif vs boxing L\u2019\u00e9largissement l\u2019emporte Boxing vs varargs Le boxing l\u2019emporte Type de r\u00e9f\u00e9rence le plus sp\u00e9cifique L\u2019emporte Types de r\u00e9f\u00e9rence non li\u00e9s Ambigu \u2192 erreur de compilation Primitif + wrapper m\u00e9lang\u00e9s \u00c9largissement \u2192 boxing \u2192 varargs"},{"location":"fr/module-04/methods-attributes/#144-variables-locales-et-dinstance","title":"14.4 Variables locales et d\u2019instance","text":""},{"location":"fr/module-04/methods-attributes/#1441-variables-dinstance","title":"14.4.1 Variables d\u2019instance","text":"<p>Les variables d\u2019instance sont :</p> <ul> <li>d\u00e9clar\u00e9es comme membres d\u2019une classe</li> <li>cr\u00e9\u00e9es lorsqu\u2019un objet est instanci\u00e9</li> <li>accessibles par toutes les m\u00e9thodes de l\u2019instance</li> </ul> <p>Modificateurs possibles pour les variables d\u2019instance :</p> <ul> <li>modificateurs d\u2019acc\u00e8s (<code>public</code>, <code>protected</code>, <code>private</code>)</li> <li><code>final</code></li> <li><code>volatile</code></li> <li> <p><code>transient</code></p> </li> <li> <p>Exemple :</p> </li> </ul> <pre><code>public class Person {\n    private String name;         // variable d\u2019instance\n    protected final int age = 0; // final signifie ne peut pas \u00eatre r\u00e9affect\u00e9e\n}\n</code></pre> <p></p>"},{"location":"fr/module-04/methods-attributes/#1442-variables-locales","title":"14.4.2 Variables locales","text":"<p>Les variables locales :</p> <ul> <li>sont d\u00e9clar\u00e9es \u00e0 l\u2019int\u00e9rieur d\u2019une m\u00e9thode, d\u2019un constructeur ou d\u2019un bloc</li> <li>n\u2019ont aucune valeur par d\u00e9faut \u2192 doivent \u00eatre explicitement initialis\u00e9es avant utilisation</li> <li> <p>seul modificateur autoris\u00e9 : final</p> </li> <li> <p>Exemple :</p> </li> </ul> <pre><code>void calculate() {\n    int x;        // d\u00e9clar\u00e9e\n    x = 10;       // doit \u00eatre initialis\u00e9e avant utilisation\n\n    final int y = 5;  // l\u00e9gal\n}\n</code></pre> <p>Deux cas particuliers :</p> <p></p>"},{"location":"fr/module-04/methods-attributes/#14421-variables-locales-effectivement-final","title":"14.4.2.1 Variables locales effectivement final","text":"<p>Une variable locale est effectivement final si elle est assign\u00e9e une seule fois, m\u00eame sans <code>final</code>.</p> <p>Les variables effectivement final peuvent \u00eatre utilis\u00e9es dans :</p> <ul> <li>expressions lambda</li> <li>classes locales/anonimes</li> </ul> <p></p>"},{"location":"fr/module-04/methods-attributes/#14422-parametres-comme-effectivement-final","title":"14.4.2.2 Param\u00e8tres comme effectivement final","text":"<p>Les param\u00e8tres de m\u00e9thode se comportent comme des variables locales et suivent les m\u00eames r\u00e8gles.</p> <p></p>"},{"location":"fr/module-04/methods-attributes/#145-varargs-listes-darguments-a-longueur-variable","title":"14.5 Varargs (Listes d\u2019arguments \u00e0 longueur variable)","text":"<p>Les varargs permettent \u00e0 une m\u00e9thode d\u2019accepter z\u00e9ro ou plusieurs param\u00e8tres du m\u00eame type.</p> <p>Syntaxe :</p> <pre><code>void printNames(String... names)\n</code></pre> <p>R\u00e8gles :</p> <ul> <li>Une m\u00e9thode peut avoir un seul param\u00e8tre varargs.</li> <li>Il doit \u00eatre le dernier param\u00e8tre dans la liste.</li> <li> <p>Les varargs sont trait\u00e9s comme un tableau \u00e0 l\u2019int\u00e9rieur de la m\u00e9thode.</p> </li> <li> <p>Exemple :</p> </li> </ul> <pre><code>void show(int x, String... values) {\n    System.out.println(values.length);\n}\n\nshow(10);                     // length = 0\nshow(10, \"A\");                // length = 1\nshow(10, \"A\", \"B\", \"C\");      // length = 3\n</code></pre> <p>Important</p> <p>Les varargs et les tableaux participent \u00e0 la surcharge des m\u00e9thodes. La r\u00e9solution de la surcharge peut devenir ambigu\u00eb.</p> <p></p>"},{"location":"fr/module-04/methods-attributes/#146-methodes-statiques-variables-statiques-et-initialiseurs-statiques","title":"14.6 M\u00e9thodes statiques, variables statiques et initialiseurs statiques","text":"<p>En Java, le mot-cl\u00e9 <code>static</code> marque des \u00e9l\u00e9ments qui appartiennent \u00e0 la classe elle-m\u00eame, et non aux instances individuelles. Cela signifie :</p> <ul> <li>Ils sont charg\u00e9s une seule fois en m\u00e9moire lorsque la classe est charg\u00e9e pour la premi\u00e8re fois par la JVM.</li> <li>Ils sont partag\u00e9s entre toutes les instances.</li> <li>Ils peuvent \u00eatre accessibles sans cr\u00e9er d\u2019objet de la classe.</li> </ul> <p>Les membres statiques sont stock\u00e9s dans la method area de la JVM (m\u00e9moire au niveau de la classe), tandis que les membres d\u2019instance vivent dans le heap.</p> <p></p>"},{"location":"fr/module-04/methods-attributes/#1461-variables-statiques-variables-de-classe","title":"14.6.1 Variables statiques (Variables de classe)","text":"<p>Une variable statique est une variable d\u00e9finie au niveau de la classe et partag\u00e9e par toutes les instances.</p> <p>Caract\u00e9ristiques :</p> <ul> <li>Cr\u00e9\u00e9es lorsque la classe est charg\u00e9e.</li> <li>Existent m\u00eame si aucune instance de la classe n\u2019est cr\u00e9\u00e9e.</li> <li>Tous les objets voient la m\u00eame valeur.</li> <li> <p>Peuvent \u00eatre marqu\u00e9es <code>final</code>, <code>volatile</code> ou <code>transient</code>.</p> </li> <li> <p>Exemple :</p> </li> </ul> <pre><code>public class Counter {\n    static int count = 0;    // partag\u00e9e par toutes les instances\n    int id;                  // variable d\u2019instance\n\n    public Counter() {\n        count++;\n        id = count;          // chaque instance obtient un id unique\n    }\n}\n</code></pre> <p></p>"},{"location":"fr/module-04/methods-attributes/#1462-methodes-statiques","title":"14.6.2 M\u00e9thodes statiques","text":"<p>Une m\u00e9thode statique appartient \u00e0 la classe, et non \u00e0 une instance d\u2019objet.</p> <p>R\u00e8gles :</p> <ul> <li>Elles peuvent \u00eatre appel\u00e9es en utilisant le nom de la classe : <code>ClassName.method()</code>.</li> <li>Elles ne peuvent pas acc\u00e9der directement aux variables ou m\u00e9thodes d\u2019instance, mais uniquement via une instance de la classe.</li> <li>Elles ne peuvent pas utiliser <code>this</code> ou <code>super</code>.</li> <li>Elles sont couramment utilis\u00e9es pour :</li> <li> <ul> <li>des m\u00e9thodes utilitaires (ex. <code>Math.sqrt()</code>)</li> </ul> </li> <li> <ul> <li>des m\u00e9thodes de fabrique</li> </ul> </li> <li> <ul> <li>des comportements globaux qui ne d\u00e9pendent pas de l\u2019\u00e9tat d\u2019instance</li> </ul> </li> <li> <p>Exemple :</p> </li> </ul> <pre><code>public class MathUtil {\n\n    static int square(int x) {        // m\u00e9thode statique\n        return x * x;\n    }\n\n    void instanceMethod() {\n        // System.out.println(count);   // OK : acc\u00e8s \u00e0 une variable statique\n        // square(5);                   // OK : m\u00e9thode statique accessible\n    }\n}\n</code></pre> <p>Erreurs courantes :</p> <pre><code>// \u274c Erreur de compilation : une m\u00e9thode d\u2019instance ne peut pas \u00eatre appel\u00e9e directement dans un contexte statique\nstatic void go() {\n    run();        // run() est une m\u00e9thode d\u2019instance !\n}\n\nvoid run() { }\n</code></pre> <p></p>"},{"location":"fr/module-04/methods-attributes/#1463-blocs-dinitialisation-statique","title":"14.6.3 Blocs d\u2019initialisation statique","text":"<p>Les blocs d\u2019initialisation statique permettent d\u2019ex\u00e9cuter du code une seule fois, lorsque la classe est charg\u00e9e.</p> <p>Syntaxe :</p> <pre><code>static {\n    // logique d\u2019initialisation\n}\n</code></pre> <p>Utilisation :</p> <ul> <li>initialisation de variables statiques complexes</li> <li>ex\u00e9cution d\u2019un setup au niveau de la classe</li> <li> <p>ex\u00e9cution de code qui doit \u00eatre ex\u00e9cut\u00e9 exactement une fois</p> </li> <li> <p>Exemple :</p> </li> </ul> <pre><code>public class Config {\n\n    static final Map&lt;String, String&gt; settings = new HashMap&lt;&gt;();\n\n    static {\n        settings.put(\"mode\", \"production\");\n        settings.put(\"version\", \"1.0\");\n        System.out.println(\"Static initializer executed\");\n    }\n}\n</code></pre> <p>Important</p> <p>Les blocs d\u2019initialisation statique s\u2019ex\u00e9cutent une seule fois, dans l\u2019ordre o\u00f9 ils apparaissent, avant <code>main()</code> et avant qu\u2019une m\u00e9thode statique ne soit appel\u00e9e.</p> <p></p>"},{"location":"fr/module-04/methods-attributes/#1464-ordre-dinitialisation-statique-vs-instance","title":"14.6.4 Ordre d\u2019initialisation (Statique vs. Instance)","text":"<p>( Se r\u00e9f\u00e9rer au chapitre : 15. Class Loading, Initialization, and Object Construction )</p> <p></p>"},{"location":"fr/module-04/methods-attributes/#1465-acces-aux-membres-statiques","title":"14.6.5 Acc\u00e8s aux membres statiques","text":""},{"location":"fr/module-04/methods-attributes/#14651-utiliser-le-nom-de-la-classe","title":"14.6.5.1 Utiliser le nom de la classe","text":"<pre><code>Math.sqrt(16);\nMyClass.staticMethod();\n</code></pre>"},{"location":"fr/module-04/methods-attributes/#14652-via-une-reference-dinstance","title":"14.6.5.2 Via une r\u00e9f\u00e9rence d\u2019instance","text":"<pre><code>MyClass obj = new MyClass();\nobj.staticMethod();\n</code></pre>"},{"location":"fr/module-04/methods-attributes/#1466-statique-et-heritage","title":"14.6.6 Statique et h\u00e9ritage","text":"<p>Les m\u00e9thodes statiques :</p> <ul> <li>peuvent \u00eatre masqu\u00e9es, pas red\u00e9finies</li> <li>le binding est \u00e0 la compilation, pas \u00e0 l\u2019ex\u00e9cution</li> <li> <p>sont accessibles selon le type de la r\u00e9f\u00e9rence, et non le type de l\u2019objet</p> </li> <li> <p>Exemple :</p> </li> </ul> <pre><code>class A {\n    static void test() { System.out.println(\"A\"); }\n}\n\nclass B extends A {\n    static void test() { System.out.println(\"B\"); }\n}\n\nA ref = new B();\nref.test();   // affiche \"A\" \u2014 binding statique !\n</code></pre> <p>Note</p> <p>R\u00e8gle cl\u00e9 : les m\u00e9thodes statiques utilisent le type de la r\u00e9f\u00e9rence, et non le type de l\u2019objet.</p> <p></p>"},{"location":"fr/module-04/methods-attributes/#1467-pieges-courants","title":"14.6.7 Pi\u00e8ges courants","text":"<ul> <li>Tenter de r\u00e9f\u00e9rencer une variable ou une m\u00e9thode d\u2019instance depuis un contexte statique.</li> <li>Supposer que les m\u00e9thodes statiques sont red\u00e9finies \u2192 elles sont masqu\u00e9es.</li> <li>Appeler une m\u00e9thode statique via une r\u00e9f\u00e9rence d\u2019instance (l\u00e9gal mais d\u00e9routant).</li> <li>Confondre l\u2019ordre d\u2019initialisation des \u00e9l\u00e9ments statiques et des \u00e9l\u00e9ments d\u2019instance.</li> <li>Oublier que les variables statiques sont partag\u00e9es entre tous les objets.</li> <li>Ignorer que les initialiseurs statiques s\u2019ex\u00e9cutent une seule fois, dans l\u2019ordre de d\u00e9claration.</li> </ul>"},{"location":"fr/module-05/functional/","title":"20. Programmation Fonctionnelle en Java","text":""},{"location":"fr/module-05/functional/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>20.1 Interfaces Fonctionnelles<ul> <li>20.1.1 R\u00e8gles pour les Interfaces Fonctionnelles</li> <li>20.1.2 Interfaces Fonctionnelles Courantes (java.util.function)</li> <li>20.1.3 M\u00e9thodes de Commodit\u00e9 sur les Interfaces Fonctionnelles</li> <li>20.1.4 Interfaces Fonctionnelles Primitives</li> <li>20.1.5 R\u00e9sum\u00e9</li> </ul> </li> <li>20.2 Expressions Lambda<ul> <li>20.2.1 Syntaxe des Expressions Lambda</li> <li>20.2.2 Exemples de Syntaxe Lambda</li> <li>20.2.3 R\u00e8gles pour les Expressions Lambda</li> <li>20.2.4 Inf\u00e9rence de Type</li> <li>20.2.5 Restrictions dans les Corps des Lambda</li> <li>20.2.6 R\u00e8gles de Type de Retour</li> <li>20.2.7 Lambdas vs Classes Anonymes</li> <li>20.2.8 Erreurs Courantes (Pi\u00e8ges de Certification)</li> </ul> </li> <li>20.3 R\u00e9f\u00e9rences de M\u00e9thodes<ul> <li>20.3.1 R\u00e9f\u00e9rence \u00e0 une M\u00e9thode Statique</li> <li>20.3.2 R\u00e9f\u00e9rence \u00e0 une M\u00e9thode d\u2019Instance d\u2019un Objet Particulier</li> <li>20.3.3 R\u00e9f\u00e9rence \u00e0 une M\u00e9thode d\u2019Instance d\u2019un Objet Arbitraire d\u2019un Type Donn\u00e9</li> <li>20.3.4 R\u00e9f\u00e9rence \u00e0 un Constructeur</li> <li>20.3.5 Tableau R\u00e9capitulatif des Types de Method Reference</li> <li>20.3.6 Pi\u00e8ges Fr\u00e9quents</li> </ul> </li> </ul> <p>La <code>programmation fonctionnelle</code> est un paradigme qui se concentre sur ce qui doit \u00eatre fait plut\u00f4t que sur la mani\u00e8re de le faire.</p> <p>\u00c0 partir de Java 8, le langage a ajout\u00e9 plusieurs fonctionnalit\u00e9s qui permettent un style \u201cfonctionnel\u201d : <code>lambda expressions</code>, <code>functional interfaces</code> et <code>method references</code>.</p> <p>Ces fonctionnalit\u00e9s permettent d\u2019\u00e9crire du code plus expressif, concis et r\u00e9utilisable, en particulier lorsqu\u2019on travaille avec des collections, des API de concurrence et des syst\u00e8mes event-driven.</p> <p></p>"},{"location":"fr/module-05/functional/#201-interfaces-fonctionnelles","title":"20.1 Interfaces Fonctionnelles","text":"<p>En Java, une interface fonctionnelle est une interface qui contient exactement une m\u00e9thode abstraite.</p> <p>Les interfaces fonctionnelles permettent les Lambda Expressions et les Method References, et constituent le c\u0153ur du mod\u00e8le de programmation fonctionnelle de Java.</p> <p>Note</p> <p>Java consid\u00e8re automatiquement comme interface fonctionnelle toute interface ayant une seule m\u00e9thode abstraite. L\u2019annotation <code>@FunctionalInterface</code> est optionnelle mais recommand\u00e9e.</p> <p></p>"},{"location":"fr/module-05/functional/#2011-regles-pour-les-interfaces-fonctionnelles","title":"20.1.1 R\u00e8gles pour les Interfaces Fonctionnelles","text":"<ul> <li>Exactement une m\u00e9thode abstraite (SAM = Single Abstract Method).</li> <li>Une interface peut d\u00e9clarer un nombre quelconque de m\u00e9thodes default, static ou private.</li> <li>Elle peut red\u00e9finir des m\u00e9thodes de <code>Object</code> (<code>toString()</code>, <code>equals(Object)</code>, <code>hashCode()</code>) sans affecter le d\u00e9compte SAM.</li> <li>La m\u00e9thode fonctionnelle peut provenir d\u2019une super-interface.</li> </ul> <p>Exemple :</p> <pre><code>@FunctionalInterface\ninterface Adder {\n    int add(int a, int b);   // single abstract method\n    static void info() {}\n    default void log() {}\n}\n</code></pre> <p></p>"},{"location":"fr/module-05/functional/#2012-interfaces-fonctionnelles-courantes-javautilfunction","title":"20.1.2 Interfaces Fonctionnelles Courantes (java.util.function)","text":"<p>Ci-dessous, un r\u00e9sum\u00e9 des interfaces fonctionnelles les plus importantes.</p> Functional Interface Returns Method Parameters <code>Supplier&lt;T&gt;</code> T get() 0 <code>Consumer&lt;T&gt;</code> void accept(T) 1 <code>BiConsumer&lt;T,U&gt;</code> void accept(T,U) 2 <code>Function&lt;T,R&gt;</code> R apply(T) 1 <code>BiFunction&lt;T,U,R&gt;</code> R apply(T,U) 2 <code>UnaryOperator&lt;T&gt;</code> T apply(T) 1 (m\u00eames types) <code>BinaryOperator&lt;T&gt;</code> T apply(T,T) 2 (m\u00eames types) <code>Predicate&lt;T&gt;</code> boolean test(T) 1 <code>BiPredicate&lt;T,U&gt;</code> boolean test(T,U) 2 <ul> <li>Exemples</li> </ul> <pre><code>Supplier&lt;String&gt; sup = () -&gt; \"Hello!\";\n\nConsumer&lt;String&gt; printer = s -&gt; System.out.println(s);\n\nFunction&lt;String, Integer&gt; length = s -&gt; s.length();\n\nUnaryOperator&lt;Integer&gt; square = x -&gt; x * x;\n\nPredicate&lt;Integer&gt; positive = x -&gt; x &gt; 0;\n</code></pre> <p></p>"},{"location":"fr/module-05/functional/#2013-methodes-de-commodite-sur-les-interfaces-fonctionnelles","title":"20.1.3 M\u00e9thodes de Commodit\u00e9 sur les Interfaces Fonctionnelles","text":"<p>De nombreuses interfaces fonctionnelles proposent des m\u00e9thodes utilitaires permettant l\u2019encha\u00eenement et la composition.</p> Interface Method Description Function andThen() applique celle-ci, puis une autre Function compose() applique une autre, puis celle-ci Function identity() renvoie une fonction x -&gt; x Predicate and() ET logique Predicate or() OU logique Predicate negate() NON logique Consumer andThen() cha\u00eene des consumers BinaryOperator minBy() minimum bas\u00e9 sur un comparator BinaryOperator maxBy() maximum bas\u00e9 sur un comparator <ul> <li>Exemples</li> </ul> <pre><code>Function&lt;Integer, Integer&gt; times2 = x -&gt; x * 2;\nFunction&lt;Integer, Integer&gt; plus3  = x -&gt; x + 3;\n\nvar result1 = times2.andThen(plus3).apply(5);   // (5*2)+3 = 13\nvar result2 = times2.compose(plus3).apply(5);   // (5+3)*2 = 16\n\nPredicate&lt;String&gt; longString = s -&gt; s.length() &gt; 5;\nPredicate&lt;String&gt; startsWithA = s -&gt; s.startsWith(\"A\");\n\nboolean ok = longString.and(startsWithA).test(\"Amazing\");  // true\n</code></pre> <p></p>"},{"location":"fr/module-05/functional/#2014-interfaces-fonctionnelles-primitives","title":"20.1.4 Interfaces Fonctionnelles Primitives","text":"<p>Java fournit des versions sp\u00e9cialis\u00e9es des interfaces fonctionnelles pour les types primitifs afin d\u2019\u00e9viter le co\u00fbt du boxing/unboxing.</p> Functional Interface Return Type Single Abstract Method # Parameters IntSupplier int getAsInt() 0 LongSupplier long getAsLong() 0 DoubleSupplier double getAsDouble() 0 BooleanSupplier boolean getAsBoolean() 0 IntConsumer void accept(int) 1 (int) LongConsumer void accept(long) 1 (long) DoubleConsumer void accept(double) 1 (double) IntPredicate boolean test(int) 1 (int) LongPredicate boolean test(long) 1 (long) DoublePredicate boolean test(double) 1 (double) IntUnaryOperator int applyAsInt(int) 1 (int) LongUnaryOperator long applyAsLong(long) 1 (long) DoubleUnaryOperator double applyAsDouble(double) 1 (double) IntBinaryOperator int applyAsInt(int, int) 2 (int,int) LongBinaryOperator long applyAsLong(long, long) 2 (long,long) DoubleBinaryOperator double applyAsDouble(double,double) 2 IntFunction R apply(int) 1 (int) LongFunction R apply(long) 1 (long) DoubleFunction R apply(double) 1 (double) ToIntFunction int applyAsInt(T) 1 (T) ToLongFunction long applyAsLong(T) 1 (T) ToDoubleFunction double applyAsDouble(T) 1 (T) ToIntBiFunction int applyAsInt(T,U) 2 (T,U) ToLongBiFunction long applyAsLong(T,U) 2 (T,U) ToDoubleBiFunction double applyAsDouble(T,U) 2 (T,U) ObjIntConsumer void accept(T,int) 2 (T,int) ObjLongConsumer void accept(T,long) 2 (T,long) ObjDoubleConsumer void accept(T,double) 2 (T,double) DoubleToIntFunction int applyAsInt(double) 1 DoubleToLongFunction long applyAsLong(double) 1 IntToDoubleFunction double applyAsDouble(int) 1 IntToLongFunction long applyAsLong(int) 1 LongToDoubleFunction double applyAsDouble(long) 1 LongToIntFunction int applyAsInt(long) 1 <ul> <li>Exemple</li> </ul> <pre><code>IntSupplier dice = () -&gt; (int)(Math.random() * 6) + 1;\n\nIntPredicate even = x -&gt; x % 2 == 0;\n\nIntUnaryOperator doubleIt = x -&gt; x * 2;\n</code></pre> <p></p>"},{"location":"fr/module-05/functional/#2015-resume","title":"20.1.5 R\u00e9sum\u00e9","text":"<ul> <li>Les interfaces fonctionnelles contiennent exactement une m\u00e9thode abstraite (SAM).</li> <li>Elles sont le support des Lambdas et des Method References.</li> <li>Java propose de nombreuses FI int\u00e9gr\u00e9es dans <code>java.util.function</code>.</li> <li>Les variantes primitives am\u00e9liorent les performances en supprimant le boxing.</li> </ul>"},{"location":"fr/module-05/functional/#202-expressions-lambda","title":"20.2 Expressions Lambda","text":"<p>Une expression lambda est une mani\u00e8re compacte d\u2019\u00e9crire une fonction.</p> <p>Les expressions lambda offrent une fa\u00e7on concise de d\u00e9finir des impl\u00e9mentations d\u2019interfaces fonctionnelles.</p> <p>Une lambda est essentiellement un petit bloc de code qui prend des param\u00e8tres et renvoie une valeur, sans n\u00e9cessiter une d\u00e9claration compl\u00e8te de m\u00e9thode.</p> <p>Elles repr\u00e9sentent le comportement comme une donn\u00e9e et constituent un \u00e9l\u00e9ment cl\u00e9 du mod\u00e8le de programmation fonctionnelle en Java.</p> <p></p>"},{"location":"fr/module-05/functional/#2021-syntaxe-des-expressions-lambda","title":"20.2.1 Syntaxe des Expressions Lambda","text":"<p>La syntaxe g\u00e9n\u00e9rale est :</p> <p><code>(parameters) -&gt; expression</code> ou <code>(parameters) -&gt; { statements }</code></p> <p></p>"},{"location":"fr/module-05/functional/#2022-exemples-de-syntaxe-lambda","title":"20.2.2 Exemples de Syntaxe Lambda","text":"<p>Z\u00e9ro param\u00e8tre <pre><code>Runnable r = () -&gt; System.out.println(\"Hello\");\n</code></pre></p> <p>Un param\u00e8tre (parenth\u00e8ses optionnelles) <pre><code>Consumer&lt;String&gt; c = s -&gt; System.out.println(s);\n</code></pre></p> <p>Plusieurs param\u00e8tres <pre><code>BinaryOperator&lt;Integer&gt; add = (a, b) -&gt; a + b;\n</code></pre></p> <p>Avec un corps en bloc <pre><code>Function&lt;Integer, String&gt; f = (x) -&gt; {\n    int doubled = x * 2;\n    return \"Value: \" + doubled;\n};\n</code></pre></p> <p></p>"},{"location":"fr/module-05/functional/#2023-regles-pour-les-expressions-lambda","title":"20.2.3 R\u00e8gles pour les Expressions Lambda","text":"<ul> <li>Les types des param\u00e8tres peuvent \u00eatre omis (inf\u00e9rence de type).</li> <li>Si un param\u00e8tre a un type, alors tous les param\u00e8tres doivent sp\u00e9cifier un type.</li> <li>Un seul param\u00e8tre ne n\u00e9cessite pas de parenth\u00e8ses.</li> <li>Plusieurs param\u00e8tres n\u00e9cessitent des parenth\u00e8ses.</li> <li>Si le corps est une seule expression (sans <code>{ }</code>), <code>return</code> est interdit ; l\u2019expression elle-m\u00eame est la valeur de retour.</li> <li>Si le corps utilise <code>{ }</code> (un bloc), <code>return</code> doit appara\u00eetre si une valeur est renvoy\u00e9e.</li> <li>Les expressions lambda ne peuvent \u00eatre assign\u00e9es qu\u2019\u00e0 des interfaces fonctionnelles (types SAM).</li> </ul>"},{"location":"fr/module-05/functional/#2024-inference-de-type","title":"20.2.4 Inf\u00e9rence de Type","text":"<p>Le compilateur d\u00e9duit le type de la lambda \u00e0 partir du contexte de l\u2019interface fonctionnelle cible.</p> <pre><code>Predicate&lt;String&gt; p = s -&gt; s.isEmpty();  // s d\u00e9duit comme String\n</code></pre> <p>Si le compilateur ne peut pas d\u00e9duire le type, il faut le pr\u00e9ciser explicitement.</p> <pre><code>BiFunction&lt;Integer, Integer, Integer&gt; f = (Integer a, Integer b) -&gt; a * b;\n</code></pre> <p></p>"},{"location":"fr/module-05/functional/#2025-restrictions-dans-les-corps-des-lambda","title":"20.2.5 Restrictions dans les Corps des Lambda","text":"<p>Les lambdas ne peuvent capturer que des variables locales <code>final</code> ou effectively final (non r\u00e9assign\u00e9es).</p> <pre><code>int x = 10;\nRunnable r = () -&gt; {\n    // x++;   // \u274c erreur de compilation \u2014 x doit \u00eatre effectively final\n    System.out.println(x);\n};\n</code></pre> <p>Elles peuvent en revanche modifier l\u2019\u00e9tat d\u2019un objet (seules les r\u00e9f\u00e9rences doivent \u00eatre effectively final).</p> <pre><code>var list = new ArrayList&lt;&gt;();\nRunnable r2 = () -&gt; list.add(\"OK\");  // autoris\u00e9\n</code></pre> <p></p>"},{"location":"fr/module-05/functional/#2026-regles-de-type-de-retour","title":"20.2.6 R\u00e8gles de Type de Retour","text":"<p>Si le corps est une expression : l\u2019expression est la valeur de retour.</p> <pre><code>Function&lt;Integer, Integer&gt; f = x -&gt; x * 2;\n</code></pre> <p>Si le corps est un bloc : il faut inclure <code>return</code>.</p> <pre><code>Function&lt;Integer, Integer&gt; g = x -&gt; {\n    return x * 2;\n};\n</code></pre> <p></p>"},{"location":"fr/module-05/functional/#2027-lambdas-vs-classes-anonymes","title":"20.2.7 Lambdas vs Classes Anonymes","text":"<ul> <li>Les lambdas ne cr\u00e9ent PAS une nouvelle port\u00e9e : elles partagent la port\u00e9e englobante.</li> <li><code>this</code> dans une lambda fait r\u00e9f\u00e9rence \u00e0 l\u2019objet englobant, pas \u00e0 la lambda.</li> </ul> <pre><code>class Test {\n    void run() {\n        Runnable r = () -&gt; System.out.println(this.toString());\n    }\n}\n</code></pre> <p>Dans une classe anonyme, <code>this</code> fait r\u00e9f\u00e9rence \u00e0 l\u2019instance de la classe anonyme.</p> <p></p>"},{"location":"fr/module-05/functional/#2028-erreurs-courantes-pieges-de-certification","title":"20.2.8 Erreurs Courantes (Pi\u00e8ges de Certification)","text":"<p>Types de retour incoh\u00e9rents <pre><code>x -&gt; { if (x &gt; 0) return 1; }  // \u274c manque un return pour le cas n\u00e9gatif\n</code></pre></p> <p>M\u00e9langer param\u00e8tres typ\u00e9s et non typ\u00e9s <pre><code>(a, int b) -&gt; a + b   // \u274c ill\u00e9gal\n</code></pre></p> <p>Renvoyer une valeur pour une lambda ciblant void <pre><code>Runnable r = () -&gt; 5;  // \u274c Runnable.run() retourne void\n</code></pre></p> <p>R\u00e9solution d\u2019overload ambigu\u00eb</p> <pre><code>void m(IntFunction&lt;Integer&gt; f) {}\nvoid m(Function&lt;Integer, Integer&gt; f) {}\n\nm(x -&gt; x + 1);  // \u274c ambigu\n</code></pre> <p></p>"},{"location":"fr/module-05/functional/#203-references-de-methodes","title":"20.3 R\u00e9f\u00e9rences de M\u00e9thodes","text":"<p>Les r\u00e9f\u00e9rences de m\u00e9thodes (method references) fournissent une syntaxe abr\u00e9g\u00e9e pour utiliser une m\u00e9thode existante comme impl\u00e9mentation d\u2019une interface fonctionnelle.</p> <p>Elles sont \u00e9quivalentes aux expressions lambda, mais plus concises, plus lisibles, et souvent pr\u00e9f\u00e9r\u00e9es lorsque la m\u00e9thode cible existe d\u00e9j\u00e0.</p> <p>Il existe quatre cat\u00e9gories de r\u00e9f\u00e9rences de m\u00e9thodes en Java :</p> <ul> <li> <ol> <li>R\u00e9f\u00e9rence \u00e0 une m\u00e9thode statique (<code>ClassName::staticMethod</code>)</li> </ol> </li> <li> <ol> <li>R\u00e9f\u00e9rence \u00e0 une m\u00e9thode d\u2019instance d\u2019un objet particulier (<code>instance::method</code>)</li> </ol> </li> <li> <ol> <li>R\u00e9f\u00e9rence \u00e0 une m\u00e9thode d\u2019instance d\u2019un objet arbitraire d\u2019un type donn\u00e9 (<code>ClassName::instanceMethod</code>)</li> </ol> </li> <li> <ol> <li>R\u00e9f\u00e9rence \u00e0 un constructeur (<code>ClassName::new</code>)</li> </ol> </li> </ul> <p></p>"},{"location":"fr/module-05/functional/#2031-reference-a-une-methode-statique","title":"20.3.1 R\u00e9f\u00e9rence \u00e0 une M\u00e9thode Statique","text":"<p>Une r\u00e9f\u00e9rence \u00e0 m\u00e9thode statique remplace une lambda qui appelle une m\u00e9thode statique.</p> <pre><code>class Utils {\n    static int square(int x) { return x * x; }\n}\n\nFunction&lt;Integer, Integer&gt; f1 = x -&gt; Utils.square(x);\nFunction&lt;Integer, Integer&gt; f2 = Utils::square;  // method reference\n</code></pre> <p><code>f1</code> et <code>f2</code> se comportent de mani\u00e8re identique.</p> <p></p>"},{"location":"fr/module-05/functional/#2032-reference-a-une-methode-dinstance-dun-objet-particulier","title":"20.3.2 R\u00e9f\u00e9rence \u00e0 une M\u00e9thode d\u2019Instance d\u2019un Objet Particulier","text":"<p>Utilis\u00e9e lorsque vous avez d\u00e9j\u00e0 une instance d\u2019objet et que vous voulez r\u00e9f\u00e9rencer l\u2019une de ses m\u00e9thodes.</p> <pre><code>String prefix = \"Hello, \";\n\nUnaryOperator&lt;String&gt; op1 = s -&gt; prefix.concat(s);\nUnaryOperator&lt;String&gt; op2 = prefix::concat;   // method reference\n\nSystem.out.println(op2.apply(\"World\"));\n</code></pre> <p>La r\u00e9f\u00e9rence <code>prefix::concat</code> lie <code>concat</code> \u00e0 cet objet sp\u00e9cifique.</p> <p></p>"},{"location":"fr/module-05/functional/#2033-reference-a-une-methode-dinstance-dun-objet-arbitraire-dun-type-donne","title":"20.3.3 R\u00e9f\u00e9rence \u00e0 une M\u00e9thode d\u2019Instance d\u2019un Objet Arbitraire d\u2019un Type Donn\u00e9","text":"<p>C\u2019est la forme la plus \u201cpi\u00e9geuse\u201d.</p> <p>Le premier param\u00e8tre de l\u2019interface fonctionnelle devient le receiver de la m\u00e9thode (<code>this</code>).</p> <pre><code>BiPredicate&lt;String, String&gt; p1 = (s1, s2) -&gt; s1.equals(s2);\nBiPredicate&lt;String, String&gt; p2 = String::equals;   // method reference\n\nSystem.out.println(p2.test(\"abc\", \"abc\"));  // true\n</code></pre> <p>Note</p> <p>Cette forme applique la m\u00e9thode au premier argument de la lambda.</p> <p></p>"},{"location":"fr/module-05/functional/#2034-reference-a-un-constructeur","title":"20.3.4 R\u00e9f\u00e9rence \u00e0 un Constructeur","text":"<p>Les r\u00e9f\u00e9rences de constructeurs remplacent des lambdas qui appellent <code>new</code>.</p> <pre><code>Supplier&lt;ArrayList&lt;String&gt;&gt; sup1 = () -&gt; new ArrayList&lt;&gt;();\nSupplier&lt;ArrayList&lt;String&gt;&gt; sup2 = ArrayList::new; // method reference\n\nFunction&lt;Integer, ArrayList&lt;String&gt;&gt; sup3 = ArrayList::new;\n// appelle le constructeur ArrayList(int capacity)\n</code></pre> <p></p>"},{"location":"fr/module-05/functional/#2035-tableau-recapitulatif-des-types-de-method-reference","title":"20.3.5 Tableau R\u00e9capitulatif des Types de Method Reference","text":"<p>Le tableau ci-dessous r\u00e9sume toutes les cat\u00e9gories de r\u00e9f\u00e9rences de m\u00e9thodes.</p> Type Syntax Example Equivalent Lambda Static method Class::staticMethod x -&gt; Class.staticMethod(x) Instance method of specific object instance::method x -&gt; instance.method(x) Instance method of arbitrary object Class::method (obj, x) -&gt; obj.method(x) Constructor Class::new () -&gt; new Class() <p></p>"},{"location":"fr/module-05/functional/#2036-pieges-frequents","title":"20.3.6 Pi\u00e8ges Fr\u00e9quents","text":"<ul> <li>Une r\u00e9f\u00e9rence de m\u00e9thode doit correspondre exactement \u00e0 la signature de l\u2019interface fonctionnelle.</li> <li>Les overloads peuvent rendre une r\u00e9f\u00e9rence de m\u00e9thode ambigu\u00eb.</li> <li>La r\u00e9f\u00e9rence \u00e0 m\u00e9thode d\u2019instance (<code>Class::method</code>) d\u00e9cale le receiver sur le param\u00e8tre 1.</li> <li>Une r\u00e9f\u00e9rence de constructeur \u00e9choue s\u2019il n\u2019existe pas de constructeur compatible.</li> </ul> <pre><code>// \u274c Ambigu : quel println()? (println(int), println(String)...)\nConsumer&lt;String&gt; c = System.out::println; // OK uniquement parce que le param\u00e8tre FI est String\n\n// \u274c Constructeur non compatible : mauvaise interface fonctionnelle\nSupplier&lt;Integer&gt; s = Integer::new;          // \u2714 OK : appelle Integer()\nFunction&lt;String, Long&gt; f = Integer::new;     // \u274c ERREUR : le constructeur retourne Integer, pas Long\n</code></pre> <p>En cas de doute, r\u00e9\u00e9crivez la method reference en lambda : si la lambda fonctionne mais pas la method reference, le probl\u00e8me est g\u00e9n\u00e9ralement un mismatch de signature.</p>"},{"location":"fr/module-05/streams/","title":"21. Java Optional et Streams","text":""},{"location":"fr/module-05/streams/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>21.1 Optional (Optional OptionalInt OptionalLong OptionalDouble)<ul> <li>21.1.1 Cr\u00e9er des Optional</li> <li>21.1.2 Lire des valeurs en toute s\u00e9curit\u00e9</li> <li>21.1.3 Transformer des Optional</li> <li>21.1.4 Optional et Streams</li> <li>21.1.5 Optional pour les types primitifs</li> <li>21.1.6 Pi\u00e8ges courants</li> </ul> </li> <li>21.2 Qu\u2019est-ce qu\u2019un Stream (et ce que ce n\u2019est pas)</li> <li>21.3 Architecture du pipeline Stream<ul> <li>21.3.1 Sources de Stream</li> <li>21.3.2 Op\u00e9rations interm\u00e9diaires<ul> <li>21.3.2.1 Tableau des op\u00e9rations interm\u00e9diaires courantes</li> </ul> </li> <li>21.3.3 Op\u00e9rations terminales<ul> <li>21.3.3.1 Tableau des op\u00e9rations terminales</li> </ul> </li> </ul> </li> <li>21.4 \u00c9valuation paresseuse et court-circuitage</li> <li>21.5 Op\u00e9rations stateless vs stateful<ul> <li>21.5.1 Op\u00e9rations stateless</li> <li>21.5.2 Op\u00e9rations stateful</li> </ul> </li> <li>21.6 Ordonnancement des Streams et d\u00e9terminisme</li> <li>21.7 Streams parall\u00e8les</li> <li>21.8 Op\u00e9rations de r\u00e9duction<ul> <li>21.8.1 <code>reduce()</code> : combiner un stream en un seul objet<ul> <li>21.8.1.1 Mod\u00e8le mental correct</li> </ul> </li> <li>21.8.2 <code>collect()</code></li> <li>21.8.3 Pourquoi <code>collect()</code> est diff\u00e9rent de <code>reduce()</code></li> </ul> </li> <li>21.9 Pi\u00e8ges courants des Streams</li> <li>21.10 Streams primitifs<ul> <li>21.10.1 Pourquoi les streams primitifs sont importants</li> <li>21.10.2 M\u00e9thodes courantes de cr\u00e9ation</li> <li>21.10.3 M\u00e9thodes de mapping sp\u00e9cialis\u00e9es pour les primitifs</li> <li>21.10.4 Tableau de mapping entre <code>Stream&lt;T&gt;</code> et les streams primitifs</li> <li>21.10.5 Op\u00e9rations terminales et leurs types de r\u00e9sultat</li> <li>21.10.6 Pi\u00e8ges et gotchas courants</li> </ul> </li> <li>21.11 Collectors (collect(), Collector et les m\u00e9thodes factory de Collectors)<ul> <li>21.11.1 collect() vs Collector</li> <li>21.11.2 Collectors principaux</li> <li>21.11.3 Collectors de regroupement</li> <li>21.11.4 partitioningBy</li> <li>21.11.5 toMap et r\u00e8gles de fusion</li> <li>21.11.6 collectingAndThen</li> <li>21.11.7 Comment les collectors se rapportent aux streams parall\u00e8les</li> </ul> </li> </ul>"},{"location":"fr/module-05/streams/#211-optional-optional-optionalint-optionallong-optionaldouble","title":"21.1 Optional (Optional, OptionalInt, OptionalLong, OptionalDouble)","text":"<p><code>Optional&lt;T&gt;</code> est un objet conteneur qui peut contenir, ou non, une valeur non nulle.</p> <p>Il a \u00e9t\u00e9 con\u00e7u pour rendre explicite \u00ab l\u2019absence d\u2019une valeur \u00bb et pour r\u00e9duire le risque de <code>NullPointerException</code> en for\u00e7ant les appelants \u00e0 g\u00e9rer le cas d\u2019absence.</p> <p>Note</p> <ul> <li><code>Optional</code> est principalement destin\u00e9 aux types de retour.</li> <li>Il est g\u00e9n\u00e9ralement d\u00e9conseill\u00e9 pour les attributs, les param\u00e8tres de m\u00e9thode et les contextes de s\u00e9rialisation (sauf si un contrat API sp\u00e9cifique l\u2019exige).</li> </ul> <p></p>"},{"location":"fr/module-05/streams/#2111-creer-des-optional","title":"21.1.1 Cr\u00e9er des Optional","text":"<p>Il existe trois m\u00e9thodes factory principales pour cr\u00e9er des Optional.</p> <ul> <li><code>Optional.of(value)</code> \u2192 value doit \u00eatre non nulle ; sinon une <code>NullPointerException</code> est lev\u00e9e</li> <li><code>Optional.ofNullable(value)</code> \u2192 retourne empty si value est null</li> <li><code>Optional.empty()</code> \u2192 un Optional explicitement vide</li> </ul> <pre><code>Optional&lt;String&gt; a = Optional.of(\"x\");\nOptional&lt;String&gt; b = Optional.ofNullable(null); // Optional.empty\nOptional&lt;String&gt; c = Optional.empty();\n</code></pre> <p></p>"},{"location":"fr/module-05/streams/#2112-lire-des-valeurs-en-toute-securite","title":"21.1.2 Lire des valeurs en toute s\u00e9curit\u00e9","text":"<p>Les Optional fournissent plusieurs moyens d\u2019acc\u00e9der \u00e0 la valeur encapsul\u00e9e.</p> <ul> <li><code>isPresent()</code> / <code>isEmpty()</code> \u2192 test de pr\u00e9sence</li> <li><code>get()</code> \u2192 retourne la valeur ou l\u00e8ve <code>NoSuchElementException</code> si absente (d\u00e9conseill\u00e9)</li> <li><code>orElse(defaultValue)</code> \u2192 retourne la valeur ou la valeur par d\u00e9faut (\u00e9valu\u00e9e imm\u00e9diatement)</li> <li><code>orElseGet(supplier)</code> \u2192 retourne la valeur ou le r\u00e9sultat du supplier (supplier \u00e9valu\u00e9 de mani\u00e8re lazy)</li> <li><code>orElseThrow()</code> \u2192 retourne la valeur ou l\u00e8ve <code>NoSuchElementException</code></li> <li><code>orElseThrow(exceptionSupplier)</code> \u2192 retourne la valeur ou l\u00e8ve une exception personnalis\u00e9e</li> </ul> <pre><code>Optional&lt;String&gt; opt = Optional.of(\"java\");\n\nString v1 = opt.orElse(\"default\");\nString v2 = opt.orElseGet(() -&gt; \"computed\");\nString v3 = opt.orElseThrow(); // ok car opt est pr\u00e9sent\n</code></pre> <p>Note</p> <ul> <li>Un pi\u00e8ge courant : <code>orElse(...)</code> \u00e9value son argument m\u00eame si l\u2019Optional est pr\u00e9sent.</li> <li>Utilisez <code>orElseGet(...)</code> lorsque la valeur par d\u00e9faut est co\u00fbteuse \u00e0 calculer.</li> </ul> <p></p>"},{"location":"fr/module-05/streams/#2113-transformer-des-optional","title":"21.1.3 Transformer des Optional","text":"<p>Les Optional prennent en charge des transformations fonctionnelles similaires aux streams, mais avec une s\u00e9mantique \u00ab 0 ou 1 \u00e9l\u00e9ment \u00bb.</p> <ul> <li><code>map(fn)</code> \u2192 transforme la valeur si elle est pr\u00e9sente</li> <li><code>flatMap(fn)</code> \u2192 transforme en un Optional aplati, sans imbrication</li> <li><code>filter(predicate)</code> \u2192 conserve la valeur uniquement si le predicate est true</li> </ul> <pre><code>Optional&lt;String&gt; name = Optional.of(\"Alice\");\n\nOptional&lt;Integer&gt; len =\n    name.map(String::length); // Optional[5]\n\nOptional&lt;String&gt; filtered =\n    name.filter(n -&gt; n.startsWith(\"A\")); // Optional[Alice]\n\nSystem.out.println(len.orElse(0));\nSystem.out.println(filtered.orElseGet(() -&gt; \"11\"));\n</code></pre> <p>Sortie :</p> <pre><code>5\nAlice\n</code></pre> <p>Note</p> <ul> <li><code>map</code> encapsule le r\u00e9sultat dans un Optional.</li> <li>Si votre fonction de mapping retourne d\u00e9j\u00e0 un Optional, utilisez <code>flatMap</code> pour \u00e9viter l\u2019imbrication <code>Optional&lt;Optional&lt;T&gt;&gt;</code>.</li> </ul> <p></p>"},{"location":"fr/module-05/streams/#2114-optional-et-streams","title":"21.1.4 Optional et Streams","text":"<p>Un pattern de pipeline tr\u00e8s courant consiste \u00e0 effectuer un <code>map</code> vers un Optional puis \u00e0 supprimer les \u00e9l\u00e9ments absents.</p> <p>Depuis Java 9, <code>Optional</code> fournit <code>stream()</code> pour convertir \u00ab pr\u00e9sent \u2192 un \u00e9l\u00e9ment \u00bb et \u00ab vide \u2192 z\u00e9ro \u00e9l\u00e9ment \u00bb.</p> <pre><code>        Stream&lt;String&gt; words = Stream.of(\"a\", \"bb\", \"ccc\");\n\n        words.map(w -&gt; w.length() &gt; 1 ? Optional.of(w.length()) : Optional.&lt;Integer&gt;empty())\n             .flatMap(Optional::stream) // supprime les \u00e9l\u00e9ments vides\n             .forEach(System.out::println);\n</code></pre> <p>Sortie :</p> <pre><code>2\n3\n</code></pre> <p>Note</p> <p>Avant Java 9, ce pattern n\u00e9cessitait <code>filter(Optional::isPresent)</code> plus <code>map(Optional::get)</code>.</p> <p></p>"},{"location":"fr/module-05/streams/#2115-optional-pour-les-types-primitifs","title":"21.1.5 Optional pour les types primitifs","text":"<p>Les streams primitifs utilisent des optional primitifs pour \u00e9viter le boxing : <code>OptionalInt</code>, <code>OptionalLong</code>, <code>OptionalDouble</code>.</p> <p>Ils refl\u00e8tent l\u2019API principale de Optional avec des getters primitifs comme <code>getAsInt()</code>.</p> <ul> <li><code>OptionalInt.getAsInt()</code> / <code>OptionalLong.getAsLong()</code> / <code>OptionalDouble.getAsDouble()</code></li> <li><code>orElse(...)</code> / <code>orElseGet(...)</code> / <code>orElseThrow(...)</code></li> </ul> <pre><code>OptionalInt m = IntStream.of(3, 1, 2).min(); // OptionalInt[1]\nint value = m.orElse(0); // 1\n</code></pre> <p></p>"},{"location":"fr/module-05/streams/#2116-pieges-courants","title":"21.1.6 Pi\u00e8ges courants","text":"<ul> <li>Ne pas utiliser <code>get()</code> sans v\u00e9rifier la pr\u00e9sence ; pr\u00e9f\u00e9rer <code>orElseThrow</code> ou les transformations</li> <li>\u00c9viter de retourner <code>null</code> au lieu de <code>Optional.empty()</code> ; une r\u00e9f\u00e9rence Optional elle-m\u00eame ne devrait pas \u00eatre null</li> <li>Se souvenir que <code>average()</code> sur les streams primitifs retourne toujours <code>OptionalDouble</code> (m\u00eame pour <code>IntStream</code> et <code>LongStream</code>)</li> <li>Utiliser <code>orElseGet</code> lorsque le calcul de la valeur par d\u00e9faut est co\u00fbteux en termes de performances</li> </ul>"},{"location":"fr/module-05/streams/#212-quest-ce-quun-stream-et-ce-que-ce-nest-pas","title":"21.2 Qu\u2019est-ce qu\u2019un Stream (et ce que ce n\u2019est pas)","text":"<p>Un <code>Stream Java</code> repr\u00e9sente une s\u00e9quence d\u2019\u00e9l\u00e9ments (un pipeline) prenant en charge des op\u00e9rations de style fonctionnel.</p> <p>Les streams sont con\u00e7us pour le traitement des donn\u00e9es, et non pour leur stockage.</p> <p>Caract\u00e9ristiques cl\u00e9s :</p> <ul> <li>Un stream ne stocke pas de donn\u00e9es</li> <li>Un stream est lazy \u2014 rien ne se produit tant qu\u2019une op\u00e9ration terminale n\u2019est pas invoqu\u00e9e</li> <li>Un stream ne peut \u00eatre consomm\u00e9 qu\u2019une seule fois</li> <li>Les streams encouragent des op\u00e9rations sans effets de bord</li> </ul> <p>Note</p> <p>Les streams sont conceptuellement similaires aux requ\u00eates de bases de donn\u00e9es : ils d\u00e9crivent ce qu\u2019il faut calculer, et non comment it\u00e9rer.</p> <p></p>"},{"location":"fr/module-05/streams/#213-architecture-du-pipeline-stream","title":"21.3 Architecture du pipeline Stream","text":"<p>Chaque pipeline de stream se compose de trois phases distinctes :</p> <ul> <li>1\ufe0f Source</li> <li>2\ufe0f Z\u00e9ro ou plusieurs Op\u00e9rations interm\u00e9diaires</li> <li>3\ufe0f Exactement une Op\u00e9ration terminale</li> </ul> <p></p>"},{"location":"fr/module-05/streams/#2131-sources-de-stream","title":"21.3.1 Sources de Stream","text":"<p>Les sources courantes de stream incluent :</p> <ul> <li>Collections : <code>collection.stream()</code></li> <li>Tableaux : <code>Arrays.stream(array)</code></li> <li>Canaux I/O et fichiers</li> <li>Streams infinis : <code>Stream.iterate</code>, <code>Stream.generate</code></li> </ul> <pre><code>List&lt;String&gt; names = List.of(\"Ana\", \"Bob\", \"Carla\");\n\nStream&lt;String&gt; s = names.stream();\n</code></pre> <p></p>"},{"location":"fr/module-05/streams/#2132-operations-intermediaires","title":"21.3.2 Op\u00e9rations interm\u00e9diaires","text":"<p>Op\u00e9rations interm\u00e9diaires :</p> <ul> <li>Retournent un nouveau stream</li> <li>Sont \u00e9valu\u00e9es de mani\u00e8re lazy</li> <li>Ne d\u00e9clenchent pas l\u2019ex\u00e9cution</li> </ul> <p></p>"},{"location":"fr/module-05/streams/#21321-tableau-des-operations-intermediaires-courantes","title":"21.3.2.1 Tableau des op\u00e9rations interm\u00e9diaires courantes","text":"Method Common input Params Return value Desctiption <code>filter</code> Predicate <code>Stream&lt;T&gt;</code> filtre le stream selon une correspondance du predicate <code>map</code> Function <code>Stream&lt;R&gt;</code> transforme un stream par un mapping un-\u00e0-un entr\u00e9e/sortie <code>flatMap</code> Function <code>Stream&lt;R&gt;</code> aplatit des streams imbriqu\u00e9s en un seul stream <code>sorted</code> (none) or Comparator <code>Stream&lt;T&gt;</code> trie par ordre naturel ou selon le Comparator fourni <code>distinct</code> (none) <code>Stream&lt;T&gt;</code> supprime les \u00e9l\u00e9ments dupliqu\u00e9s <code>limit</code> / <code>skip</code> long <code>Stream&lt;T&gt;</code> limite la taille ou saute des \u00e9l\u00e9ments <code>peek</code> Consumer <code>Stream&lt;T&gt;</code> ex\u00e9cute une action avec effet de bord pour chaque \u00e9l\u00e9ment (debugging) <ul> <li>Exemple :</li> </ul> <pre><code>        List&lt;String&gt; names = List.of(\"Ana\", \"Bob\", \"Carla\", \"Mario\");\n\n        names.stream()\n             .filter(n -&gt; n.length() &gt; 3)\n             .map(String::toUpperCase)\n             .forEach(System.out::println);\n</code></pre> <p>Sortie :</p> <pre><code>CARLA\nMARIO\n</code></pre> <p>Note</p> <p>Les op\u00e9rations interm\u00e9diaires d\u00e9crivent uniquement le calcul. Aucun \u00e9l\u00e9ment n\u2019est encore trait\u00e9.</p> <p></p>"},{"location":"fr/module-05/streams/#2133-operations-terminales","title":"21.3.3 Op\u00e9rations terminales","text":"<p>Op\u00e9rations terminales :</p> <ul> <li>D\u00e9clenchent l\u2019ex\u00e9cution</li> <li>Consomment le stream</li> <li>Produisent un r\u00e9sultat ou un effet de bord</li> </ul> <p></p>"},{"location":"fr/module-05/streams/#21331-tableau-des-operations-terminales","title":"21.3.3.1 Tableau des op\u00e9rations terminales","text":"Method Return value behaviour for infinite streams <code>forEach</code> void ne termine pas <code>collect</code> varie ne termine pas <code>reduce</code> varie ne termine pas <code>findFirst</code> / <code>findAny</code> <code>Optional&lt;T&gt;</code> termine <code>anyMatch</code> / <code>allMatch</code> / <code>noneMatch</code> boolean peut terminer t\u00f4t (court-circuit) <code>min</code> / <code>max</code> <code>Optional&lt;T&gt;</code> ne termine pas <code>count</code> long ne termine pas"},{"location":"fr/module-05/streams/#214-evaluation-paresseuse-et-court-circuitage","title":"21.4 \u00c9valuation paresseuse et court-circuitage","text":"<pre><code>var newNames = new ArrayList&lt;String&gt;();\n\nnewNames.add(\"Bob\");\nnewNames.add(\"Dan\");\n\n// Les streams sont \u00e9valu\u00e9s de mani\u00e8re paresseuse : ceci ne parcourt pas encore les donn\u00e9es,\n// cela cr\u00e9e uniquement une description du pipeline li\u00e9e \u00e0 la source.\nvar stream = newNames.stream();\n\nnewNames.add(\"Erin\");\n\n// L\u2019op\u00e9ration terminale d\u00e9clenche l\u2019\u00e9valuation. Le stream voit la source mise \u00e0 jour,\n// donc le count inclut \"Erin\".\nstream.count(); // 3\n</code></pre> <p>Note importante : Un stream est li\u00e9 \u00e0 sa source (<code>newNames</code>), et le pipeline n\u2019est pas ex\u00e9cut\u00e9 tant qu\u2019une op\u00e9ration terminale n\u2019est pas invoqu\u00e9e. Pour cette raison, si vous modifiez la collection avant l\u2019op\u00e9ration terminale, l\u2019op\u00e9ration terminale \u00ab voit \u00bb les nouveaux \u00e9l\u00e9ments (ici, <code>Erin</code>). En g\u00e9n\u00e9ral, toutefois, modifier la source pendant qu\u2019un pipeline de stream est en cours d\u2019utilisation est une mauvaise pratique et peut conduire \u00e0 un comportement non d\u00e9terministe (ou \u00e0 une <code>ConcurrentModificationException</code> avec certaines sources/op\u00e9rations). La r\u00e8gle pratique est : construire la source, puis cr\u00e9er et ex\u00e9cuter le stream sans la modifier.</p> <p>Les streams traitent les \u00e9l\u00e9ments un par un, en circulant \u00ab verticalement \u00bb \u00e0 travers le pipeline plut\u00f4t que \u00e9tape par \u00e9tape.</p> <p>Ci-dessous, nous modifions l\u2019exemple pour utiliser une op\u00e9ration terminale \u00e0 court-circuit : <code>findFirst()</code>.</p> <pre><code>Stream.of(\"a\", \"bb\", \"ccc\")\n    .filter(s -&gt; {\n        System.out.println(\"filter \" + s);\n        return s.length() &gt; 1;\n    })\n    .map(s -&gt; {\n        System.out.println(\"map \" + s);\n        return s.toUpperCase();\n    })\n    .findFirst()\n    .ifPresent(System.out::println);\n</code></pre> <p>Ordre d\u2019ex\u00e9cution :</p> <p>Note</p> <p>Seul le nombre minimal d\u2019\u00e9l\u00e9ments requis par l\u2019op\u00e9ration terminale est trait\u00e9.</p> <pre><code>filter a\nfilter bb\nmap bb\nBB\n</code></pre> <p><code>findFirst()</code> est satisfait d\u00e8s qu\u2019il trouve le premier \u00e9l\u00e9ment qui traverse avec succ\u00e8s le pipeline (ici <code>\"bb\"</code>), donc : - <code>\"ccc\"</code> n\u2019est jamais trait\u00e9 (ni <code>filter</code> ni <code>map</code>) ; - l\u2019\u00e9valuation paresseuse \u00e9vite un travail inutile par rapport \u00e0 une op\u00e9ration terminale qui consomme tous les \u00e9l\u00e9ments (comme <code>forEach</code> ou <code>count</code>).</p> <p></p>"},{"location":"fr/module-05/streams/#215-operations-stateless-vs-stateful","title":"21.5 Op\u00e9rations stateless vs stateful","text":""},{"location":"fr/module-05/streams/#2151-operations-stateless","title":"21.5.1 Op\u00e9rations stateless","text":"<p>Des op\u00e9rations comme <code>map</code> et <code>filter</code> traitent chaque \u00e9l\u00e9ment ind\u00e9pendamment.</p> <p></p>"},{"location":"fr/module-05/streams/#2152-operations-stateful","title":"21.5.2 Op\u00e9rations stateful","text":"<p>Des op\u00e9rations comme <code>distinct</code>, <code>sorted</code> et <code>limit</code> n\u00e9cessitent le maintien d\u2019un \u00e9tat interne.</p> <p>Note</p> <p>Les op\u00e9rations stateful peuvent avoir un impact s\u00e9v\u00e8re sur les performances des streams parall\u00e8les.</p> <p></p>"},{"location":"fr/module-05/streams/#216-ordonnancement-des-streams-et-determinisme","title":"21.6 Ordonnancement des Streams et d\u00e9terminisme","text":"<p>Les streams peuvent \u00eatre :</p> <ul> <li>Ordonn\u00e9s (ex. <code>List.stream()</code>)</li> <li>Non ordonn\u00e9s (ex. <code>HashSet.stream()</code>)</li> </ul> <p>Certaines op\u00e9rations respectent l\u2019ordre de parcours :</p> <ul> <li><code>forEachOrdered</code></li> <li><code>findFirst</code></li> </ul> <p>Note</p> <p>Dans les streams parall\u00e8les, <code>forEach</code> ne garantit pas l\u2019ordre.</p> <p></p>"},{"location":"fr/module-05/streams/#217-streams-paralleles","title":"21.7 Streams parall\u00e8les","text":"<p>Les streams parall\u00e8les divisent le travail entre threads en utilisant <code>ForkJoinPool.commonPool()</code>.</p> <pre><code>int sum =\nIntStream.range(1, 1_000_000)\n    .parallel()\n    .sum();\n</code></pre> <p>R\u00e8gles pour des streams parall\u00e8les s\u00fbrs :</p> <ul> <li>Aucun effet de bord</li> <li>Aucun \u00e9tat partag\u00e9 mutable</li> <li>Uniquement des op\u00e9rations associatives</li> </ul> <p>Note</p> <p>Les streams parall\u00e8les peuvent \u00eatre plus lents pour des charges de travail l\u00e9g\u00e8res.</p> <p></p>"},{"location":"fr/module-05/streams/#218-operations-de-reduction","title":"21.8 Op\u00e9rations de r\u00e9duction","text":""},{"location":"fr/module-05/streams/#2181-reduce-combiner-un-stream-en-un-seul-objet","title":"21.8.1 <code>reduce()</code> : combiner un stream en un seul objet","text":"<p>Il existe trois signatures de m\u00e9thode pour cette op\u00e9ration :</p> <ul> <li>public <code>Optional&lt;T&gt;</code> reduce(<code>BinaryOperator&lt;T&gt; accumulator</code>);</li> <li>public <code>T</code> reduce(<code>T identity</code>, <code>BinaryOperator&lt;T&gt; accumulator</code>);</li> <li>public <code>&lt;U&gt; U</code> reduce(<code>U identity</code>, <code>BiFunction&lt;U, ? super T, U&gt; accumulator</code>, <code>BinaryOperator&lt;U&gt; combiner</code>);</li> </ul> <pre><code>int sum = Stream.of(1, 2, 3)\n    .reduce(0, Integer::sum);\n</code></pre> <p>La r\u00e9duction requiert :</p> <ul> <li>Identity : valeur initiale pour chaque r\u00e9duction partielle ; doit \u00eatre un \u00e9l\u00e9ment neutre ; exemple : 0 pour la somme, 1 pour la multiplication, collection vide pour la collecte ;</li> <li>Accumulator : incorpore un \u00e9l\u00e9ment du stream dans un r\u00e9sultat partiel ;</li> <li>(Optionnel) Combiner : fusionne deux r\u00e9sultats partiels ; utilis\u00e9 uniquement lorsque le stream est parall\u00e8le ; ignor\u00e9 pour les streams s\u00e9quentiels</li> </ul> <p>Note</p> <p>L\u2019accumulator doit \u00eatre associatif et stateless.</p> <p></p>"},{"location":"fr/module-05/streams/#21811-modele-mental-correct","title":"21.8.1.1 Mod\u00e8le mental correct","text":"<ul> <li>Accumulator : r\u00e9sultat + \u00e9l\u00e9ment</li> <li>Combiner : r\u00e9sultat + r\u00e9sultat</li> </ul> <p>Exemple 1 : Utilisation correcte (somme des longueurs)</p> <pre><code>int totalLength =\n    Stream.of(\"a\", \"bb\", \"ccc\")\n          .parallel()\n          .reduce(\n              0,                            // identity\n              (sum, s) -&gt; sum + s.length(), // accumulator\n              (left, right) -&gt; left + right // combiner\n          );\n</code></pre> <p>Ce qui se passe en parall\u00e8le</p> <p>Supposons que le stream soit divis\u00e9 :</p> <ul> <li>Thread 1 : \"a\", \"bb\" \u2192 0 + 1 + 2 = 3</li> <li>Thread 2 : \"ccc\" \u2192 0 + 3 = 3</li> </ul> <p>Ensuite, le combiner fusionne les r\u00e9sultats partiels :</p> <pre><code>3 + 3 = 6\n</code></pre> <p>Exemple 2 : Combiner ignor\u00e9 dans les streams s\u00e9quentiels</p> <pre><code>int result =\n    Stream.of(\"a\", \"bb\", \"ccc\")\n          .reduce(\n              0,\n              (sum, s) -&gt; sum + s.length(),\n              (x, y) -&gt; {\n                  throw new RuntimeException(\"Never called\");\n              }\n          );\n</code></pre> <p>Exemple 3 : Combiner incorrect</p> <pre><code>int result =\n    Stream.of(1, 2, 3, 4)\n          .parallel()\n          .reduce(\n              0,\n              (a, b) -&gt; a - b,   // accumulator\n              (x, y) -&gt; x - y    // combiner\n          );\n</code></pre> <p>Pourquoi ceci est incorrect</p> <p>La soustraction n\u2019est pas associative.</p> <p>Ex\u00e9cution possible :</p> <ul> <li>Thread 1 : 0 - 1 - 2 = -3</li> <li>Thread 2 : 0 - 3 - 4 = -7</li> </ul> <p>Combiner :</p> <pre><code>-3 - (-7) = 4\n</code></pre> <p>Le r\u00e9sultat s\u00e9quentiel serait :</p> <pre><code>(((0 - 1) - 2) - 3) - 4 = -10\n</code></pre> <p>Warning</p> <p>\u274c Les r\u00e9sultats parall\u00e8les et s\u00e9quentiels diff\u00e8rent \u2192 r\u00e9duction ill\u00e9gale</p> <p></p>"},{"location":"fr/module-05/streams/#2182-collect","title":"21.8.2 <code>collect()</code>","text":"<p><code>collect</code> est une r\u00e9duction mutable optimis\u00e9e pour le regroupement et l\u2019agr\u00e9gation.</p> <p>C\u2019est l\u2019outil standard de l\u2019API Stream pour la \u00ab r\u00e9duction mutable \u00bb : vous accumulez des \u00e9l\u00e9ments dans un conteneur mutable (comme une List, Set, Map, StringBuilder, objet r\u00e9sultat personnalis\u00e9), puis, \u00e9ventuellement, vous fusionnez les conteneurs partiels lors de l\u2019ex\u00e9cution en parall\u00e8le.</p> <p>La forme g\u00e9n\u00e9rale est :</p> <ul> <li><code>public &lt;R&gt; R **collect**(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? super T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner)</code>;</li> </ul> <p>Une version couramment utilis\u00e9e est :</p> <ul> <li><code>public &lt;R, A&gt; R **collect**(Collector&lt;? super T, A, R&gt; collector)</code>;</li> </ul> <p>o\u00f9 <code>Collectors.*</code> fournit des collectors pr\u00e9construits (grouping, mapping, joining, counting, etc.).</p> <p>Signification :</p> <ul> <li>supplier : cr\u00e9e un nouveau conteneur de r\u00e9sultat vide (ex. <code>new ArrayList&lt;&gt;()</code>)</li> <li>accumulator : ajoute un \u00e9l\u00e9ment dans ce conteneur (ex. <code>list::add</code>)</li> <li>combiner : fusionne deux conteneurs (ex. <code>list1.addAll(list2)</code>)</li> </ul> <p></p>"},{"location":"fr/module-05/streams/#2183-pourquoi-collect-est-different-de-reduce","title":"21.8.3 Pourquoi <code>collect()</code> est diff\u00e9rent de <code>reduce()</code>","text":"<ul> <li>Intention : mutation vs immutabilit\u00e9<ul> <li><code>reduce()</code> est con\u00e7u pour une r\u00e9duction de style immuable : combiner des valeurs en une nouvelle valeur (ex. somme, min, max).</li> <li><code>collect()</code> est con\u00e7u pour des conteneurs mutables : construire une List, Map, StringBuilder, etc.</li> </ul> </li> <li>Correction en parall\u00e8le<ul> <li><code>reduce()</code> exige que l\u2019op\u00e9ration soit :<ul> <li>associative</li> <li>stateless</li> <li>compatible avec les r\u00e8gles d\u2019identity/combiner</li> </ul> </li> <li><code>collect()</code> est con\u00e7u pour supporter le parall\u00e9lisme en toute s\u00e9curit\u00e9 gr\u00e2ce \u00e0 :<ul> <li>la cr\u00e9ation d\u2019un conteneur par thread (supplier)</li> <li>l\u2019accumulation locale (accumulator)</li> <li>la fusion finale (combiner)</li> </ul> </li> </ul> </li> <li> <p>Performance</p> <ul> <li><code>collect()</code> peut \u00eatre optimis\u00e9 car le runtime du stream sait que vous construisez des conteneurs :<ul> <li>il peut \u00e9viter des copies inutiles</li> <li>il peut pr\u00e9-dimensionner ou utiliser des impl\u00e9mentations sp\u00e9cialis\u00e9es (selon le collector)</li> <li>c\u2019est l\u2019approche idiomatique et attendue</li> <li>utiliser <code>reduce()</code> pour construire une collection cr\u00e9e souvent des objets suppl\u00e9mentaires ou force une mutation non s\u00fbre.</li> </ul> </li> </ul> </li> <li> <p>Exemple : \u00ab collecter dans une List \u00bb de la bonne mani\u00e8re</p> </li> </ul> <pre><code>List&lt;String&gt; longNames =\n    names.stream()\n         .filter(s -&gt; s.length() &gt; 3)\n         .collect(Collectors.toList());\n</code></pre> <ul> <li>Exemple : groupingBy avec explication</li> </ul> <pre><code>Map&lt;Integer, List&lt;String&gt;&gt; byLength =\n    names.stream()\n         .collect(Collectors.groupingBy(String::length));\n</code></pre> <p>Ce qui se passe conceptuellement :</p> <ul> <li>Le collector cr\u00e9e une <code>Map&lt;Integer, List&lt;String&gt;&gt;</code> vide</li> <li>Pour chaque nom :<ul> <li>calcule la cl\u00e9 (<code>String::length</code>)</li> <li>l\u2019ajoute dans la liste du bucket appropri\u00e9</li> </ul> </li> <li>En parall\u00e8le :<ul> <li>chaque thread construit ses propres maps partielles</li> <li>le combiner fusionne les maps en fusionnant les listes par cl\u00e9</li> </ul> </li> </ul> <p></p>"},{"location":"fr/module-05/streams/#219-pieges-courants-des-streams","title":"21.9 Pi\u00e8ges courants des Streams","text":"<ul> <li>R\u00e9utiliser un stream d\u00e9j\u00e0 consomm\u00e9 \u2192 <code>IllegalStateException</code></li> <li>Modifier des variables externes \u00e0 l\u2019int\u00e9rieur des lambda</li> <li>Supposer l\u2019ordre d\u2019ex\u00e9cution dans les streams parall\u00e8les</li> <li>Utiliser <code>peek</code> pour la logique au lieu du debugging</li> </ul>"},{"location":"fr/module-05/streams/#2110-streams-primitifs","title":"21.10 Streams primitifs","text":"<p>Java fournit trois types de streams sp\u00e9cialis\u00e9s pour \u00e9viter le surco\u00fbt du boxing et pour permettre des op\u00e9rations centr\u00e9es sur les nombres :</p> <ul> <li><code>IntStream</code> pour <code>int</code></li> <li><code>LongStream</code> pour <code>long</code></li> <li><code>DoubleStream</code> pour <code>double</code></li> </ul> <p>Les streams primitifs restent des streams (pipelines lazy, op\u00e9rations interm\u00e9diaires + terminales, usage unique), mais ils ne sont pas g\u00e9n\u00e9riques et utilisent des interfaces fonctionnelles sp\u00e9cialis\u00e9es pour les primitifs (ex. <code>IntPredicate</code>, <code>LongUnaryOperator</code>, <code>DoubleConsumer</code>).</p> <p>Note</p> <p>Utilisez les streams primitifs lorsque les donn\u00e9es sont naturellement num\u00e9riques ou lorsque la performance compte : ils \u00e9vitent le surco\u00fbt de boxing/unboxing et fournissent des op\u00e9rations terminales num\u00e9riques suppl\u00e9mentaires.</p> <p></p>"},{"location":"fr/module-05/streams/#21101-pourquoi-les-streams-primitifs-sont-importants","title":"21.10.1 Pourquoi les streams primitifs sont importants","text":"<ul> <li>Performance : \u00e9viter l\u2019allocation d\u2019objets wrapper et le boxing/unboxing r\u00e9p\u00e9t\u00e9 dans de grands pipelines</li> <li>Commodit\u00e9 : r\u00e9ductions num\u00e9riques int\u00e9gr\u00e9es comme <code>sum()</code>, <code>average()</code>, <code>summaryStatistics()</code></li> <li>Pi\u00e8ges courants : comprendre quand les r\u00e9sultats sont primitifs vs <code>OptionalInt</code>/<code>OptionalLong</code>/<code>OptionalDouble</code></li> </ul>"},{"location":"fr/module-05/streams/#21102-methodes-courantes-de-creation","title":"21.10.2 M\u00e9thodes courantes de cr\u00e9ation","text":"<p>Les m\u00e9thodes suivantes sont les plus fr\u00e9quemment utilis\u00e9es pour cr\u00e9er des streams primitifs. De nombreuses questions de certification commencent par identifier le type de stream cr\u00e9\u00e9 par une m\u00e9thode factory.</p> Sources IntStream.of(int...) IntStream.range(int startInclusive, int endExclusive) IntStream.rangeClosed(int startInclusive, int endInclusive) IntStream.iterate(int seed, IntUnaryOperator f) // infini sauf limitation IntStream.iterate(int seed, IntPredicate hasNext, IntUnaryOperator f) IntStream.generate(IntSupplier s) // infini sauf limitation LongStream.of(long...) LongStream.range(long startInclusive, long endExclusive) LongStream.rangeClosed(long startInclusive, long endInclusive) LongStream.iterate(long seed, LongUnaryOperator f) LongStream.iterate(long seed, LongPredicate hasNext, LongUnaryOperator f) LongStream.generate(LongSupplier s) DoubleStream.of(double...) DoubleStream.iterate(double seed, DoubleUnaryOperator f) DoubleStream.iterate(double seed, DoublePredicate hasNext, DoubleUnaryOperator f) DoubleStream.generate(DoubleSupplier s) <p>Important</p> <ul> <li>Seuls <code>IntStream</code> et <code>LongStream</code> fournissent <code>range()</code> et <code>rangeClosed()</code>.</li> <li>Il n\u2019existe pas de <code>DoubleStream.range</code> car le comptage avec des doubles pose des probl\u00e8mes d\u2019arrondi.</li> </ul> <p></p>"},{"location":"fr/module-05/streams/#21103-methodes-de-mapping-specialisees-pour-les-primitifs","title":"21.10.3 M\u00e9thodes de mapping sp\u00e9cialis\u00e9es pour les primitifs","text":"<p>Les streams primitifs fournissent des op\u00e9rations de mapping uniquement pour primitifs afin d\u2019\u00e9viter le boxing :</p> <ul> <li><code>IntStream.map(IntUnaryOperator)</code> \u2192 <code>IntStream</code></li> <li><code>IntStream.mapToLong(IntToLongFunction)</code> \u2192 <code>LongStream</code></li> <li> <p><code>IntStream.mapToDouble(IntToDoubleFunction)</code> \u2192 <code>DoubleStream</code></p> </li> <li> <p><code>LongStream.map(LongUnaryOperator)</code> \u2192 <code>LongStream</code></p> </li> <li><code>LongStream.mapToInt(LongToIntFunction)</code> \u2192 <code>IntStream</code></li> <li> <p><code>LongStream.mapToDouble(LongToDoubleFunction)</code> \u2192 <code>DoubleStream</code></p> </li> <li> <p><code>DoubleStream.map(DoubleUnaryOperator)</code> \u2192 <code>DoubleStream</code></p> </li> <li><code>DoubleStream.mapToInt(DoubleToIntFunction)</code> \u2192 <code>IntStream</code></li> <li><code>DoubleStream.mapToLong(DoubleToLongFunction)</code> \u2192 <code>LongStream</code></li> </ul> <p></p>"},{"location":"fr/module-05/streams/#21104-tableau-de-mapping-entre-streamt-et-les-streams-primitifs","title":"21.10.4 Tableau de mapping entre <code>Stream&lt;T&gt;</code> et les streams primitifs","text":"<p>Ce tableau r\u00e9sume les principales conversions entre streams d\u2019objets et streams primitifs.</p> <p>La colonne \u00ab From \u00bb indique quelles m\u00e9thodes sont disponibles et le type de stream cible r\u00e9sultant.</p> From (source) To (target) Primary method(s) <code>Stream&lt;T&gt;</code> <code>Stream&lt;R&gt;</code> <code>map(Function&lt;? super T, ? extends R&gt;)</code> <code>Stream&lt;T&gt;</code> <code>Stream&lt;R&gt; (flatten)</code> <code>flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt;)</code> <code>Stream&lt;T&gt;</code> <code>IntStream</code> <code>mapToInt(ToIntFunction&lt;? super T&gt;)</code> <code>Stream&lt;T&gt;</code> <code>LongStream</code> <code>mapToLong(ToLongFunction&lt;? super T&gt;)</code> <code>Stream&lt;T&gt;</code> <code>DoubleStream</code> <code>mapToDouble(ToDoubleFunction&lt;? super T&gt;)</code> <code>Stream&lt;T&gt;</code> <code>IntStream (flatten)</code> <code>flatMapToInt(Function&lt;? super T, ? extends IntStream&gt;)</code> <code>Stream&lt;T&gt;</code> <code>LongStream (flatten)</code> <code>flatMapToLong(Function&lt;? super T, ? extends LongStream&gt;)</code> <code>Stream&lt;T&gt;</code> <code>DoubleStream (flatten)</code> <code>flatMapToDouble(Function&lt;? super T, ? extends DoubleStream&gt;)</code> <code>IntStream</code> <code>Stream&lt;Integer&gt;</code> <code>boxed()</code> <code>LongStream</code> <code>Stream&lt;Long&gt;</code> <code>boxed()</code> <code>DoubleStream</code> <code>Stream&lt;Double&gt;</code> <code>boxed()</code> <code>IntStream</code> <code>Stream&lt;U&gt;</code> <code>mapToObj(IntFunction&lt;? extends U&gt;)</code> <code>LongStream</code> <code>Stream&lt;U&gt;</code> <code>mapToObj(LongFunction&lt;? extends U&gt;)</code> <code>DoubleStream</code> <code>Stream&lt;U&gt;</code> <code>mapToObj(DoubleFunction&lt;? extends U&gt;)</code> <code>IntStream</code> <code>LongStream</code> <code>asLongStream()</code> <code>IntStream</code> <code>DoubleStream</code> <code>asDoubleStream()</code> <code>LongStream</code> <code>DoubleStream</code> <code>asDoubleStream()</code> <p>Important</p> <ul> <li>Il n\u2019existe pas d\u2019op\u00e9ration <code>unboxed()</code>.</li> <li>Pour passer des wrappers aux primitifs, vous devez partir de <code>Stream&lt;T&gt;</code> et utiliser <code>mapToInt</code> / <code>mapToLong</code> / <code>mapToDouble</code>.</li> </ul> <p></p>"},{"location":"fr/module-05/streams/#21105-operations-terminales-et-leurs-types-de-resultat","title":"21.10.5 Op\u00e9rations terminales et leurs types de r\u00e9sultat","text":"<p>Les streams primitifs disposent de plusieurs op\u00e9rations terminales qui sont uniques ou qui ont des types de retour sp\u00e9cifiques aux primitifs.</p> Terminal operation IntStream returns LongStream returns DoubleStream returns <code>count()</code> long long long <code>sum()</code> int long double <code>min()</code> / max() OptionalInt OptionalLong OptionalDouble <code>average()</code> OptionalDouble OptionalDouble OptionalDouble <code>findFirst()</code> / findAny() OptionalInt OptionalLong OptionalDouble <code>reduce(op)</code> OptionalInt OptionalLong OptionalDouble <code>reduce(identity, op)</code> int long double <code>summaryStatistics()</code> IntSummaryStatistics LongSummaryStatistics DoubleSummaryStatistics <p>Warning</p> <ul> <li>M\u00eame pour <code>IntStream</code> et <code>LongStream</code>, <code>average()</code> retourne <code>OptionalDouble</code> (et non <code>OptionalInt</code> ou <code>OptionalLong</code>).</li> </ul> <ul> <li>Exemple 1 : <code>Stream&lt;String&gt;</code> \u2192 <code>IntStream</code> \u2192 op\u00e9rations terminales primitives</li> </ul> <pre><code>List&lt;String&gt; words = List.of(\"a\", \"bb\", \"ccc\");\n\nint totalLength = words.stream()\n    .mapToInt(String::length) // IntStream\n    .sum(); // int\n\n// totalLength = 1 + 2 + 3 = 6\n</code></pre> <ul> <li>Exemple 2 : <code>IntStream</code> \u2192 <code>Stream&lt;Integer&gt;</code> box\u00e9 (boxing introduit)</li> </ul> <pre><code>Stream&lt;Integer&gt; boxed = IntStream.rangeClosed(1, 3) // 1,2,3\n    .boxed(); // Stream&lt;Integer&gt;\n</code></pre> <ul> <li>Exemple 3 : stream primitif \u2192 stream d\u2019objets via <code>mapToObj</code></li> </ul> <pre><code>Stream&lt;String&gt; labels = IntStream.range(1, 4) // 1,2,3\n    .mapToObj(i -&gt; \"N=\" + i); // Stream&lt;String&gt;\n</code></pre> <p></p>"},{"location":"fr/module-05/streams/#21106-pieges-et-gotchas-courants","title":"21.10.6 Pi\u00e8ges et gotchas courants","text":"<ul> <li>Ne pas confondre <code>Stream&lt;Integer&gt;</code> avec <code>IntStream</code> : leurs m\u00e9thodes de mapping et interfaces fonctionnelles diff\u00e8rent</li> <li><code>IntStream.sum()</code> retourne <code>int</code> mais <code>IntStream.count()</code> retourne <code>long</code></li> <li><code>average()</code> retourne toujours <code>OptionalDouble</code> pour tous les types de streams primitifs</li> <li>Utiliser <code>boxed()</code> r\u00e9introduit le boxing ; ne le faire que si l\u2019API en aval requiert des objets (ex. collecte dans <code>List&lt;Integer&gt;</code>)</li> <li>Attention aux conversions de narrowing : <code>LongStream.mapToInt</code> et <code>DoubleStream.mapToInt</code> peuvent tronquer les valeurs</li> </ul>"},{"location":"fr/module-05/streams/#2111-collectors-collect-collector-et-les-methodes-factory-de-collectors","title":"21.11 Collectors (collect(), Collector et les m\u00e9thodes factory de Collectors)","text":"<p>Un <code>Collector</code> d\u00e9crit comment accumuler des \u00e9l\u00e9ments de stream dans un r\u00e9sultat final.</p> <p>L\u2019op\u00e9ration terminale <code>collect(...)</code> ex\u00e9cute cette recette.</p> <p>La classe utilitaire <code>Collectors</code> fournit des collectors pr\u00eats \u00e0 l\u2019emploi pour des t\u00e2ches courantes d\u2019agr\u00e9gation.</p> <p></p>"},{"location":"fr/module-05/streams/#21111-collect-vs-collector","title":"21.11.1 collect() vs Collector","text":"<p>Il existe deux mani\u00e8res principales de collecter :</p> <ul> <li><code>collect(Collector)</code> \u2192 la forme courante utilisant <code>Collectors.*</code></li> <li><code>collect(supplier, accumulator, combiner)</code> \u2192 r\u00e9duction mutable explicite (plus bas niveau)</li> </ul> <pre><code>List&lt;String&gt; list =\nStream.of(\"a\", \"b\")\n    .collect(Collectors.toList());\n\nStringBuilder sb =\nStream.of(\"a\", \"b\")\n    .collect(StringBuilder::new, StringBuilder::append, StringBuilder::append);\n</code></pre> <p>Note</p> <p>Utilisez <code>collect(supplier, accumulator, combiner)</code> lorsque vous avez besoin d\u2019un conteneur mutable personnalis\u00e9 et que vous ne souhaitez pas impl\u00e9menter un <code>Collector</code> complet.</p> <p></p>"},{"location":"fr/module-05/streams/#21112-collectors-principaux","title":"21.11.2 Collectors principaux","text":"<p>Voici les collectors les plus fr\u00e9quemment utilis\u00e9s et les plus susceptibles d\u2019appara\u00eetre dans les questions d\u2019examen.</p> <ul> <li><code>toList()</code> \u2192 <code>List&lt;T&gt;</code> (aucune garantie sur la mutabilit\u00e9 ou l\u2019impl\u00e9mentation)</li> <li><code>toSet()</code> \u2192 <code>Set&lt;T&gt;</code></li> <li><code>toCollection(supplier)</code> \u2192 type de collection sp\u00e9cifique (ex. <code>TreeSet</code>)</li> <li><code>joining(delim, prefix, suffix)</code> \u2192 <code>String</code> \u00e0 partir d\u2019\u00e9l\u00e9ments <code>CharSequence</code></li> <li><code>counting()</code> \u2192 comptage <code>Long</code></li> <li><code>summingInt</code> / <code>summingLong</code> / <code>summingDouble</code> \u2192 sommes num\u00e9riques</li> <li><code>averagingInt</code> / <code>averagingLong</code> / <code>averagingDouble</code> \u2192 moyennes num\u00e9riques</li> <li><code>minBy(comparator)</code> / <code>maxBy(comparator)</code> \u2192 <code>Optional&lt;T&gt;</code></li> <li><code>mapping(mapper, downstream)</code> \u2192 transforme puis collecte avec un downstream</li> <li><code>filtering(predicate, downstream)</code> \u2192 filtre \u00e0 l\u2019int\u00e9rieur du collector (Java 9+)</li> </ul> <p></p>"},{"location":"fr/module-05/streams/#21113-collectors-de-regroupement","title":"21.11.3 Collectors de regroupement","text":"<p><code>groupingBy</code> classe les \u00e9l\u00e9ments dans des buckets \u00e0 l\u2019aide d\u2019une fonction classifier.</p> <p>Il produit une <code>Map&lt;K, V&gt;</code> o\u00f9 <code>V</code> d\u00e9pend du collector downstream.</p> <pre><code>Map&lt;Integer, List&lt;String&gt;&gt; byLen =\nStream.of(\"a\", \"bb\", \"ccc\", \"dd\")\n    .collect(Collectors.groupingBy(String::length));\nSystem.out.println(\"byLen: \" + byLen.toString());\n</code></pre> <p>Sortie :</p> <pre><code>byLen: {1=[a], 2=[bb, dd], 3=[ccc]}\n</code></pre> <p>Avec un collector downstream, vous contr\u00f4lez ce que contient chaque bucket :</p> <pre><code>Map&lt;Integer, Long&gt; countByLen =\nStream.of(\"a\", \"bb\", \"ccc\", \"dd\")\n    .collect(Collectors.groupingBy(String::length, Collectors.counting()));\nSystem.out.println(\"countByLen: \" + countByLen.toString());\n\nMap&lt;Integer, Set&lt;String&gt;&gt; setByLen =\nStream.of(\"a\", \"bb\", \"ccc\", \"dd\")\n    .collect(Collectors.groupingBy(String::length, Collectors.toSet()));\nSystem.out.println(\"setByLen: \" + setByLen.toString());\n</code></pre> <p>Sortie :</p> <pre><code>countByLen: {1=1, 2=2, 3=1}\nsetByLen: {1=[a], 2=[bb, dd], 3=[ccc]}\n</code></pre> <p>Warning</p> <p>Faites attention au type de la valeur de la map r\u00e9sultante. Exemple : <code>groupingBy(..., counting())</code> produit <code>Map&lt;K, Long&gt;</code> (et non <code>int</code>).</p> <p></p>"},{"location":"fr/module-05/streams/#21114-partitioningby","title":"21.11.4 partitioningBy","text":"<p><code>partitioningBy</code> divise le stream en exactement deux groupes \u00e0 l\u2019aide d\u2019un <code>Predicate</code> bool\u00e9en. Il retourne toujours une map avec les cl\u00e9s <code>true</code> et <code>false</code>.</p> <pre><code>Map&lt;Boolean, List&lt;String&gt;&gt; parts =\nStream.of(\"a\", \"bb\", \"ccc\")\n    .collect(Collectors.partitioningBy(s -&gt; s.length() &gt; 1));\nSystem.out.println(\"parts: \" + parts.toString());\n</code></pre> <p>Sortie :</p> <pre><code>parts: {false=[a], true=[bb, ccc]}\n</code></pre> <p>Note</p> <p><code>partitioningBy</code> cr\u00e9e toujours deux buckets, tandis que <code>groupingBy</code> peut en cr\u00e9er plusieurs. Les deux prennent en charge des collectors downstream.</p> <p></p>"},{"location":"fr/module-05/streams/#21115-tomap-et-regles-de-fusion","title":"21.11.5 toMap et r\u00e8gles de fusion","text":"<p><code>toMap</code> l\u00e8ve une exception en cas de cl\u00e9s dupliqu\u00e9es sauf si vous fournissez une fonction de fusion.</p> <pre><code>Map&lt;Integer, String&gt; m1 =\nStream.of(\"aa\", \"bb\")\n    .collect(Collectors.toMap(String::length, s -&gt; s)); // \u274c Exception in thread \"main\" java.lang.IllegalStateException: Duplicate key 2 (attempted merging values aa and bb)\n\nMap&lt;Integer, String&gt; m2 =\nStream.of(\"aa\", \"bb\", \"cc\")\n    .collect(Collectors.toMap(String::length, s -&gt; s, (oldV, newV) -&gt; oldV + \",\" + newV)); // key=2 merges values\n</code></pre> <p>Sortie :</p> <pre><code>m2: {2=aa,bb,cc}\n</code></pre> <p></p>"},{"location":"fr/module-05/streams/#21116-collectingandthen","title":"21.11.6 collectingAndThen","text":"<p><code>collectingAndThen(downstream, finisher)</code> permet d\u2019appliquer une transformation finale apr\u00e8s la collecte (ex. rendre la liste non modifiable).</p> <pre><code>List&lt;String&gt; unmodifiable =\nStream.of(\"a\", \"b\", \"c\")\n    .collect(Collectors.collectingAndThen(Collectors.toList(), List::copyOf));\n</code></pre> <p></p>"},{"location":"fr/module-05/streams/#21117-comment-les-collectors-se-rapportent-aux-streams-paralleles","title":"21.11.7 Comment les collectors se rapportent aux streams parall\u00e8les","text":"<p>Les collectors sont con\u00e7us pour fonctionner avec des streams parall\u00e8les en utilisant supplier/accumulator/combiner en interne. En parall\u00e8le, chaque worker construit un conteneur de r\u00e9sultat partiel puis fusionne les conteneurs.</p> <ul> <li>L\u2019accumulator modifie un conteneur par thread (aucun \u00e9tat partag\u00e9 mutable)</li> <li>Le combiner fusionne les conteneurs (requis pour l\u2019ex\u00e9cution parall\u00e8le)</li> <li>Certains collectors sont \u00ab concurrent \u00bb ou poss\u00e8dent des caract\u00e9ristiques influen\u00e7ant les performances et l\u2019ordonnancement</li> </ul> <p>Note</p> <p>Pr\u00e9f\u00e9rez <code>collect(Collectors.toList())</code> \u00e0 l\u2019utilisation de <code>reduce</code> pour construire des collections. <code>reduce</code> est destin\u00e9 aux r\u00e9ductions de style immuable ; <code>collect</code> est destin\u00e9 aux conteneurs mutables.</p>"},{"location":"fr/module-06/collections/","title":"22. Introduction au Framework des Collections","text":""},{"location":"fr/module-06/collections/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>22.1 Qu\u2019est-ce que le Framework des Collections</li> <li>22.2 Les Interfaces Principales<ul> <li>22.2.1 Principales interfaces de Collection</li> <li>22.2.2 Hi\u00e9rarchie de Map</li> </ul> </li> <li>22.3 Collections Sequenced Java-21</li> <li>22.4 Pourquoi le Framework des Collections existe</li> <li>22.5 Les deux c\u00f4t\u00e9s du Framework Collections-vs-Maps</li> <li>22.6 Types g\u00e9n\u00e9riques dans le Framework des Collections</li> <li>22.7 Mutabilit\u00e9 vs Immutabilit\u00e9</li> <li>22.8 Attentes de Performance Big-O</li> <li>22.9 R\u00e9sum\u00e9</li> </ul> <p>Le <code>Java Collections Framework (JCF)</code> est un ensemble d\u2019interfaces, de classes et d\u2019algorithmes con\u00e7u pour stocker, manipuler et traiter des groupes de donn\u00e9es de mani\u00e8re efficace.</p> <p>Il fournit une architecture unifi\u00e9e pour g\u00e9rer les collections, permettant aux d\u00e9veloppeurs d\u2019\u00e9crire du code r\u00e9utilisable et interop\u00e9rable avec des comportements pr\u00e9visibles et des caract\u00e9ristiques de performance.</p> <p>Ce chapitre introduit les concepts fondamentaux n\u00e9cessaires avant d\u2019\u00e9tudier List, Set, Queue, Map et les Sequenced Collections, explor\u00e9s en d\u00e9tail dans les chapitres suivants.</p> <p></p>"},{"location":"fr/module-06/collections/#221-quest-ce-que-le-framework-des-collections","title":"22.1 Qu\u2019est-ce que le Framework des Collections ?","text":"<p>Le Framework des Collections fournit :</p> <ul> <li>Un ensemble d\u2019interfaces (Collection, List, Set, Queue, Deque, Map\u2026)</li> <li>Un ensemble d\u2019impl\u00e9mentations (ArrayList, HashSet, TreeSet, LinkedList\u2026)</li> <li>Un ensemble d\u2019algorithmes utilitaires (tri, recherche, copie, inversion\u2026) dans java.util.Collections et java.util.Arrays.</li> <li>Un langage commun pour les attentes de performance (complexit\u00e9 Big-O).</li> </ul> <p>Toutes les principales structures de collection partagent une conception coh\u00e9rente, de sorte que le code fonctionnant avec une impl\u00e9mentation peut souvent \u00eatre r\u00e9utilis\u00e9 avec une autre.</p> <p></p>"},{"location":"fr/module-06/collections/#222-les-interfaces-principales","title":"22.2 Les Interfaces Principales","text":"<p>Au c\u0153ur du Java Collections Framework se trouve un petit ensemble d\u2019interfaces racines qui d\u00e9finissent des comportements g\u00e9n\u00e9riques de gestion des donn\u00e9es.</p> <ul> <li>List : une collection <code>ordonn\u00e9e</code> d\u2019\u00e9l\u00e9ments qui autorise les <code>doublons</code> ;</li> <li>Set : une collection qui n\u2019autorise pas les <code>doublons</code> ;</li> <li>Queue : une collection con\u00e7ue pour contenir des \u00e9l\u00e9ments en cours de traitement, typiquement FIFO (first-in-first-out), avec des variantes comme les priority queues et les deques.</li> <li>Map : une structure qui associe des cl\u00e9s \u00e0 des valeurs, o\u00f9 les cl\u00e9s dupliqu\u00e9es ne sont pas autoris\u00e9es ; chaque cl\u00e9 peut \u00eatre associ\u00e9e \u00e0 au plus une valeur.</li> </ul> <p></p>"},{"location":"fr/module-06/collections/#2221-principales-interfaces-de-collection","title":"22.2.1 Principales interfaces de Collection","text":"<p>Ci-dessous se trouve la hi\u00e9rarchie conceptuelle.</p> <pre><code>java.util\n\u251c\u2500 Collection&lt;E&gt;\n\u2502 \u251c\u2500 SequencedCollection&lt;E&gt; (Java 21+)\n\u2502 \u2502 \u251c\u2500 List&lt;E&gt;\n\u2502 \u2502 \u2502   \u251c\u2500 ArrayList&lt;E&gt;\n\u2502 \u2502 \u2502   \u2514\u2500 LinkedList&lt;E&gt; (also implements Deque&lt;E&gt;)\n\u2502 \u2502 \u2514\u2500 Deque&lt;E&gt; (also extends Queue&lt;E&gt;)\n\u2502 \u2502     \u251c\u2500 ArrayDeque&lt;E&gt;\n\u2502 \u2502     \u2514\u2500 LinkedList&lt;E&gt;\n\u2502 \u251c\u2500 Set&lt;E&gt;\n\u2502 \u2502     \u251c\u2500 SequencedSet&lt;E&gt; (Java 21+)\n\u2502 \u2502     \u2502       \u2514\u2500 LinkedHashSet&lt;E&gt;\n\u2502 \u2502     \u251c\u2500 SortedSet&lt;E&gt;\n\u2502 \u2502     \u2502       \u2514\u2500 NavigableSet&lt;E&gt;\n\u2502 \u2502     \u2502           \u2514\u2500 TreeSet&lt;E&gt;\n\u2502 \u2502     \u251c\u2500 HashSet&lt;E&gt;\n\u2502 \u2502     \u2514\u2500 (other Set implementations)\n\u2502 \u251c\u2500 Queue&lt;E&gt;\n\u2502 \u2502     \u251c\u2500 Deque&lt;E&gt; (already under SequencedCollection&lt;E&gt;)\n\u2502 \u2502     \u251c\u2500 PriorityQueue&lt;E&gt;\n\u2502 \u2502     \u2514\u2500 (other Queue implementations)\n\u2502 \u2514\u2500 (other Collection implementations)\n\u2502\n\u2514\u2500 Map&lt;K,V&gt; (not a Collection)\n    \u251c\u2500 SequencedMap&lt;K,V&gt; (Java 21+)\n    \u2502   \u2514\u2500 LinkedHashMap&lt;K,V&gt;\n    \u251c\u2500 SortedMap&lt;K,V&gt;\n    \u2502   \u2514\u2500 NavigableMap&lt;K,V&gt;\n    \u2502   \u2514\u2500 TreeMap&lt;K,V&gt;\n    \u251c\u2500 HashMap&lt;K,V&gt;\n    \u251c\u2500 Hashtable&lt;K,V&gt;\n    \u2514\u2500 (other Map/ConcurrentMap implementations)\n</code></pre> <p>L\u2019interface Map n\u2019\u00e9tend pas Collection, car une map stocke des paires cl\u00e9/valeur plut\u00f4t que des valeurs uniques.</p> <p></p>"},{"location":"fr/module-06/collections/#2222-hierarchie-de-map","title":"22.2.2 Hi\u00e9rarchie de Map","text":"<pre><code>java.util\n\u2514\u2500 Map&lt;K,V&gt;\n    \u251c\u2500 SequencedMap&lt;K,V&gt; (Java 21+)\n    \u2502   \u2514\u2500 LinkedHashMap&lt;K,V&gt;\n    \u251c\u2500 SortedMap&lt;K,V&gt;\n    \u2502   \u2514\u2500 NavigableMap&lt;K,V&gt;\n    \u2502       \u2514\u2500 TreeMap&lt;K,V&gt;\n    \u251c\u2500 HashMap&lt;K,V&gt;\n    \u251c\u2500 Hashtable&lt;K,V&gt;\n    \u2514\u2500 ConcurrentMap&lt;K,V&gt; (java.util.concurrent)\n        \u2514\u2500 ConcurrentHashMap&lt;K,V&gt;\n</code></pre>"},{"location":"fr/module-06/collections/#223-collections-sequenced-java-21","title":"22.3 Collections Sequenced (Java 21+)","text":"<p>Java 21 introduit la nouvelle interface <code>SequencedCollection</code>, qui formalise l\u2019id\u00e9e qu\u2019une collection maintient un ordre de parcours d\u00e9fini. Cela \u00e9tait d\u00e9j\u00e0 vrai pour List, LinkedHashSet, LinkedHashMap, Deque, etc., mais ce comportement est d\u00e9sormais standardis\u00e9.</p> <ul> <li><code>SequencedCollection</code> d\u00e9finit des m\u00e9thodes telles que <code>getFirst()</code>, <code>getLast()</code>, <code>addFirst()</code>, <code>addLast()</code>, <code>removeFirst()</code>, <code>removeLast()</code> et <code>reversed()</code>.</li> <li>SequencedSet et SequencedMap \u00e9tendent ce concept aux sets et aux maps.</li> </ul> <p>Cela simplifie consid\u00e9rablement la sp\u00e9cification des comportements d\u2019ordonnancement et sera utilis\u00e9 dans tous les chapitres suivants.</p> <p></p>"},{"location":"fr/module-06/collections/#224-pourquoi-le-framework-des-collections-existe","title":"22.4 Pourquoi le Framework des Collections existe","text":"<ul> <li>\u00c9viter de r\u00e9inventer les structures de donn\u00e9es</li> <li>Fournir des algorithmes bien test\u00e9s et hautement performants</li> <li>Am\u00e9liorer l\u2019interop\u00e9rabilit\u00e9 gr\u00e2ce \u00e0 des interfaces partag\u00e9es</li> <li>Prendre en charge les types g\u00e9n\u00e9riques pour des collections s\u00fbres du point de vue du type</li> </ul> <p>Avant Java 1.2, les structures de donn\u00e9es \u00e9taient ad hoc, incoh\u00e9rentes et non typ\u00e9es.</p> <p>Le Collections Framework a unifi\u00e9 tout cela dans une API coh\u00e9rente.</p> <p></p>"},{"location":"fr/module-06/collections/#225-les-deux-cotes-du-framework-collections-vs-maps","title":"22.5 Les deux c\u00f4t\u00e9s du Framework : Collections vs Maps","text":"<p>\u00ab Map \u00e9tend-elle Collection ? \u00bb Non. Une Map stocke des paires, tandis qu\u2019une Collection stocke des \u00e9l\u00e9ments uniques.</p> <ul> <li>Collection = List, Set, Queue, Deque, SequencedCollection</li> <li>Map = stockage cl\u00e9/valeur de type dictionnaire</li> </ul> <p></p>"},{"location":"fr/module-06/collections/#226-types-generiques-dans-le-framework-des-collections","title":"22.6 Types g\u00e9n\u00e9riques dans le Framework des Collections","text":"<p>Les collections sont presque toujours utilis\u00e9es avec des generics. L\u2019utilisation de raw types est d\u00e9conseill\u00e9e.</p> <pre><code>List&lt;String&gt; names = new ArrayList&lt;&gt;();\nMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();\n</code></pre> <p>Note</p> <p>Les generics dans les collections fonctionnent via le <code>type erasure</code> : se r\u00e9f\u00e9rer au paragraphe \"18.4 Type Erasure\" dans le chapitre : Generics in Java.</p> <p></p>"},{"location":"fr/module-06/collections/#227-mutabilite-vs-immutabilite","title":"22.7 Mutabilit\u00e9 vs Immutabilit\u00e9","text":"<p>De nombreuses m\u00e9thodes de la Collections API renvoient des collections unmodifiable :</p> <pre><code>List&lt;String&gt; immutable = List.of(\"a\", \"b\");\nimmutable.add(\"c\"); // \u274c UnsupportedOperationException\n</code></pre> <p>Java fournit plusieurs moyens de cr\u00e9er des collections immuables :</p> <ul> <li><code>List.of()</code>, <code>Set.of()</code>, <code>Map.of()</code></li> <li><code>List.copyOf(collection)</code></li> <li>wrappers <code>Collections.unmodifiableList(...)</code></li> <li><code>Records</code> utilis\u00e9s comme conteneurs de valeurs immuables</li> </ul> <p>Note</p> <p>La m\u00e9thode <code>Arrays.asList(varargs)</code>, qui est construite sur un tableau, se comporte diff\u00e9remment : voir les exemples ci-dessous.</p> <pre><code>String[] vargs = new String[] {\"u\", \"v\", \"z\"};\nList&lt;String&gt; fromAsList = Arrays.asList(vargs);\n\nList&lt;String&gt; immutable1 = List.of(vargs);\nimmutable1.add(\"c\"); // \u274c UnsupportedOperationException\n\nList&lt;String&gt; immutable2 = List.copyOf(fromAsList);\nimmutable2.set(0, \"k\"); // \u274c UnsupportedOperationException\n\n\n// Nous ne pouvons pas ADD ou REMOVE des \u00e9l\u00e9ments de \"fromAsList\" mais nous pouvons les remplacer ;\n// soit en modifiant le tableau sous-jacent \"vargs\", soit en mutant la liste elle-m\u00eame :\n\n\nfromAsList.set(0, \"k\");  // la mise \u00e0 jour sera \u00e9galement refl\u00e9t\u00e9e dans le tableau sous-jacent.\n</code></pre> <p>Note</p> <p><code>Arrays.asList(...)</code> renvoie une vue List de taille fixe, mais mutable, support\u00e9e par le tableau d\u2019origine. Vous ne pouvez pas ajouter/supprimer des \u00e9l\u00e9ments, mais vous pouvez remplacer ceux existants.</p> <p></p>"},{"location":"fr/module-06/collections/#228-attentes-de-performance-big-o","title":"22.8 Attentes de Performance Big-O","text":"<p>Comprendre la complexit\u00e9 des types de collection est essentiel. Voici quelques exemples courants :</p> Type Methods Complexity ArrayList <code>get()</code>, <code>add()</code>, <code>remove()</code> <code>O(1)</code>, <code>O(1) amorti</code>, <code>O(n)</code> LinkedList <code>get()</code>, <code>add/remove first/last</code> <code>O(n)</code>,  <code>O(1)</code> HashSet <code>add()</code>, <code>contains()</code>, <code>remove()</code> ~ <code>O(1)</code> TreeSet <code>add()</code>, <code>contains()</code>, <code>remove()</code> <code>O(log n)</code> HashMap <code>get()/put()</code> ~ <code>O(1) en moyenne</code> TreeMap <code>get()/put()</code> <code>O(log n)</code> Deque <code>add/remove first/last</code> <code>O(1)</code> <p>Note</p> <p>Ces valeurs sont des moyennes ; le pire cas peut \u00eatre diff\u00e9rent (en particulier pour les structures bas\u00e9es sur le hachage).</p> <p></p>"},{"location":"fr/module-06/collections/#229-resume","title":"22.9 R\u00e9sum\u00e9","text":"<ul> <li>Le Collection Framework est construit sur un petit ensemble d\u2019interfaces principales.</li> <li>Java 21 ajoute les Sequenced Collections pour unifier le comportement d\u2019ordonnancement.</li> <li>Les Map ne sont pas des Collection \u2014 elles forment une hi\u00e9rarchie parall\u00e8le.</li> <li>Les collections font un usage intensif des generics.</li> <li>La mutabilit\u00e9 est importante \u2014 les m\u00e9thodes factory renvoient souvent des collections immuables.</li> <li>Les caract\u00e9ristiques de performance sont pr\u00e9visibles.</li> </ul>"},{"location":"fr/module-06/comparing/","title":"24. Comparable, Comparator &amp; Tri en Java","text":""},{"location":"fr/module-06/comparing/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>24.1 Comparable \u2014 Ordre Naturel<ul> <li>24.1.1 Contrat de la M\u00e9thode Comparable</li> <li>24.1.2 Classe d\u2019Exemple Impl\u00e9mentant Comparable</li> <li>24.1.3 Erreurs Courantes de Comparable</li> </ul> </li> <li>24.2 Comparator \u2014 Ordre Personnalis\u00e9<ul> <li>24.2.1 M\u00e9thodes Principales de Comparator<ul> <li>24.2.1.1 M\u00e9thodes de Support Statiques de Comparator</li> <li>24.2.1.2 M\u00e9thodes d\u2019Instance sur Comparator</li> </ul> </li> <li>24.2.2 Exemple de Comparator</li> </ul> </li> <li>24.3 Comparable vs Comparator</li> <li>24.4 Tri des Tableaux et des Collections<ul> <li>24.4.1 Arrays sort</li> <li>24.4.2 Collections sort</li> </ul> </li> <li>24.5 Tri Multi-Niveaux thenComparing</li> <li>24.6 Comparer les Primitifs Efficacement</li> <li>24.7 Pi\u00e8ges Courants</li> <li>24.8 Exemple Complet</li> <li>24.9 R\u00e9sum\u00e9</li> </ul> <p>Java fournit deux strat\u00e9gies principales pour le tri et la comparaison : <code>Comparable</code> (ordre naturel) et <code>Comparator</code> (ordre personnalis\u00e9).</p> <p>Comprendre leurs r\u00e8gles, leurs contraintes et leurs interactions avec les <code>generics</code> est essentiel.</p> <ul> <li>Pour les types num\u00e9riques, le tri suit l\u2019ordre num\u00e9rique naturel, ce qui signifie que les valeurs plus petites pr\u00e9c\u00e8dent les valeurs plus grandes.</li> <li>Le tri des cha\u00eenes suit l\u2019ordre lexicographique (<code>code point</code> Unicode) : comparaison caract\u00e8re par caract\u00e8re ; les chiffres viennent avant les majuscules, les majuscules avant les minuscules.</li> </ul> <p>Cet ordre est bas\u00e9 sur le <code>code point Unicode</code> de chaque caract\u00e8re, et non sur une intuition alphab\u00e9tique.</p> <p>Un Unicode code point est une valeur num\u00e9rique unique attribu\u00e9e aux caract\u00e8res dans le standard Unicode.</p> <p>Plus pr\u00e9cis\u00e9ment : un <code>Unicode code point</code> est un entier (\u00e9crit en hexad\u00e9cimal sous la forme U+XXXX) qui repr\u00e9sente un caract\u00e8re, un symbole ou un caract\u00e8re sp\u00e9cial sp\u00e9cifique ind\u00e9pendamment de la police, de la langue ou de la plateforme.</p> <ul> <li>Exemples :<ul> <li>U+0041 \u2192 A</li> <li>U+0061 \u2192 a</li> <li>U+0030 \u2192 0</li> <li>U+1F600 \u2192 \ud83d\ude00</li> </ul> </li> </ul> <p>Un code point n\u2019est pas une s\u00e9quence d\u2019octets ; c\u2019est un nombre abstrait.</p> <p>La mani\u00e8re dont le code point est ensuite stock\u00e9 en m\u00e9moire physique d\u00e9pend de l\u2019encodage (UTF-8, UTF-16, UTF-32).</p> <p>Unicode d\u00e9finit les code points de U+0000 \u00e0 U+10FFFF.</p> <p>En bref : les Unicode code points d\u00e9finissent quel est le caract\u00e8re ; les encodings d\u00e9finissent comment celui-ci est repr\u00e9sent\u00e9 en octets.</p> <ul> <li>Exemples d\u2019ordre naturel</li> </ul> <pre><code>List&lt;String&gt; items = List.of(\"10\", \"2\", \"A\", \"Z\", \"a\", \"b\");\n\nList&lt;String&gt; sorted = new ArrayList&lt;&gt;(items);\nCollections.sort(sorted);\n\nSystem.out.println(sorted);\n</code></pre> <p>Sortie :</p> <pre><code>[10, 2, A, Z, a, b]\n</code></pre> <p>Note</p> <p>L\u2019ordre naturel est d\u00e9fini uniquement pour les types qui impl\u00e9mentent <code>Comparable</code>.</p> <p></p>"},{"location":"fr/module-06/comparing/#241-comparable-ordre-naturel","title":"24.1 Comparable \u2014 Ordre Naturel","text":"<p>L\u2019interface <code>Comparable&lt;T&gt;</code> d\u00e9finit l\u2019ordre naturel d\u2019un type.</p> <p>Une classe l\u2019impl\u00e9mente lorsqu\u2019elle souhaite d\u00e9finir sa r\u00e8gle de tri par d\u00e9faut.</p> <p></p>"},{"location":"fr/module-06/comparing/#2411-contrat-de-la-methode-comparable","title":"24.1.1 Contrat de la M\u00e9thode Comparable","text":"<pre><code>public interface Comparable&lt;T&gt; {\n    int compareTo(T other);\n}\n</code></pre> <p>R\u00e8gles et valeur de retour :</p> <ul> <li>Retourne n\u00e9gatif \u2192 <code>this</code> &lt; <code>other</code></li> <li>Retourne z\u00e9ro \u2192 <code>this</code> == <code>other</code></li> <li>Retourne positif \u2192 <code>this</code> &gt; <code>other</code></li> </ul> <p>Important</p> <ul> <li>L\u2019ordre naturel doit \u00eatre coh\u00e9rent avec <code>equals()</code>, sauf si explicitement document\u00e9 autrement :</li> <li><code>compareTo()</code> est coh\u00e9rent avec <code>equals()</code> si, et seulement si, <code>a.compareTo(b) == 0</code> et <code>a.equals(b) est true</code>.</li> </ul> <p>Warning</p> <p>compareTo peut lever une ClassCastException s\u2019il re\u00e7oit un type non comparable \u2014 mais cela se produit g\u00e9n\u00e9ralement uniquement avec des types raw.</p> <p></p>"},{"location":"fr/module-06/comparing/#2412-exemple-classe-implementant-comparable","title":"24.1.2 Exemple : Classe Impl\u00e9mentant Comparable","text":"<pre><code>public class Person implements Comparable&lt;Person&gt; {\n\n    private String name;\n    private int age;\n\n    public Person(String n, int a) {\n        this.name = n;\n        this.age = a;\n    }\n\n    @Override\n    public int compareTo(Person other) {\n        return Integer.compare(this.age, other.age);\n    }\n\n\n}\n\nvar list = List.of(new Person(\"Bob\", 40), new Person(\"Alice\", 30));\n\nlist.stream().sorted().forEach(p -&gt; System.out.println(p.getAge()));\n</code></pre> <p>La liste est tri\u00e9e par \u00e2ge, car il s\u2019agit de l\u2019ordre num\u00e9rique naturel.</p> <p></p>"},{"location":"fr/module-06/comparing/#2413-erreurs-courantes-de-comparable","title":"24.1.3 Erreurs Courantes de Comparable","text":"<ul> <li>Comparer tous les champs pertinents \u2192 r\u00e9sultats incoh\u00e9rents si ce n\u2019est pas le cas</li> <li>Violer la transitivit\u00e9 \u2192 conduit \u00e0 un comportement ind\u00e9fini</li> <li>Lever des exceptions dans compareTo() casse le tri</li> <li>Ne pas impl\u00e9menter la m\u00eame logique que equals() \u2192 pi\u00e8ge courant</li> </ul>"},{"location":"fr/module-06/comparing/#242-comparator-ordre-personnalise","title":"24.2 Comparator \u2014 Ordre Personnalis\u00e9","text":"<p>L\u2019interface <code>Comparator&lt;T&gt;</code> permet de d\u00e9finir plusieurs strat\u00e9gies de tri sans modifier la classe elle-m\u00eame.</p> <p></p>"},{"location":"fr/module-06/comparing/#2421-methodes-principales-de-comparator","title":"24.2.1 M\u00e9thodes Principales de Comparator","text":"<pre><code>int compare(T a, T b);\n</code></pre> <p>M\u00e9thodes de support suppl\u00e9mentaires :</p> <p></p>"},{"location":"fr/module-06/comparing/#24211-methodes-de-support-statiques-de-comparator","title":"24.2.1.1 M\u00e9thodes de Support Statiques de Comparator","text":"M\u00e9thode Statique / Instance Type de Retour Param\u00e8tres Description <code>Comparator.comparing(keyExtractor)</code> statique Comparator Function&lt;? super T, ? extends U&gt; Construit un comparator comparant les cl\u00e9s extraites en utilisant l\u2019ordre naturel. <code>Comparator.comparing(keyExtractor, keyComparator)</code> statique Comparator Function, Comparator Construit un comparator comparant les cl\u00e9s extraites \u00e0 l\u2019aide d\u2019un comparator personnalis\u00e9. <code>Comparator.comparingInt(keyExtractor)</code> statique Comparator ToIntFunction Comparator optimis\u00e9 pour les cl\u00e9s int (\u00e9vite le boxing). <code>Comparator.comparingLong(keyExtractor)</code> statique Comparator ToLongFunction Comparator optimis\u00e9 pour les cl\u00e9s long. <code>Comparator.comparingDouble(keyExtractor)</code> statique Comparator ToDoubleFunction Comparator optimis\u00e9 pour les cl\u00e9s double. <code>Comparator.naturalOrder()</code> statique Comparator none Comparator utilisant l\u2019ordre naturel (Comparable). <code>Comparator.reverseOrder()</code> statique Comparator none Ordre naturel invers\u00e9. <code>Comparator.nullsFirst(comparator)</code> statique Comparator Comparator Enveloppe un comparator afin que les null soient compar\u00e9s avant les non-null. <code>Comparator.nullsLast(comparator)</code> statique Comparator Comparator Enveloppe un comparator afin que les null soient compar\u00e9s apr\u00e8s les non-null."},{"location":"fr/module-06/comparing/#24212-methodes-dinstance-sur-comparator","title":"24.2.1.2 M\u00e9thodes d\u2019Instance sur Comparator","text":"M\u00e9thode Statique / Instance Type de Retour Param\u00e8tres Description <code>thenComparing(otherComparator)</code> instance Comparator Comparator Ajoute un comparator secondaire lorsque le primaire compare comme \u00e9gal. <code>thenComparing(keyExtractor)</code> instance Comparator Function Comparaison secondaire utilisant l\u2019ordre naturel de la cl\u00e9 extraite. <code>thenComparing(keyExtractor, keyComparator)</code> instance Comparator Function, Comparator Comparaison secondaire avec un comparator personnalis\u00e9. <code>thenComparingInt(keyExtractor)</code> instance Comparator ToIntFunction Comparaison num\u00e9rique secondaire (optimis\u00e9e). <code>thenComparingLong(keyExtractor)</code> instance Comparator ToLongFunction Comparaison num\u00e9rique secondaire. <code>thenComparingDouble(keyExtractor)</code> instance Comparator ToDoubleFunction Comparaison num\u00e9rique secondaire. <code>reversed()</code> instance Comparator none Retourne un comparator invers\u00e9 pour la m\u00eame logique de comparaison."},{"location":"fr/module-06/comparing/#2422-exemple-de-comparator","title":"24.2.2 Exemple de Comparator","text":"<pre><code>var people = List.of(new Person(\"Bob\",40), new Person(\"Ann\",30));\n\nComparator&lt;Person&gt; byName = Comparator.comparing(Person::getName);\n\nComparator&lt;Person&gt; byAgeDesc = Comparator.comparingInt(Person::getAge).reversed();\n\nvar sorted = people.stream().sorted(byName.thenComparing(byAgeDesc)).toList();\n</code></pre>"},{"location":"fr/module-06/comparing/#243-comparable-vs-comparator","title":"24.3 Comparable vs Comparator","text":"Caract\u00e9ristique Comparable Comparator Package java.lang java.util M\u00e9thode compareTo(T) compare(T,T) Type de Tri Naturel (par d\u00e9faut) Personnalis\u00e9 (strat\u00e9gies multiples) Modifie la Classe Source OUI NON Utile Pour Ordre par d\u00e9faut Ordre externe ou alternatif Autorise Plusieurs Ordres NON OUI Utilis\u00e9 par Collections.sort OUI OUI Utilis\u00e9 par Arrays.sort OUI OUI"},{"location":"fr/module-06/comparing/#244-tri-des-tableaux-et-des-collections","title":"24.4 Tri des Tableaux et des Collections","text":""},{"location":"fr/module-06/comparing/#2441-arrays-sort","title":"24.4.1 Arrays sort()","text":"<pre><code>int[] nums = {3,1,2};\nArrays.sort(nums); // ordre naturel\n\nPerson[] arr = {...};\nArrays.sort(arr); // Person doit impl\u00e9menter Comparable\nArrays.sort(arr, byName); // en utilisant Comparator\n</code></pre>"},{"location":"fr/module-06/comparing/#2442-collections-sort","title":"24.4.2 Collections sort()","text":"<pre><code>Collections.sort(list); // ordre naturel\nCollections.sort(list, byName); // comparator\n</code></pre> <p>Note</p> <p>Collections.sort(list) d\u00e9l\u00e8gue \u00e0 list.sort(comparator) depuis Java 8.</p> <p></p>"},{"location":"fr/module-06/comparing/#245-tri-multi-niveaux-thencomparing","title":"24.5 Tri Multi-Niveaux (thenComparing)","text":"<pre><code>var cmp = Comparator\n    .comparing(Person::getLastName)\n        .thenComparing(Person::getFirstName)\n            .thenComparingInt(Person::getAge);\n</code></pre>"},{"location":"fr/module-06/comparing/#246-comparer-les-primitifs-efficacement","title":"24.6 Comparer les Primitifs Efficacement","text":"<pre><code>Comparator.comparingInt(Person::getAge)\nComparator.comparingLong(...)\nComparator.comparingDouble(...)\n</code></pre> <p>Note</p> <p>Ceux-ci \u00e9vitent le boxing et sont pr\u00e9f\u00e9r\u00e9s dans le code sensible aux performances.</p> <p></p>"},{"location":"fr/module-06/comparing/#247-pieges-courants","title":"24.7 Pi\u00e8ges Courants","text":"<ul> <li>Trier une liste d\u2019Object sans Comparable \u2192 ClassCastException \u00e0 l\u2019ex\u00e9cution</li> <li>compareTo incoh\u00e9rent avec equals \u2192 comportement impr\u00e9visible</li> <li>Comparator qui viole la transitivit\u00e9 \u2192 le tri devient ind\u00e9fini</li> <li>\u00c9l\u00e9ments null \u2192 sauf si le Comparator les g\u00e8re, le tri l\u00e8ve une NPE</li> <li>Comparator comparant des champs de types mixtes \u2192 ClassCastException</li> <li>Utiliser la soustraction pour comparer des int peut provoquer un overflow \u2192 toujours utiliser <code>Integer.compare()</code></li> <li>Trier une liste avec des \u00e9l\u00e9ments null et l\u2019ordre naturel \u2192 NPE</li> <li>compareTo ne doit jamais retourner des valeurs n\u00e9gatives/z\u00e9ro/positives incoh\u00e9rentes sur les m\u00eames deux objets (aucune al\u00e9atoire)</li> </ul>"},{"location":"fr/module-06/comparing/#248-exemple-complet","title":"24.8 Exemple Complet","text":"<pre><code>record Book(String title, double price, int year) {}\n\nvar books = List.of(\nnew Book(\"Java 17\", 40.0, 2021),\nnew Book(\"Algorithms\", 55.0, 2019),\nnew Book(\"Java 21\", 42.0, 2023)\n);\n\nComparator&lt;Book&gt; cmp =\nComparator\n    .comparingDouble(Book::price)\n        .thenComparing(Book::year)\n            .reversed();\n\nbooks.stream().sorted(cmp)\n    .forEach(System.out::println);\n</code></pre> <p>Note</p> <p><code>reversed()</code> s\u2019applique \u00e0 l\u2019ensemble du comparator compos\u00e9, et non uniquement \u00e0 la premi\u00e8re cl\u00e9 de comparaison.</p> <p></p>"},{"location":"fr/module-06/comparing/#249-resume","title":"24.9 R\u00e9sum\u00e9","text":"<ul> <li>Utiliser <code>Comparable</code> pour l\u2019ordre naturel (1 ordre par d\u00e9faut).</li> <li>Utiliser <code>Comparator</code> pour des strat\u00e9gies de tri flexibles ou multiples.</li> <li>Les comparators peuvent \u00eatre compos\u00e9s (reversed, thenComparing).</li> <li>Le tri requiert une logique de comparaison coh\u00e9rente.</li> <li>Arrays.sort et Collections.sort utilisent \u00e0 la fois Comparable et Comparator. </li> </ul>"},{"location":"fr/module-06/list-api/","title":"25. L\u2019API List","text":""},{"location":"fr/module-06/list-api/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>25.1 Caract\u00e9ristiques des List</li> <li>25.2 Cr\u00e9er des List (Constructeurs)<ul> <li>25.2.1 Constructeurs de ArrayList</li> <li>25.2.2 Constructeurs de LinkedList</li> </ul> </li> <li>25.3 M\u00e9thodes Factory<ul> <li>25.3.1 List of immutable</li> <li>25.3.2 List copyOf immutable-copy</li> <li>25.3.3 Arrays asList fixed-size-list</li> </ul> </li> <li>25.4 Op\u00e9rations Principales de List<ul> <li>25.4.1 Ajouter des \u00c9l\u00e9ments</li> <li>25.4.2 Acc\u00e9der aux \u00c9l\u00e9ments</li> <li>25.4.3 Supprimer des \u00c9l\u00e9ments</li> <li>25.4.4 Comportements et Caract\u00e9ristiques Importants</li> </ul> </li> <li>25.5 contains, equals et hashCode<ul> <li>25.5.1 contains</li> <li>25.5.2 \u00c9galit\u00e9 des List</li> <li>25.5.3 hashCode</li> </ul> </li> <li>25.6 It\u00e9rer \u00e0 Travers une List<ul> <li>25.6.1 Boucle For Classique</li> <li>25.6.2 Boucle For Am\u00e9lior\u00e9e</li> <li>25.6.3 Iterator--ListIterator</li> </ul> </li> <li>25.7 La M\u00e9thode subList<ul> <li>25.7.1 Syntaxe</li> <li>25.7.2 R\u00e8gles</li> <li>25.7.3 Exemples</li> <li>25.7.4 Modifier la liste parent invalide la vue</li> <li>25.7.5 Modifier la subList modifie le parent</li> <li>25.7.6 Vider la subList vide une partie de la liste parent</li> <li>25.7.7 Pi\u00e8ges Courants</li> </ul> </li> <li>25.8 Tableau R\u00e9sum\u00e9 des Op\u00e9rations Importantes</li> </ul> <p>Dans le <code>Collections Framework</code>, une List repr\u00e9sente une collection ordonn\u00e9e, bas\u00e9e sur des indices, autorisant les doublons.</p> <p>L\u2019interface List \u00e9tend <code>Collection</code> et est impl\u00e9ment\u00e9e par :</p> <pre><code>List\n\u251c\u2500\u2500 ArrayList (Tableau redimensionnable \u2014 acc\u00e8s al\u00e9atoire rapide, insertions/suppressions plus lentes au milieu)\n\u251c\u2500\u2500 LinkedList (Liste doublement cha\u00een\u00e9e \u2014 insertions/suppressions rapides, acc\u00e8s al\u00e9atoire plus lent)\n\u2514\u2500\u2500 Vector (Liste synchronis\u00e9e legacy \u2014 rarement utilis\u00e9e aujourd\u2019hui)\n</code></pre> <p>Note</p> <p>Vector est legacy et synchronis\u00e9 \u2014 \u00e0 \u00e9viter sauf si explicitement requis.</p> <p></p>"},{"location":"fr/module-06/list-api/#251-caracteristiques-des-list","title":"25.1 Caract\u00e9ristiques des List","text":"<ul> <li>Ordonn\u00e9es \u2014 les \u00e9l\u00e9ments pr\u00e9servent l\u2019ordre d\u2019insertion.</li> <li>Index\u00e9es \u2014 accessibles via <code>get(int)</code> et <code>set(int,E)</code>.</li> <li>Autorisent les doublons \u2014 <code>List</code> n\u2019impose pas l\u2019unicit\u00e9.</li> <li>Peuvent contenir <code>null</code> \u2014 sauf si l\u2019on utilise des impl\u00e9mentations sp\u00e9ciales.</li> </ul>"},{"location":"fr/module-06/list-api/#252-creer-des-list-constructeurs","title":"25.2 Cr\u00e9er des List (Constructeurs)","text":""},{"location":"fr/module-06/list-api/#2521-constructeurs-de-arraylist","title":"25.2.1 Constructeurs de ArrayList","text":"<pre><code>List&lt;String&gt; a1 = new ArrayList&lt;&gt;();\nList&lt;String&gt; a2 = new ArrayList&lt;&gt;(50); // capacit\u00e9 initiale\nList&lt;String&gt; a3 = new ArrayList&lt;&gt;(List.of(\"A\", \"B\"));\n</code></pre> <p>Note</p> <p>La capacit\u00e9 initiale n\u2019est pas une taille. Elle d\u00e9cide seulement combien d\u2019\u00e9l\u00e9ments le tableau interne peut contenir avant redimensionnement.</p> <p></p>"},{"location":"fr/module-06/list-api/#2522-constructeurs-de-linkedlist","title":"25.2.2 Constructeurs de LinkedList","text":"<pre><code>List&lt;String&gt; l1 = new LinkedList&lt;&gt;();\nList&lt;String&gt; l2 = new LinkedList&lt;&gt;(List.of(\"A\", \"B\"));\n</code></pre> <p>Note</p> <p><code>LinkedList</code> impl\u00e9mente aussi <code>Deque</code>.</p> <p></p>"},{"location":"fr/module-06/list-api/#253-methodes-factory","title":"25.3 M\u00e9thodes Factory","text":""},{"location":"fr/module-06/list-api/#2531-listof-immuable","title":"25.3.1 <code>List.of()</code> (immuable)","text":"<pre><code>List&lt;String&gt; list1 = List.of(\"A\", \"B\", \"C\");\nlist1.add(\"X\"); // \u274c UnsupportedOperationException\nlist1.set(0, \"Z\"); // \u274c UnsupportedOperationException\n</code></pre> <p>Note</p> <p>Toutes les listes <code>List.of()</code> : - rejettent les <code>null</code> - sont immuables - l\u00e8vent <code>UOE</code> lors d\u2019une modification structurelle</p> <p></p>"},{"location":"fr/module-06/list-api/#2532-listcopyof-copie-immuable","title":"25.3.2 <code>List.copyOf()</code> (copie immuable)","text":"<pre><code>List&lt;String&gt; src = new ArrayList&lt;&gt;();\nsrc.add(\"Hello\");\n\nList&lt;String&gt; copy = List.copyOf(src); // instantan\u00e9 immuable\n</code></pre>"},{"location":"fr/module-06/list-api/#2533-arraysaslist-liste-a-taille-fixe","title":"25.3.3 Arrays.asList() (liste \u00e0 taille fixe)","text":"<pre><code>String[] arr = {\"A\", \"B\"};\nList&lt;String&gt; list = Arrays.asList(arr);\n\nlist.set(0, \"Z\"); // OK\nlist.add(\"X\"); // \u274c UOE \u2014 la taille est fixe\n</code></pre> <p>Note</p> <p>La liste est adoss\u00e9e au tableau : modifier l\u2019un affecte l\u2019autre.</p> <p></p>"},{"location":"fr/module-06/list-api/#254-operations-principales-de-list","title":"25.4 Op\u00e9rations Principales de List","text":""},{"location":"fr/module-06/list-api/#2541-ajouter-des-elements","title":"25.4.1 Ajouter des \u00c9l\u00e9ments","text":"<pre><code>list.add(\"A\");\nlist.add(1, \"B\"); // ins\u00e8re \u00e0 l\u2019index\nlist.addAll(otherList);\nlist.addAll(2, otherList);\n</code></pre>"},{"location":"fr/module-06/list-api/#2542-acceder-aux-elements","title":"25.4.2 Acc\u00e9der aux \u00c9l\u00e9ments","text":"<pre><code>String x = list.get(0);\nlist.set(1, \"NewValue\");\n</code></pre> <p>Note</p> <p><code>get()</code> l\u00e8ve <code>IndexOutOfBoundsException</code> pour des index invalides.</p> <p>Si vous essayez de <code>mettre \u00e0 jour</code> un \u00e9l\u00e9ment dans une List vide, m\u00eame \u00e0 l\u2019index 0, vous obtenez une <code>IndexOutOfBoundsException</code></p> <pre><code>List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\nlist.add(3);\nlist.add(5);\nSystem.out.println(list.toString());\nlist.clear();\nlist.set(0, 2);\n</code></pre> <p>Sortie</p> <pre><code>[3, 5]\nException in thread \"main\" java.lang.IndexOutOfBoundsException: Index 0 out of bounds for length 0\n</code></pre> <p>Warning</p> <p>Appeler get/set avec un index invalide l\u00e8ve IndexOutOfBoundsException</p> <p></p>"},{"location":"fr/module-06/list-api/#2543-supprimer-des-elements","title":"25.4.3 Supprimer des \u00c9l\u00e9ments","text":"<pre><code>list.remove(0); // remove(int index) \u2014 supprime par index ; remove(Object) \u2014 supprime le premier \u00e9l\u00e9ment \u00e9gal\nlist.remove(\"A\"); // supprime la premi\u00e8re occurrence\nlist.removeIf(s -&gt; s.startsWith(\"X\"));\nlist.clear();\n</code></pre>"},{"location":"fr/module-06/list-api/#2544-comportements-et-caracteristiques-importants","title":"25.4.4 Comportements et Caract\u00e9ristiques Importants","text":"Op\u00e9ration Comportement Exception(s) <code>add(E)</code> ajoute toujours \u00e0 la fin \u2014 <code>add(int,E)</code> d\u00e9cale les \u00e9l\u00e9ments vers la droite IndexOutOfBoundsException <code>get(int)</code> temps constant pour ArrayList, lin\u00e9aire pour LinkedList IndexOutOfBoundsException <code>set(int,E)</code> remplace l\u2019\u00e9l\u00e9ment IndexOutOfBoundsException <code>remove(int)</code> d\u00e9cale les \u00e9l\u00e9ments vers la gauche IndexOutOfBoundsException <code>remove(Object)</code> supprime le premier \u00e9l\u00e9ment \u00e9gal \u2014"},{"location":"fr/module-06/list-api/#255-contains-equals-et-hashcode","title":"25.5 <code>contains()</code>, <code>equals()</code> et <code>hashCode()</code>","text":""},{"location":"fr/module-06/list-api/#2551-contains","title":"25.5.1 <code>contains()</code>","text":"<p>La M\u00e9thode <code>contains()</code> utilise <code>.equals()</code> sur les \u00e9l\u00e9ments.</p> <p></p>"},{"location":"fr/module-06/list-api/#2552-egalite-des-list","title":"25.5.2 \u00c9galit\u00e9 des List","text":"<p><code>List.equals()</code> effectue une comparaison \u00e9l\u00e9ment par \u00e9l\u00e9ment dans l\u2019ordre.</p> <pre><code>List&lt;String&gt; a = List.of(\"A\", \"B\");\nList&lt;String&gt; b = List.of(\"A\", \"B\");\n\nSystem.out.println(a.equals(b)); // true\n</code></pre> <p>Note</p> <ul> <li>L\u2019ordre compte.</li> <li>Le type de liste ne compte PAS.</li> </ul> <p></p>"},{"location":"fr/module-06/list-api/#2553-hashcode","title":"25.5.3 <code>hashCode()</code>","text":"<p>Calcul\u00e9 sur la base du contenu.</p> <p></p>"},{"location":"fr/module-06/list-api/#256-iterer-a-travers-une-list","title":"25.6 It\u00e9rer \u00e0 Travers une List","text":""},{"location":"fr/module-06/list-api/#2561-boucle-for-classique","title":"25.6.1 Boucle For Classique","text":"<pre><code>for (int i = 0; i &lt; list.size(); i++) {\n    System.out.println(list.get(i));\n}\n</code></pre>"},{"location":"fr/module-06/list-api/#2562-boucle-for-amelioree","title":"25.6.2 Boucle For Am\u00e9lior\u00e9e","text":"<pre><code>for (String s : list) {\n    System.out.println(s);\n}\n</code></pre>"},{"location":"fr/module-06/list-api/#2563-iterator-listiterator","title":"25.6.3 Iterator &amp; ListIterator","text":"<pre><code>Iterator&lt;String&gt; it = list.iterator();\nwhile (it.hasNext()) { System.out.println(it.next()); }\n\nListIterator&lt;String&gt; lit = list.listIterator();\nwhile (lit.hasNext()) {\n    if (lit.next().equals(\"A\")) lit.set(\"Z\");\n}\n</code></pre> <p>Warning</p> <p>Tous les it\u00e9rateurs standard de List sont fail-fast : une modification structurelle en dehors de l\u2019it\u00e9rateur cause ConcurrentModificationException.</p> <p>Note</p> <p>Seul <code>ListIterator</code> supporte la travers\u00e9e bidirectionnelle et la modification.</p> <p></p>"},{"location":"fr/module-06/list-api/#257-la-methode-sublist","title":"25.7 La M\u00e9thode <code>subList()</code>","text":"<p><code>subList()</code> cr\u00e9e une vue d\u2019une portion de la liste, pas une copie. Modifier l\u2019une des deux peut modifier l\u2019autre.</p> <p></p>"},{"location":"fr/module-06/list-api/#2571-syntaxe","title":"25.7.1 Syntaxe","text":"<pre><code>List&lt;E&gt; subList(int fromIndex, int toIndex);\n</code></pre>"},{"location":"fr/module-06/list-api/#2572-regles","title":"25.7.2 R\u00e8gles","text":"R\u00e8gle Explication fromIndex inclusif l\u2019\u00e9l\u00e9ment \u00e0 fromIndex est inclus toIndex exclusif l\u2019\u00e9l\u00e9ment \u00e0 toIndex n\u2019est PAS inclus La vue est adoss\u00e9e \u00e0 la liste originale modifier l\u2019une modifie l\u2019autre Modification structurelle du parent invalide la subList \u2192 ConcurrentModificationException"},{"location":"fr/module-06/list-api/#2573-exemples","title":"25.7.3 Exemples","text":"<pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;(List.of(\"A\", \"B\", \"C\", \"D\"));\nList&lt;String&gt; view = list.subList(1, 3);\n// view = [\"B\", \"C\"]\n\nview.set(0, \"X\");\n// list = [\"A\", \"X\", \"C\", \"D\"]\n// view = [\"X\", \"C\"]\n</code></pre>"},{"location":"fr/module-06/list-api/#2574-modifier-la-liste-parent-invalide-la-vue","title":"25.7.4 Modifier la liste parent invalide la vue","text":"<pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;(List.of(\"A\",\"B\",\"C\",\"D\"));\nList&lt;String&gt; view = list.subList(1, 3);\n\nlist.add(\"E\"); // modification structurelle de la liste parent\n\nview.get(0); // \u274c ConcurrentModificationException\n</code></pre>"},{"location":"fr/module-06/list-api/#2575-modifier-la-sublist-modifie-le-parent","title":"25.7.5 Modifier la subList modifie le parent","text":"<pre><code>view.remove(1);\n// supprime \"C\" \u00e0 la fois de la view et de la liste parent\n</code></pre>"},{"location":"fr/module-06/list-api/#2576-vider-la-sublist-vide-une-partie-de-la-liste-parent","title":"25.7.6 Vider la subList vide une partie de la liste parent","text":"<pre><code>view.clear();\n// supprime les index 1 et 2 du parent\n</code></pre>"},{"location":"fr/module-06/list-api/#2577-pieges-courants","title":"25.7.7 Pi\u00e8ges Courants","text":"<ul> <li>Supposer que subList est ind\u00e9pendante : c\u2019est une vue, pas une copie</li> <li>Supposer que subList permet le redimensionnement : fonctionne uniquement sur des listes parent modifiables</li> <li>Oublier que les modifications du parent invalident la vue entra\u00eenant ConcurrentModificationException</li> <li>Attentes d\u2019index incorrectes : l\u2019index de fin est exclusif</li> </ul>"},{"location":"fr/module-06/list-api/#258-tableau-resume-des-operations-importantes","title":"25.8 Tableau R\u00e9sum\u00e9 des Op\u00e9rations Importantes","text":"Op\u00e9ration ArrayList LinkedList List Immuables <code>add(E)</code> rapide rapide \u274c non support\u00e9 <code>add(index,E)</code> lent (shift) rapide \u274c <code>get(index)</code> rapide lent rapide <code>remove(index)</code> lent lent (sauf si suppression du premier/dernier) \u274c <code>remove(Object)</code> plus lent plus lent \u274c <code>set(index,E)</code> rapide lent \u274c <code>iterator()</code> rapide rapide rapide <code>listIterator()</code> rapide rapide rapide <code>contains(Object)</code> O(n) O(n) O(n)"},{"location":"fr/module-06/map-api/","title":"28. Map API","text":""},{"location":"fr/module-06/map-api/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>28.1 Caract\u00e9ristiques Fondamentales de Map</li> <li>28.2 Principales Impl\u00e9mentations de Map</li> <li>28.3 Cr\u00e9er des Map</li> <li>28.4 Op\u00e9rations de Base sur les Map</li> <li>28.5 It\u00e9rer sur une Map</li> <li>28.6 D\u00e9terminer l\u2019\u00c9galit\u00e9 dans les Map</li> <li>28.7 Comportement Sp\u00e9cial de TreeMap</li> <li>28.8 Gestion des Null</li> <li>28.9 Pi\u00e8ges Courants</li> <li>28.10 R\u00e9sum\u00e9</li> </ul> <p>L\u2019interface <code>Map</code> repr\u00e9sente une collection de paires cl\u00e9\u2013valeur, o\u00f9 chaque cl\u00e9 est associ\u00e9e \u00e0 au plus une valeur.</p> <p>Contrairement aux autres types de collections, <code>Map</code> n\u2019\u00e9tend pas <code>Collection</code> et poss\u00e8de donc sa propre hi\u00e9rarchie et ses propres r\u00e8gles.</p> <p></p>"},{"location":"fr/module-06/map-api/#281-caracteristiques-fondamentales-de-map","title":"28.1 Caract\u00e9ristiques Fondamentales de Map","text":"<ul> <li>Chaque cl\u00e9 est unique ; les cl\u00e9s dupliqu\u00e9es \u00e9crasent la valeur pr\u00e9c\u00e9dente</li> <li>Les valeurs peuvent \u00eatre dupliqu\u00e9es</li> <li>Les Map ne prennent pas en charge l\u2019acc\u00e8s positionnel (bas\u00e9 sur des indices)</li> <li>L\u2019it\u00e9ration s\u2019effectue via <code>keySet()</code>, <code>values()</code> ou <code>entrySet()</code></li> </ul> <p>Note</p> <p>Une <code>Map</code> n\u2019est pas une <code>Collection</code>, mais ses vues (keySet, values, entrySet) sont des collections.</p> <p></p>"},{"location":"fr/module-06/map-api/#282-principales-implementations-de-map","title":"28.2 Principales Impl\u00e9mentations de Map","text":"Impl\u00e9mentation Ordonnancement Cl\u00e9s Null Valeurs Null Thread-Safe Notes <code>HashMap</code> Aucun ordre 1 Plusieurs Non Rapide, la plus courante <code>LinkedHashMap</code> Ordre d\u2019insertion 1 Plusieurs Non It\u00e9ration pr\u00e9visible <code>TreeMap</code> Tri\u00e9e par cl\u00e9 Non Plusieurs Non Les cl\u00e9s doivent \u00eatre comparables <code>Hashtable</code> Aucun ordre Non Non Oui Legacy <code>ConcurrentHashMap</code> Aucun ordre Non Non Oui Adapt\u00e9e \u00e0 la concurrence <p>Note</p> <p>L\u2019ordre de <code>TreeMap</code> est d\u00e9termin\u00e9 soit par <code>Comparable</code>, soit par un <code>Comparator</code> fourni lors de la construction.</p> <p></p>"},{"location":"fr/module-06/map-api/#283-creer-des-map","title":"28.3 Cr\u00e9er des Map","text":"<p>Les <code>Map</code> peuvent \u00eatre cr\u00e9\u00e9es \u00e0 l\u2019aide de constructeurs ou de m\u00e9thodes factory.</p> <pre><code>Map&lt;String, Integer&gt; map1 = new HashMap&lt;&gt;();\nMap&lt;String, Integer&gt; map2 = new LinkedHashMap&lt;&gt;();\nMap&lt;String, Integer&gt; map3 = new TreeMap&lt;&gt;();\n\nMap&lt;String, Integer&gt; map4 = Map.of(\"A\", 1, \"B\", 2);\nMap&lt;String, Integer&gt; map5 = Map.ofEntries(\n    Map.entry(\"X\", 10),\n    Map.entry(\"Y\", 20)\n);\n</code></pre> <p>Note</p> <p>Les Map cr\u00e9\u00e9es avec <code>Map.of(...)</code> et <code>Map.ofEntries(...)</code> sont immuables. Toute tentative de modification l\u00e8ve <code>UnsupportedOperationException</code>.</p> <p></p>"},{"location":"fr/module-06/map-api/#284-operations-de-base-sur-les-map","title":"28.4 Op\u00e9rations de Base sur les Map","text":"M\u00e9thode Description Valeur de Retour <code>put(k, v)</code> Ajoute ou remplace une association Valeur pr\u00e9c\u00e9dente ou null <code>putIfAbsent(k,v)</code> Ajoute seulement si la cl\u00e9 est absente Valeur existante ou null <code>get(k)</code> Retourne la valeur ou null Valeur sp\u00e9cifique ou null <code>getOrDefault(k, default)</code> Retourne la valeur ou la valeur par d\u00e9faut Valeur sp\u00e9cifique ou d\u00e9faut <code>remove(k)</code> Supprime l\u2019association Valeur supprim\u00e9e ou null <code>containsKey(k)</code> V\u00e9rifie la pr\u00e9sence de la cl\u00e9 boolean <code>containsValue(v)</code> V\u00e9rifie la pr\u00e9sence de la valeur boolean <code>size()</code> Nombre d\u2019entr\u00e9es int <code>isEmpty()</code> Test de vacuit\u00e9 boolean <code>clear()</code> Supprime toutes les entr\u00e9es void <code>V merge(k, v, BiFunction(V, V, V))</code> merge(k, v, remappingFunction) si cl\u00e9 absente \u2192 d\u00e9finit la valeur ; si cl\u00e9 pr\u00e9sente \u2192 function(oldValue, newValue) ; si la fonction retourne null \u2192 association supprim\u00e9e <pre><code>Map&lt;String, String&gt; map = new HashMap&lt;&gt;();\nmap.put(\"A\", \"Apple\");\nmap.put(\"B\", \"Banana\");\n\nmap.put(\"A\", \"Avocado\"); // \u00e9crase la valeur\n\nString v = map.get(\"B\"); // Banana\n</code></pre>"},{"location":"fr/module-06/map-api/#285-iterer-sur-une-map","title":"28.5 It\u00e9rer sur une Map","text":"<p>Les Map sont parcourues via des vues :</p> <ul> <li><code>keySet()</code> \u2192 Set de cl\u00e9s</li> <li><code>values()</code> \u2192 Collection de valeurs</li> <li><code>entrySet()</code> \u2192 Set de Map.Entry</li> </ul> <pre><code>for (String key : map.keySet()) {\n    System.out.println(key);\n}\n\nfor (String value : map.values()) {\n    System.out.println(value);\n}\n\nfor (Map.Entry&lt;String, String&gt; e : map.entrySet()) {\n    System.out.println(e.getKey() + \" = \" + e.getValue());\n}\n</code></pre> <p>Note</p> <p>Modifier la map pendant l\u2019it\u00e9ration sur ces vues peut lever <code>ConcurrentModificationException</code> (sauf pour les map concurrentes).</p> <p></p>"},{"location":"fr/module-06/map-api/#286-determiner-legalite-dans-les-map","title":"28.6 D\u00e9terminer l\u2019\u00c9galit\u00e9 dans les Map","text":"<p>L\u2019\u00e9galit\u00e9 des map est d\u00e9finie comme suit :</p> <ul> <li>Deux map sont \u00e9gales si elles contiennent les m\u00eames associations cl\u00e9\u2013valeur</li> <li>La comparaison des cl\u00e9s utilise <code>equals()</code></li> <li>La comparaison des valeurs utilise <code>equals()</code></li> </ul> <pre><code>Map&lt;String, Integer&gt; m1 = Map.of(\"A\", 1, \"B\", 2);\nMap&lt;String, Integer&gt; m2 = Map.of(\"B\", 2, \"A\", 1);\n\nSystem.out.println(m1.equals(m2)); // true\n</code></pre> <p>Note</p> <p>L\u2019ordre d\u2019it\u00e9ration n\u2019affecte pas l\u2019\u00e9galit\u00e9 des map.</p> <p></p>"},{"location":"fr/module-06/map-api/#287-comportement-special-de-treemap","title":"28.7 Comportement Sp\u00e9cial de TreeMap","text":"<p>TreeMap maintient les entr\u00e9es tri\u00e9es selon les cl\u00e9s.</p> <pre><code>Map&lt;Integer, String&gt; tm = new TreeMap&lt;&gt;();\ntm.put(3, \"C\");\ntm.put(1, \"A\");\ntm.put(2, \"B\");\n\nSystem.out.println(tm); // {1=A, 2=B, 3=C}\n</code></pre> <p>Warning</p> <p>Toutes les cl\u00e9s d\u2019une <code>TreeMap</code> doivent \u00eatre mutuellement comparables. M\u00e9langer des types incompatibles provoque une <code>ClassCastException</code> \u00e0 l\u2019ex\u00e9cution.</p> <p></p>"},{"location":"fr/module-06/map-api/#288-gestion-des-null","title":"28.8 Gestion des Null","text":"Impl\u00e9mentation Cl\u00e9 Null Valeur Null HashMap Oui (1) Oui LinkedHashMap Oui (1) Oui TreeMap Non Oui Hashtable Non Non ConcurrentHashMap Non Non <p>Note</p> <p><code>TreeMap</code> accepte les valeurs <code>null</code> uniquement lorsqu\u2019elles ne participent pas \u00e0 la comparaison des cl\u00e9s. En pratique, cela est rare, car les cl\u00e9s null sont interdites et les comparators peuvent rejeter les null.</p> <p><code>HashMap</code> et <code>LinkedHashMap</code> autorisent une seule cl\u00e9 null \u2014 en ins\u00e9rer une autre remplace l\u2019existante.</p> <p></p>"},{"location":"fr/module-06/map-api/#289-pieges-courants","title":"28.9 Pi\u00e8ges Courants","text":"<ul> <li>Supposer que Map est une Collection</li> <li>Oublier que les cl\u00e9s dupliqu\u00e9es \u00e9crasent les valeurs</li> <li>Utiliser des cl\u00e9s null dans TreeMap ou ConcurrentHashMap</li> <li>Confondre l\u2019ordre d\u2019it\u00e9ration avec l\u2019\u00e9galit\u00e9</li> <li>Tenter de modifier des map immuables cr\u00e9\u00e9es via Map.of</li> </ul>"},{"location":"fr/module-06/map-api/#2810-resume","title":"28.10 R\u00e9sum\u00e9","text":"<ul> <li>Les Map stockent des cl\u00e9s uniques associ\u00e9es \u00e0 des valeurs</li> <li>L\u2019ordonnancement d\u00e9pend de l\u2019impl\u00e9mentation</li> <li>L\u2019\u00e9galit\u00e9 est bas\u00e9e sur les paires cl\u00e9\u2013valeur</li> <li>TreeMap exige des cl\u00e9s comparables</li> <li>Les map immuables l\u00e8vent des exceptions en cas de modification</li> </ul>"},{"location":"fr/module-06/queue-api/","title":"27. API Queue &amp; Deque","text":""},{"location":"fr/module-06/queue-api/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>27.1 Queue \u2014 Vue d\u2019ensemble<ul> <li>27.1.1 M\u00e9thodes Principales de Queue</li> <li>27.1.2 Impl\u00e9mentations de Queue</li> </ul> </li> <li>27.2 Deque \u2014 Vue d\u2019ensemble<ul> <li>27.2.1 M\u00e9thodes Principales de Deque</li> <li>27.2.2 Impl\u00e9mentations de Deque</li> </ul> </li> <li>27.3 Utiliser une Queue</li> <li>27.4 Utiliser une Deque comme Queue et comme Stack<ul> <li>27.4.1 Exemple FIFO (Comportement Queue)</li> <li>27.4.2 Exemple LIFO (Comportement Stack)</li> </ul> </li> <li>27.5 PriorityQueue \u2014 Queue Sp\u00e9ciale</li> <li>27.6 Blocking Queue (Bases)</li> <li>27.7 Pi\u00e8ges Courants</li> <li>27.8 Tableau R\u00e9capitulatif</li> </ul> <p>Les interfaces <code>Queue</code> et <code>Deque</code> de Java mod\u00e9lisent des collections ordonn\u00e9es con\u00e7ues pour traiter des \u00e9l\u00e9ments dans une s\u00e9quence particuli\u00e8re.</p> <p>Une Queue mod\u00e9lise typiquement une structure FIFO (First-In, First-Out). Une Deque (<code>double-ended queue</code>) permet l\u2019insertion et la suppression aux deux extr\u00e9mit\u00e9s, autorisant des comportements FIFO et LIFO dans une seule API.</p> <p></p>"},{"location":"fr/module-06/queue-api/#271-queue-vue-densemble","title":"27.1 Queue \u2014 Vue d\u2019ensemble","text":"<p>L\u2019interface <code>Queue</code> \u00e9tend <code>Collection</code> et est couramment utilis\u00e9e dans la programmation asynchrone, la distribution du travail, les algorithmes et le buffering.</p> <p>Il existe deux familles de m\u00e9thodes : celles qui l\u00e8vent des exceptions et celles qui retournent des valeurs sp\u00e9ciales (g\u00e9n\u00e9ralement <code>null</code>).</p> <p></p>"},{"location":"fr/module-06/queue-api/#2711-methodes-principales-de-queue","title":"27.1.1 M\u00e9thodes Principales de Queue","text":"Op\u00e9ration L\u00e8ve une Exception Retourne une Valeur Sp\u00e9ciale Description Insertion <code>add(e)</code> <code>offer(e)</code> Ajoute un \u00e9l\u00e9ment ; <code>offer</code> est pr\u00e9f\u00e9r\u00e9 pour les queues \u00e0 capacit\u00e9 limit\u00e9e Suppression <code>E remove()</code> <code>E poll()</code> Supprime et retourne la t\u00eate. <code>remove()</code> l\u00e8ve NoSuchElementException si la queue est vide, <code>poll()</code> retourne null Lecture <code>E element()</code> <code>E peek()</code> Retourne la t\u00eate sans la supprimer. <code>element()</code> l\u00e8ve NoSuchElementException si la queue est vide, <code>peek()</code> retourne null"},{"location":"fr/module-06/queue-api/#2712-implementations-de-queue","title":"27.1.2 Impl\u00e9mentations de Queue","text":"<p>Classes courantes impl\u00e9mentant <code>Queue</code> :</p> <ul> <li><code>LinkedList</code> \u2014 non born\u00e9e, impl\u00e9mente aussi <code>Deque</code> et <code>List</code>.</li> <li><code>ArrayDeque</code> \u2014 queue rapide bas\u00e9e sur un tableau redimensionnable ; ne peut pas stocker <code>null</code>.</li> <li><code>PriorityQueue</code> \u2014 ordonne les \u00e9l\u00e9ments par ordre naturel ou comparator ; n\u2019est pas FIFO.</li> <li><code>ConcurrentLinkedQueue</code> \u2014 thread-safe, lock-free.</li> </ul> <p>Note</p> <p><code>PriorityQueue</code> ne garantit pas que l\u2019ordre d\u2019it\u00e9ration corresponde \u00e0 l\u2019ordre de priorit\u00e9.</p> <p>Warning</p> <p>La plupart des impl\u00e9mentations de Queue rejettent <code>null</code> car <code>null</code> est utilis\u00e9 comme valeur de retour pour \u201cvide\u201d.</p> <p></p>"},{"location":"fr/module-06/queue-api/#272-deque-vue-densemble","title":"27.2 Deque \u2014 Vue d\u2019ensemble","text":"<p><code>Deque</code> (double-ended queue) prend en charge l\u2019insertion, la suppression et l\u2019inspection \u00e0 la fois en t\u00eate et en queue.</p> <p>Elle est plus polyvalente qu\u2019une Queue : - FIFO (comportement de queue) - LIFO (comportement de stack) - Algorithmes bidirectionnels</p> <p></p>"},{"location":"fr/module-06/queue-api/#2721-methodes-principales-de-deque","title":"27.2.1 M\u00e9thodes Principales de Deque","text":"Op\u00e9ration Avant Arri\u00e8re Insertion addFirst(e), offerFirst(e) addLast(e), offerLast(e) Suppression removeFirst(), pollFirst() removeLast(), pollLast() Inspection getFirst(), peekFirst() getLast(), peekLast()"},{"location":"fr/module-06/queue-api/#2722-implementations-de-deque","title":"27.2.2 Impl\u00e9mentations de Deque","text":"<ul> <li><code>ArrayDeque</code> \u2014 impl\u00e9mentation recommand\u00e9e pour un usage g\u00e9n\u00e9ral (rapide, sans limite de capacit\u00e9).</li> <li><code>LinkedList</code> \u2014 compl\u00e8te mais plus lente en raison de la structure \u00e0 n\u0153uds.</li> <li><code>ConcurrentLinkedDeque</code> \u2014 deque concurrente non bloquante.</li> </ul> <p>Note</p> <p><code>Stack</code> est legacy ; utiliser <code>Deque</code> pour le comportement de stack (push/pop). Les op\u00e9rations de queue de ArrayDeque et LinkedList (add/remove/peek) sont en O(1) amorti.</p> <p></p>"},{"location":"fr/module-06/queue-api/#273-utiliser-une-queue","title":"27.3 Utiliser une Queue","text":"<pre><code>Queue&lt;String&gt; q = new LinkedList&lt;&gt;();\n\nq.offer(\"A\");\nq.offer(\"B\");\nq.offer(\"C\");\n\nSystem.out.println(q.peek());   // A\nSystem.out.println(q.poll());   // A\nSystem.out.println(q.poll());   // B\nSystem.out.println(q.poll());   // C\nSystem.out.println(q.poll());   // null (queue vide)\n</code></pre>"},{"location":"fr/module-06/queue-api/#274-utiliser-une-deque-comme-queue-et-comme-stack","title":"27.4 Utiliser une Deque (comme Queue et comme Stack)","text":""},{"location":"fr/module-06/queue-api/#2741-exemple-fifo-comportement-queue","title":"27.4.1 Exemple FIFO (Comportement Queue)","text":"<pre><code>Deque&lt;String&gt; dq = new ArrayDeque&lt;&gt;();\n\ndq.offerLast(\"A\"); // enqueue\ndq.offerLast(\"B\");\ndq.offerLast(\"C\");\n\nSystem.out.println(dq.pollFirst()); // A\nSystem.out.println(dq.pollFirst()); // B\nSystem.out.println(dq.pollFirst()); // C\n</code></pre>"},{"location":"fr/module-06/queue-api/#2742-exemple-lifo-comportement-stack","title":"27.4.2 Exemple LIFO (Comportement Stack)","text":"<pre><code>Deque&lt;String&gt; stack = new ArrayDeque&lt;&gt;();\n\nstack.push(\"A\");\nstack.push(\"B\");\nstack.push(\"C\");\n\nSystem.out.println(stack.pop()); // C\nSystem.out.println(stack.pop()); // B\nSystem.out.println(stack.pop()); // A\n</code></pre>"},{"location":"fr/module-06/queue-api/#275-priorityqueue-queue-speciale","title":"27.5 PriorityQueue \u2014 Queue Sp\u00e9ciale","text":"<p><code>PriorityQueue</code> ordonne les \u00e9l\u00e9ments par ordre naturel ou via un <code>Comparator</code> fourni.</p> <p>Caract\u00e9ristiques importantes :</p> <ul> <li>Non FIFO \u2014 la t\u00eate est l\u2019\u00e9l\u00e9ment \u201cle plus petit\u201d.</li> <li>L\u2019ordre est garanti uniquement lors de la suppression, pas lors de l\u2019it\u00e9ration.</li> <li>Les \u00e9l\u00e9ments <code>null</code> ne sont pas autoris\u00e9s.</li> </ul> <pre><code>PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;();\n\npq.offer(50);\npq.offer(10);\npq.offer(30);\n\nSystem.out.println(pq.poll()); // 10\nSystem.out.println(pq.poll()); // 30\nSystem.out.println(pq.poll()); // 50\n</code></pre> <p></p>"},{"location":"fr/module-06/queue-api/#276-blocking-queue-bases","title":"27.6 Blocking Queue (Bases)","text":"<p>Dans les environnements concurrents, le package <code>java.util.concurrent</code> fournit des types de queues bloquantes.</p> <ul> <li><code>ArrayBlockingQueue</code> \u2014 tableau sous-jacent de taille fixe.</li> <li><code>LinkedBlockingQueue</code> \u2014 optionnellement born\u00e9e.</li> <li><code>PriorityBlockingQueue</code> \u2014 priority queue thread-safe.</li> <li><code>DelayQueue</code> \u2014 \u00e9l\u00e9ments lib\u00e9r\u00e9s apr\u00e8s des d\u00e9lais.</li> </ul> <p>Note</p> <p>BlockingQueue n\u2019autorise jamais <code>null</code>. put(e) \u2014 bloque jusqu\u2019\u00e0 ce qu\u2019un espace soit disponible take() \u2014 bloque jusqu\u2019\u00e0 ce qu\u2019un \u00e9l\u00e9ment soit disponible BlockingQueue prend aussi en charge des op\u00e9rations temporis\u00e9es : offer(e, timeout), poll(timeout)</p> <p></p>"},{"location":"fr/module-06/queue-api/#277-pieges-courants","title":"27.7 Pi\u00e8ges Courants","text":"<ul> <li>Les m\u00e9thodes de <code>Queue</code> et <code>Deque</code> existent en variantes \u201cexception\u201d et \u201cvaleur sp\u00e9ciale\u201d \u2014 m\u00e9moriser lesquelles sont lesquelles.</li> <li><code>ArrayDeque</code> ne peut pas stocker <code>null</code> \u2014 <code>null</code> est utilis\u00e9 en interne.</li> <li>L\u2019ordre d\u2019it\u00e9ration de <code>PriorityQueue</code> n\u2019est PAS tri\u00e9.</li> <li>L\u2019utilisation de <code>Stack</code> est d\u00e9conseill\u00e9e ; utiliser <code>Deque</code> \u00e0 la place.</li> <li>Deque permet \u00e0 la fois FIFO et LIFO et poss\u00e8de l\u2019API la plus compl\u00e8te.</li> </ul>"},{"location":"fr/module-06/queue-api/#278-tableau-recapitulatif","title":"27.8 Tableau R\u00e9capitulatif","text":"Interface Comportement Typique Null Autoris\u00e9 ? Impl\u00e9mentations Courantes Notes Queue FIFO D\u00e9pend LinkedList, ArrayDeque, PriorityQueue PriorityQueue non FIFO Deque FIFO + LIFO Non (ArrayDeque) ArrayDeque, LinkedList Op\u00e9rations compl\u00e8tes aux deux extr\u00e9mit\u00e9s PriorityQueue Ordonn\u00e9e par priorit\u00e9 Non PriorityQueue Supprime d\u2019abord l\u2019\u00e9l\u00e9ment le plus petit BlockingQueue FIFO thread-safe Non ArrayBlockingQueue, LinkedBlockingQueue diff\u00e9rences entre add/offer et put ConcurrentLinkedQueue FIFO lock-free Non ConcurrentLinkedQueue Tr\u00e8s rapide pour le multi-threading"},{"location":"fr/module-06/sequenced/","title":"29. Collections S\u00e9quenc\u00e9es &amp; Map S\u00e9quenc\u00e9es","text":""},{"location":"fr/module-06/sequenced/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>29.1 Motivation et Contexte</li> <li>29.2 Interface SequencedCollection<ul> <li>29.2.1 M\u00e9thodes Principales de SequencedCollection</li> <li>29.2.2 Impl\u00e9mentations de SequencedCollection</li> <li>29.2.3 Vues Invers\u00e9es</li> </ul> </li> <li>29.3 Interface SequencedMap<ul> <li>29.3.1 M\u00e9thodes Principales de SequencedMap</li> <li>29.3.2 Impl\u00e9mentations de SequencedMap</li> <li>29.3.3 Map Invers\u00e9es</li> </ul> </li> <li>29.4 Relation avec les API Existantes<ul> <li>29.4.1 Quels Types Built-in Sont S\u00e9quenc\u00e9s</li> </ul> </li> <li>29.5 Pi\u00e8ges Courants</li> <li>29.6 R\u00e9sum\u00e9</li> </ul> <p>Java 21 introduit les <code>Collections S\u00e9quenc\u00e9es</code> et les <code>Map S\u00e9quenc\u00e9es</code> afin d\u2019unifier et de formaliser l\u2019acc\u00e8s aux \u00e9l\u00e9ments en fonction de leur ordre d\u2019apparition.</p> <p>Cet ajout r\u00e9sout des incoh\u00e9rences de longue date entre listes, sets, queues, deques et map, en fournissant une API commune pour travailler avec le premier et le dernier \u00e9l\u00e9ment, ainsi qu\u2019avec des vues invers\u00e9es.</p> <p></p>"},{"location":"fr/module-06/sequenced/#291-motivation-et-contexte","title":"29.1 Motivation et Contexte","text":"<p>Avant Java 21, les collections ordonn\u00e9es (telles que List, LinkedHashSet, Deque ou LinkedHashMap) exposaient les op\u00e9rations li\u00e9es \u00e0 l\u2019ordre via des m\u00e9thodes diff\u00e9rentes ou, dans certains cas, pas du tout. Les d\u00e9veloppeurs devaient s\u2019appuyer sur des API sp\u00e9cifiques \u00e0 l\u2019impl\u00e9mentation ou sur des contournements indirects.</p> <p>Les interfaces s\u00e9quenc\u00e9es introduisent un contrat coh\u00e9rent pour toutes les collections et map ordonn\u00e9es, rendant les op\u00e9rations bas\u00e9es sur l\u2019ordre explicites, s\u00fbres et uniformes.</p> <p></p>"},{"location":"fr/module-06/sequenced/#292-interface-sequencedcollection","title":"29.2 Interface SequencedCollection","text":"<p><code>SequencedCollection&lt;E&gt;</code> est une nouvelle interface qui \u00e9tend <code>Collection&lt;E&gt;</code> et repr\u00e9sente des collections avec un ordre d\u2019apparition bien d\u00e9fini.</p> <p>Elle est impl\u00e9ment\u00e9e par <code>List</code>, <code>Deque</code> et <code>LinkedHashSet</code> (<code>TreeSet</code> est ordonn\u00e9 mais n\u2019impl\u00e9mente pas directement SequencedCollection).</p> <p></p>"},{"location":"fr/module-06/sequenced/#2921-methodes-principales-de-sequencedcollection","title":"29.2.1 M\u00e9thodes Principales de SequencedCollection","text":"<p>L\u2019interface d\u00e9finit des m\u00e9thodes pour acc\u00e9der et manipuler les \u00e9l\u00e9ments aux deux extr\u00e9mit\u00e9s de la collection.</p> M\u00e9thode Description <code>E getFirst()</code> Retourne le premier \u00e9l\u00e9ment <code>E getLast()</code> Retourne le dernier \u00e9l\u00e9ment <code>void addFirst(E e)</code> Ins\u00e8re un \u00e9l\u00e9ment au d\u00e9but <code>void addLast(E e)</code> Ins\u00e8re un \u00e9l\u00e9ment \u00e0 la fin <code>E removeFirst()</code> Supprime et retourne le premier \u00e9l\u00e9ment <code>E removeLast()</code> Supprime et retourne le dernier \u00e9l\u00e9ment <code>SequencedCollection&lt;E&gt; reversed()</code> Retourne une vue invers\u00e9e <p></p>"},{"location":"fr/module-06/sequenced/#2922-implementations-de-sequencedcollection","title":"29.2.2 Impl\u00e9mentations de SequencedCollection","text":"<p>Les types standards suivants impl\u00e9mentent SequencedCollection :</p> Type Notes List Ordonn\u00e9e par index Deque File \u00e0 double extr\u00e9mit\u00e9 LinkedHashSet Maintient l\u2019ordre d\u2019insertion <p></p>"},{"location":"fr/module-06/sequenced/#2923-vues-inversees","title":"29.2.3 Vues Invers\u00e9es","text":"<p>L\u2019appel \u00e0 <code>reversed()</code> ne cr\u00e9e pas de copie.</p> <p>Il retourne une vue live de la m\u00eame collection avec l\u2019ordre invers\u00e9.</p> <pre><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;(List.of(1, 2, 3));\nSequencedCollection&lt;Integer&gt; rev = list.reversed();\n\nrev.removeFirst(); // supprime 3\nSystem.out.println(list); // [1, 2]\n</code></pre> <p>Note</p> <p>Les vues invers\u00e9es partagent la m\u00eame collection sous-jacente. Les modifications structurelles dans l\u2019une ou l\u2019autre vue affectent l\u2019autre : modifier soit la collection originale soit la vue invers\u00e9e a un effet sur les deux.</p> <p></p>"},{"location":"fr/module-06/sequenced/#293-interface-sequencedmap","title":"29.3 Interface SequencedMap","text":"<p><code>SequencedMap&lt;K,V&gt;</code> \u00e9tend <code>Map&lt;K,V&gt;</code> et repr\u00e9sente des map avec un ordre d\u2019apparition des entr\u00e9es bien d\u00e9fini.</p> <p>Elle standardise des op\u00e9rations qui n\u2019existaient auparavant que dans des impl\u00e9mentations sp\u00e9cifiques comme <code>LinkedHashMap</code>.</p> <p></p>"},{"location":"fr/module-06/sequenced/#2931-methodes-principales-de-sequencedmap","title":"29.3.1 M\u00e9thodes Principales de SequencedMap","text":"M\u00e9thode Description <code>Entry&lt;K,V&gt; firstEntry()</code> Premi\u00e8re entr\u00e9e de la map <code>Entry&lt;K,V&gt; lastEntry()</code> Derni\u00e8re entr\u00e9e de la map <code>Entry&lt;K,V&gt; pollFirstEntry()</code> Supprime et retourne la premi\u00e8re entr\u00e9e, ou null si vide <code>Entry&lt;K,V&gt; pollLastEntry()</code> Supprime et retourne la derni\u00e8re entr\u00e9e, ou null si vide <code>SequencedMap&lt;K,V&gt; reversed()</code> Vue invers\u00e9e de la map"},{"location":"fr/module-06/sequenced/#2932-implementations-de-sequencedmap","title":"29.3.2 Impl\u00e9mentations de SequencedMap","text":"<p>Actuellement, la principale impl\u00e9mentation standard est :</p> Type Ordonnancement <code>LinkedHashMap</code> Ordre d\u2019insertion (ou ordre d\u2019acc\u00e8s si configur\u00e9) <p>Note</p> <p>LinkedHashMap peut r\u00e9ordonner les entr\u00e9es lors de la lecture si elle est construite avec <code>accessOrder=true</code>.</p> <p>Dans ce cas, \u00ab premi\u00e8re \u00bb et \u00ab derni\u00e8re \u00bb refl\u00e8tent l\u2019ordre d\u2019acc\u00e8s le plus r\u00e9cent.</p> <p></p>"},{"location":"fr/module-06/sequenced/#2933-map-inversees","title":"29.3.3 Map Invers\u00e9es","text":"<p>Comme pour les collections, <code>reversed()</code> sur une map s\u00e9quenc\u00e9e retourne une vue, et non une copie.</p> <pre><code>SequencedMap&lt;String, Integer&gt; map =\nnew LinkedHashMap&lt;&gt;(Map.of(\"A\", 1, \"B\", 2, \"C\", 3));\n\nSequencedMap&lt;String, Integer&gt; rev = map.reversed();\n\nrev.pollFirstEntry(); // supprime C=3\nSystem.out.println(map); // {A=1, B=2}\n</code></pre> <p>Note</p> <p>Comme pour SequencedCollection, <code>reversed()</code> retourne une vue live \u2014 les mutations s\u2019appliquent aux deux map.</p> <p></p>"},{"location":"fr/module-06/sequenced/#294-relation-avec-les-api-existantes","title":"29.4 Relation avec les API Existantes","text":"<p>Les interfaces s\u00e9quenc\u00e9es ne remplacent pas les types de collections existants.</p> <p>Elles se placent au-dessus d\u2019eux dans la hi\u00e9rarchie et unifient les comportements communs.</p> <p>Toutes les collections ordonn\u00e9es existantes b\u00e9n\u00e9ficient automatiquement de ces API sans casser la r\u00e9trocompatibilit\u00e9.</p> <p></p>"},{"location":"fr/module-06/sequenced/#2941-quels-types-built-in-sont-sequences","title":"29.4.1 Quels Types Built-in Sont S\u00e9quenc\u00e9s","text":"<p>Le tableau suivant r\u00e9sume si les types standards de collections sont ordonn\u00e9s et s\u2019ils impl\u00e9mentent les nouvelles interfaces Sequenced.</p> Type Ordonn\u00e9 ? SequencedCollection ? SequencedMap ? <code>List</code> \u2714 Oui \u2714 Oui \u2718 Non <code>Deque</code> \u2714 Oui \u2714 Oui \u2718 Non <code>LinkedHashSet</code> \u2714 Oui \u2714 Oui \u2718 Non <code>TreeSet</code> \u2714 Oui (tri\u00e9) \u2718 Non* \u2718 Non <code>HashSet</code> \u2718 Non \u2718 Non \u2718 Non <code>LinkedHashMap</code> \u2714 Oui \u2718 Non \u2714 Oui <code>HashMap</code> \u2718 Non \u2718 Non \u2718 Non <code>TreeMap</code> \u2714 Oui (tri\u00e9) \u2718 Non \u2718 Non <p>Note</p> <p><code>TreeSet</code> est ordonn\u00e9, mais impl\u00e9mente <code>SortedSet</code>/<code>NavigableSet</code>, pas <code>SequencedCollection</code>.</p> <p></p>"},{"location":"fr/module-06/sequenced/#295-pieges-courants","title":"29.5 Pi\u00e8ges Courants","text":"<ul> <li>Les interfaces s\u00e9quenc\u00e9es d\u00e9finissent des vues, pas des copies</li> <li><code>reversed()</code> refl\u00e8te les modifications de mani\u00e8re bidirectionnelle</li> <li>Toutes les impl\u00e9mentations de Set ou de Map ne sont pas s\u00e9quenc\u00e9es</li> <li>HashSet et HashMap n\u2019impl\u00e9mentent pas les interfaces s\u00e9quenc\u00e9es</li> <li>L\u2019ordre n\u2019est garanti que lorsqu\u2019il est explicitement d\u00e9fini</li> <li>Supprimer des \u00e9l\u00e9ments via un iterator sur la vue invers\u00e9e impacte imm\u00e9diatement l\u2019ordre original</li> </ul>"},{"location":"fr/module-06/sequenced/#296-resume","title":"29.6 R\u00e9sum\u00e9","text":"<ul> <li>Les interfaces s\u00e9quenc\u00e9es formalisent l\u2019ordre d\u2019apparition</li> <li>Elles fournissent un acc\u00e8s first/last et l\u2019inversion</li> <li>Elles fonctionnent via des vues live, pas des copies</li> <li>Elles unifient les API entre listes, deque, set et map</li> </ul>"},{"location":"fr/module-06/set-api/","title":"26. Set API","text":""},{"location":"fr/module-06/set-api/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>26.1 Hi\u00e9rarchie des Set Java-Collections-Framework</li> <li>26.2 Caract\u00e9ristiques de Chaque Impl\u00e9mentation de Set<ul> <li>26.2.1 HashSet</li> <li>26.2.2 LinkedHashSet</li> <li>26.2.3 TreeSet</li> </ul> </li> <li>26.3 R\u00e8gles d\u2019\u00c9galit\u00e9 dans les Set<ul> <li>26.3.1 HashSet--LinkedHashSet</li> <li>26.3.2 TreeSet</li> </ul> </li> <li>26.4 Cr\u00e9er des Instances de Set<ul> <li>26.4.1 En Utilisant les Constructeurs</li> <li>26.4.2 Constructeurs de Copie</li> <li>26.4.3 M\u00e9thodes Factory</li> </ul> </li> <li>26.5 Op\u00e9rations Principales sur les Set<ul> <li>26.5.1 Ajouter des \u00c9l\u00e9ments</li> <li>26.5.2 V\u00e9rifier l\u2019Appartenance</li> <li>26.5.3 Supprimer des \u00c9l\u00e9ments</li> <li>26.5.4 Op\u00e9rations Bulk</li> </ul> </li> <li>26.6 Pi\u00e8ges Courants</li> <li>26.7 Tableau R\u00e9capitulatif</li> </ul> <p>Un Set en Java repr\u00e9sente une collection qui ne contient pas d\u2019\u00e9l\u00e9ments dupliqu\u00e9s.  </p> <p>Il mod\u00e9lise le concept math\u00e9matique d\u2019<code>ensemble</code> : non ordonn\u00e9 (sauf si une impl\u00e9mentation ordonn\u00e9e est utilis\u00e9e) et compos\u00e9 de valeurs uniques.</p> <p>Toutes les impl\u00e9mentations de Set reposent sur des s\u00e9mantiques d\u2019\u00e9galit\u00e9 (via <code>equals()</code> ou la logique de <code>Comparator</code>).</p> <p></p>"},{"location":"fr/module-06/set-api/#261-hierarchie-des-set-java-collections-framework","title":"26.1 Hi\u00e9rarchie des Set (Java Collections Framework)","text":"<pre><code>Set&lt;E&gt;\n \u251c\u2500\u2500 SequencedSet&lt;E&gt; (Java 21+)\n \u2502    \u2514\u2500\u2500 LinkedHashSet&lt;E&gt;   (ordonn\u00e9)\n \u251c\u2500\u2500 HashSet&lt;E&gt;              (non ordonn\u00e9)\n \u2514\u2500\u2500 SortedSet&lt;E&gt;\n      \u2514\u2500\u2500 NavigableSet&lt;E&gt;\n           \u2514\u2500\u2500 TreeSet&lt;E&gt;    (ordonn\u00e9)\n</code></pre> <p>Toutes les impl\u00e9mentations de <code>Set</code> requi\u00e8rent : - l\u2019unicit\u00e9 des \u00e9l\u00e9ments - une \u00e9galit\u00e9 et un hashing pr\u00e9visibles (selon l\u2019impl\u00e9mentation)</p> <p>Note</p> <p><code>LinkedHashSet</code> est d\u00e9sormais formellement un <code>SequencedSet</code> depuis Java 21.</p> <p></p>"},{"location":"fr/module-06/set-api/#262-caracteristiques-de-chaque-implementation-de-set","title":"26.2 Caract\u00e9ristiques de Chaque Impl\u00e9mentation de Set","text":""},{"location":"fr/module-06/set-api/#2621-hashset","title":"26.2.1 HashSet","text":"<ul> <li>Set g\u00e9n\u00e9raliste le plus rapide  </li> <li>Non ordonn\u00e9 (aucune garantie sur l\u2019ordre d\u2019it\u00e9ration)  </li> <li>Utilise <code>hashCode()</code> et <code>equals()</code> </li> <li>Autorise un seul \u00e9l\u00e9ment <code>null</code> </li> </ul> <pre><code>Set&lt;String&gt; set = new HashSet&lt;&gt;();\nset.add(\"A\");\nset.add(\"B\");\nset.add(\"A\");   // doublon ignor\u00e9\nSystem.out.println(set); // ordre non garanti\n</code></pre>"},{"location":"fr/module-06/set-api/#2622-linkedhashset","title":"26.2.2 LinkedHashSet","text":"<ul> <li>Maintient l\u2019ordre d\u2019insertion </li> <li>L\u00e9g\u00e8rement plus lent que HashSet  </li> <li>Utile lorsqu\u2019un ordre d\u2019it\u00e9ration pr\u00e9visible est requis</li> </ul> <pre><code>Set&lt;String&gt; set = new LinkedHashSet&lt;&gt;();\nset.add(\"A\");\nset.add(\"C\");\nset.add(\"B\");\nSystem.out.println(set);  // [A, C, B]\n</code></pre>"},{"location":"fr/module-06/set-api/#2623-treeset","title":"26.2.3 TreeSet","text":"<p>Un Set tri\u00e9 dont l\u2019ordre est d\u00e9termin\u00e9 par : 1. L\u2019ordre naturel (<code>Comparable</code>) 2. Un <code>Comparator</code> fourni  </p> <p>TreeSet : - N\u2019autorise pas d\u2019\u00e9l\u00e9ments <code>null</code> (NullPointerException \u00e0 l\u2019ex\u00e9cution) - Garantit une it\u00e9ration tri\u00e9e - Prend en charge des vues par plage : <code>headSet()</code>, <code>tailSet()</code>, <code>subSet()</code> </p> <pre><code>TreeSet&lt;Integer&gt; tree = new TreeSet&lt;&gt;();\ntree.add(10);\ntree.add(1);\ntree.add(5);\n\nSystem.out.println(tree); // [1, 5, 10]\n</code></pre> <p>Note</p> <p><code>TreeSet</code> exige que tous les \u00e9l\u00e9ments soient mutuellement comparables \u2014 m\u00e9langer des types non comparables produit une <code>ClassCastException</code>. Les op\u00e9rations (add, remove, contains) sont en O(log n).</p> <p></p>"},{"location":"fr/module-06/set-api/#263-regles-degalite-dans-les-set","title":"26.3 R\u00e8gles d\u2019\u00c9galit\u00e9 dans les Set","text":"<p>Les r\u00e8gles diff\u00e8rent selon l\u2019impl\u00e9mentation.</p> <p></p>"},{"location":"fr/module-06/set-api/#2631-hashset-linkedhashset","title":"26.3.1 HashSet &amp; LinkedHashSet","text":"<p>L\u2019<code>unicit\u00e9</code> est d\u00e9termin\u00e9e par deux m\u00e9thodes : - <code>hashCode()</code> - <code>equals()</code> </p> <p>Deux objets sont consid\u00e9r\u00e9s comme le m\u00eame \u00e9l\u00e9ment si :</p> <ol> <li>Leurs hash codes correspondent  </li> <li>Leur m\u00e9thode <code>equals()</code> retourne <code>true</code> </li> </ol> <p>Warning</p> <p>Si vous modifiez un objet apr\u00e8s l\u2019avoir ajout\u00e9 \u00e0 un HashSet ou LinkedHashSet, son hashCode peut changer et le set peut perdre la r\u00e9f\u00e9rence \u00e0 cet \u00e9l\u00e9ment.</p> <p></p>"},{"location":"fr/module-06/set-api/#2632-treeset","title":"26.3.2 TreeSet","text":"<p>L\u2019unicit\u00e9 est bas\u00e9e sur <code>compareTo()</code> ou sur le <code>Comparator</code> fourni.  </p> <p>Si <code>compare(a, b) == 0</code>, alors les objets sont consid\u00e9r\u00e9s comme des doublons, m\u00eame si <code>equals()</code> retourne false.</p> <pre><code>Comparator&lt;String&gt; comp = (a, b) -&gt; a.length() - b.length();\nSet&lt;String&gt; set = new TreeSet&lt;&gt;(comp);\n\nset.add(\"Hi\");\nset.add(\"Yo\"); // m\u00eame longueur \u2192 trait\u00e9 comme doublon\n\nSystem.out.println(set);  // [\"Hi\"]\n</code></pre> <p></p>"},{"location":"fr/module-06/set-api/#264-creer-des-instances-de-set","title":"26.4 Cr\u00e9er des Instances de Set","text":""},{"location":"fr/module-06/set-api/#2641-en-utilisant-les-constructeurs","title":"26.4.1 En Utilisant les Constructeurs","text":"<pre><code>Set&lt;String&gt; s1 = new HashSet&lt;&gt;();\nSet&lt;String&gt; s2 = new LinkedHashSet&lt;&gt;();\nSet&lt;String&gt; s3 = new TreeSet&lt;&gt;();\n</code></pre>"},{"location":"fr/module-06/set-api/#2642-constructeurs-de-copie","title":"26.4.2 Constructeurs de Copie","text":"<pre><code>List&lt;String&gt; list = List.of(\"A\", \"B\", \"C\");\n\nSet&lt;String&gt; copy = new HashSet&lt;&gt;(list); // ordre perdu\nSystem.out.println(copy);\n\nSet&lt;String&gt; ordered = new LinkedHashSet&lt;&gt;(list); // conserve l\u2019ordre de la liste\nSystem.out.println(ordered);\n</code></pre>"},{"location":"fr/module-06/set-api/#2643-methodes-factory","title":"26.4.3 M\u00e9thodes Factory","text":"<pre><code>Set&lt;String&gt; s1 = Set.of(\"A\", \"B\", \"C\");   // immuable\nSet&lt;String&gt; empty = Set.of();             // set immuable vide\n</code></pre> <p>Note</p> <p>Les set cr\u00e9\u00e9s via les factory sont immuables : ajouter ou supprimer des \u00e9l\u00e9ments l\u00e8ve <code>UnsupportedOperationException</code>. <code>Set.of(...)</code> rejette les doublons \u00e0 la cr\u00e9ation \u2192 IllegalArgumentException et rejette null \u2192 NullPointerException</p> <p></p>"},{"location":"fr/module-06/set-api/#265-operations-principales-sur-les-set","title":"26.5 Op\u00e9rations Principales sur les Set","text":""},{"location":"fr/module-06/set-api/#2651-ajouter-des-elements","title":"26.5.1 Ajouter des \u00c9l\u00e9ments","text":"<pre><code>set.add(\"A\");          // retourne true si ajout\u00e9\nset.add(\"A\");          // retourne false si doublon\n</code></pre>"},{"location":"fr/module-06/set-api/#2652-verifier-lappartenance","title":"26.5.2 V\u00e9rifier l\u2019Appartenance","text":"<pre><code>set.contains(\"A\");\n</code></pre>"},{"location":"fr/module-06/set-api/#2653-supprimer-des-elements","title":"26.5.3 Supprimer des \u00c9l\u00e9ments","text":"<pre><code>set.remove(\"A\");\nset.clear();\n</code></pre>"},{"location":"fr/module-06/set-api/#2654-operations-bulk","title":"26.5.4 Op\u00e9rations Bulk","text":"<pre><code>set.addAll(otherSet);\nset.removeAll(otherSet);\nset.retainAll(otherSet); // intersection\n</code></pre>"},{"location":"fr/module-06/set-api/#266-pieges-courants","title":"26.6 Pi\u00e8ges Courants","text":"<ul> <li>Utiliser TreeSet avec des objets non comparables \u2192 <code>ClassCastException</code></li> <li>TreeSet n\u2019utilise pas <code>equals()</code> : seul comparator/compareTo d\u00e9termine l\u2019unicit\u00e9</li> <li>Utiliser des objets mutables comme cl\u00e9s de Set \u2192 casse les r\u00e8gles de hashing</li> <li>Les Set cr\u00e9\u00e9s avec Set.of() sont immuables \u2014 la modification \u00e9choue</li> <li>HashSet ne garantit pas l\u2019ordre d\u2019it\u00e9ration</li> <li>TreeSet traite les objets avec compare()==0 comme des doublons m\u00eame s\u2019ils ne sont pas \u00e9gaux</li> </ul>"},{"location":"fr/module-06/set-api/#267-tableau-recapitulatif","title":"26.7 Tableau R\u00e9capitulatif","text":"Impl\u00e9mentation Conserve l\u2019Ordre ? Autorise Null ? Tri\u00e9 ? Logique Sous-jacente HashSet Non Oui (1 null) Non hashCode + equals LinkedHashSet Oui (ordre d\u2019insertion) Oui (1 null) Non table de hachage + liste cha\u00een\u00e9e TreeSet Oui (tri\u00e9) Non Oui (naturel/comparator) compareTo / Comparator"},{"location":"fr/module-06/shared-operations/","title":"23. Op\u00e9rations Partag\u00e9es des Collections &amp; \u00c9galit\u00e9","text":""},{"location":"fr/module-06/shared-operations/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>23.1 M\u00e9thodes Fondamentales des Collections Disponibles pour la Majorit\u00e9 des Collections<ul> <li>23.1.1 Op\u00e9rations de Mutation</li> <li>23.1.2 Op\u00e9rations de Requ\u00eate</li> </ul> </li> <li>23.2 \u00c9galit\u00e9</li> <li>23.3 Comportement Fail-Fast</li> <li>23.4 Op\u00e9rations Bulk</li> <li>23.5 Types de Retour et Exceptions Courantes</li> <li>23.6 Tableau de Synth\u00e8se \u2014 Op\u00e9rations Partag\u00e9es</li> </ul> <p>Ce chapitre couvre les op\u00e9rations fondamentales partag\u00e9es dans toute la Java Collections API, y compris la mani\u00e8re dont l\u2019\u00e9galit\u00e9 est d\u00e9termin\u00e9e \u00e0 l\u2019int\u00e9rieur des collections.</p> <p>Ces concepts s\u2019appliquent \u00e0 toutes les principales familles de collections bas\u00e9es sur Collection (List, Set, Queue, Deque et leurs variantes Sequenced). <p>Map partage plusieurs comportements conceptuels (it\u00e9ration, \u00e9galit\u00e9) mais n\u2019h\u00e9rite pas de Collection.</p> <p>Ma\u00eetriser ces op\u00e9rations est essentiel, car elles expliquent comment les collections se comportent lors de l\u2019ajout, de la recherche, de la suppression, de la comparaison, de l\u2019it\u00e9ration et du tri des \u00e9l\u00e9ments.</p> <p></p>"},{"location":"fr/module-06/shared-operations/#231-methodes-fondamentales-des-collections-disponibles-pour-la-majorite-des-collections","title":"23.1 M\u00e9thodes Fondamentales des Collections (Disponibles pour la Majorit\u00e9 des Collections)","text":"<p>Les m\u00e9thodes suivantes proviennent de l\u2019interface <code>Collection&lt;E&gt;</code> et sont h\u00e9rit\u00e9es par toutes les principales collections \u00e0 l\u2019exception de <code>Map</code> (qui poss\u00e8de sa propre famille d\u2019op\u00e9rations).</p> <p>Note</p> <p><code>Map</code> n\u2019impl\u00e9mente pas <code>Collection</code>, mais ses vues <code>keySet()</code>, <code>values()</code> et <code>entrySet()</code> l\u2019impl\u00e9mentent, et exposent donc ces op\u00e9rations partag\u00e9es.</p> <p></p>"},{"location":"fr/module-06/shared-operations/#2311-operations-de-mutation","title":"23.1.1 Op\u00e9rations de Mutation","text":"<ul> <li><code>boolean add(E e)</code> \u2014 Ajoute un \u00e9l\u00e9ment (les listes autorisent les doublons).</li> <li><code>boolean remove(Object o)</code> \u2014 Supprime le premier \u00e9l\u00e9ment correspondant.</li> <li><code>void clear()</code> \u2014 Supprime tous les \u00e9l\u00e9ments.</li> <li><code>boolean addAll(Collection&lt;? extends E&gt; c)</code> \u2014 Insertion bulk.</li> <li><code>boolean removeAll(Collection&lt;?&gt; c)</code> \u2014 Supprime tous les \u00e9l\u00e9ments contenus dans la collection fournie.</li> <li><code>boolean retainAll(Collection&lt;?&gt; c)</code> \u2014 Conserve uniquement les \u00e9l\u00e9ments correspondants.</li> </ul>"},{"location":"fr/module-06/shared-operations/#2312-operations-de-requete","title":"23.1.2 Op\u00e9rations de Requ\u00eate","text":"<ul> <li><code>int size()</code> \u2014 Nombre d\u2019\u00e9l\u00e9ments.</li> <li><code>boolean isEmpty()</code> \u2014 Indique si la collection contient z\u00e9ro \u00e9l\u00e9ment.</li> <li><code>boolean contains(Object o)</code> \u2014 S\u2019appuie sur les r\u00e8gles d\u2019\u00e9galit\u00e9 des \u00e9l\u00e9ments.</li> <li><code>Iterator&lt;E&gt; iterator()</code> \u2014 Retourne un it\u00e9rateur (fail-fast).</li> <li><code>Object[] toArray()</code> et <code>&lt;T&gt; T[] toArray(T[] a)</code> \u2014 Copie dans un tableau.</li> </ul>"},{"location":"fr/module-06/shared-operations/#232-egalite","title":"23.2 \u00c9galit\u00e9","text":"<p>Une impl\u00e9mentation personnalis\u00e9e de la m\u00e9thode <code>equals()</code> permet de comparer le type et le contenu de deux collections.</p> <p>L\u2019impl\u00e9mentation diff\u00e8re selon que l\u2019on traite des List ou des Set.</p> <ul> <li>Exemple</li> </ul> <pre><code>List&lt;Integer&gt; firstList = List.of(10, 11, 22);\nList&lt;Integer&gt; secondList = List.of(10, 11, 22);\nList&lt;Integer&gt; thirdList = List.of(22, 11, 10);\n\nSystem.out.println(\"firstList.equals(secondList): \" + firstList.equals(secondList));\nSystem.out.println(\"secondList.equals(thirdList): \" + secondList.equals(thirdList));\n\nSet&lt;Integer&gt; firstSet = Set.of(10, 11, 22);\nSet&lt;Integer&gt; secondSet = Set.of(10, 11, 22);\nSet&lt;Integer&gt; thirdSet = Set.of(22, 11, 10);\n\nSystem.out.println(\"firstSet.equals(secondSet): \" + firstSet.equals(secondSet));\nSystem.out.println(\"secondSet.equals(thirdSet): \" + secondSet.equals(thirdSet));\n</code></pre> <p>Sortie</p> <pre><code>firstList.equals(secondList): true\nsecondList.equals(thirdList): false\nfirstSet.equals(secondSet): true\nsecondSet.equals(thirdSet): true\n</code></pre> <p>Note</p> <ul> <li>Les List comparent la taille, l\u2019ordre et l\u2019\u00e9galit\u00e9 des \u00e9l\u00e9ments un par un.</li> <li>Les Set comparent uniquement la taille et l\u2019appartenance \u2014 l\u2019ordre de parcours est sans importance.</li> <li>Deux sets contenant les m\u00eames \u00e9l\u00e9ments logiques sont \u00e9gaux m\u00eame s\u2019ils maintiennent des ordres d\u2019it\u00e9ration internes diff\u00e9rents.</li> </ul> <p></p>"},{"location":"fr/module-06/shared-operations/#233-comportement-fail-fast","title":"23.3 Comportement Fail-Fast","text":"<p>La plupart des it\u00e9rateurs de collections (\u00e0 l\u2019exception des collections concurrentes) sont <code>fail-fast</code> : modifier structurellement une collection pendant l\u2019it\u00e9ration d\u00e9clenche une <code>ConcurrentModificationException</code>.</p> <pre><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;(List.of(1,2,3));\nfor (Integer i : list) {\n    list.add(99); // \u274c ConcurrentModificationException\n}\n</code></pre> <p>Note</p> <p>Utilisez <code>Iterator.remove()</code> lorsque vous devez supprimer des \u00e9l\u00e9ments pendant l\u2019it\u00e9ration. Le comportement fail-fast n\u2019est pas garanti \u2014 l\u2019exception est lev\u00e9e selon un principe de best-effort. Vous ne devez pas compter sur sa capture pour assurer la correction du programme.</p> <p></p>"},{"location":"fr/module-06/shared-operations/#234-operations-bulk","title":"23.4 Op\u00e9rations Bulk","text":"<ul> <li><code>removeIf(Predicate&lt;? super E&gt; filter)</code> \u2014 Supprime tous les \u00e9l\u00e9ments correspondants.</li> <li><code>replaceAll(UnaryOperator&lt;E&gt; op)</code> \u2014 Remplace chaque \u00e9l\u00e9ment.</li> <li><code>forEach(Consumer&lt;? super E&gt; action)</code> \u2014 Applique une action \u00e0 chaque \u00e9l\u00e9ment.</li> <li><code>stream()</code> \u2014 Retourne un stream pour les op\u00e9rations de pipeline.</li> </ul>"},{"location":"fr/module-06/shared-operations/#235-types-de-retour-et-exceptions-courantes","title":"23.5 Types de Retour et Exceptions Courantes","text":"<ul> <li><code>add(E)</code> retourne boolean \u2014 toujours <code>true</code> pour <code>ArrayList</code>, peut \u00eatre <code>false</code> pour les <code>Set</code> si aucune modification n\u2019a lieu.</li> <li><code>remove(Object)</code> retourne boolean (pas l\u2019\u00e9l\u00e9ment supprim\u00e9).</li> <li><code>get(int)</code> l\u00e8ve <code>IndexOutOfBoundsException</code>.</li> <li><code>iterator().remove()</code> l\u00e8ve <code>IllegalStateException</code> s\u2019il est appel\u00e9 deux fois sans <code>next()</code>.</li> <li><code>toArray()</code> retourne toujours un <code>Object[]</code> \u2014 jamais un <code>T[]</code>.</li> </ul>"},{"location":"fr/module-06/shared-operations/#236-tableau-de-synthese-operations-partagees","title":"23.6 Tableau de Synth\u00e8se \u2014 Op\u00e9rations Partag\u00e9es","text":"Op\u00e9ration S\u2019applique \u00e0 Notes <code>add(e)</code> Toutes les collections sauf Map Les List autorisent les doublons <code>remove(o)</code> Toutes les collections sauf Map Supprime la premi\u00e8re occurrence <code>contains(o)</code> Toutes les collections sauf Map Utilise equals() <code>size(), isEmpty()</code> Toutes les collections Temps constant pour la majorit\u00e9 <code>iterator()</code> Toutes les collections Fail-fast <code>clear()</code> Toutes les collections Supprime tous les \u00e9l\u00e9ments <code>stream()</code> Toutes les collections Retourne un stream s\u00e9quentiel <code>removeIf(), replaceAll()</code> List uniquement (la plupart des Set ne supportent pas replaceAll) Op\u00e9rations bulk <code>toArray()</code> Toutes les collections Retourne Object[]"},{"location":"fr/module-07/concurrency/","title":"31. Java Concurrency APIs","text":""},{"location":"fr/module-07/concurrency/#indice","title":"Indice","text":"<ul> <li>31.1 Objectifs et Port\u00e9e de la Concurrency API</li> <li>31.2 Probl\u00e8mes Fondamentaux du Threading<ul> <li>31.2.1 Race Conditions</li> <li>31.2.2 Deadlock</li> <li>31.2.3 Starvation</li> <li>31.2.4 Livelock</li> </ul> </li> <li>31.3 Des Thread aux Task</li> <li>31.4 Executor Framework<ul> <li>31.4.1 Submitting Task et Futures</li> <li>31.4.2 Callable vs Runnable</li> </ul> </li> <li>31.5 Thread Pools et Scheduling</li> <li>31.6 Lifecycle et Terminaison de l'Executor</li> <li>31.7 Strat\u00e9gies de Thread Safety<ul> <li>31.7.1 Synchronisation</li> <li>31.7.2 Variables atomiques<ul> <li>31.7.2.1 Atomic classes</li> <li>31.7.2.2 M\u00e9thodes Atomiques</li> </ul> </li> <li>31.7.3 Lock Framework<ul> <li>31.7.3.1 Lock implementations</li> <li>31.7.3.2 Common Lock methods</li> </ul> </li> <li>31.7.4 Coordination Utilities</li> </ul> </li> <li>31.8 Concurrent Collections</li> <li>31.9 Parallel Streams</li> <li>31.10 Relation avec Virtual Threads</li> <li>31.11 Sommaire</li> </ul> <p>Ce chapitre introduit la Java Concurrency API, qui fournit des abstractions de haut niveau pour g\u00e9rer la concurrence de mani\u00e8re s\u00fbre, efficace et scalable.</p> <p>\u00c0 la diff\u00e9rence de la manipulation de bas niveau des thread pr\u00e9sent\u00e9e dans le chapitre pr\u00e9c\u00e9dent, la Concurrency API se concentre sur task, executor et m\u00e9canismes de coordination, permettant aux programmeurs de raisonner sur ce qui doit \u00eatre fait plut\u00f4t que sur la mani\u00e8re dont les thread sont schedul\u00e9s.</p> <p></p>"},{"location":"fr/module-07/concurrency/#311-objectifs-et-portee-de-la-concurrency-api","title":"31.1 Objectifs et Port\u00e9e de la Concurrency API","text":"<p>La <code>Java Concurrency API</code>, principalement situ\u00e9e dans le package <code>java.util.concurrent</code>, a \u00e9t\u00e9 introduite pour affronter des probl\u00e8mes fondamentaux inh\u00e9rents \u00e0 la gestion manuelle des thread.</p> <ul> <li>S\u00e9parer la soumission des task de la gestion des thread.</li> <li>R\u00e9duire la <code>synchronization</code> de bas niveau sujette \u00e0 erreurs.</li> <li>Am\u00e9liorer scalabilit\u00e9 et performance sur des syst\u00e8mes multi-core.</li> <li>Fournir des m\u00e9canismes structur\u00e9s pour <code>coordination</code>, <code>cancellation</code> et <code>shutdown</code>.</li> </ul> <p>L'API n\u2019\u00e9limine pas les probl\u00e8mes de concurrence mais fournit des outils pour les g\u00e9rer de mani\u00e8re s\u00fbre et pr\u00e9visible.</p> <p>Au lieu de cr\u00e9er et de contr\u00f4ler explicitement les thread, les programmeurs ex\u00e9cutent des task et laissent le framework g\u00e9rer thread allocation, riuso, et synchronization.</p> <pre><code>ExecutorService executor = Executors.newSingleThreadExecutor();\nexecutor.execute(() -&gt; System.out.println(\"Task executed\"));\nexecutor.shutdown();\n</code></pre> <p></p>"},{"location":"fr/module-07/concurrency/#312-problemes-fondamentaux-du-threading","title":"31.2 Probl\u00e8mes Fondamentaux du Threading","text":"<p>Avant de comprendre la <code>Concurrency API</code>, il est essentiel de comprendre les probl\u00e9matiques de concurrence qu\u2019elle veut att\u00e9nuer.</p> <p>Ces probl\u00e8mes proviennent de <code>shared mutable state</code>, <code>scheduling unpredictability</code> et <code>improper coordination</code>.</p> <p></p>"},{"location":"fr/module-07/concurrency/#3121-race-conditions","title":"31.2.1 Race Conditions","text":"<p>Une race condition se produit lorsque plusieurs thread acc\u00e8dent \u00e0 <code>shared mutable state</code> (un \u00e9tat mutable et partag\u00e9) et la correction du programme d\u00e9pend du timing ou de l\u2019intercalage de leur ex\u00e9cution.</p> <ul> <li>Caus\u00e9e par un acc\u00e8s non synchronis\u00e9 \u00e0 des donn\u00e9es partag\u00e9es.</li> <li>Conduit \u00e0 un \u00e9tat du programme inconsistent ou incorrect.</li> </ul> <pre><code>class Counter {\n    int count = 0;\n    void increment() {\n       count++;\n    }\n}\n</code></pre> <p>Si plusieurs thread invoquent <code>increment()</code> de mani\u00e8re concurrente, certains increments peuvent \u00eatre perdus parce que l\u2019op\u00e9ration n\u2019est pas atomique.</p> <p></p>"},{"location":"fr/module-07/concurrency/#3122-deadlock","title":"31.2.2 Deadlock","text":"<p>Un deadlock se produit lorsque deux ou plusieurs thread sont bloqu\u00e9s de mani\u00e8re permanente, chacun en attente d\u2019une ressource d\u00e9tenue par un autre thread.</p> <ul> <li>Typiquement caus\u00e9 par des d\u00e9pendances circulaires entre lock.</li> <li>Aucun thread impliqu\u00e9 ne peut faire de progr\u00e8s.</li> </ul> <pre><code>synchronized (lockA) {\n    synchronized (lockB) {\n    }\n}\n</code></pre> <p>Si un autre thread acquiert d\u2019abord <code>lockB</code> et ensuite attend <code>lockA</code>, un deadlock peut se produire.</p> <p>Note</p> <p>Les deadlock dans le monde r\u00e9el impliquent typiquement des lock multiples et des inversions d\u2019ordre.</p> <p></p>"},{"location":"fr/module-07/concurrency/#3123-starvation","title":"31.2.3 Starvation","text":"<p>La starvation se produit lorsqu\u2019un thread se voit refuser ind\u00e9finiment l\u2019acc\u00e8s aux ressources, m\u00eame si ces ressources sont disponibles.</p> <ul> <li>Souvent caus\u00e9e par <code>unfair locking</code> ou des policy de scheduling.</li> <li>Le thread reste <code>runnable</code> mais n\u2019est jamais ex\u00e9cut\u00e9.</li> </ul> <pre><code>ReentrantLock lock = new ReentrantLock(false); // unfair lock\n</code></pre> <p>Certains thread peuvent acqu\u00e9rir de mani\u00e8re r\u00e9p\u00e9t\u00e9e le lock tandis que d\u2019autres attendent ind\u00e9finiment.</p> <p></p>"},{"location":"fr/module-07/concurrency/#3124-livelock","title":"31.2.4 Livelock","text":"<p>Dans un livelock, les thread ne sont pas bloqu\u00e9s mais r\u00e9agissent continuellement l\u2019un \u00e0 l\u2019autre d\u2019une mani\u00e8re qui en emp\u00eache le progr\u00e8s.</p> <ul> <li>Les thread restent actifs mais inefficaces.</li> <li>Souvent caus\u00e9 par une logique de retry ou d\u2019avoidance agressive.</li> </ul> <pre><code>while (!tryLock()) {\n    Thread.sleep(10);\n}\n</code></pre> <p>Les deux thread peuvent r\u00e9p\u00e9ter continuellement le retry, emp\u00eachant le forward progress.</p> <p></p>"},{"location":"fr/module-07/concurrency/#313-des-thread-aux-task","title":"31.3 Des Thread aux Task","text":"<p>La Concurrency API d\u00e9place le mod\u00e8le de programmation de la gestion directe des thread vers la soumission de task.</p> <p>Un task repr\u00e9sente une unit\u00e9 logique de travail ind\u00e9pendante du thread qui l\u2019ex\u00e9cute.</p> <ul> <li>Runnable: Repr\u00e9sente un task qui ne retourne pas un r\u00e9sultat.</li> <li>Callable: Repr\u00e9sente un task qui retourne un r\u00e9sultat et peut lancer des checked exceptions.</li> </ul> <pre><code>Runnable task = () -&gt; System.out.println(\"Runnable task\");\nCallable&lt;Integer&gt; callable = () -&gt; 42;\n</code></pre> <p>Cette abstraction permet aux task d\u2019\u00eatre r\u00e9utilis\u00e9s, schedul\u00e9s de mani\u00e8re flexible et ex\u00e9cut\u00e9s via des strat\u00e9gies d\u2019ex\u00e9cution diff\u00e9rentes.</p> <p></p>"},{"location":"fr/module-07/concurrency/#314-executor-framework","title":"31.4 Executor Framework","text":"<p>L\u2019Executor Framework est le c\u0153ur de la Concurrency API.</p> <p>Il g\u00e8re la cr\u00e9ation des thread, le riuso et l'ex\u00e9cution des task \u00e0 travers une interface simple.</p> <ul> <li>Executor: Interface de base pour ex\u00e9cuter des task.</li> <li>ExecutorService: \u00c9tend Executor avec contr\u00f4le du lifecycle et gestion des r\u00e9sultats.</li> <li>ScheduledExecutorService: Supporte l\u2019ex\u00e9cution de task delayed et p\u00e9riodiques.</li> </ul> <pre><code>ExecutorService executor = Executors.newFixedThreadPool(2);\nexecutor.execute(() -&gt; System.out.println(\"Task 1\"));\nexecutor.execute(() -&gt; System.out.println(\"Task 2\"));\nexecutor.shutdown();\n</code></pre> <p></p>"},{"location":"fr/module-07/concurrency/#3141-submitting-task-et-futures","title":"31.4.1 Submitting Task et Futures","text":"<p>Les task soumis via <code>execute()</code> retournent <code>void</code>: c\u2019est une m\u00e9thode \"fire-and-forget\" qui ne retourne aucune information sur le r\u00e9sultat du task.</p> <p>Les task soumis en utilisant <code>submit()</code> retournent un Future, qui repr\u00e9sente le r\u00e9sultat d\u2019une computation asynchrone.</p> <p>Les deux m\u00e9thodes sont utilis\u00e9es pour soumettre du travail pour une ex\u00e9cution asynchrone.</p> <pre><code>Future&lt;Integer&gt; future = executor.submit(() -&gt; 10 + 20);\nInteger result = future.get();\n</code></pre> Method Description void execute(Runnable task) Ex\u00e9cute un task de mani\u00e8re asynchrone sans valeur de retour et sans <code>Future</code>. Future&lt;?&gt; submit(Runnable task) Ex\u00e9cute un task de mani\u00e8re asynchrone; aucun r\u00e9sultat n\u2019est produit (<code>Future.get()</code> retourne <code>null</code>).  Future submit(Callable task) Ex\u00e9cute un task de mani\u00e8re asynchrone et retourne un r\u00e9sultat de type <code>T</code>.  List&gt; invokeAll(Collection&lt;? extends Callable&gt; tasks) Ex\u00e9cute tous les task et retourne un <code>Future</code> pour chacun, apr\u00e8s que tous compl\u00e8tent.  T invokeAny(Collection&lt;? extends Callable&gt; tasks) Ex\u00e9cute les task et retourne le r\u00e9sultat d\u2019un qui compl\u00e8te avec succ\u00e8s; les autres sont annul\u00e9s. Method Description boolean isDone() Retourne <code>true</code> si le task est termin\u00e9 (normalement, exceptionnellement, ou via cancellation). boolean isCancelled() Retourne <code>true</code> si le task a \u00e9t\u00e9 annul\u00e9 avant la fin normale. boolean cancel(boolean mayInterruptIfRunning) Tente d\u2019annuler l\u2019ex\u00e9cution. Si <code>true</code>, interrompt le thread en ex\u00e9cution si possible. T get() Blocque jusqu\u2019\u00e0 la fin et retourne le r\u00e9sultat, ou lance une exception si \u00e9chou\u00e9 ou annul\u00e9. T get(long timeout, TimeUnit unit) Blocque jusqu\u2019au timeout donn\u00e9 et retourne le r\u00e9sultat, ou lance <code>TimeoutException</code> si non termin\u00e9. <p>Warning</p> <p><code>execute()</code> rejettera les exceptions silencieusement \u00e0 moins qu\u2019elles ne soient g\u00e9r\u00e9es \u00e0 l\u2019int\u00e9rieur du task.</p> <p></p>"},{"location":"fr/module-07/concurrency/#3142-callable-vs-runnable","title":"31.4.2 Callable vs Runnable","text":"<p>Les deux interfaces repr\u00e9sentent des task, mais avec des capacit\u00e9s diff\u00e9rentes.</p> <ul> <li><code>Runnable</code>: Aucune valeur de retour, ne peut pas lancer de checked exceptions.</li> <li><code>Callable</code>: Retourne une valeur et supporte des checked exceptions.</li> </ul> <pre><code>Callable&lt;String&gt; c = () -&gt; \"done\";\nRunnable r = () -&gt; System.out.println(\"done\");\n</code></pre> <p>Pour une computation asynchrone orient\u00e9e r\u00e9sultat, <code>Callable</code> est g\u00e9n\u00e9ralement pr\u00e9f\u00e9r\u00e9.</p> <p></p>"},{"location":"fr/module-07/concurrency/#315-thread-pools-et-scheduling","title":"31.5 Thread Pools et Scheduling","text":"<p>Les executor g\u00e8rent des thread pools, qui r\u00e9utilisent un nombre fixe ou dynamique de thread pour ex\u00e9cuter des task de mani\u00e8re efficace.</p> <ul> <li>Fixed thread pool: Limite la concurrence \u00e0 un nombre fixe de thread.</li> <li>Cached thread pool: Cro\u00eet et se r\u00e9duit dynamiquement selon la demande: cr\u00e9e de nouveaux thread quand n\u00e9cessaire mais r\u00e9utilise des thread disponibles.</li> <li>Single-thread executor: Garantit l\u2019ex\u00e9cution s\u00e9quentielle des task.</li> <li>Scheduled executor: Supporte des task delayed et p\u00e9riodiques.</li> </ul> M\u00e9thode Factory Type de Retour Description <code>Executors.newFixedThreadPool(int nThreads)</code> ExecutorService Cr\u00e9e un thread pool avec un nombre fixe de threads. <code>Executors.newFixedThreadPool(int nThreads, ThreadFactory threadFactory)</code> ExecutorService Identique \u00e0 newFixedThreadPool mais avec un ThreadFactory personnalis\u00e9. <code>Executors.newSingleThreadExecutor()</code> ExecutorService Cr\u00e9e un thread pool \u00e0 un seul thread qui ex\u00e9cute les task de mani\u00e8re s\u00e9quentielle. <code>Executors.newSingleThreadExecutor(ThreadFactory threadFactory)</code> ExecutorService Executor \u00e0 un seul thread avec un ThreadFactory personnalis\u00e9. <code>Executors.newCachedThreadPool()</code> ExecutorService Cr\u00e9e un thread pool qui cr\u00e9e de nouveaux threads si n\u00e9cessaire et r\u00e9utilise ceux inactifs. <code>Executors.newCachedThreadPool(ThreadFactory threadFactory)</code> ExecutorService Thread pool cached avec un ThreadFactory personnalis\u00e9. <code>Executors.newSingleThreadScheduledExecutor()</code> ScheduledExecutorService Cr\u00e9e un scheduled executor \u00e0 un seul thread. <code>Executors.newSingleThreadScheduledExecutor(ThreadFactory threadFactory)</code> ScheduledExecutorService Scheduled executor \u00e0 un seul thread avec ThreadFactory personnalis\u00e9. <code>Executors.newScheduledThreadPool(int corePoolSize)</code> ScheduledExecutorService Cr\u00e9e un scheduled thread pool avec la taille core sp\u00e9cifi\u00e9e. <code>Executors.newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory)</code> ScheduledExecutorService Scheduled thread pool avec ThreadFactory personnalis\u00e9. <code>Executors.newWorkStealingPool()</code> ExecutorService Cr\u00e9e un work-stealing pool en utilisant le nombre de processeurs disponibles comme niveau de parall\u00e9lisme. <code>Executors.newWorkStealingPool(int parallelism)</code> ExecutorService Cr\u00e9e un work-stealing pool avec le niveau de parall\u00e9lisme sp\u00e9cifi\u00e9. <code>Executors.newThreadPerTaskExecutor(ThreadFactory threadFactory)</code> ExecutorService Cr\u00e9e un executor qui d\u00e9marre un nouveau thread pour chaque task. <code>Executors.newVirtualThreadPerTaskExecutor()</code> ExecutorService Cr\u00e9e un executor qui d\u00e9marre un nouveau virtual thread pour chaque task. <p><code>Task scheduling</code> : les task soumis \u00e0 un executor sont plac\u00e9s dans une file et r\u00e9cup\u00e9r\u00e9s par les threads du pool ; l\u2019ordre d\u2019ex\u00e9cution d\u00e9pend de l\u2019impl\u00e9mentation de l\u2019executor, de la politique de file et de la disponibilit\u00e9 des threads. Dans un scheduled executor, les task sont ordonn\u00e9s selon leur temps d\u2019activation ; les task p\u00e9riodiques sont r\u00e9ins\u00e9r\u00e9s dans la file apr\u00e8s chaque ex\u00e9cution.</p> <pre><code>ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\n\nscheduler.schedule(\n    () -&gt; System.out.println(\"Delayed\"),\n    2, TimeUnit.SECONDS);\n</code></pre> Method Description ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit) Planifie une action one-shot qui devient ex\u00e9cutable apr\u00e8s le delay sp\u00e9cifi\u00e9.  ScheduledFuture schedule(Callable callable, long delay, TimeUnit unit) Planifie un task one-shot qui retourne une valeur apr\u00e8s le delay sp\u00e9cifi\u00e9. ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) Planifie une ex\u00e9cution p\u00e9riodique \u00e0 fixed rate : chaque ex\u00e9cution est planifi\u00e9e par rapport au temps initial ; si une ex\u00e9cution est retard\u00e9e, les suivantes peuvent tenter de \u00ab rattraper \u00bb. ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) Planifie une ex\u00e9cution p\u00e9riodique avec fixed delay : chaque ex\u00e9cution est planifi\u00e9e par rapport \u00e0 la fin de la pr\u00e9c\u00e9dente ; aucun comportement de rattrapage. <p>Important</p> <p>Ne jamais cr\u00e9er des thread manuellement dans une boucle: utilise plut\u00f4t des pools ou des virtual threads.</p> <p></p>"},{"location":"fr/module-07/concurrency/#316-lifecycle-et-terminaison-de-lexecutor","title":"31.6 Lifecycle et Terminaison de l'Executor","text":"<p>Les executor doivent \u00eatre ferm\u00e9s explicitement pour lib\u00e9rer des ressources et permettre la terminaison de la JVM.</p> <ul> <li>shutdown(): D\u00e9marre un shutdown ordonn\u00e9: compl\u00e8te les task en attente mais n\u2019accepte pas de task suppl\u00e9mentaires.</li> <li>close(): (Java 19+) appelle shutdown() et attend que les task finissent, se comportant comme support try-with-resources pour ExecutorService.</li> <li>shutdownNow(): Tente un shutdown imm\u00e9diat et interrompt les task en ex\u00e9cution.</li> <li>awaitTermination(): Attend la compl\u00e9tion ou un timeout.</li> </ul> <pre><code>executor.shutdown();\nexecutor.awaitTermination(5, TimeUnit.SECONDS);\n</code></pre> <p></p>"},{"location":"fr/module-07/concurrency/#317-strategies-de-thread-safety","title":"31.7 Strat\u00e9gies de Thread Safety","text":"<p>La Concurrency API fournit de multiples strat\u00e9gies compl\u00e9mentaires pour obtenir thread safety.</p> <p></p>"},{"location":"fr/module-07/concurrency/#3171-synchronisation","title":"31.7.1 Synchronisation","text":"<p>La synchronisation impose <code>mutual exclusion</code> et <code>memory visibility</code> en utilisant un intrinsic lock (monitor) associ\u00e9 \u00e0 un objet ou \u00e0 une classe.</p> <pre><code>synchronized void increment() {\n    count++;\n}\n</code></pre> <p>Quand un thread entre dans une m\u00e9thode synchronized:</p> <ul> <li>Il acquiert l\u2019intrinsic lock de l\u2019objet target (<code>this</code> pour les m\u00e9thodes d\u2019instance).</li> <li>Un seul thread \u00e0 la fois peut d\u00e9tenir le m\u00eame lock, emp\u00eachant une ex\u00e9cution concurrente.</li> <li>Quand la m\u00e9thode se termine, le lock est lib\u00e9r\u00e9 automatiquement.</li> </ul> <p>La synchronization \u00e9tablit une happens-before relationship dans le Java Memory Model:</p> <ul> <li>Toutes les \u00e9critures faites dans la r\u00e9gion synchronized sont flush\u00e9es dans la m\u00e9moire principale quand le lock est lib\u00e9r\u00e9.</li> <li>Un thread qui acquiert le m\u00eame lock ensuite est garanti de voir ces update.</li> </ul> <p>La keyword synchronized peut \u00eatre appliqu\u00e9e \u00e0:</p> <ul> <li>M\u00e9thodes d\u2019instance (lock sur <code>this</code>)</li> <li>M\u00e9thodes statiques (lock sur l\u2019objet <code>Class</code>)</li> <li>Blocs (lock sur un objet sp\u00e9cifique, permettant un contr\u00f4le plus fin)</li> </ul> <p>Important</p> <p>La synchronisation est simple mais peut r\u00e9duire la scalabilit\u00e9 sous contention.</p> <p></p>"},{"location":"fr/module-07/concurrency/#3172-variables-atomiques","title":"31.7.2 Variables Atomiques","text":"<p>Les <code>atomic classes</code> fournissent des op\u00e9rations lock-free, thread-safe impl\u00e9ment\u00e9es en utilisant des primitives CPU de bas niveau comme Compare-And-Swap (CAS).</p> <pre><code>AtomicInteger count = new AtomicInteger();\ncount.incrementAndGet();\n</code></pre> <p></p>"},{"location":"fr/module-07/concurrency/#31721-atomic-classes","title":"31.7.2.1 Atomic classes","text":"Atomic Class Description AtomicBoolean Met \u00e0 jour et lit de mani\u00e8re atomique une valeur <code>boolean</code>. AtomicInteger Met \u00e0 jour et lit de mani\u00e8re atomique une valeur <code>int</code>. AtomicLong Met \u00e0 jour et lit de mani\u00e8re atomique une valeur <code>long</code>. AtomicReference Met \u00e0 jour et lit de mani\u00e8re atomique un reference \u00e0 objet. AtomicIntegerArray Fournit des op\u00e9rations atomiques sur les \u00e9l\u00e9ments d\u2019un array <code>int</code>. AtomicLongArray Fournit des op\u00e9rations atomiques sur les \u00e9l\u00e9ments d\u2019un array <code>long</code>. AtomicReferenceArray Fournit des op\u00e9rations atomiques sur les \u00e9l\u00e9ments d\u2019un array de reference. AtomicStampedReference Met \u00e0 jour de mani\u00e8re atomique un reference avec un integer stamp pour \u00e9viter des probl\u00e8mes ABA. AtomicMarkableReference Met \u00e0 jour de mani\u00e8re atomique un reference avec un boolean mark."},{"location":"fr/module-07/concurrency/#31722-methodes-atomiques","title":"31.7.2.2 M\u00e9thodes Atomiques","text":"Method Description get() Retourne la valeur courante avec une s\u00e9mantique volatile-read. set(value) D\u00e9finit la valeur avec une s\u00e9mantique volatile-write. lazySet(value) D\u00e9finit \u00e9ventuellement la valeur avec des garanties d\u2019ordering plus faibles. compareAndSet(expect, update) D\u00e9finit de mani\u00e8re atomique la valeur si la valeur courante est \u00e9gale \u00e0 la valeur attendue. getAndSet(value) D\u00e9finit de mani\u00e8re atomique la valeur et retourne la valeur pr\u00e9c\u00e9dente. incrementAndGet() Incr\u00e9mente de mani\u00e8re atomique la valeur et retourne le r\u00e9sultat mis \u00e0 jour. getAndIncrement() Incr\u00e9mente de mani\u00e8re atomique la valeur et retourne le r\u00e9sultat pr\u00e9c\u00e9dent. decrementAndGet() D\u00e9cr\u00e9mente de mani\u00e8re atomique la valeur et retourne le r\u00e9sultat mis \u00e0 jour. getAndDecrement() D\u00e9cr\u00e9mente de mani\u00e8re atomique la valeur et retourne le r\u00e9sultat pr\u00e9c\u00e9dent. addAndGet(delta) Ajoute de mani\u00e8re atomique le delta donn\u00e9 et retourne le r\u00e9sultat mis \u00e0 jour. getAndAdd(delta) Ajoute de mani\u00e8re atomique le delta donn\u00e9 et retourne le r\u00e9sultat pr\u00e9c\u00e9dent. <p>Variables Atomiques:</p> <ul> <li>Ex\u00e9cutent des op\u00e9rations uniques atomiquement</li> <li>Fournissent des memory visibility guarantees similaires \u00e0 <code>volatile</code></li> <li>\u00c9vitent le thread blocking, les rendant hautement scalables sous contention</li> </ul> <p>Cependant, les atomic variables garantissent l\u2019atomicit\u00e9 seulement pour des op\u00e9rations individuelles.</p> <p>Composer plusieurs op\u00e9rations requiert quand m\u00eame une synchronization externe.</p> <p>Les Variables atomiques sont typiquement utilis\u00e9es pour:</p> <ul> <li>Counter et sequence generator</li> <li>Flag et state indicator</li> <li>Update \u00e0 haut throughput et basse latence</li> </ul> <p></p>"},{"location":"fr/module-07/concurrency/#3173-lock-framework","title":"31.7.3 Lock Framework","text":"<p>Le package <code>java.util.concurrent.locks</code> fournit des m\u00e9canismes de locking explicites qui offrent plus de flexibilit\u00e9 et de contr\u00f4le que synchronized.</p> <pre><code>ReentrantLock lock = new ReentrantLock();\nlock.lock();\ntry {\n    // critical section\n} finally {\n    lock.unlock();\n}\n</code></pre> <p>Caract\u00e9ristiques cl\u00e9s du Lock framework:</p> <ul> <li>Les lock doivent \u00eatre acquis et lib\u00e9r\u00e9s explicitement</li> <li>L\u2019acquisition du lock peut \u00eatre interruptible ou time-bounded</li> <li>Les lock peuvent \u00eatre configur\u00e9s avec une fairness policy (param\u00e8tre) quand l\u2019ordering est requis (quand tu dois contr\u00f4ler l\u2019ordre dans lequel les thread tournent)</li> <li>Plusieurs objets Condition peuvent \u00eatre associ\u00e9s \u00e0 un seul lock</li> </ul> <p></p>"},{"location":"fr/module-07/concurrency/#31731-lock-implementations","title":"31.7.3.1 Lock implementations","text":"Lock Implementation Description Lock Interface core qui d\u00e9finit des op\u00e9rations de lock explicites. ReentrantLock Lock reentrant de <code>mutual exclusion</code> avec fairness policy optionnelle. ReadWriteLock Interface qui d\u00e9finit des lock s\u00e9par\u00e9s de read et write. ReentrantReadWriteLock Fournit des lock s\u00e9par\u00e9s reentrant de read et write pour am\u00e9liorer la scalabilit\u00e9 en lecture. StampedLock Lock qui supporte des modes optimistic, read et write locking (non-reentrant). <p>Warning</p> <p>\u00c0 la diff\u00e9rence d\u2019autres lock, StampedLock n\u2019est pas reentrant \u2014 le r\u00e9acqu\u00e9rir depuis le m\u00eame thread cause un deadlock.</p> <p></p>"},{"location":"fr/module-07/concurrency/#31732-common-lock-methods","title":"31.7.3.2 Common Lock methods","text":"Method Description lock() Acquiert le lock, bloquant ind\u00e9finiment jusqu\u2019\u00e0 disponibilit\u00e9. unlock() Lib\u00e8re le lock; doit \u00eatre appel\u00e9 par le thread propri\u00e9taire. tryLock() Tente d\u2019acqu\u00e9rir le lock imm\u00e9diatement sans bloquer: retourne un boolean indiquant si le lock a \u00e9t\u00e9 acquis avec succ\u00e8s tryLock(long, TimeUnit) Tente d\u2019acqu\u00e9rir le lock dans le timeout donn\u00e9. lockInterruptibly() Acquiert le lock \u00e0 moins que le thread ne soit interrompu. newCondition() Cr\u00e9e une instance <code>Condition</code> pour une coordination fine-grained entre thread. <p>\u00c0 la diff\u00e9rence de synchronized, les lock ne sont pas lib\u00e9r\u00e9s automatiquement, rendant essentiel l\u2019usage correct de try/finally pour \u00e9viter des deadlock.</p> <p></p>"},{"location":"fr/module-07/concurrency/#3174-coordination-utilities","title":"31.7.4 Coordination Utilities","text":"<p>Les coordination utilities permettent aux thread de coordonner des phases d\u2019ex\u00e9cution sans prot\u00e9ger des donn\u00e9es partag\u00e9es via <code>mutual exclusion</code>.</p> <p>D\u2019autres coordination primitives incluent: - <code>CountDownLatch</code> - <code>Semaphore</code> - <code>Phaser</code></p> <pre><code>import java.util.concurrent.CyclicBarrier;\n\npublic class BarrierExample {\n\n    private static final int THREAD_COUNT = 3;\n\n    public static void main(String[] args) {\n\n        CyclicBarrier barrier = new CyclicBarrier(\n            THREAD_COUNT,\n            () -&gt; System.out.println(\"All threads reached the barrier. Proceeding...\")\n        );\n\n        Runnable task = () -&gt; {\n            String name = Thread.currentThread().getName();\n            try {\n                System.out.println(name + \" performing initial work\");\n                Thread.sleep((long) (Math.random() * 2000));\n\n                // Wait for other threads\n                System.out.println(name + \" waiting at barrier\");\n                barrier.await();\n\n                // Executed only after all threads reach the barrier\n                System.out.println(name + \" performing next phase\");\n\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        };\n\n        for (int i = 1; i &lt;= THREAD_COUNT; i++) {\n            new Thread(task, \"Worker-\" + i).start();\n        }\n    }\n}\n</code></pre> <p>Sample Output:</p> <pre><code>Worker-1 performing initial work\nWorker-2 performing initial work\nWorker-3 performing initial work\nWorker-3 waiting at barrier\nWorker-1 waiting at barrier\nWorker-2 waiting at barrier\nAll threads reached the barrier. Proceeding...\nWorker-3 performing next phase\nWorker-1 performing next phase\nWorker-2 performing next phase\n</code></pre> <p>Un <code>CyclicBarrier</code>:</p> <ul> <li>Bloque les thread jusqu\u2019\u00e0 ce qu\u2019un nombre pr\u00e9d\u00e9fini de thread atteigne la barrier</li> <li>Lib\u00e8re simultan\u00e9ment tous les thread en attente une fois que la barrier est tripped</li> <li>Peut \u00eatre r\u00e9utilis\u00e9 pour plusieurs cycles de coordination</li> </ul> <p>Ces utilities se concentrent sur execution ordering et synchronization, pas sur data protection.</p> <p></p>"},{"location":"fr/module-07/concurrency/#318-concurrent-collections","title":"31.8 Concurrent Collections","text":"<p>Les concurrent collections sont des thread-safe data structures con\u00e7ues pour supporter des niveaux \u00e9lev\u00e9s de concurrence sans exiger une synchronization externe.</p> <p>\u00c0 la diff\u00e9rence des synchronized wrappers (ex. <code>Collections.synchronizedMap</code>), les concurrent collections: - Utilisent fine-grained locking ou des lock-free techniques - Permettent \u00e0 plusieurs thread d\u2019acc\u00e9der et de modifier la collection simultan\u00e9ment - Scalent mieux sous contention</p> <p>Des exemples communs incluent:</p> <ul> <li>ConcurrentHashMap</li> <li> <p>Une concurrent map \u00e0 hautes performance qui permet des lectures et des update concurrents en partitionnant l\u2019\u00e9tat interne et en minimisant le lock contention.</p> </li> <li> <p>CopyOnWriteArrayList</p> </li> <li> <p>Une thread-safe list optimis\u00e9e pour des sc\u00e9narios avec beaucoup de lectures et peu d\u2019\u00e9critures. Les op\u00e9rations de write cr\u00e9ent un nouvel array interne, permettant aux lectures de proc\u00e9der sans locking.</p> </li> <li> <p>BlockingQueue</p> </li> <li>Une queue con\u00e7ue pour des producer-consumer patterns, o\u00f9 les thread peuvent se bloquer en attendant des \u00e9l\u00e9ments ou une capacit\u00e9 disponible.</li> </ul> <pre><code>BlockingQueue&lt;String&gt; queue = new LinkedBlockingQueue&lt;&gt;();\nqueue.put(\"item\");   // blocks if the queue is full\nqueue.take();        // blocks if the queue is empty\n</code></pre> <p>Les blocking queue g\u00e8rent la synchronization en interne, simplifiant la coordination entre thread producer et consumer.</p> <p>Caution</p> <p>Les CopyOnWrite collections sont memory-expensive; les \u00e9viter dans des workload write-heavy.</p> <p></p>"},{"location":"fr/module-07/concurrency/#319-parallel-streams","title":"31.9 Parallel Streams","text":"<p>Les <code>parallel streams</code> fournissent du declarative data parallelism, permettant que les op\u00e9rations du stream soient ex\u00e9cut\u00e9es de mani\u00e8re concurrente sur plusieurs thread avec des changements minimaux de code.</p> <p>Caract\u00e9ristiques cl\u00e9s: - Activ\u00e9s via <code>parallelStream()</code> ou <code>stream().parallel()</code> - Ex\u00e9cut\u00e9s en interne en utilisant le common ForkJoinPool - Divisent automatiquement les donn\u00e9es en chunk trait\u00e9s en parall\u00e8le</p> <p>Les parallel streams fonctionnent mieux quand: - Les op\u00e9rations sont CPU-bound - Les fonctions sont stateless et non-blocking - La source de donn\u00e9es est suffisamment grande pour amortir l\u2019overhead de la parall\u00e9lisation</p> <pre><code>list.parallelStream()\n    .map(x -&gt; x * x)\n    .forEach(System.out::println);\n</code></pre> <p>Puisque l\u2019ordre d\u2019ex\u00e9cution n\u2019est pas garanti, les parallel streams devraient \u00e9viter: - Shared mutable state - Blocking I/O - Order-dependent side effects</p> <p>Note</p> <p>Utilise <code>forEachOrdered()</code> si un output d\u00e9terministique est requis.</p> <p></p>"},{"location":"fr/module-07/concurrency/#3110-relation-avec-virtual-threads","title":"31.10 Relation avec Virtual Threads","text":"<p>En Java 21, l\u2019<code>Executor framework</code> s\u2019int\u00e8gre de mani\u00e8re seamless avec virtual threads, permettant massive concurrency avec usage minimal de ressources.</p> <pre><code>ExecutorService executor =\nExecutors.newVirtualThreadPerTaskExecutor();\n\nexecutor.submit(() -&gt; blockingIO());\nexecutor.close();\n</code></pre> <p>Cela permet au code blocking de scaler efficacement sans redessiner les API.</p> <p></p>"},{"location":"fr/module-07/concurrency/#3111-sommaire","title":"31.11 Sommaire","text":"<ul> <li>La <code>Java Concurrency API</code> fournit une alternative robuste, scalable et plus s\u00fbre \u00e0 la gestion manuelle des thread.</li> <li>Abstraire l\u2019ex\u00e9cution, coordonner les task et offrir des utilities thread-safe permet aux d\u00e9veloppeurs de construire des syst\u00e8mes concurrents \u00e0 la fois performants et maintenables.</li> <li>Choisis l\u2019outil juste: synchronized \u2192 locks \u2192 atomics \u2192 executors \u2192 virtual threads.</li> </ul>"},{"location":"fr/module-07/threads/","title":"30. Thread Java \u2013 Fondamentaux et Mod\u00e8le d\u2019Ex\u00e9cution","text":""},{"location":"fr/module-07/threads/#indice","title":"Indice","text":"<ul> <li>30.1 Thread, Processus et le Syst\u00e8me d\u2019Exploitation</li> <li>30.2 Mod\u00e8le de M\u00e9moire Stack et Heap</li> <li>30.3 Contexte et Context Switching</li> <li>30.4 Concurrency vs Parallelisme</li> <li>30.5 Thread en Java Mod\u00e8le Conceptuel</li> <li>30.6 Cat\u00e9gories de Thread en Java 21</li> <li>30.7 Cr\u00e9er des Thread en Java</li> <li>30.8 Cycle de Vie et Ex\u00e9cution d\u2019un Thread</li> <li>30.9 D\u00e9marrer vs Ex\u00e9cuter un Thread Synchrone-ou-Asynchrone</li> <li>30.10 Priorit\u00e9 des Thread et Scheduling</li> <li>30.11 Diff\u00e9r\u00e9ment et Yield des Thread</li> <li>30.12 Interruption des Thread et Annulation Coop\u00e9rative<ul> <li>30.12.1 Ce que Signifie Interrompre un Thread</li> <li>30.12.2 Interrompre des Op\u00e9rations Bloquantes</li> <li>30.12.3 V\u00e9rifier le Statut d\u2019Interruption</li> <li>30.12.4 Exemple Interrompre un Thread en Sleep</li> <li>30.12.5 Observations Cl\u00e9s</li> </ul> </li> <li>30.13 Thread et le Thread Principal</li> <li>30.14 Concurrency des Thread et \u00c9tat Partag\u00e9</li> <li>30.15 Sommaire</li> </ul> <p>Ce chapitre introduit les thread \u00e0 partir des principes de base et explique comment ils sont mod\u00e9lis\u00e9s et utilis\u00e9s en Java 21.</p> <p>Ce texte \u00e9tablit \u00e9galement les fondations conceptuelles n\u00e9cessaires pour comprendre <code>concurrency</code>, <code>synchronization</code> et la <code>Java Concurrency API</code> trait\u00e9e dans le prochain chapitre.</p> <p></p>"},{"location":"fr/module-07/threads/#301-thread-processus-et-le-systeme-dexploitation","title":"30.1 Thread, Processus et le Syst\u00e8me d\u2019Exploitation","text":"<p>Pour comprendre les thread, nous devons partir du mod\u00e8le d\u2019ex\u00e9cution du syst\u00e8me d\u2019exploitation.</p> <p>Les syst\u00e8mes d\u2019exploitation modernes ex\u00e9cutent des programmes en utilisant des processus et des thread.</p> <ul> <li>Processus: Une instance de programme en ex\u00e9cution g\u00e9r\u00e9e par le syst\u00e8me d\u2019exploitation. Un processus poss\u00e8de son propre espace de m\u00e9moire virtuelle, des ressources syst\u00e8me (fichiers, sockets) et au moins un thread.</li> <li>Thread: Une unit\u00e9 d\u2019ex\u00e9cution l\u00e9g\u00e8re \u00e0 l\u2019int\u00e9rieur d\u2019un processus. Les thread partagent la m\u00e9moire et les ressources du processus mais s\u2019ex\u00e9cutent de mani\u00e8re ind\u00e9pendante.</li> <li>Task: Une unit\u00e9 logique de travail \u00e0 ex\u00e9cuter. Un task peut \u00eatre ex\u00e9cut\u00e9 par un thread mais n\u2019est pas lui-m\u00eame un thread.</li> <li>Core CPU: Une unit\u00e9 d\u2019ex\u00e9cution physique ou logique capable d\u2019ex\u00e9cuter un thread \u00e0 la fois. Plusieurs core permettent une v\u00e9ritable ex\u00e9cution parall\u00e8le.</li> </ul> <p>Un seul processus peut contenir de nombreux thread, tous op\u00e9rant dans le m\u00eame environnement partag\u00e9. Cet environnement partag\u00e9 est \u00e0 la fois source des potentialit\u00e9s de la Concurrency et de ses risques.</p> <p></p>"},{"location":"fr/module-07/threads/#302-modele-de-memoire-stack-et-heap","title":"30.2 Mod\u00e8le de M\u00e9moire: Stack et Heap","text":"<p>Les thread interagissent avec la m\u00e9moire de deux mani\u00e8res fondamentalement diff\u00e9rentes.</p> <ul> <li>Stack du Thread: Zone de m\u00e9moire priv\u00e9e pour chaque thread. Elle stocke les frames des appels de m\u00e9thode, les variables locales et l\u2019\u00e9tat d\u2019ex\u00e9cution. Chaque thread a exactement un stack.</li> <li>Heap: Zone de m\u00e9moire partag\u00e9e utilis\u00e9e pour les objets et les instances de classe. Tous les thread dans le m\u00eame processus peuvent acc\u00e9der au heap.</li> </ul> <p>Puisque les <code>stack sont isol\u00e9s</code> et le <code>heap est partag\u00e9</code>, les probl\u00e8mes de concurrence surviennent lorsque plusieurs thread acc\u00e8dent aux m\u00eames objets dans le heap sans coordination ad\u00e9quate.</p> <p></p>"},{"location":"fr/module-07/threads/#303-contexte-et-context-switching","title":"30.3 Contexte et Context Switching","text":"<p>Le syst\u00e8me d\u2019exploitation planifie l\u2019ex\u00e9cution des thread sur les core de la CPU.</p> <p>Puisque le nombre de thread ex\u00e9cutables d\u00e9passe souvent le nombre de core disponibles, le syst\u00e8me d\u2019exploitation effectue le context switching.</p> <ul> <li>Contexte: L\u2019\u00e9tat complet d\u2019ex\u00e9cution d\u2019un thread, y compris registres, compteur de programme et pointeur de stack.</li> <li>Context Switch: L\u2019acte de suspendre un thread et d\u2019en reprendre un autre en sauvegardant et en restaurant leurs contextes respectifs.</li> </ul> <p>Le <code>context switching</code> permet la concurrence mais a un co\u00fbt: des cycles CPU sont consomm\u00e9s sans ex\u00e9cuter de logique applicative.</p> <p>Les programmeurs Java doivent concevoir des syst\u00e8mes qui \u00e9quilibrent concurrence et efficacit\u00e9.</p> <p></p>"},{"location":"fr/module-07/threads/#304-concurrency-vs-parallelisme","title":"30.4 Concurrency vs Parallelisme","text":"<p>Ces deux termes sont souvent confondus mais d\u00e9crivent des concepts diff\u00e9rents.</p> <ul> <li>Concurrence: Plusieurs thread sont en ex\u00e9cution dans le m\u00eame intervalle de temps, \u00e9ventuellement entrelac\u00e9s sur un seul core CPU.</li> <li>Parallelisme: Plusieurs thread s\u2019ex\u00e9cutent simultan\u00e9ment sur des core CPU diff\u00e9rents.</li> </ul> <p>Java supporte la concurrence ind\u00e9pendamment du parall\u00e9lisme mat\u00e9riel.</p> <p>M\u00eame sur un syst\u00e8me single-core, les thread Java peuvent \u00eatre concurrents via le time slicing.</p> <p></p>"},{"location":"fr/module-07/threads/#305-thread-en-java-modele-conceptuel","title":"30.5 Thread en Java: Mod\u00e8le Conceptuel","text":"<p>En Java, un thread repr\u00e9sente un chemin ind\u00e9pendant d\u2019ex\u00e9cution \u00e0 l\u2019int\u00e9rieur d\u2019un seul processus JVM. Tous les thread Java op\u00e8rent dans le m\u00eame heap et dans le m\u00eame contexte de <code>class loading</code>, \u00e0 moins qu\u2019ils ne soient explicitement isol\u00e9s via des m\u00e9canismes avanc\u00e9s.</p> <ul> <li>Thread Java: Un objet de type <code>java.lang.Thread</code> qui mappe \u00e0 une unit\u00e9 d\u2019ex\u00e9cution sous-jacente.</li> <li>Runnable: Une interface fonctionnelle qui repr\u00e9sente un <code>task</code> dont la m\u00e9thode <code>run()</code> contient la logique ex\u00e9cutable.</li> </ul> <p>Un thread ex\u00e9cute du code en invoquant sa propre m\u00e9thode <code>run()</code>, directement ou indirectement via le scheduler des thread de la JVM: voir D\u00e9marrer vs Ex\u00e9cuter un Thread</p> <p></p>"},{"location":"fr/module-07/threads/#306-categories-de-thread-en-java-21","title":"30.6 Cat\u00e9gories de Thread en Java 21","text":"<p>Java 21 d\u00e9finit diff\u00e9rents types de thread, qui diff\u00e8rent par cycle de vie, scheduling et usage pr\u00e9vu.</p> <ul> <li>Platform Thread: Un thread Java traditionnel mapp\u00e9 un-\u00e0-un \u00e0 un thread du syst\u00e8me d\u2019exploitation.</li> <li>Virtual Thread: Un thread l\u00e9ger g\u00e9r\u00e9 par la JVM et schedul\u00e9 sur des thread carrier. Introduit pour permettre une concurrence massive avec un overhead minimal.</li> <li>Carrier Thread: Un Platform Thread utilis\u00e9 en interne par la JVM pour ex\u00e9cuter des thread virtuels.</li> <li>Daemon Thread: Un thread en arri\u00e8re-plan qui n\u2019emp\u00eache pas la terminaison de la JVM. Quand seuls des thread daemon restent en ex\u00e9cution, la JVM se termine.</li> <li>Thread Utilisateur: Tout thread non-daemon. La JVM attend que tous les thread utilisateur terminent avant de se terminer.</li> <li>Thread Syst\u00e8me: Des thread cr\u00e9\u00e9s en interne par la JVM pour le garbage collection, la compilation JIT et d\u2019autres services runtime.</li> </ul> <p>Note</p> <p>Les <code>thread virtuels</code> sont des thread utilisateur l\u00e9gers; ils ne sont pas daemon par d\u00e9faut.</p> <p></p>"},{"location":"fr/module-07/threads/#307-creer-des-thread-en-java","title":"30.7 Cr\u00e9er des Thread en Java","text":"<p>Les thread peuvent \u00eatre cr\u00e9\u00e9s de diff\u00e9rentes mani\u00e8res, toutes conceptuellement centr\u00e9es sur la fourniture de logique ex\u00e9cutable.</p> <ul> <li>En \u00e9tendant <code>Thread</code> et en red\u00e9finissant <code>run()</code>.</li> <li>En passant un <code>Runnable</code> au constructeur de <code>Thread</code>.</li> <li>En utilisant des factories de thread et des executor (trait\u00e9s dans la section Concurrency API).</li> </ul> <pre><code>Runnable runnable = ...\n\n  // Cr\u00e9e un thread de plateforme via constructeur\n  Thread thread = new Thread(runnable);\n  thread.start();\n\n  // D\u00e9marre un thread daemon pour ex\u00e9cuter un task\n  Thread thread = Thread.ofPlatform().daemon().start(runnable);\n\n  // Cr\u00e9e un thread non d\u00e9marr\u00e9 nomm\u00e9 \"duke\", sa m\u00e9thode start()\n  // doit \u00eatre invoqu\u00e9e pour planifier son ex\u00e9cution.\n  Thread thread = Thread.ofPlatform().name(\"duke\").unstarted(runnable);\n\n  // Une ThreadFactory qui cr\u00e9e des thread daemon nomm\u00e9s \"worker-0\", \"worker-1\", ...\n  ThreadFactory factory = Thread.ofPlatform().daemon().name(\"worker-\", 0).factory();\n\n  // D\u00e9marre un thread virtuel pour ex\u00e9cuter un task\n  Thread thread = Thread.ofVirtual().start(runnable);\n\n  // Une ThreadFactory qui cr\u00e9e des thread virtuels\n  ThreadFactory factory = Thread.ofVirtual().factory();\n</code></pre> <p>Warning</p> <ul> <li>La seule cr\u00e9ation d\u2019un thread ne d\u00e9marre pas son ex\u00e9cution.</li> <li>L\u2019ex\u00e9cution commence seulement lorsque le scheduler de la JVM est impliqu\u00e9.</li> </ul> <p></p>"},{"location":"fr/module-07/threads/#308-cycle-de-vie-et-execution-dun-thread","title":"30.8 Cycle de Vie et Ex\u00e9cution d\u2019un Thread","text":"<p>Un thread Java traverse des \u00e9tats bien d\u00e9finis au cours de son cycle de vie.</p> <ul> <li>New: Objet thread cr\u00e9\u00e9 mais pas encore d\u00e9marr\u00e9.</li> <li>Runnable: \u00c9ligible \u00e0 l\u2019ex\u00e9cution par le scheduler.</li> <li>Running: En ex\u00e9cution active sur un core CPU.</li> <li>Blocked / Waiting: Temporairement incapable de continuer \u00e0 cause de synchronisation ou de coordination.</li> <li>Terminated: Ex\u00e9cution termin\u00e9e ou interrompue.</li> </ul> <p>La JVM et le syst\u00e8me d\u2019exploitation coop\u00e8rent pour d\u00e9placer les thread entre ces \u00e9tats.</p> <p>Les thread dans l\u2019\u00e9tat <code>BLOCKED</code>, <code>WAITING</code> ou <code>TIMED_WAITING</code> n\u2019utilisent pas de ressources CPU</p> <p></p>"},{"location":"fr/module-07/threads/#309-demarrer-vs-executer-un-thread-synchrone-ou-asynchrone","title":"30.9 D\u00e9marrer vs Ex\u00e9cuter un Thread: Synchrone ou Asynchrone","text":"<p>Il existe une distinction conceptuelle critique entre invoquer <code>run()</code> et invoquer <code>start()</code>.</p> <ul> <li>Appeler directement <code>run()</code> ex\u00e9cute la m\u00e9thode de mani\u00e8re synchrone dans le thread courant, comme un appel de m\u00e9thode normal.</li> <li>Appeler <code>start()</code> demande \u00e0 la JVM de cr\u00e9er un nouveau stack d\u2019appel et d\u2019ex\u00e9cuter <code>run()</code> de mani\u00e8re asynchrone dans un thread s\u00e9par\u00e9.</li> </ul> <p>Par cons\u00e9quent, du code comme <code>new Thread(r).run();</code> NE cr\u00e9e PAS de concurrence. L\u2019ex\u00e9cution reste synchrone et bloque le thread appelant jusqu\u2019\u00e0 l\u2019ach\u00e8vement.</p> <p>Note</p> <p><code>Ex\u00e9cution asynchrone</code> signifie que l\u2019appelant continue imm\u00e9diatement tandis que le nouveau thread progresse de mani\u00e8re ind\u00e9pendante, soumis au scheduling.</p> <p><code>Ex\u00e9cution synchrone</code> signifie que l\u2019appelant attend que l\u2019op\u00e9ration soit termin\u00e9e.</p> <p>Important</p> <p>La concurrence commence seulement lorsque <code>start()</code> est invoqu\u00e9.</p> <p></p>"},{"location":"fr/module-07/threads/#3010-priorite-des-thread-et-scheduling","title":"30.10 Priorit\u00e9 des Thread et Scheduling","text":"<p>Les thread Java ont une priorit\u00e9 associ\u00e9e qui influence le scheduling.</p> <ul> <li><code>Priorit\u00e9 du Thread</code>: Une valeur enti\u00e8re indiquant son importance relative, allant de minimum \u00e0 maximum.</li> <li><code>Scheduling</code>: La JVM d\u00e9l\u00e8gue les d\u00e9cisions de scheduling au syst\u00e8me d\u2019exploitation, qui peut ou non respecter strictement les priorit\u00e9s.</li> </ul> <p>La priorit\u00e9 du thread influence la probabilit\u00e9 de scheduling mais ne garantit jamais l\u2019ordre d\u2019ex\u00e9cution. Le code Java portable ne doit jamais d\u00e9pendre des priorit\u00e9s pour la correction.</p> <p>Il est possible de d\u00e9finir la priorit\u00e9 sur les <code>platform threads</code>; pour les <code>thread virtuels</code> la priorit\u00e9 est toujours fix\u00e9e \u00e0 5 (<code>Thread.NORM_PRIORITY</code>) et tenter de la modifier n\u2019a aucun effet.</p> <p></p>"},{"location":"fr/module-07/threads/#3011-differement-et-yield-des-thread","title":"30.11 Diff\u00e9r\u00e9ment et Yield des Thread","text":"<p>Les thread peuvent influencer volontairement le comportement de scheduling.</p> <p>Appeler <code>Thread.yield()</code> signale la disponibilit\u00e9 \u00e0 suspendre l\u2019ex\u00e9cution.</p> <ul> <li><code>Yielding</code>: Un thread sugg\u00e8re qu\u2019il est dispos\u00e9 \u00e0 suspendre l\u2019ex\u00e9cution pour permettre \u00e0 d\u2019autres thread ex\u00e9cutables de progresser.</li> <li><code>Sleeping</code>: Un thread suspend l\u2019ex\u00e9cution pour une dur\u00e9e fixe, entrant dans un \u00e9tat d\u2019attente temporis\u00e9e.</li> </ul> <p>Ces m\u00e9canismes ne garantissent pas l\u2019ex\u00e9cution imm\u00e9diate d\u2019autres thread; ils fournissent seulement des suggestions de scheduling.</p> <p></p>"},{"location":"fr/module-07/threads/#3012-interruption-des-thread-et-annulation-cooperative","title":"30.12 Interruption des Thread et Annulation Coop\u00e9rative","text":"<p>Les thread Java ne peuvent pas \u00eatre arr\u00eat\u00e9s de force depuis l\u2019ext\u00e9rieur.</p> <p>\u00c0 la place, Java fournit un m\u00e9canisme coop\u00e9ratif appel\u00e9 interruption du thread, qui permet \u00e0 un thread de demander qu\u2019un autre thread interrompe ce qu\u2019il est en train de faire.</p> <p>Le thread cible d\u00e9cide comment et quand r\u00e9pondre.</p> <p></p>"},{"location":"fr/module-07/threads/#30121-ce-que-signifie-interrompre-un-thread","title":"30.12.1 Ce que Signifie Interrompre un Thread","text":"<p>Interrompre un thread ne le termine pas. Appeler <code>interrupt()</code> d\u00e9finit un flag d\u2019interruption interne sur le thread cible. Il est de la responsabilit\u00e9 du thread en ex\u00e9cution d\u2019observer ce flag et de r\u00e9agir de mani\u00e8re appropri\u00e9e.</p> <ul> <li><code>Demande d'interruption</code>: Un signal envoy\u00e9 \u00e0 un thread indiquant qu\u2019il devrait s\u2019arr\u00eater ou changer son activit\u00e9 courante.</li> <li><code>Flag d'interruption</code>: Un statut bool\u00e9en associ\u00e9 \u00e0 chaque thread, d\u00e9fini lorsque <code>interrupt()</code> est invoqu\u00e9.</li> <li><code>Annulation Coop\u00e9rative</code>: Un design pattern dans lequel les thread v\u00e9rifient p\u00e9riodiquement d\u2019\u00e9ventuelles interruptions et se terminent proprement.</li> </ul> <p></p>"},{"location":"fr/module-07/threads/#30122-interrompre-des-operations-bloquantes","title":"30.12.2 Interrompre des Op\u00e9rations Bloquantes","text":"<p>Certaines m\u00e9thodes bloquantes en Java r\u00e9pondent imm\u00e9diatement \u00e0 l\u2019interruption en lan\u00e7ant <code>InterruptedException</code> et en mettant \u00e0 z\u00e9ro le flag d\u2019interruption. Ces m\u00e9thodes incluent <code>sleep()</code>, <code>wait()</code> et <code>join()</code>.</p> <p>Lorsqu\u2019un thread est bloqu\u00e9 dans l\u2019une de ces m\u00e9thodes et qu\u2019un autre thread l\u2019interrompt, le thread bloqu\u00e9 est r\u00e9veill\u00e9 et une exception est lanc\u00e9e. Cela fournit un point de sortie s\u00fbr des op\u00e9rations bloquantes.</p> <p></p>"},{"location":"fr/module-07/threads/#30123-verifier-le-statut-dinterruption","title":"30.12.3 V\u00e9rifier le Statut d\u2019Interruption","text":"<p>Les thread qui ne sont pas bloqu\u00e9s doivent v\u00e9rifier explicitement s\u2019ils ont \u00e9t\u00e9 interrompus. Java fournit deux fa\u00e7ons de le faire.</p> <ul> <li><code>Thread.currentThread().isInterrupted()</code>: Retourne le statut d\u2019interruption sans le mettre \u00e0 z\u00e9ro.</li> <li><code>Thread.interrupted()</code>: Retourne le statut d\u2019interruption et le met \u00e0 z\u00e9ro. Ceci est subtil: l\u2019appel suivant retournera false.</li> </ul> <p>Ne pas v\u00e9rifier le statut d\u2019interruption peut amener les thread \u00e0 ignorer des demandes d\u2019annulation et \u00e0 continuer \u00e0 s\u2019ex\u00e9cuter ind\u00e9finiment.</p> <p></p>"},{"location":"fr/module-07/threads/#30124-exemple-interrompre-un-thread-en-sleep","title":"30.12.4 Exemple: Interrompre un Thread en Sleep","text":"<p>L\u2019exemple suivant d\u00e9montre l\u2019annulation coop\u00e9rative via interruption.</p> <p>Un thread worker dort pendant qu\u2019il ex\u00e9cute du travail. Le thread main l\u2019interrompt, provoquant un shutdown propre.</p> <pre><code>class Main {\n\n    static class Task implements Runnable {\n        public void run() {\n            try {\n                while (true) {\n                    System.out.println(\"Working...\");\n                    Thread.sleep(1000);\n                }\n            } catch (InterruptedException e) {\n                System.out.println(\"Task interrupted, shutting down\");\n            }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread worker = new Thread(new Task());\n        worker.start();\n        System.out.println(\"main before sleep...\");\n        Thread.sleep(3000);\n        System.out.println(\"main after sleep...\");\n        worker.interrupt();\n        System.out.println(\"main reached END\");\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>main before sleep...\nWorking...\nWorking...\nWorking...\nmain after sleep...\nmain reached END\nTask interrupted, shutting down\n</code></pre> <p>Note</p> <p>L\u2019ordre de l\u2019output peut varier l\u00e9g\u00e8rement \u00e0 cause du scheduling.</p> <p></p>"},{"location":"fr/module-07/threads/#30125-observations-cles","title":"30.12.5 Observations Cl\u00e9s","text":"<ul> <li>Appeler <code>interrupt()</code> n\u2019arr\u00eate pas directement le thread.</li> <li>L\u2019interruption est d\u00e9tect\u00e9e et <code>sleep()</code> lance une <code>InterruptedException</code>.</li> <li>Le thread worker se termine de lui-m\u00eame de mani\u00e8re contr\u00f4l\u00e9e.</li> <li>Une gestion correcte de l\u2019interruption permet aux thread de lib\u00e9rer des ressources et de maintenir la coh\u00e9rence du programme.</li> </ul> <p>Note</p> <p>Ignorer <code>InterruptedException</code> sans terminer ou restaurer le statut d\u2019interruption est consid\u00e9r\u00e9 comme une mauvaise pratique et peut mener \u00e0 des thread non r\u00e9actifs.</p> <p></p>"},{"location":"fr/module-07/threads/#3013-thread-et-le-thread-principal","title":"30.13 Thread et le Thread Principal","text":"<p>Chaque application Java commence avec un thread principal. Ce thread ex\u00e9cute la m\u00e9thode <code>main(String[])</code>.</p> <ul> <li>Le thread principal est un thread utilisateur.</li> <li>La JVM reste active tant qu\u2019au moins un thread utilisateur est en ex\u00e9cution.</li> <li>Si le thread principal se termine mais qu\u2019il existe d\u2019autres thread utilisateur, la JVM continue l\u2019ex\u00e9cution en attendant que les thread utilisateur se terminent.</li> <li>Les thread daemon ne maintiennent pas la JVM en vie.</li> </ul> <p>Comprendre le r\u00f4le du thread principal est essentiel pour raisonner sur la terminaison du programme et le traitement en arri\u00e8re-plan.</p> <p></p>"},{"location":"fr/module-07/threads/#3014-concurrency-des-thread-et-etat-partage","title":"30.14 Concurrency des Thread et \u00c9tat Partag\u00e9","text":"<p>La <code>Concurrence</code> na\u00eet lorsque plusieurs thread acc\u00e8dent \u00e0 un \u00e9tat mutable partag\u00e9.</p> <ul> <li><code>\u00c9tat partag\u00e9</code>: Toute donn\u00e9e situ\u00e9e dans le heap accessible par plus d\u2019un thread.</li> <li><code>Race Condition</code>: Une erreur de correction caus\u00e9e par un acc\u00e8s non synchronis\u00e9 \u00e0 un \u00e9tat partag\u00e9.</li> <li><code>Probl\u00e8me de visibilit\u00e9</code>: Un thread op\u00e8re sur des donn\u00e9es obsol\u00e8tes \u00e0 cause de l\u2019absence de synchronisation m\u00e9moire correcte.</li> </ul> <p>Java r\u00e9sout ces probl\u00e8mes avec synchronization, volatile, lock, atomiques et des frameworks de haut niveau (Executors, futures).</p> <p>La synchronization, les variables volatile et les utilities de concurrence de haut niveau seront \u00e9tudi\u00e9es dans les sections suivantes.</p> <p></p>"},{"location":"fr/module-07/threads/#3015-sommaire","title":"30.15 Sommaire","text":"<ul> <li>Les <code>Thread</code> sont le bloc de construction fondamental de l\u2019ex\u00e9cution concurrente en Java.</li> <li>Ils existent \u00e0 l\u2019int\u00e9rieur des processus, partagent la m\u00e9moire et sont schedul\u00e9s par la JVM en coop\u00e9ration avec le syst\u00e8me d\u2019exploitation.</li> <li>Une gestion correcte des thread \u00e9vite des fuites, des deadlocks et du gaspillage de CPU.</li> </ul>"},{"location":"fr/module-08/files-path-api/","title":"33. APIs des fichiers et des chemins","text":""},{"location":"fr/module-08/files-path-api/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>33.1 File legacy et Path NIO : cr\u00e9ation et conversion<ul> <li>33.1.1 Cr\u00e9er un File legacy</li> <li>33.1.2 Cr\u00e9er un Path NIO-v2</li> <li>33.1.3 Absolu vs relatif : ce que signifie relatif</li> <li>33.1.4 Joindre--Construire-des-Paths<ul> <li>33.1.4.1 resolve</li> <li>33.1.4.2 relativize</li> </ul> </li> <li>33.1.5 Convertir entre File et Path</li> <li>33.1.6 Conversion URI quand-n\u00e9cessaire</li> <li>33.1.7 Canonique vs absolu vs normalis\u00e9 diff\u00e9rences-fondamentales<ul> <li>33.1.7.1 normalize</li> </ul> </li> <li>33.1.8 Tableau de comparaison rapide cr\u00e9ation--conversion</li> </ul> </li> <li>33.2 G\u00e9rer les fichiers et r\u00e9pertoires : cr\u00e9er-copier-d\u00e9placer-remplacer-comparer-supprimer<ul> <li>33.2.1 Mod\u00e8le mental Path-Locator-vs-Op\u00e9rations</li> <li>33.2.2 Cr\u00e9er des fichiers et des r\u00e9pertoires<ul> <li>33.2.2.1 Cr\u00e9er un fichier</li> <li>33.2.2.2 Cr\u00e9er des r\u00e9pertoires</li> </ul> </li> <li>33.2.3 Copier des fichiers et des r\u00e9pertoires<ul> <li>33.2.3.1 Copier un fichier NIO</li> <li>33.2.3.2 Copie manuelle legacy bas\u00e9e-sur-stream</li> </ul> </li> <li>33.2.4 D\u00e9placer--Renommer-et-Remplacer<ul> <li>33.2.4.1 Renommage legacy pi\u00e8ge-commun</li> <li>33.2.4.2 NIO Move pr\u00e9f\u00e9r\u00e9</li> </ul> </li> <li>33.2.5 Comparer des paths et des fichiers<ul> <li>33.2.5.1 \u00c9galit\u00e9-vs-M\u00eame-fichier</li> </ul> </li> <li>33.2.6 Supprimer des fichiers et des r\u00e9pertoires<ul> <li>33.2.6.1 Delete legacy</li> <li>33.2.6.2 NIO Delete et Delete-If-Exists</li> </ul> </li> <li>33.2.7 Copier--Supprimer-r\u00e9cursivement-des-arbres-de-r\u00e9pertoires pattern-nio</li> <li>33.2.8 Checklist de r\u00e9sum\u00e9</li> </ul> </li> </ul> <p>Cette section se concentre sur la cr\u00e9ation de localisateurs de syst\u00e8me de fichiers en utilisant l\u2019API legacy <code>java.io.File</code> et l\u2019API moderne <code>java.nio.file.Path</code> : comment convertir entre eux et comprendre les surcharges, les valeurs par d\u00e9faut et les pi\u00e8ges courants.</p> <p></p>"},{"location":"fr/module-08/files-path-api/#331-file-legacy-et-path-nio-creation-et-conversion","title":"33.1 <code>File</code> legacy et <code>Path</code> NIO : cr\u00e9ation et conversion","text":""},{"location":"fr/module-08/files-path-api/#3311-creer-un-file-legacy","title":"33.1.1 Cr\u00e9er un <code>File</code> (Legacy)","text":"<p>Une instance <code>File</code> repr\u00e9sente un pathname du syst\u00e8me de fichiers (absolu ou relatif).</p> <p>En cr\u00e9er une n\u2019acc\u00e8de pas au syst\u00e8me de fichiers et ne lance pas <code>IOException</code>.</p> <p>Constructeurs principaux (les plus courants) :</p> <ul> <li><code>new File(String pathname)</code> </li> <li><code>new File(String parent, String child)</code> </li> <li><code>new File(File parent, String child)</code> </li> <li><code>new File(URI uri)</code> (typiquement <code>file:...</code>)</li> </ul> <pre><code>import java.io.File;\nimport java.net.URI;\n\nFile f1 = new File(\"data.txt\"); // relatif\nFile f2 = new File(\"/tmp\", \"data.txt\"); // parent + enfant\nFile f3 = new File(new File(\"/tmp\"), \"data.txt\");\n\nFile f4 = new File(URI.create(\"file:///tmp/data.txt\"));\n</code></pre> <p>Note</p> <ul> <li><code>new File(...)</code> n\u2019ouvre jamais le fichier.</li> <li>Existence/permissions sont v\u00e9rifi\u00e9es seulement lorsque vous appelez des m\u00e9thodes comme <code>exists()</code>, <code>length()</code>, ou lorsque vous ouvrez un stream/channel.</li> </ul> <p></p>"},{"location":"fr/module-08/files-path-api/#3312-creer-un-path-nio-v2","title":"33.1.2 Cr\u00e9er un <code>Path</code> (NIO v.2)","text":"<p>Un <code>Path</code> est aussi juste un locator.</p> <p>Comme <code>File</code>, cr\u00e9er un <code>Path</code> n\u2019acc\u00e8de pas au syst\u00e8me de fichiers.</p> <p>Factories principales :</p> <ul> <li><code>Path.of(String first, String... more)</code> (Java 11+)</li> <li><code>Paths.get(String first, String... more)</code> (style plus ancien ; toujours valide)</li> <li><code>Path.of(URI uri)</code> (ex. <code>file:///...</code>)</li> </ul> <pre><code>import java.net.URI;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\nPath p1 = Path.of(\"data.txt\"); // relatif\nPath p2 = Path.of(\"/tmp\", \"data.txt\"); // parent + enfant\n\nPath p3 = Paths.get(\"data.txt\"); // style factory legacy\nPath p4 = Path.of(URI.create(\"file:///tmp/data.txt\"));\n</code></pre> <p>Note</p> <ul> <li><code>Path.of(...)</code> et <code>Paths.get(...)</code> sont \u00e9quivalents pour le syst\u00e8me de fichiers par d\u00e9faut.</li> <li>Pr\u00e9f\u00e9rez <code>Path.of</code> dans le code moderne.</li> </ul> <p></p>"},{"location":"fr/module-08/files-path-api/#3313-absolu-vs-relatif-ce-que-signifie-relatif","title":"33.1.3 Absolu vs relatif : ce que signifie \u201crelatif\u201d","text":"<p><code>File</code> et <code>Path</code> peuvent \u00eatre cr\u00e9\u00e9s comme chemins relatifs.</p> <p>Les chemins relatifs sont r\u00e9solus par rapport au r\u00e9pertoire de travail du processus (typiquement <code>System.getProperty(\"user.dir\")</code>).</p> <pre><code>import java.io.File;\nimport java.nio.file.Path;\n\nFile rf = new File(\"data.txt\");\nPath rp = Path.of(\"data.txt\");\n\nSystem.out.println(rf.isAbsolute()); // false\nSystem.out.println(rp.isAbsolute()); // false\n\nSystem.out.println(rf.getAbsolutePath());\nSystem.out.println(rp.toAbsolutePath());\n</code></pre> <p>Note</p> <p>Les chemins relatifs sont une source courante de bugs \u201cworks on my machine\u201d parce que <code>user.dir</code> d\u00e9pend de la mani\u00e8re/o\u00f9 la JVM a \u00e9t\u00e9 lanc\u00e9e.</p> <p></p>"},{"location":"fr/module-08/files-path-api/#3314-joindre-construire-des-paths","title":"33.1.4 Joindre / construire des paths","text":"<ul> <li>Le <code>File</code> legacy utilise des constructeurs (parent + enfant).</li> <li>NIO utilise <code>resolve</code> et des m\u00e9thodes associ\u00e9es.</li> </ul> T\u00e2che Legacy (File) NIO (Path) Joindre parent + enfant <code>new File(parent, child)</code> <code>parent.resolve(child)</code> Joindre plusieurs segments Constructeurs r\u00e9p\u00e9t\u00e9s <code>Path.of(a, b, c)</code> ou <code>resolve()</code> cha\u00een\u00e9 <pre><code>import java.io.File;\nimport java.nio.file.Path;\n\nFile f = new File(\"/tmp\", \"a.txt\");\n\nPath base = Path.of(\"/tmp\");\nPath p = base.resolve(\"a.txt\"); // /tmp/a.txt\nPath p2 = base.resolve(\"dir\").resolve(\"a.txt\"); // /tmp/dir/a.txt\n</code></pre>"},{"location":"fr/module-08/files-path-api/#33141-resolve","title":"33.1.4.1 <code>resolve()</code>","text":"<p>Combine des paths d\u2019une mani\u00e8re filesystem-aware.</p> <ul> <li>Les paths relatifs sont ajout\u00e9s</li> <li>Un argument absolu remplace le path de base</li> </ul> <p>Note</p> <p><code>Path.resolve(...)</code> a une r\u00e8gle : si l\u2019argument est absolu, il retourne l\u2019argument et ignore la base (vous ne pouvez pas combiner deux paths absolus en utilisant <code>resolve</code>).</p> <p></p>"},{"location":"fr/module-08/files-path-api/#33142-relativize","title":"33.1.4.2 <code>relativize()</code>","text":"<p><code>Path.relativize</code> calcule un path relatif d\u2019un path \u00e0 un autre. Le path r\u00e9sultant, lorsqu\u2019il est <code>resolved</code> contre le path source, donne le path cible.</p> <p>Autrement dit :</p> <ul> <li>Il r\u00e9pond \u00e0 la question : \u201cComment aller du path A au path B ?\u201d</li> <li>Le r\u00e9sultat est toujours un path relatif</li> <li>Aucun acc\u00e8s au syst\u00e8me de fichiers n\u2019a lieu</li> </ul> <p>R\u00e8gles fondamentales</p> <p><code>relativize</code> a des pr\u00e9conditions strictes. Les violer lance une exception.</p> R\u00e8gle Explication Les deux paths doivent \u00eatre absolus ou tous les deux relatifs Les deux paths doivent appartenir au m\u00eame syst\u00e8me de fichiers m\u00eame provider Les composants de root doivent correspondre m\u00eame root (sur Windows, m\u00eame drive) Le r\u00e9sultat n\u2019est jamais absolu toujours relatif <p>Note</p> <p>Si un path est absolu et l\u2019autre relatif, <code>IllegalArgumentException</code> est lanc\u00e9e.</p> <p>Exemple relatif simple :</p> <p>Les deux paths sont relatifs, donc la relativisation est autoris\u00e9e.</p> <pre><code>Path p1 = Path.of(\"docs/manual\");\nPath p2 = Path.of(\"docs/images/logo.png\");\n\nPath relative = p1.relativize(p2);\nSystem.out.println(relative);\n</code></pre> <pre><code>../images/logo.png\n</code></pre> <p>Interpr\u00e9tation : depuis <code>docs/manual</code>, monter d\u2019un niveau, puis entrer dans <code>images/logo.png</code>.</p> <p>Exemple de paths absolus :</p> <p>Les paths absolus fonctionnent exactement de la m\u00eame mani\u00e8re.</p> <pre><code>Path base = Path.of(\"/home/user/projects\");\nPath target = Path.of(\"/home/user/docs/readme.txt\");\n\nPath relative = base.relativize(target);\nSystem.out.println(relative);\n</code></pre> <pre><code>../docs/readme.txt\n</code></pre> <p>Utiliser <code>resolve</code> pour v\u00e9rifier le r\u00e9sultat</p> <p>Une propri\u00e9t\u00e9 cl\u00e9 de <code>relativize</code> est cette identit\u00e9 :</p> <pre><code>base.resolve(base.relativize(target)).equals(target)\n</code></pre> <pre><code>Path base = Path.of(\"/a/b/c\");\nPath target = Path.of(\"/a/d/e\");\n\nPath r = base.relativize(target);\nSystem.out.println(r); // ../../d/e\nSystem.out.println(base.resolve(r)); // /a/d/e\n</code></pre> <p>Exemple : m\u00e9langer des paths absolus et relatifs (CAS ERREUR)</p> <p>C\u2019est l\u2019une des erreurs les plus courantes.</p> <pre><code>Path abs = Path.of(\"/a/b\");\nPath rel = Path.of(\"c/d\");\n\nabs.relativize(rel); // lance une exception\n</code></pre> <pre><code>Exception in thread \"main\" java.lang.IllegalArgumentException\n</code></pre> <p>Note</p> <p><code>relativize</code> NE tente PAS de convertir automatiquement des paths en absolus.</p> <p>Exemple : roots diff\u00e9rentes (pi\u00e8ge sp\u00e9cifique Windows)</p> <p>Sur Windows, des paths avec des lettres de drive diff\u00e9rentes ne peuvent pas \u00eatre relativis\u00e9s.</p> <pre><code>Path p1 = Path.of(\"C:\\\\data\\\\a\");\nPath p2 = Path.of(\"D:\\\\data\\\\b\");\n\np1.relativize(p2); // IllegalArgumentException\n</code></pre> <p>Note</p> <p>Sur les syst\u00e8mes Unix-like, la root est toujours <code>/</code>, donc ce probl\u00e8me ne se produit pas.</p> <p></p>"},{"location":"fr/module-08/files-path-api/#3315-convertir-entre-file-et-path","title":"33.1.5 Convertir entre <code>File</code> et <code>Path</code>","text":"<p>La conversion est directe et sans perte pour les paths normaux du syst\u00e8me de fichiers local.</p> Conversion Comment File \u2192 Path <code>file.toPath()</code> Path \u2192 File <code>path.toFile()</code> <pre><code>import java.io.File;\nimport java.nio.file.Path;\n\nFile f = new File(\"data.txt\");\nPath p = f.toPath();\n\nFile back = p.toFile();\n</code></pre> <p>Note</p> <p>La conversion ne valide pas l\u2019existence. Elle convertit seulement des repr\u00e9sentations.</p> <p></p>"},{"location":"fr/module-08/files-path-api/#3316-conversion-uri-quand-necessaire","title":"33.1.6 Conversion URI (quand n\u00e9cessaire)","text":"<p>Les <code>URI</code> sont utiles lorsque les paths doivent \u00eatre repr\u00e9sent\u00e9s dans une forme standard et absolue (par ex. interop\u00e9rer avec des ressources r\u00e9seau ou de la configuration).</p> <p>Les deux APIs supportent la conversion URI.</p> Direction Legacy (File) NIO (Path) Depuis URI <code>new File(uri)</code> <code>Path.of(uri)</code> Vers URI <code>file.toURI()</code> <code>path.toUri()</code> <pre><code>import java.io.File;\nimport java.net.URI;\nimport java.nio.file.Path;\n\nFile f = new File(\"/tmp/data.txt\");\nURI u1 = f.toURI();\n\nPath p = Path.of(\"/tmp/data.txt\");\nURI u2 = p.toUri();\n\nPath pFromUri = Path.of(u2);\nFile fFromUri = new File(u1);\n</code></pre> <p>Note</p> <p><code>new File(URI)</code> requiert un URI <code>file:</code> et lance <code>IllegalArgumentException</code> si l\u2019URI n\u2019est pas hi\u00e9rarchique ou n\u2019est pas un file URI.</p> <p></p>"},{"location":"fr/module-08/files-path-api/#3317-canonique-vs-absolu-vs-normalise-differences-fondamentales","title":"33.1.7 Canonique vs absolu vs normalis\u00e9 (diff\u00e9rences fondamentales)","text":"<p>Ces termes sont souvent m\u00e9lang\u00e9s. Ils ne sont pas identiques.</p> Concept Legacy (File) NIO (Path) Touche le syst\u00e8me de fichiers Absolu <code>getAbsoluteFile()</code> <code>toAbsolutePath()</code> Non Normalis\u00e9 (pas de normalize pur, utiliser canonical)* <code>normalize()</code> <code>normalize()</code>: Non Canonique / R\u00e9el <code>getCanonicalFile()</code> <code>toRealPath()</code> Oui <p>Note</p> <p><code>File.getCanonicalFile()</code> et <code>Path.toRealPath()</code> peuvent r\u00e9soudre des symlinks et exigent que le path existe, donc ils peuvent lancer <code>IOException</code>.</p> <p>File ne fournit pas de m\u00e9thode pour une normalisation purement syntaxique : historiquement beaucoup de d\u00e9veloppeurs utilisaient getCanonicalFile(), mais ceci acc\u00e8de au syst\u00e8me de fichiers et peut \u00e9chouer.</p> <pre><code>import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Path;\n\nFile f = new File(\"a/../data.txt\");\nSystem.out.println(f.getAbsolutePath()); // absolu, peut encore contenir \"..\"\n\ntry {\n    System.out.println(f.getCanonicalPath()); // r\u00e9sout \"..\", peut toucher le syst\u00e8me de fichiers\n} catch (IOException e) {\n    System.out.println(\"Canonical failed: \" + e.getMessage());\n}\n\nPath p = Path.of(\"a/../data.txt\");\nSystem.out.println(p.toAbsolutePath()); // absolu, peut encore contenir \"..\"\nSystem.out.println(p.normalize()); // purement syntaxique\n\ntry {\n    System.out.println(p.toRealPath()); // r\u00e9sout symlinks, exige l\u2019existence\n} catch (IOException e) {\n    System.out.println(\"RealPath failed: \" + e.getMessage());\n}\n</code></pre> <p></p>"},{"location":"fr/module-08/files-path-api/#33171-normalize","title":"33.1.7.1 <code>normalize()</code>","text":"<p>Supprime des \u00e9l\u00e9ments de nom redondants comme <code>.</code> et <code>..</code>.</p> <ul> <li>Purement syntaxique</li> <li>Ne v\u00e9rifie pas si le path existe</li> </ul> <p>Note</p> <p><code>normalize()</code> est purement syntaxique, ne v\u00e9rifie pas l\u2019existence, et peut produire des paths invalides s\u2019il est mal utilis\u00e9.</p> <p></p>"},{"location":"fr/module-08/files-path-api/#3318-tableau-de-comparaison-rapide-creation-conversion","title":"33.1.8 Tableau de comparaison rapide (cr\u00e9ation + conversion)","text":"Besoin Legacy (File) NIO (Path) Pr\u00e9f\u00e9r\u00e9 aujourd\u2019hui Cr\u00e9er depuis string <code>new File(\"x\")</code> <code>Path.of(\"x\")</code> Path Parent + enfant <code>new File(p, c)</code> <code>Path.of(p, c)</code> ou <code>resolve()</code> Path Convertir entre APIs <code>toPath()</code> <code>toFile()</code> Path-centric Normaliser <code>getCanonicalFile()</code> (bas\u00e9 filesystem) <code>normalize()</code> (syntactique seulement) Path R\u00e9soudre symlinks Canonical <code>toRealPath()</code> Path"},{"location":"fr/module-08/files-path-api/#332-gerer-les-fichiers-et-repertoires-creer-copier-deplacer-remplacer-comparer-supprimer-legacy-vs-nio","title":"33.2 G\u00e9rer les fichiers et r\u00e9pertoires : cr\u00e9er, copier, d\u00e9placer, remplacer, comparer, supprimer (Legacy vs NIO)","text":"<p>Cette section couvre les op\u00e9rations que vous effectuez sur des entr\u00e9es du syst\u00e8me de fichiers (fichiers/r\u00e9pertoires) : cr\u00e9er, copier, d\u00e9placer/renommer, remplacer, comparer et supprimer.</p> <p>Elle contraste <code>java.io.File</code> legacy (et des helpers legacy associ\u00e9s) avec <code>java.nio.file</code> moderne (NIO.2).</p> <p></p>"},{"location":"fr/module-08/files-path-api/#3321-modele-mental-pathlocator-vs-operations","title":"33.2.1 Mod\u00e8le mental : \u201cPath/Locator\u201d vs \u201cOp\u00e9rations\u201d","text":"<p>Les deux APIs utilisent des objets qui repr\u00e9sentent un path, mais les op\u00e9rations diff\u00e8rent :</p> <ul> <li>Legacy : <code>File</code> est \u00e0 la fois un wrapper de path et une API d\u2019op\u00e9rations (responsabilit\u00e9 m\u00e9lang\u00e9e)</li> <li>NIO : <code>Path</code> est le path ; <code>Files</code> effectue les op\u00e9rations (s\u00e9paration des pr\u00e9occupations)</li> </ul> Responsabilit\u00e9 Legacy NIO Repr\u00e9sentation du path <code>File</code> <code>Path</code> Op\u00e9rations sur le syst\u00e8me de fichiers <code>File</code> <code>Files</code> Reporting riche des erreurs Faible (booleans) Fort (exceptions) <p>Note</p> <p>Les m\u00e9thodes legacy retournent souvent <code>boolean</code> (\u00e9chec silencieux), tandis que NIO lance <code>IOException</code> avec cause.</p> <p></p>"},{"location":"fr/module-08/files-path-api/#3322-creer-des-fichiers-et-des-repertoires","title":"33.2.2 Cr\u00e9er des fichiers et des r\u00e9pertoires","text":"<p>La cr\u00e9ation est l\u00e0 o\u00f9 l\u2019ancienne API est la plus maladroite et l\u2019API NIO la plus expressive.</p> T\u00e2che Approche legacy Approche NIO Notes Cr\u00e9er fichier vide ouvrir+fermer un stream <code>Files.createFile</code> NIO \u00e9choue si existe Cr\u00e9er un r\u00e9pertoire <code>mkdir</code> <code>Files.createDirectory</code> Le parent doit exister Cr\u00e9er des r\u00e9pertoires r\u00e9cursivement <code>mkdirs</code> <code>Files.createDirectories</code> Cr\u00e9e les parents <p></p>"},{"location":"fr/module-08/files-path-api/#33221-creer-un-fichier","title":"33.2.2.1 Cr\u00e9er un fichier","text":"<p>Legacy n\u2019a pas de m\u00e9thode \u201ccr\u00e9er fichier vide\u201d, donc typiquement vous cr\u00e9ez un fichier en ouvrant un output stream (side effect).</p> <pre><code>import java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\nFile f = new File(\"created-legacy.txt\");\ntry (FileOutputStream out = new FileOutputStream(f)) {\n    // le fichier est cr\u00e9\u00e9 (ou tronqu\u00e9) comme side effect\n}\n</code></pre> <p>NIO fournit une m\u00e9thode explicite de cr\u00e9ation.</p> <pre><code>import java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.io.IOException;\n\nPath p = Path.of(\"created-nio.txt\");\nFiles.createFile(p);\n</code></pre> <p>Note</p> <p><code>Files.createFile</code> lance <code>FileAlreadyExistsException</code> si l\u2019entr\u00e9e existe.</p> <p></p>"},{"location":"fr/module-08/files-path-api/#33222-creer-des-repertoires","title":"33.2.2.2 Cr\u00e9er des r\u00e9pertoires","text":"<pre><code>import java.io.File;\n\nFile dir1 = new File(\"a/b\");\nboolean ok1 = dir1.mkdir(); // \u00e9choue si le parent \"a\" n\u2019existe pas\nboolean ok2 = dir1.mkdirs(); // cr\u00e9e les parents\n</code></pre> <pre><code>import java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.io.IOException;\n\nPath d = Path.of(\"a/b\");\nFiles.createDirectory(d); // le parent doit exister\nFiles.createDirectories(d); // cr\u00e9e les parents, ok si d\u00e9j\u00e0 existe\n</code></pre> <p>Note</p> <p>Legacy <code>mkdir()/mkdirs()</code> retournent <code>false</code> en cas d\u2019\u00e9chec sans dire pourquoi. NIO lance <code>IOException</code>.</p> <p></p>"},{"location":"fr/module-08/files-path-api/#3323-copier-des-fichiers-et-des-repertoires","title":"33.2.3 Copier des fichiers et des r\u00e9pertoires","text":"<p>La copie legacy est g\u00e9n\u00e9ralement une copie manuelle par stream (ou des libs externes). NIO a une op\u00e9ration unique et explicite.</p> Capacit\u00e9 Legacy NIO Copier contenu de fichier Streams manuels <code>Files.copy</code> Copier dans une cible existante Manuel Option <code>REPLACE_EXISTING</code> Copier arbre de r\u00e9pertoires R\u00e9cursion manuelle R\u00e9cursion manuelle (mais meilleurs outils : <code>Files.walk</code> + <code>Files.copy</code>) <p></p>"},{"location":"fr/module-08/files-path-api/#33231-copier-un-fichier-nio","title":"33.2.3.1 Copier un fichier (NIO)","text":"<pre><code>import java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\nimport java.io.IOException;\n\nPath src = Path.of(\"src.txt\");\nPath dst = Path.of(\"dst.txt\");\n\nFiles.copy(src, dst); // \u00e9choue si dst existe\nFiles.copy(src, dst, StandardCopyOption.REPLACE_EXISTING);\n</code></pre> <p>Note</p> <p><code>Files.copy</code> lance <code>FileAlreadyExistsException</code> si la cible existe et que vous n\u2019avez pas utilis\u00e9 <code>REPLACE_EXISTING</code>.</p> <p></p>"},{"location":"fr/module-08/files-path-api/#33232-copie-manuelle-legacy-basee-sur-stream","title":"33.2.3.2 Copie manuelle (Legacy, bas\u00e9e sur stream)","text":"<pre><code>import java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\ntry (FileInputStream in = new FileInputStream(\"src.bin\");\nFileOutputStream out = new FileOutputStream(\"dst.bin\")) {\n\n    byte[] buf = new byte[8192];\n    int n;\n    while ((n = in.read(buf)) != -1) {\n        out.write(buf, 0, n);\n    }\n}\n</code></pre> <p>Note</p> <p>Rappelez-vous <code>read(byte[])</code> retourne le nombre de bytes lus ; vous devez \u00e9crire seulement ce compte, pas le buffer entier.</p> <p></p>"},{"location":"fr/module-08/files-path-api/#3324-deplacer-renommer-et-remplacer","title":"33.2.4 D\u00e9placer / renommer et remplacer","text":"<p>Dans les deux APIs, rename/move est \u201cau niveau metadata\u201d quand possible, mais peut se comporter comme copy+delete entre syst\u00e8mes de fichiers. NIO rend cela explicite via des options.</p> Op\u00e9ration Legacy NIO Renommer/d\u00e9placer <code>File.renameTo</code> <code>Files.move</code> Remplacer existant Peu fiable <code>REPLACE_EXISTING</code> D\u00e9placement atomique Non support\u00e9 <code>ATOMIC_MOVE</code> (si support\u00e9) <p></p>"},{"location":"fr/module-08/files-path-api/#33241-renommage-legacy-piege-commun","title":"33.2.4.1 Renommage legacy (pi\u00e8ge commun)","text":"<pre><code>import java.io.File;\n\nFile from = new File(\"old.txt\");\nFile to = new File(\"new.txt\");\n\nboolean ok = from.renameTo(to); // peut \u00e9chouer silencieusement\nSystem.out.println(ok);\n</code></pre> <p>Note</p> <ul> <li><code>renameTo</code> est notoirement platform-dependent et retourne seulement <code>boolean</code>.</li> <li>Il peut \u00e9chouer parce que la cible existe, le fichier est ouvert, permissions, ou d\u00e9placement cross-filesystem.</li> </ul> <p></p>"},{"location":"fr/module-08/files-path-api/#33242-nio-move-prefere","title":"33.2.4.2 NIO Move (pr\u00e9f\u00e9r\u00e9)","text":"<pre><code>import java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\nimport java.io.IOException;\n\nPath from = Path.of(\"old.txt\");\nPath to = Path.of(\"new.txt\");\n\nFiles.move(from, to); // \u00e9choue si la cible existe\nFiles.move(from, to, StandardCopyOption.REPLACE_EXISTING);\n</code></pre> <p>Note</p> <p><code>Files.move</code> lance <code>FileAlreadyExistsException</code> quand la cible existe et que <code>REPLACE_EXISTING</code> n\u2019est pas sp\u00e9cifi\u00e9.</p> <p></p>"},{"location":"fr/module-08/files-path-api/#3325-comparer-des-paths-et-des-fichiers","title":"33.2.5 Comparer des paths et des fichiers","text":"<p>Comparer des locators peut signifier : \u00e9galit\u00e9 de string/path, \u00e9galit\u00e9 normalis\u00e9e/canonique, ou \u201cm\u00eame fichier sur disque\u201d.</p> <p>Les APIs diff\u00e8rent significativement ici.</p> Objectif de comparaison Legacy NIO M\u00eame texte de path <code>File.equals</code> <code>Path.equals</code> Normaliser le path <code>getCanonicalFile</code> <code>normalize</code> M\u00eame fichier/ressource sur disque faible (heuristique canonique) <code>Files.isSameFile</code> <p></p>"},{"location":"fr/module-08/files-path-api/#33251-egalite-vs-meme-fichier","title":"33.2.5.1 \u00c9galit\u00e9 vs m\u00eame fichier","text":"<p>Deux strings de path diff\u00e9rentes peuvent r\u00e9f\u00e9rer au m\u00eame fichier.</p> <pre><code>import java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.io.IOException;\n\nPath p1 = Path.of(\"a/../data.txt\");\nPath p2 = Path.of(\"data.txt\");\n\nSystem.out.println(p1.equals(p2)); // false (texte de path diff\u00e9rent)\nSystem.out.println(p1.normalize().equals(p2.normalize())); // peut encore \u00eatre false si relatif\n\ntry {\n    System.out.println(Files.isSameFile(p1, p2)); // peut \u00eatre true, peut lancer si non accessible\n} catch (IOException e) {\n    System.out.println(\"isSameFile failed: \" + e.getMessage());\n}\n</code></pre> <p>Note</p> <p><code>Files.isSameFile</code> peut acc\u00e9der au syst\u00e8me de fichiers et peut lancer <code>IOException</code> (probl\u00e8mes de permissions, fichiers manquants, etc.).</p> <p></p>"},{"location":"fr/module-08/files-path-api/#3326-supprimer-des-fichiers-et-des-repertoires","title":"33.2.6 Supprimer des fichiers et des r\u00e9pertoires","text":"<p>La suppression est simple conceptuellement mais a des edge cases importants : r\u00e9pertoires non vides, cibles manquantes, et diff\u00e9rences de reporting d\u2019erreurs.</p> T\u00e2che Legacy NIO Comportement si manquant Supprimer fichier/dir <code>File.delete</code> <code>Files.delete</code> Legacy false, NIO exception Supprimer si existe Pas direct (check+delete) <code>Files.deleteIfExists</code> retourne boolean Supprimer dir non vide R\u00e9cursion manuelle R\u00e9cursion manuelle (walk) Les deux exigent r\u00e9cursion <p></p>"},{"location":"fr/module-08/files-path-api/#33261-delete-legacy","title":"33.2.6.1 Delete legacy","text":"<pre><code>import java.io.File;\n\nFile f = new File(\"x.txt\");\nboolean ok = f.delete(); // false si non supprim\u00e9\nSystem.out.println(ok);\n</code></pre> <p>Note</p> <p>Legacy <code>delete()</code> \u00e9choue (retourne false) pour un r\u00e9pertoire non vide et souvent ne fournit aucune raison.</p> <p></p>"},{"location":"fr/module-08/files-path-api/#33262-nio-delete-et-delete-if-exists","title":"33.2.6.2 NIO Delete et Delete-If-Exists","text":"<pre><code>import java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.NoSuchFileException;\nimport java.nio.file.DirectoryNotEmptyException;\nimport java.io.IOException;\n\nPath p = Path.of(\"x.txt\");\n\ntry {\n    Files.delete(p);\n} catch (NoSuchFileException e) {\n    System.out.println(\"Missing: \" + e.getFile());\n} catch (DirectoryNotEmptyException e) {\n    System.out.println(\"Directory not empty: \" + e.getFile());\n} catch (IOException e) {\n    System.out.println(\"Delete failed: \" + e.getMessage());\n}\n\nboolean deleted = Files.deleteIfExists(p);\nSystem.out.println(deleted);\n</code></pre> <p>Note</p> <p>Certification tip: <code>Files.delete</code> lance <code>NoSuchFileException</code> si manquant, tandis que <code>deleteIfExists</code> retourne <code>false</code>.</p> <p></p>"},{"location":"fr/module-08/files-path-api/#3327-copier-supprimer-recursivement-des-arbres-de-repertoires-pattern-nio","title":"33.2.7 Copier / supprimer r\u00e9cursivement des arbres de r\u00e9pertoires (pattern NIO)","text":"<p>NIO ne fournit pas une seule m\u00e9thode \u201ccopyTree/deleteTree\u201d, mais l\u2019approche standard utilise <code>Files.walk</code> ou <code>Files.walkFileTree</code>.</p> <pre><code>import java.io.IOException;\nimport java.nio.file.*;\nimport java.nio.file.attribute.BasicFileAttributes;\n\nPath root = Path.of(\"dirToDelete\");\n\nFiles.walkFileTree(root, new SimpleFileVisitor&lt;Path&gt;() {\n    @Override\n    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n        Files.delete(file);\n        return FileVisitResult.CONTINUE;\n    }\n\n    @Override\n    public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n        if (exc != null) throw exc;\n        Files.delete(dir);\n        return FileVisitResult.CONTINUE;\n    }\n});\n</code></pre> <p>Note</p> <p>Supprimer un arbre de r\u00e9pertoires exige de supprimer d\u2019abord les fichiers, puis les r\u00e9pertoires (post-order). C\u2019est une question de raisonnement courante.</p> <p></p>"},{"location":"fr/module-08/files-path-api/#3328-checklist-de-resume","title":"33.2.8 Checklist de r\u00e9sum\u00e9","text":"<ul> <li>Pr\u00e9f\u00e9rer <code>Files.createFile/createDirectory/createDirectories</code> aux workarounds legacy</li> <li><code>File.renameTo</code> est peu fiable ; pr\u00e9f\u00e9rer <code>Files.move</code> avec options</li> <li><code>Files.copy/move</code> lancent <code>FileAlreadyExistsException</code> \u00e0 moins que <code>REPLACE_EXISTING</code> soit utilis\u00e9</li> <li><code>Files.delete</code> lance ; <code>Files.deleteIfExists</code> retourne boolean</li> <li><code>Files.isSameFile</code> peut lancer <code>IOException</code> et peut toucher le syst\u00e8me de fichiers</li> <li>La suppression de r\u00e9pertoires non vides exige une r\u00e9cursion (les deux APIs)</li> </ul>"},{"location":"fr/module-08/files-path/","title":"32. Fondamentaux des fichiers et des chemins","text":""},{"location":"fr/module-08/files-path/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>32.1 Mod\u00e8le conceptuel : syst\u00e8me de fichiers, fichiers, r\u00e9pertoires, liens et cibles-d\u2019E/S</li> <li>32.2 Syst\u00e8me de fichiers \u2013 L\u2019abstraction globale</li> <li>32.3 Chemin \u2013 Localiser une entr\u00e9e dans un syst\u00e8me de fichiers</li> <li>32.4 Fichiers \u2013 Conteneurs persistants de donn\u00e9es</li> <li>32.5 R\u00e9pertoires \u2013 Conteneurs structurels</li> <li>32.6 Liens \u2013 M\u00e9canismes d\u2019indirection<ul> <li>32.6.1 Liens physiques</li> <li>32.6.2 Liens symboliques soft</li> </ul> </li> <li>32.7 Autres types d\u2019entr\u00e9es du syst\u00e8me de fichiers</li> <li>32.8 Comment Java IO interagit avec ces concepts</li> <li>32.9 Pi\u00e8ges conceptuels fondamentaux</li> <li>32.10 Pourquoi Path et Files existent (contexte-IO)</li> <li>32.11 File est (API legacy) \u00e0 la fois un path et une api-d\u2019op\u00e9rations-sur-fichiers<ul> <li>32.11.1 Ce qu\u2019est vraiment File</li> <li>32.11.2 Responsabilit\u00e9s de type-Path</li> <li>32.11.3 Responsabilit\u00e9s d\u2019op\u00e9rations sur le syst\u00e8me de fichiers</li> <li>32.11.4 Ce que File N\u2019EST PAS</li> <li>32.11.5 L\u2019ancien double r\u00f4le</li> <li>32.11.6 Comment NIO a corrig\u00e9 cela</li> <li>32.11.7 R\u00e9sum\u00e9</li> </ul> </li> <li>32.12 Path est une description, pas une ressource</li> <li>32.13 Chemins absolus vs relatifs<ul> <li>32.13.1 Chemins absolus</li> <li>32.13.2 Chemins relatifs</li> </ul> </li> <li>32.14 Connaissance du syst\u00e8me de fichiers et s\u00e9parateurs<ul> <li>32.14.1 FileSystem</li> <li>32.14.2 S\u00e9parateurs de chemin</li> </ul> </li> <li>32.15 Ce que Files fait r\u00e9ellement et ce qu\u2019il ne fait pas<ul> <li>32.15.1 Files FAIT</li> <li>32.15.2 Files NE FAIT PAS</li> </ul> </li> <li>32.16 Philosophie de gestion des erreurs : Old-vs-NIO</li> <li>32.17 Id\u00e9es fausses courantes</li> </ul> <p>Cette section se concentre sur <code>Path</code>, <code>File</code>, <code>Files</code> et les classes associ\u00e9es, en expliquant pourquoi elles existent, quels probl\u00e8mes elles r\u00e9solvent et quelles sont les diff\u00e9rences entre les API legacy <code>java.io</code> et <code>NIO v.2</code> (nouvelles API d\u2019E/S), avec une attention particuli\u00e8re \u00e0 la s\u00e9mantique du syst\u00e8me de fichiers, \u00e0 la r\u00e9solution des chemins et aux id\u00e9es fausses courantes.</p> <p></p>"},{"location":"fr/module-08/files-path/#321-modele-conceptuel-systeme-de-fichiers-fichiers-repertoires-liens-et-cibles-des","title":"32.1 Mod\u00e8le conceptuel : syst\u00e8me de fichiers, fichiers, r\u00e9pertoires, liens et cibles-d\u2019E/S","text":"<p>Avant de comprendre les API d\u2019E/S Java, il est essentiel de comprendre avec quoi elles interagissent.</p> <p>Java I/O n\u2019op\u00e8re pas dans le vide : il interagit avec des abstractions de syst\u00e8me de fichiers fournies par le syst\u00e8me d\u2019exploitation.</p> <p>Cette section d\u00e9finit ces concepts ind\u00e9pendamment de Java, puis explique comment Java I/O les mappe et quels probl\u00e8mes sont r\u00e9solus.</p> <p></p>"},{"location":"fr/module-08/files-path/#322-systeme-de-fichiers-labstraction-globale","title":"32.2 Syst\u00e8me de fichiers \u2013 L\u2019abstraction globale","text":"<p>Un <code>syst\u00e8me de fichiers</code> est un m\u00e9canisme structur\u00e9 fourni par un syst\u00e8me d\u2019exploitation pour organiser, stocker, r\u00e9cup\u00e9rer et g\u00e9rer des donn\u00e9es sur des dispositifs de stockage persistant.</p> <p>Au niveau conceptuel, un syst\u00e8me de fichiers r\u00e9sout plusieurs probl\u00e8mes fondamentaux :</p> <ul> <li>Stockage persistant au-del\u00e0 de l\u2019ex\u00e9cution du programme</li> <li>Organisation hi\u00e9rarchique des donn\u00e9es</li> <li>Nommer et localiser les donn\u00e9es</li> <li>Contr\u00f4le d\u2019acc\u00e8s et permissions</li> <li>Garanties de concurrence et de coh\u00e9rence</li> </ul> <p>En Java NIO, un syst\u00e8me de fichiers est repr\u00e9sent\u00e9 par l\u2019abstraction <code>FileSystem</code>, g\u00e9n\u00e9ralement obtenue via <code>FileSystems.getDefault()</code> pour le syst\u00e8me de fichiers du syst\u00e8me d\u2019exploitation.</p> Aspect Signification Persistance Les donn\u00e9es survivent \u00e0 la terminaison de la JVM Port\u00e9e G\u00e9r\u00e9 par le SE, pas par la JVM Multiplicit\u00e9 Plusieurs syst\u00e8mes de fichiers peuvent exister Exemples Disk FS, ZIP FS, in-memory FS <p>Note</p> <p>Java n\u2019impl\u00e9mente pas de syst\u00e8mes de fichiers ; il s\u2019adapte aux impl\u00e9mentations fournies par le SE ou par des providers personnalis\u00e9s.</p> <p></p>"},{"location":"fr/module-08/files-path/#323-chemin-localiser-une-entree-dans-un-systeme-de-fichiers","title":"32.3 Chemin \u2013 Localiser une entr\u00e9e dans un syst\u00e8me de fichiers","text":"<p>Un <code>chemin</code> est un localisateur logique, pas une ressource.</p> <p>Il d\u00e9crit o\u00f9 quelque chose se trouverait dans un syst\u00e8me de fichiers, pas ce que c\u2019est ni si cela existe.</p> <p>Un <code>chemin</code> r\u00e9sout le probl\u00e8me de l\u2019<code>addressing</code> :</p> <ul> <li>Identifie un emplacement</li> <li>Est interpr\u00e9t\u00e9 dans un syst\u00e8me de fichiers sp\u00e9cifique</li> <li>Peut ou non correspondre \u00e0 une entr\u00e9e existante</li> </ul> Propri\u00e9t\u00e9 Path Conscient de l\u2019existence Non Conscient du type Non Immuable Oui Ressource du SE Non <p>Note</p> <p>En Java, <code>Path</code> repr\u00e9sente des entr\u00e9es potentielles du syst\u00e8me de fichiers, pas des entr\u00e9es r\u00e9elles.</p> <p></p>"},{"location":"fr/module-08/files-path/#324-fichiers-conteneurs-persistants-de-donnees","title":"32.4 Fichiers \u2013 Conteneurs persistants de donn\u00e9es","text":"<p>Un <code>fichier</code> est une entr\u00e9e du syst\u00e8me de fichiers dont le r\u00f4le principal est de stocker des donn\u00e9es.</p> <p>Le syst\u00e8me de fichiers traite les fichiers comme des s\u00e9quences de bytes opaques.</p> <p>Probl\u00e8mes r\u00e9solus par les fichiers :</p> <ul> <li>Stockage durable d\u2019informations</li> <li>Acc\u00e8s s\u00e9quentiel et al\u00e9atoire aux donn\u00e9es</li> <li>Partage des donn\u00e9es entre processus</li> </ul> <p>Du point de vue du syst\u00e8me de fichiers, un fichier a :</p> <ul> <li>Contenu (bytes)</li> <li>M\u00e9tadonn\u00e9es (taille, timestamps, permissions)</li> <li>Un emplacement (chemin)</li> </ul> Aspect Description Contenu Orient\u00e9 byte Interpr\u00e9tation D\u00e9finie par l\u2019application Dur\u00e9e de vie Ind\u00e9pendante des processus Acc\u00e8s Java Streams, channels, m\u00e9thodes de Files <p>Note</p> <p><code>Texte</code> vs <code>binaire</code> n\u2019est pas un concept de syst\u00e8me de fichiers ; c\u2019est une interpr\u00e9tation au niveau application.</p> <p></p>"},{"location":"fr/module-08/files-path/#325-repertoires-conteneurs-structurels","title":"32.5 R\u00e9pertoires \u2013 Conteneurs structurels","text":"<p>Un <code>r\u00e9pertoire (ou dossier)</code> est une entr\u00e9e du syst\u00e8me de fichiers dont le but est d\u2019organiser d\u2019autres entr\u00e9es.</p> <p>Les <code>r\u00e9pertoires</code> r\u00e9solvent le probl\u00e8me de l\u2019\u00e9volutivit\u00e9 et de l\u2019organisation :</p> <ul> <li>Regrouper des entr\u00e9es li\u00e9es</li> <li>Permettre un nommage hi\u00e9rarchique</li> <li>Supporter une recherche efficace</li> </ul> Aspect R\u00e9pertoire Stocke des donn\u00e9es Non (stocke des r\u00e9f\u00e9rences) Contient Fichiers, r\u00e9pertoires, liens Lecture/\u00e9criture Structurelle, pas bas\u00e9e sur le contenu Acc\u00e8s Java Files.list, Files.walk <p>Note</p> <p>Un r\u00e9pertoire n\u2019est pas un fichier avec du contenu, m\u00eame si les deux partagent des m\u00e9tadonn\u00e9es communes.</p> <p></p>"},{"location":"fr/module-08/files-path/#326-liens-mecanismes-dindirection","title":"32.6 Liens \u2013 M\u00e9canismes d\u2019indirection","text":"<p>Un <code>lien</code> est une entr\u00e9e du syst\u00e8me de fichiers qui r\u00e9f\u00e9rence une autre entr\u00e9e.</p> <p>Les liens r\u00e9solvent le probl\u00e8me de l\u2019indirection et de la r\u00e9utilisation.</p> <p></p>"},{"location":"fr/module-08/files-path/#3261-liens-physiques","title":"32.6.1 Liens physiques","text":"<p>Un <code>lien physique</code> est un nom suppl\u00e9mentaire pour les m\u00eames donn\u00e9es sous-jacentes.</p> <ul> <li>Plusieurs chemins pointent vers les m\u00eames donn\u00e9es de fichier</li> <li>La suppression n\u2019a lieu que lorsque tous les liens sont supprim\u00e9s</li> </ul> <p></p>"},{"location":"fr/module-08/files-path/#3262-liens-symboliques-soft","title":"32.6.2 Liens symboliques (Soft)","text":"<p>Un <code>lien symbolique</code> est un fichier sp\u00e9cial qui contient un chemin vers une autre entr\u00e9e :</p> <ul> <li>Peut pointer vers des cibles inexistantes</li> <li>R\u00e9solu au moment de l\u2019acc\u00e8s</li> </ul> Type de lien R\u00e9f\u00e9rence Peut \u00eatre dangling Gestion Java Physique Donn\u00e9es Non Transparent Symbolique Chemin Oui Contr\u00f4le explicite <p>Note</p> <p>Java NIO expose le comportement des liens explicitement via <code>LinkOption</code>.</p> <p>Dans de nombreux syst\u00e8mes de fichiers courants, le code Java ne peut pas cr\u00e9er des liens physiques de mani\u00e8re pleinement portable, tandis que les liens symboliques sont support\u00e9s directement via <code>Files.createSymbolicLink(...)</code> (l\u00e0 o\u00f9 autoris\u00e9 par le SE / permissions).</p> <p></p>"},{"location":"fr/module-08/files-path/#327-autres-types-dentrees-du-systeme-de-fichiers","title":"32.7 Autres types d\u2019entr\u00e9es du syst\u00e8me de fichiers","text":"<p>Certaines entr\u00e9es du syst\u00e8me de fichiers ne sont pas des conteneurs de donn\u00e9es mais des endpoints d\u2019interaction.</p> Type But Fichier de p\u00e9riph\u00e9rique Interface vers le mat\u00e9riel FIFO / Pipe Communication inter-processus Fichier socket Communication r\u00e9seau <p>Note</p> <p>Java I/O peut interagir avec ces entr\u00e9es, mais le comportement d\u00e9pend de la plateforme.</p> <p></p>"},{"location":"fr/module-08/files-path/#328-comment-java-io-interagit-avec-ces-concepts","title":"32.8 Comment Java IO interagit avec ces concepts","text":"<p>Les API Java I/O op\u00e8rent \u00e0 diff\u00e9rents niveaux d\u2019abstraction :</p> <ul> <li><code>Path</code> / <code>File</code> (API legacy) \u2192 d\u00e9crit une entr\u00e9e du syst\u00e8me de fichiers</li> <li><code>File</code> (API legacy) / <code>Files</code> \u2192 interroge ou modifie l\u2019\u00e9tat du syst\u00e8me de fichiers</li> <li><code>Streams</code> / <code>Channels</code> \u2192 d\u00e9placent des bytes ou des caract\u00e8res</li> </ul> API Java R\u00f4le <code>Path</code> Addressing <code>File</code> (API legacy) Addressing / op\u00e9rations sur le syst\u00e8me de fichiers <code>Files</code> Op\u00e9rations sur le syst\u00e8me de fichiers <code>InputStream</code> / <code>Reader</code> Lecture de donn\u00e9es <code>OutputStream</code> / <code>Writer</code> \u00c9criture de donn\u00e9es <code>Channel</code> / <code>SeekableByteChannel</code> Avanc\u00e9 / acc\u00e8s al\u00e9atoire <p>Note</p> <p>Aucune API Java \u201cn\u2019est\u201d un fichier ; les API m\u00e9diatisent l\u2019acc\u00e8s \u00e0 des ressources g\u00e9r\u00e9es par le syst\u00e8me de fichiers.</p> <p></p>"},{"location":"fr/module-08/files-path/#329-pieges-conceptuels-fondamentaux","title":"32.9 Pi\u00e8ges conceptuels fondamentaux","text":"<ul> <li>Confondre les chemins avec les fichiers</li> <li>Supposer que les chemins impliquent l\u2019existence</li> <li>Supposer que les r\u00e9pertoires stockent les donn\u00e9es des fichiers</li> <li>Supposer que les liens sont toujours r\u00e9solus automatiquement</li> </ul> <p>Note</p> <p>S\u00e9parer toujours emplacement, structure et flux de donn\u00e9es lorsqu\u2019on raisonne sur les E/S.</p> <p></p>"},{"location":"fr/module-08/files-path/#3210-pourquoi-path-et-files-existent-contexte-io","title":"32.10 Pourquoi Path et Files existent (contexte-IO)","text":"<p>Le classique <code>java.io</code> m\u00e9langeait trois pr\u00e9occupations diff\u00e9rentes dans des API mal s\u00e9par\u00e9es :</p> <ul> <li>Repr\u00e9sentation du chemin (o\u00f9 se trouve la ressource ?)</li> <li>Interaction avec le syst\u00e8me de fichiers (existe-t-elle ? quel type ?)</li> <li>Acc\u00e8s aux donn\u00e9es (lecture/\u00e9criture de bytes ou de caract\u00e8res)</li> </ul> <p>La conception NIO.2 (Java 7+) s\u00e9pare d\u00e9lib\u00e9r\u00e9ment ces pr\u00e9occupations :</p> <ul> <li><code>Path</code> \u2192 d\u00e9crit un emplacement</li> <li><code>Files</code> \u2192 effectue des op\u00e9rations sur le syst\u00e8me de fichiers</li> <li><code>Streams / Channels</code> \u2192 d\u00e9placent des donn\u00e9es</li> </ul> <p>Note</p> <p>Un <code>Path</code> n\u2019ouvre jamais un fichier et ne touche jamais le disque \u00e0 lui seul.</p> <p></p>"},{"location":"fr/module-08/files-path/#3211-file-est-api-legacy-a-la-fois-un-path-et-une-api-doperations-sur-fichiers","title":"32.11 File est (API legacy) \u00e0 la fois un path et une api-d\u2019op\u00e9rations-sur-fichiers","text":"<p>Oui \u2014 dans l\u2019ancienne API d\u2019E/S, <code>java.io.File</code> joue de mani\u00e8re confuse deux r\u00f4les en m\u00eame temps, et cette conception est exactement l\u2019une des raisons pour lesquelles <code>java.nio.file</code> a \u00e9t\u00e9 introduit.</p> <p>R\u00e9ponse courte</p> <ul> <li><code>File</code> repr\u00e9sente un chemin du syst\u00e8me de fichiers</li> <li><code>File</code> expose aussi des op\u00e9rations sur le syst\u00e8me de fichiers</li> <li>Il ne repr\u00e9sente ni un fichier ouvert, ni le contenu du fichier</li> </ul> <p>Note</p> <p>Ce m\u00e9lange de responsabilit\u00e9s est consid\u00e9r\u00e9 comme un d\u00e9faut de conception r\u00e9trospectivement.</p> <p></p>"},{"location":"fr/module-08/files-path/#32111-ce-quest-vraiment-file","title":"32.11.1 Ce qu\u2019est vraiment File","text":"<p>Conceptuellement, <code>File</code> est plus proche de ce que nous appelons aujourd\u2019hui un <code>Path</code>, mais avec des m\u00e9thodes op\u00e9rationnelles ajout\u00e9es.</p> Aspect java.io.File Repr\u00e9sente un emplacement Oui Ouvre un fichier Non Lit / \u00e9crit des donn\u00e9es Non Interroge le syst\u00e8me de fichiers Oui Modifie le syst\u00e8me de fichiers Oui Contient un handle SE Non <p>Note</p> <p>Un objet <code>File</code> peut exister m\u00eame si le fichier n\u2019existe pas.</p> <p></p>"},{"location":"fr/module-08/files-path/#32112-responsabilites-de-type-path","title":"32.11.2 Responsabilit\u00e9s de type-Path","text":"<p><code>File</code> se comporte comme une abstraction de chemin parce qu\u2019il :</p> <ul> <li>Encapsule un pathname du syst\u00e8me de fichiers (absolu ou relatif)</li> <li>Peut \u00eatre r\u00e9solu par rapport au r\u00e9pertoire de travail</li> <li>Peut \u00eatre converti en forme absolue ou canonique</li> </ul> <p>Exemples :</p> <pre><code>File f = new File(\"data.txt\"); // chemin relatif\nFile abs = f.getAbsoluteFile(); // chemin absolu\nFile canon = f.getCanonicalFile(); // normalis\u00e9 + r\u00e9solu\n</code></pre> <p></p>"},{"location":"fr/module-08/files-path/#32113-responsabilites-doperations-sur-le-systeme-de-fichiers","title":"32.11.3 Responsabilit\u00e9s d\u2019op\u00e9rations sur le syst\u00e8me de fichiers","text":"<p>En m\u00eame temps, <code>File</code> expose des m\u00e9thodes qui touchent le syst\u00e8me de fichiers :</p> <ul> <li>exists()</li> <li>isFile(), isDirectory()</li> <li>length()</li> <li>delete()</li> <li>mkdir(), mkdirs()</li> <li>list(), listFiles()</li> </ul> <p>Note</p> <p>La plupart de ces m\u00e9thodes renvoient <code>boolean</code> au lieu de lancer <code>IOException</code>, ce qui masque les causes des \u00e9checs.</p> <p></p>"},{"location":"fr/module-08/files-path/#32114-ce-que-file-nest-pas","title":"32.11.4 Ce que File N\u2019EST PAS","text":"<ul> <li>Ce n\u2019est pas un file descriptor ouvert</li> <li>Ce n\u2019est pas un stream</li> <li>Ce n\u2019est pas un channel</li> <li>Ce n\u2019est pas un conteneur de donn\u00e9es du fichier</li> </ul> <p>Il faut tout de m\u00eame utiliser des streams ou des reader/writer pour acc\u00e9der au contenu.</p> <p></p>"},{"location":"fr/module-08/files-path/#32115-lancien-double-role","title":"32.11.5 L\u2019ancien double r\u00f4le","text":"<p>Le double r\u00f4le de <code>File</code> a caus\u00e9 plusieurs probl\u00e8mes :</p> <ul> <li>Pr\u00e9occupations m\u00e9lang\u00e9es (chemin + op\u00e9rations)</li> <li>Mauvaise gestion des erreurs (boolean au lieu d\u2019exceptions)</li> <li>Support faible pour les liens et les syst\u00e8mes de fichiers multiples</li> <li>Comportement d\u00e9pendant de la plateforme</li> </ul> <p></p>"},{"location":"fr/module-08/files-path/#32116-comment-nio-a-corrige-cela","title":"32.11.6 Comment NIO a corrig\u00e9 cela","text":"<p>NIO.2 s\u00e9pare explicitement les responsabilit\u00e9s :</p> Responsabilit\u00e9 Ancienne API API NIO <code>Repr\u00e9sentation Path</code> <code>File</code> <code>Path</code> <code>Op\u00e9rations sur le syst\u00e8me de fichiers</code> <code>File</code> <code>Files</code> <code>Acc\u00e8s aux donn\u00e9es</code> Streams Streams / Channels <p>Note</p> <p>Cette s\u00e9paration est l\u2019une des am\u00e9liorations conceptuelles les plus importantes en Java I/O.</p> <p></p>"},{"location":"fr/module-08/files-path/#32117-resume","title":"32.11.7 R\u00e9sum\u00e9","text":"<ul> <li><code>File</code> repr\u00e9sente un chemin ET effectue des op\u00e9rations sur le syst\u00e8me de fichiers</li> <li>Il ne lit ni n\u2019\u00e9crit jamais le contenu du fichier</li> <li>Il n\u2019ouvre jamais un fichier</li> <li><code>Path</code> + <code>Files</code> est le remplacement moderne</li> </ul>"},{"location":"fr/module-08/files-path/#3212-path-est-une-description-pas-une-ressource","title":"32.12 Path est une description, pas une ressource","text":"<p>Un <code>Path</code> est une abstraction pure repr\u00e9sentant une s\u00e9quence d\u2019\u00e9l\u00e9ments de nom dans un syst\u00e8me de fichiers.</p> <ul> <li>Il n\u2019implique PAS l\u2019existence</li> <li>Il n\u2019implique PAS l\u2019accessibilit\u00e9</li> <li>Il ne contient PAS de file descriptor</li> </ul> <p>Ceci est fondamentalement diff\u00e9rent des streams ou des channels.</p> Concept Path Stream / Channel <code>Ouvre ressource</code> Non Oui <code>Touche disque</code> Non Oui <code>Contient handle SE</code> Non Oui <code>Immuable</code> Oui Non <p>Note</p> <p>Cr\u00e9er un Path ne peut pas lancer <code>IOException</code> car aucun E/S ne se produit.</p> <p></p>"},{"location":"fr/module-08/files-path/#3213-chemins-absolus-vs-relatifs","title":"32.13 Chemins absolus vs relatifs","text":"<p>Comprendre la r\u00e9solution des chemins est essentiel.</p> <p></p>"},{"location":"fr/module-08/files-path/#32131-chemins-absolus","title":"32.13.1 Chemins absolus","text":"<p>Un chemin absolu identifie compl\u00e8tement un emplacement depuis la racine du syst\u00e8me de fichiers.</p> <ul> <li>Racine d\u00e9pendante de la plateforme</li> <li>Ind\u00e9pendant du r\u00e9pertoire de travail de la JVM</li> </ul> Plateforme Exemple de chemin absolu Unix <code>/home/user/file.txt</code> Windows <code>C:\\Users\\User\\file.txt</code> <p>Important</p> <ul> <li>Un chemin commen\u00e7ant par un slash <code>(/)</code> (type Unix) ou par une lettre de drive telle que <code>C:</code> (Windows) est typiquement consid\u00e9r\u00e9 comme un chemin absolu.</li> <li>Le symbole <code>.</code> est une r\u00e9f\u00e9rence au r\u00e9pertoire courant tandis que <code>..</code> est une r\u00e9f\u00e9rence \u00e0 son r\u00e9pertoire parent. Sur Windows, un chemin comme <code>\\dir\\file.txt</code> (sans lettre de drive) est rooted sur le drive courant, pas pleinement qualifi\u00e9 avec drive + chemin.</li> </ul> <p>Exemple :</p> <pre><code>/dirA/dirB/../dirC/./content.txt\n\nis equivalent to:\n\n/dirA/dirC/content.txt\n\n// in this example the symbols were redundant and unnecessary\n</code></pre> <p></p>"},{"location":"fr/module-08/files-path/#32132-chemins-relatifs","title":"32.13.2 Chemins relatifs","text":"<p>Un chemin relatif est r\u00e9solu par rapport au r\u00e9pertoire de travail courant de la JVM.</p> <ul> <li>D\u00e9pend de l\u2019endroit o\u00f9 la JVM a \u00e9t\u00e9 lanc\u00e9e</li> <li>Source courante de bugs</li> </ul> <p>Note</p> <p>Le r\u00e9pertoire de travail est typiquement disponible via <code>System.getProperty(\"user.dir\")</code>.</p> <p>Exemple :</p> <pre><code>dirB/dirC/content.txt\n</code></pre> <p></p>"},{"location":"fr/module-08/files-path/#3214-connaissance-du-systeme-de-fichiers-et-separateurs","title":"32.14 Connaissance du syst\u00e8me de fichiers et s\u00e9parateurs","text":"<p>NIO introduit l\u2019abstraction de syst\u00e8me de fichiers, qui \u00e9tait largement absente dans java.io.</p> <p></p>"},{"location":"fr/module-08/files-path/#32141-filesystem","title":"32.14.1 FileSystem","text":"<p>Un <code>FileSystem</code> repr\u00e9sente une impl\u00e9mentation concr\u00e8te sp\u00e9cifique de syst\u00e8me de fichiers.</p> <ul> <li>Le syst\u00e8me de fichiers par d\u00e9faut correspond au syst\u00e8me de fichiers du SE</li> <li>D\u2019autres syst\u00e8mes de fichiers possibles (ZIP, m\u00e9moire, r\u00e9seau)</li> </ul> <p>Note</p> <p>Les chemins sont toujours associ\u00e9s \u00e0 exactement UN FileSystem.</p> <p></p>"},{"location":"fr/module-08/files-path/#32142-separateurs-de-chemin","title":"32.14.2 S\u00e9parateurs de chemin","text":"<p>Les s\u00e9parateurs diff\u00e8rent selon les plateformes, mais <code>Path</code> les abstrait.</p> Aspect java.io.File java.nio.file.Path S\u00e9parateur Bas\u00e9 sur des cha\u00eenes Conscient du syst\u00e8me de fichiers Portabilit\u00e9 Gestion manuelle Automatique Comparaison Sujette aux erreurs Plus s\u00fbre <p>Note</p> <p>Hardcoder <code>\"/\"</code> ou <code>\"\\\\\"</code> est d\u00e9conseill\u00e9 ; <code>Path</code> le g\u00e8re automatiquement.</p> <p></p>"},{"location":"fr/module-08/files-path/#3215-ce-que-files-fait-reellement-et-ce-quil-ne-fait-pas","title":"32.15 Ce que Files fait r\u00e9ellement et ce qu\u2019il ne fait pas","text":"<p>La classe <code>Files</code> effectue de vraies op\u00e9rations d\u2019E/S.</p> <p></p>"},{"location":"fr/module-08/files-path/#32151-files-fait","title":"32.15.1 Files FAIT","text":"<ul> <li>Ouvre des fichiers indirectement (via streams / channels renvoy\u00e9s par ses m\u00e9thodes)</li> <li>Cr\u00e9e et supprime des entr\u00e9es du syst\u00e8me de fichiers</li> <li>Lance des exceptions checked en cas d\u2019\u00e9chec</li> <li>Respecte les permissions du syst\u00e8me de fichiers</li> </ul>"},{"location":"fr/module-08/files-path/#32152-files-ne-fait-pas","title":"32.15.2 Files NE FAIT PAS","text":"<ul> <li>Maintenir des ressources ouvertes apr\u00e8s le retour de la m\u00e9thode (sauf les streams)</li> <li>Stocker le contenu des fichiers en interne</li> <li>Garantir l\u2019atomicit\u00e9 sauf si sp\u00e9cifi\u00e9</li> <li>Maintenir un handle persistant vers des fichiers ouverts (les streams/channels poss\u00e8dent le handle \u00e0 la place)</li> </ul> <p>Note</p> <p>Les m\u00e9thodes qui renvoient des streams (par ex. <code>Files.lines()</code>) gardent le fichier ouvert jusqu\u2019\u00e0 ce que le stream soit ferm\u00e9.</p> <p></p>"},{"location":"fr/module-08/files-path/#3216-philosophie-de-gestion-des-erreurs-old-vs-nio","title":"32.16 Philosophie de gestion des erreurs : Old-vs-NIO","text":"<p>Une grande diff\u00e9rence conceptuelle r\u00e9side dans le reporting des erreurs.</p> Aspect <code>java.io.File</code> <code>java.nio.file.Files</code> Signalement d\u2019erreur boolean / <code>null</code> <code>IOException</code> Diagnostic Faible Riche Conscience des race Faible Am\u00e9lior\u00e9e Pr\u00e9f\u00e9rence D\u00e9conseill\u00e9 Pr\u00e9f\u00e9r\u00e9 <p></p>"},{"location":"fr/module-08/files-path/#3217-idees-fausses-courantes","title":"32.17 Id\u00e9es fausses courantes","text":"<ul> <li>\u201cPath repr\u00e9sente un fichier\u201d \u2192 faux</li> <li>\u201cnormalize v\u00e9rifie l\u2019existence\u201d \u2192 faux</li> <li>\u201cFiles.readAllLines stream les donn\u00e9es\u201d \u2192 faux</li> <li>\u201cLes chemins relatifs sont portables\u201d \u2192 faux</li> <li>\u201cCr\u00e9er un Path peut \u00e9chouer \u00e0 cause des permissions\u201d \u2192 faux</li> </ul> <p>Note</p> <p>De nombreuses m\u00e9thodes NIO qui semblent \u201cs\u00fbres\u201d sont purement syntaxiques (comme <code>normalize</code> ou <code>resolve</code>) : elles ne touchent pas le syst\u00e8me de fichiers et ne peuvent pas d\u00e9tecter des fichiers manquants.</p>"},{"location":"fr/module-08/io-streams-api/","title":"35. API Java d\u2019E/S (Legacy et NIO)","text":""},{"location":"fr/module-08/io-streams-api/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>35.1 Legacy java.io \u2014 Conception, comportement et subtilit\u00e9s<ul> <li>35.1.1 L\u2019abstraction de flux</li> <li>35.1.2 Cha\u00eenage des flux et pattern D\u00e9corateur</li> <li>35.1.3 E/S bloquantes: ce que cela signifie</li> <li>35.1.4 Gestion des ressources: close(), flush() et pourquoi ils existent</li> <li>35.1.5 finalize(): pourquoi il existe et pourquoi il \u00e9choue</li> <li>35.1.6 available(): objectif et abus</li> <li>35.1.7 mark() et reset(): backtracking contr\u00f4l\u00e9</li> <li>35.1.8 Reader, Writer et encodage des caract\u00e8res</li> <li>35.1.9 File vs FileDescriptor</li> </ul> </li> <li>35.2 java.nio \u2014 Buffer, Channel et E/S non bloquantes<ul> <li>35.2.1 Des flux aux buffers: un changement conceptuel</li> <li>35.2.2 Buffer: objectif et structure</li> <li>35.2.3 Cycle de vie du buffer: Write \u2192 Flip \u2192 Read</li> <li>35.2.4 clear() vs compact()</li> <li>35.2.5 Heap buffers vs Direct buffers</li> <li>35.2.6 Channel: ce que c\u2019est</li> <li>35.2.7 Channel bloquants vs non bloquants</li> <li>35.2.8 Scatter/Gather E/S</li> <li>35.2.9 Selector: multiplexage de lE/S non bloquante</li> <li>35.2.10 Quand utiliser java.nio</li> </ul> </li> <li>35.3 java.nio.file (NIO.2) \u2014 Op\u00e9rations sur fichiers et r\u00e9pertoires (Legacy vs Moderne)<ul> <li>35.3.1 V\u00e9rifications d\u2019existence et d\u2019accessibilit\u00e9</li> <li>35.3.2 Cr\u00e9ation de fichiers et de r\u00e9pertoires</li> <li>35.3.3 Suppression de fichiers et de r\u00e9pertoires</li> <li>35.3.4 Copie de fichiers et de r\u00e9pertoires</li> <li>35.3.5 D\u00e9placement et renommage</li> <li>35.3.6 Lecture et \u00e9criture de texte et d\u2019octets (am\u00e9liorations de Files)</li> <li>35.3.7 newInputStream/newOutputStream et newBufferedReader/newBufferedWriter</li> <li>35.3.8 Listing de r\u00e9pertoires et travers\u00e9e d\u2019arbres</li> <li>35.3.9 Recherche et filtre</li> <li>35.3.10 Attributs: lecture, \u00e9criture et view</li> <li>35.3.11 Liens symboliques et follow des liens</li> <li>35.3.12 Synth\u00e8se: pourquoi Files est une am\u00e9lioration</li> </ul> </li> <li>35.4 S\u00e9rialisation \u2014 Object stream, compatibilit\u00e9 et pi\u00e8ges<ul> <li>35.4.1 Ce que fait la s\u00e9rialisation (et ce qu\u2019elle ne fait pas)</li> <li>35.4.2 Les deux principales marker interface</li> <li>35.4.3 Exemple de base: \u00e9crire et lire un objet</li> <li>35.4.4 Graphes d\u2019objets, r\u00e9f\u00e9rences et identit\u00e9</li> <li>35.4.5 serialVersionUID: la cl\u00e9 de versioning</li> <li>35.4.6 Champs transient et static</li> <li>35.4.7 Champs non s\u00e9rialisables et NotSerializableException</li> <li>35.4.8 Constructeurs et s\u00e9rialisation</li> <li>35.4.9 Hook de s\u00e9rialisation custom: writeObject et readObject</li> <li>35.4.10 Exemple d\u2019usage: restaurer un champ d\u00e9riv\u00e9 transient</li> <li>35.4.11 Externalizable: contr\u00f4le total (et responsabilit\u00e9 totale)</li> <li>35.4.12 Consid\u00e9rations de s\u00e9curit\u00e9 sur readObject()</li> <li>35.4.13 Pi\u00e8ges communs et conseils pratiques</li> <li>35.4.14 Quand utiliser (ou \u00e9viter) la s\u00e9rialisation Java</li> </ul> </li> </ul>"},{"location":"fr/module-08/io-streams-api/#351-legacy-javaio-conception-comportement-et-subtilites","title":"35.1 Legacy java.io \u2014 Conception, comportement et subtilit\u00e9s","text":"<p>L\u2019API legacy <code>java.io</code> est l\u2019abstraction E/S originale introduite dans Java 1.0.</p> <p>Elle est orient\u00e9e flux, bloquante, et mapp\u00e9e \u00e9troitement sur les concepts E/S du syst\u00e8me d\u2019exploitation.</p> <p>M\u00eame si des API plus r\u00e9centes existent, <code>java.io</code> reste fondamentale: beaucoup d\u2019API de niveau sup\u00e9rieur s\u2019appuient dessus, et elle est encore tr\u00e8s utilis\u00e9e.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#3511-labstraction-de-flux","title":"35.1.1 L\u2019abstraction de flux","text":"<p>Un <code>stream</code> repr\u00e9sente un flux continu de donn\u00e9es entre une source et une destination.</p> <p>Dans <code>java.io</code>, les flux sont unidirectionnels: ils sont soit d\u2019entr\u00e9e soit de sortie.</p> Flux Direction Unit\u00e9 de donn\u00e9es Cat\u00e9gorie <code>InputStream</code> Entr\u00e9e Octets (8-bit) Flux d\u2019octets <code>OutputStream</code> Sortie Octets (8-bit) Flux d\u2019octets <code>Reader</code> Entr\u00e9e Caract\u00e8res Flux de caract\u00e8res <code>Writer</code> Sortie Caract\u00e8res Flux de caract\u00e8res <p>Les <code>stream</code> masquent l\u2019origine concr\u00e8te des donn\u00e9es (fichier, r\u00e9seau, m\u00e9moire) et exposent une interface uniforme de lecture/\u00e9criture.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#3512-chainage-des-flux-et-pattern-decorateur","title":"35.1.2 Cha\u00eenage des flux et pattern D\u00e9corateur","text":"<p>La plupart des flux java.io sont con\u00e7us pour \u00eatre combin\u00e9s.</p> <p>Chaque wrapper ajoute un comportement sans changer la source de donn\u00e9es sous-jacente.</p> <pre><code>InputStream in =\n    new BufferedInputStream(\n        new FileInputStream(\"data.bin\"));\n</code></pre> <p>Dans cet exemple: - <code>FileInputStream</code> effectue l\u2019acc\u00e8s r\u00e9el au fichier - <code>BufferedInputStream</code> ajoute un buffer en m\u00e9moire</p> <p>Note</p> <p>Cette conception est connue comme Decorator Pattern.</p> <p>Elle permet de stratifier des fonctionnalit\u00e9s de mani\u00e8re dynamique.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#3513-es-bloquantes-ce-que-cela-signifie","title":"35.1.3 E/S bloquantes: ce que cela signifie","text":"<p>Tous les flux legacy <code>java.io</code> sont bloquants.</p> <p>Cela signifie qu\u2019un thread qui effectue des E/S peut \u00eatre suspendu par le syst\u00e8me d\u2019exploitation.</p> <p>Par exemple, quand tu appelles <code>read()</code>: - si des donn\u00e9es sont disponibles, elles sont retourn\u00e9es tout de suite - s\u2019il n\u2019y a pas de donn\u00e9es, le thread attend - si on atteint la fin du flux, -1 est retourn\u00e9</p> <p>Note</p> <p>Le comportement bloquant simplifie la programmation, mais limite la scalabilit\u00e9.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#3514-gestion-des-ressources-close-flush-et-pourquoi-ils-existent","title":"35.1.4 Gestion des ressources: <code>close()</code>, <code>flush()</code> et pourquoi ils existent","text":"<p>Les flux encapsulent souvent des ressources natives du syst\u00e8me d\u2019exploitation comme <code>file descriptor</code> ou des handles de socket.</p> <p>Ces ressources sont limit\u00e9es et doivent \u00eatre lib\u00e9r\u00e9es explicitement.</p> M\u00e9thode Objectif <code>flush()</code> \u00c9crit les donn\u00e9es bufferis\u00e9es vers la destination <code>close()</code> Effectue flush et lib\u00e8re la ressource <pre><code>try (OutputStream out = new FileOutputStream(\"file.bin\")) {\n    out.write(42);\n} // close() appel\u00e9 automatiquement\n</code></pre> <p>Note</p> <p>Ne pas fermer les flux peut causer une perte de donn\u00e9es ou un \u00e9puisement des ressources.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#3515-finalize-pourquoi-il-existe-et-pourquoi-il-echoue","title":"35.1.5 <code>finalize()</code>: pourquoi il existe et pourquoi il \u00e9choue","text":"<p>Les premi\u00e8res versions de Java ont tent\u00e9 d\u2019automatiser le nettoyage des ressources en utilisant la finalisation.</p> <p>La m\u00e9thode <code>finalize()</code> \u00e9tait appel\u00e9e par le garbage collector avant de r\u00e9cup\u00e9rer la m\u00e9moire.</p> <p>Cependant, les temps du GC sont impr\u00e9visibles.</p> Aspect finalize() Temps d\u2019ex\u00e9cution Non sp\u00e9cifi\u00e9 Fiabilit\u00e9 Faible \u00c9tat actuel D\u00e9pr\u00e9ci\u00e9 <p>Note</p> <p><code>finalize()</code> ne doit jamais \u00eatre utilis\u00e9 pour le nettoyage E/S; il est d\u00e9pr\u00e9ci\u00e9 et non s\u00fbr.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#3516-available-objectif-et-abus","title":"35.1.6 <code>available()</code>: objectif et abus","text":"<p><code>available()</code> estime combien d\u2019octets peuvent \u00eatre lus sans bloquer.</p> <p>Il n\u2019indique pas la quantit\u00e9 totale de donn\u00e9es restantes.</p> <p>Cas d\u2019usage typiques: - \u00e9viter des blocages en UI ou parsing de protocoles - dimensionner des buffers temporaires</p> <pre><code>if (in.available() &gt; 0) {\n    in.read(buffer);\n}\n</code></pre> <p>Note</p> <p><code>available()</code> ne doit pas \u00eatre utilis\u00e9 pour d\u00e9tecter EOF. Seul <code>read()</code>, qui retourne -1, signale la fin du flux.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#3517-mark-et-reset-backtracking-controle","title":"35.1.7 <code>mark()</code> et <code>reset()</code>: backtracking contr\u00f4l\u00e9","text":"<p>Certains flux d\u2019entr\u00e9e permettent de marquer une position et d\u2019y revenir ensuite.</p> <pre><code>BufferedInputStream in = new BufferedInputStream(...);\nin.mark(1024);\n// read ahead\nin.reset();\n</code></pre> Flux markSupported() <code>FileInputStream</code> Non <code>BufferedInputStream</code> Oui <code>ByteArrayInputStream</code> Oui <p></p>"},{"location":"fr/module-08/io-streams-api/#3518-reader-writer-et-encodage-des-caracteres","title":"35.1.8 Reader, Writer et encodage des caract\u00e8res","text":"<p><code>Reader</code> et <code>Writer</code> op\u00e8rent sur des <code>caract\u00e8res</code>, pas sur des octets.</p> <p>Cela requiert un <code>encodage des caract\u00e8res</code> (charset).</p> <p>Si tu ne sp\u00e9cifies pas un charset, celui par d\u00e9faut de la plateforme est utilis\u00e9.</p> <pre><code>new FileReader(\"file.txt\"); // encodage par d\u00e9faut de la plateforme\n</code></pre> <p>Note</p> <p>S\u2019appuyer sur le charset par d\u00e9faut m\u00e8ne \u00e0 des bugs de non-portabilit\u00e9.</p> <p>Sp\u00e9cifie toujours un charset explicitement.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#3519-file-vs-filedescriptor","title":"35.1.9 File vs FileDescriptor","text":"<p><code>File</code> repr\u00e9sente un <code>chemin</code> dans le filesystem.</p> <p>Il ne repr\u00e9sente pas une ressource ouverte.</p> <p><code>FileDescriptor</code> repr\u00e9sente un handle natif du SE vers un fichier ou un flux ouvert.</p> Classe Repr\u00e9sente Poss\u00e8de handle OS? <code>File</code> Chemin filesystem Non <code>FileDescriptor</code> Handle fichier natif OS Oui <p>Note</p> <p>Plusieurs flux peuvent partager le m\u00eame FileDescriptor.</p> <p>En en fermant un, on ferme la ressource sous-jacente pour tous.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#352-javanio-buffer-channel-et-es-non-bloquantes","title":"35.2 <code>java.nio</code> \u2014 Buffer, Channel et E/S non bloquantes","text":"<p>L\u2019API <code>java.nio</code> (New I/O) a \u00e9t\u00e9 introduite pour r\u00e9soudre les limites de <code>java.io</code>.</p> <p>Elle offre un mod\u00e8le E/S de plus bas niveau et plus explicite, qui mappe bien sur les syst\u00e8mes d\u2019exploitation modernes.</p> <p>\u00c0 la base, <code>java.nio</code> tourne autour de trois concepts: - <code>Buffer</code> \u2014 conteneurs de m\u00e9moire explicites - <code>Channel</code> \u2014 connexions de donn\u00e9es bidirectionnelles - <code>Selector</code> \u2014 multiplexage de lE/S non bloquante</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#3521-des-flux-aux-buffers-un-changement-conceptuel","title":"35.2.1 Des flux aux buffers: un changement conceptuel","text":"<p>Les flux legacy masquent la gestion de la m\u00e9moire au programmeur.</p> <p>Au contraire, <code>NIO</code> rend la m\u00e9moire explicite via les buffers.</p> Aspect java.io java.nio Mod\u00e8le de donn\u00e9es Bas\u00e9 sur flux (push) Bas\u00e9 sur buffer (pull depuis les buffers) M\u00e9moire Cach\u00e9e dans les flux Explicite via buffer Contr\u00f4le Simple, peu granulaire Plus granulaire et configurable <p>Avec NIO, l\u2019application contr\u00f4le quand les donn\u00e9es sont lues en m\u00e9moire et comment elles sont consomm\u00e9es.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#3522-buffer-objectif-et-structure","title":"35.2.2 Buffer: objectif et structure","text":"<p>Un <code>buffer</code> est un conteneur typ\u00e9 de taille fixe.</p> <p>Toutes les op\u00e9rations E/S NIO lisent depuis ou \u00e9crivent sur des buffers.</p> <p>Le buffer le plus commun est <code>ByteBuffer</code>.</p> <pre><code>ByteBuffer buffer = ByteBuffer.allocate(1024);\n</code></pre> Propri\u00e9t\u00e9 Signification <code>capacity</code> Taille totale du buffer <code>position</code> Index courant de lecture/\u00e9criture <code>limit</code> Limite des donn\u00e9es lisibles ou inscriptibles <p></p>"},{"location":"fr/module-08/io-streams-api/#3523-cycle-de-vie-du-buffer-write-flip-read","title":"35.2.3 Cycle de vie du buffer: Write \u2192 Flip \u2192 Read","text":"<p>Les <code>buffer</code> ont un cycle d\u2019usage rigoureux.</p> <p>Le comprendre mal est une source commune de bugs.</p> <p>S\u00e9quence typique: - \u00e9cris les donn\u00e9es dans le buffer - <code>flip()</code> pour passer en mode lecture - lis les donn\u00e9es du buffer - <code>clear()</code> ou <code>compact()</code> pour le r\u00e9utiliser</p> <pre><code>ByteBuffer buffer = ByteBuffer.allocate(16);\n\nbuffer.put((byte) 1);\nbuffer.put((byte) 2);\n\nbuffer.flip(); // passe en mode lecture\n\nwhile (buffer.hasRemaining()) {\n    byte b = buffer.get();\n}\n\nbuffer.clear(); // pr\u00eat \u00e0 \u00e9crire de nouveau\n</code></pre> <p>Note</p> <p><code>flip()</code> n\u2019efface pas les donn\u00e9es: il r\u00e8gle position et limit.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#3524-clear-vs-compact","title":"35.2.4 <code>clear()</code> vs <code>compact()</code>","text":"<p>Apr\u00e8s la lecture, un buffer peut \u00eatre r\u00e9utilis\u00e9 de deux mani\u00e8res.</p> M\u00e9thode Comportement <code>clear()</code> Jette les donn\u00e9es non lues <code>compact()</code> Pr\u00e9serve les donn\u00e9es non lues <p><code>compact()</code> est utile dans les protocoles streaming o\u00f9 dans le buffer peuvent rester des messages partiels.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#3525-heap-buffers-vs-direct-buffers","title":"35.2.5 Heap buffers vs Direct buffers","text":"<p>Les buffers peuvent \u00eatre allou\u00e9s dans deux r\u00e9gions de m\u00e9moire diff\u00e9rentes.</p> <pre><code>ByteBuffer heap = ByteBuffer.allocate(1024);\nByteBuffer direct = ByteBuffer.allocateDirect(1024);\n</code></pre> Type Position m\u00e9moire Caract\u00e9ristiques <code>Heap</code> Heap JVM GC, \u00e9conomique \u00e0 allouer <code>Direct</code> M\u00e9moire native Meilleur throughput E/S, plus co\u00fbteux \u00e0 allouer <p>Note</p> <p>Les direct buffer r\u00e9duisent les copies entre JVM et OS, mais doivent \u00eatre utilis\u00e9s avec attention pour \u00e9viter une pression m\u00e9moire.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#3526-channel-ce-que-cest","title":"35.2.6 Channel: ce que c\u2019est","text":"<p>Un <code>channel</code> repr\u00e9sente une connexion vers une entit\u00e9 E/S comme fichier, socket ou device.</p> <p>\u00c0 la diff\u00e9rence des flux, les channel sont bidirectionnels.</p> Channel Type Objectif <code>FileChannel</code> Fichier E/S sur fichiers <code>SocketChannel</code> TCP Networking stream (TCP) <code>DatagramChannel</code> UDP Networking datagram (UDP) <pre><code>try (FileChannel channel =\n    FileChannel.open(Path.of(\"file.txt\"))) {\n\n    ByteBuffer buffer = ByteBuffer.allocate(128);\n    channel.read(buffer);\n}\n</code></pre> <p></p>"},{"location":"fr/module-08/io-streams-api/#3527-channel-bloquants-vs-non-bloquants","title":"35.2.7 Channel bloquants vs non bloquants","text":"<p>Les channel peuvent op\u00e9rer en mode bloquant ou non bloquant.</p> <pre><code>SocketChannel channel = SocketChannel.open();\nchannel.configureBlocking(false);\n</code></pre> <p>En mode non bloquant: - <code>read()</code> peut retourner tout de suite avec 0 octets - <code>write()</code> peut \u00e9crire seulement une partie des donn\u00e9es</p> <p>Note</p> <p>L\u2019E/S non bloquante d\u00e9place la complexit\u00e9 du SE vers l\u2019application.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#3528-scattergather-es","title":"35.2.8 Scatter/Gather E/S","text":"<p>NIO supporte lecture/\u00e9criture depuis/vers plusieurs buffers avec une seule op\u00e9ration.</p> <pre><code>ByteBuffer header = ByteBuffer.allocate(128);\nByteBuffer body = ByteBuffer.allocate(1024);\n\nByteBuffer[] buffers = { header, body };\nchannel.read(buffers);\n</code></pre> <p>Utile pour des protocoles structur\u00e9s (header + payload).</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#3529-selector-multiplexage-de-les-non-bloquante","title":"35.2.9 Selector: multiplexage de lE/S non bloquante","text":"<p>Les <code>Selector</code> permettent \u00e0 un seul thread de monitorer plusieurs channel.</p> <p>Ils sont la base des serveurs scalables.</p> Composant R\u00f4le <code>Selector</code> Monitore plusieurs channel <code>SelectionKey</code> Repr\u00e9sente enregistrement et \u00e9tat du channel <code>Interest set</code> Op\u00e9rations observ\u00e9es (read, write, etc.) <p></p>"},{"location":"fr/module-08/io-streams-api/#35210-quand-utiliser-javanio","title":"35.2.10 Quand utiliser <code>java.nio</code>","text":"<p><code>NIO</code> est adapt\u00e9 quand: - il faut une haute concurrence - il te faut un contr\u00f4le fin sur la m\u00e9moire - tu impl\u00e9mentes des protocoles ou des serveurs</p> <p>Pour des op\u00e9rations simples sur fichiers, souvent <code>java.nio.file.Files</code> suffit.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#353-javaniofile-nio2-operations-sur-fichiers-et-repertoires-legacy-vs-moderne","title":"35.3 <code>java.nio.file</code> (NIO.2) \u2014 Op\u00e9rations sur fichiers et r\u00e9pertoires (Legacy vs Moderne)","text":"<p>Cette section se concentre sur les op\u00e9rations pratiques sur fichiers et r\u00e9pertoires.</p> <p>Nous comparons les approches legacy (java.io.File + flux java.io) avec celles modernes NIO.2 (Path + Files).</p> <p>L\u2019objectif n\u2019est pas seulement de conna\u00eetre les noms des m\u00e9thodes, mais de comprendre: - ce que fait vraiment chaque m\u00e9thode - ce qu\u2019elle retourne et comment elle signale les erreurs - quels pi\u00e8ges existent (race condition, liens, permissions, portabilit\u00e9) - quand une m\u00e9thode de Files est une am\u00e9lioration s\u00fbre par rapport \u00e0 l\u2019ancienne approche</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#3531-verifications-dexistence-et-daccessibilite","title":"35.3.1 V\u00e9rifications d\u2019existence et d\u2019accessibilit\u00e9","text":"<p>Une op\u00e9ration tr\u00e8s commune est de v\u00e9rifier si un fichier existe et s\u2019il est accessible (lecture, \u00e9criture, ex\u00e9cution).</p> <p>\u00c0 la fois l\u2019API legacy (java.io.File) et NIO.2 (java.nio.file.Files) fournissent des m\u00e9thodes pour ces v\u00e9rifications.</p> <p>Il est toutefois important de comprendre que ces v\u00e9rifications sont volontairement impr\u00e9cises dans les deux API.</p> <p>Ce sont des indices best-effort, pas des garanties fiables.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#35311-api-legacy-file","title":"35.3.1.1 API legacy (File)","text":"<pre><code>File f = new File(\"data.txt\");\n\nboolean exists = f.exists();\nboolean canRead = f.canRead();\nboolean canWrite = f.canWrite();\nboolean canExec = f.canExecute();\n</code></pre> <p>Ces m\u00e9thodes retournent boolean et n\u2019expliquent pas pourquoi une op\u00e9ration a \u00e9chou\u00e9.</p> <p>Par exemple, exists() peut retourner false quand: - le fichier n\u2019existe vraiment pas - le fichier existe mais l\u2019acc\u00e8s est refus\u00e9 - un lien symbolique est cass\u00e9 - une erreur E/S se produit</p> <p>L\u2019API ne permet pas de distinguer les cas.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#35312-api-moderne-files","title":"35.3.1.2 API moderne (Files)","text":"<pre><code>Path p = Path.of(\"data.txt\");\n\nboolean exists = Files.exists(p);\nboolean readable = Files.isReadable(p);\nboolean writable = Files.isWritable(p);\nboolean executable = Files.isExecutable(p);\n</code></pre> <p>Ces m\u00e9thodes aussi retournent boolean et masquent la raison de l\u2019\u00e9ventuel insucc\u00e8s.</p> <p>NIO.2 ajoute une m\u00e9thode explicite pour exprimer l\u2019incertitude:</p> <pre><code>boolean notExists = Files.notExists(p);\n</code></pre> <p>Note</p> <p><code>exists()</code> et <code>notExists()</code> peuvent \u00eatre tous deux <code>false</code> quand l\u2019\u00e9tat n\u2019est pas d\u00e9terminable (par exemple \u00e0 cause de permissions).</p> <p>Cela ne rend pas la v\u00e9rification plus pr\u00e9cise: cela rend seulement l\u2019incertitude explicite.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#353121-conscience-des-liens-symboliques-amelioration-reelle","title":"35.3.1.2.1 Conscience des liens symboliques (am\u00e9lioration r\u00e9elle)","text":"<p>Une vraie am\u00e9lioration de NIO.2 est le contr\u00f4le sur comment g\u00e9rer les liens symboliques:</p> <pre><code>Files.exists(p, LinkOption.NOFOLLOW_LINKS);\n</code></pre> <p>La classe File legacy ne distingue pas de mani\u00e8re fiable: - fichier manquant - lien symbolique cass\u00e9 - lien vers target inaccessible</p> <p>NIO.2 permet des check link-aware et une inspection explicite des liens.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#353122-pattern-dusage-correct-critique","title":"35.3.1.2.2 Pattern d\u2019usage correct (critique)","text":"<p>Aucune des deux API ne donne de diagnostics fiables via boolean \u201cde check\u201d.</p> <p>Le code NIO.2 correct ne \u201ccontr\u00f4le pas avant\u201d.</p> <p>\u00c0 la place il tente l\u2019op\u00e9ration et g\u00e8re l\u2019exception:</p> <pre><code>try {\n    Files.delete(p);\n} catch (NoSuchFileException e) {\n    // le fichier n\u2019existe vraiment pas\n} catch (AccessDeniedException e) {\n    // probl\u00e8me de permissions\n} catch (IOException e) {\n    // autre erreur E/S\n}\n</code></pre> <p>Note</p> <p>Le vrai avantage de NIO.2 est le diagnostic via exceptions pendant les actions, pas des check d\u2019existence plus \u201cpr\u00e9cis\u201d.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#353123-tableau-recapitulatif","title":"35.3.1.2.3 Tableau r\u00e9capitulatif","text":"Objectif Legacy (File) Moderne (Files) D\u00e9tail cl\u00e9 V\u00e9rifier existence <code>exists()</code> <code>exists() / notExists()</code> notExists() peut \u00eatre false si l\u2019\u00e9tat n\u2019est pas d\u00e9terminable V\u00e9rifier read/write <code>canRead() / canWrite()</code> <code>isReadable() / isWritable()</code> Files peut utiliser LinkOption.NOFOLLOW_LINKS quand support\u00e9 D\u00e9tails erreur Non disponibles Disponibles via exceptions sur les actions Les check boolean n\u2019expliquent pas le motif de l\u2019\u00e9chec"},{"location":"fr/module-08/io-streams-api/#3532-creation-de-fichiers-et-de-repertoires","title":"35.3.2 Cr\u00e9ation de fichiers et de r\u00e9pertoires","text":"<p>La cr\u00e9ation est une grande faiblesse du File legacy.</p> <p>Dans le legacy on utilise souvent createNewFile() et mkdir/mkdirs(), qui retournent boolean et donnent peu d\u2019infos diagnostiques.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#35321-api-legacy-file","title":"35.3.2.1 API legacy (File)","text":"<pre><code>File f = new File(\"a.txt\");\nboolean created = f.createNewFile(); // peut lancer IOException\n\nFile dir = new File(\"dir\");\nboolean ok1 = dir.mkdir();\nboolean ok2 = new File(\"a/b/c\").mkdirs();\n</code></pre> <p><code>mkdir()</code> cr\u00e9e un seul niveau; <code>mkdirs()</code> cr\u00e9e aussi les parents.</p> <p>Les deux retournent false en cas d\u2019\u00e9chec mais sans dire pourquoi.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#35322-api-moderne-files","title":"35.3.2.2 API moderne (Files)","text":"<pre><code>Path file = Path.of(\"a.txt\");\nFiles.createFile(file);\n\nPath dir1 = Path.of(\"dir\");\nFiles.createDirectory(dir1);\n\nPath dirDeep = Path.of(\"a/b/c\");\nFiles.createDirectories(dirDeep);\n</code></pre> <p>Note</p> <p><code>Files.createFile</code> lance <code>FileAlreadyExistsException</code> si le fichier existe.</p> <p>Souvent il est pr\u00e9f\u00e9rable aux check boolean parce qu\u2019il est race-safe.</p> Objectif Legacy (File) Moderne (Files) D\u00e9tail cl\u00e9 Cr\u00e9er fichier <code>createNewFile()</code> <code>createFile()</code> NIO lance FileAlreadyExistsException s\u2019il existe Cr\u00e9er r\u00e9pertoire <code>mkdir()</code> <code>createDirectory()</code> NIO lance des exceptions d\u00e9taill\u00e9es Cr\u00e9er parents <code>mkdirs()</code> <code>createDirectories()</code> Atomicit\u00e9 non garantie pour r\u00e9pertoires profonds <p></p>"},{"location":"fr/module-08/io-streams-api/#3533-suppression-de-fichiers-et-de-repertoires","title":"35.3.3 Suppression de fichiers et de r\u00e9pertoires","text":"<p>La s\u00e9mantique de delete diff\u00e8re beaucoup entre legacy et NIO.2.</p> <p>Le legacy <code>delete()</code> retourne boolean; NIO.2 offre des m\u00e9thodes qui lancent des exceptions significatives.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#35331-api-legacy-file","title":"35.3.3.1 API legacy (File)","text":"<pre><code>File f = new File(\"a.txt\");\nboolean deleted = f.delete();\n</code></pre> <p>S\u2019il \u00e9choue (permissions, fichier manquant, r\u00e9pertoire non vide), <code>delete()</code> retourne souvent false sans d\u00e9tails.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#35332-api-moderne-files","title":"35.3.3.2 API moderne (Files)","text":"<pre><code>Files.delete(Path.of(\"a.txt\"));\n</code></pre> <p>Pour \u201csupprime si pr\u00e9sent\u201d, utilise <code>deleteIfExists()</code>.</p> <pre><code>Files.deleteIfExists(Path.of(\"a.txt\"));\n</code></pre> Objectif Legacy (File) Moderne (Files) D\u00e9tail cl\u00e9 Supprimer <code>delete()</code> <code>delete()</code> <code>Files.delete()</code> lance exception avec la cause de l\u2019\u00e9chec Supprimer si existe <code>exists() + delete()</code> <code>deleteIfExists()</code> \u00c9vite race TOCTOU (check-then-act) <p></p>"},{"location":"fr/module-08/io-streams-api/#3534-copie-de-fichiers-et-de-repertoires","title":"35.3.4 Copie de fichiers et de r\u00e9pertoires","text":"<p>Dans le legacy, copier requiert typiquement lecture/\u00e9criture manuelle via flux.</p> <p>NIO.2 fournit des op\u00e9rations de copie de haut niveau avec options.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#35341-technique-legacy-flux-manuels","title":"35.3.4.1 Technique legacy (flux manuels)","text":"<pre><code>try (InputStream in = new FileInputStream(\"src.bin\"); OutputStream out = new FileOutputStream(\"dst.bin\")) {\n\n    byte[] buf = new byte[8192];\n    int n;\n    while ((n = in.read(buf)) != -1) {\n        out.write(buf, 0, n);\n    }\n}\n</code></pre> <p>C\u2019est verbeux et c\u2019est facile de se tromper (absence de buffering, fermeture, etc.).</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#35342-api-moderne-filescopy","title":"35.3.4.2 API moderne (Files.copy)","text":"<pre><code>Files.copy(Path.of(\"src.bin\"), Path.of(\"dst.bin\"));\n</code></pre> <p>Le comportement est contr\u00f4lable avec options.</p> <pre><code>Files.copy(\n    Path.of(\"src.bin\"),\n    Path.of(\"dst.bin\"),\n    StandardCopyOption.REPLACE_EXISTING,\n    StandardCopyOption.COPY_ATTRIBUTES\n);\n</code></pre> <p>Note</p> <p><code>Files.copy</code> lance FileAlreadyExistsException par d\u00e9faut.</p> <p>Utilise <code>REPLACE_EXISTING</code> quand l\u2019overwrite est intentionnel.</p> Objectif Approche legacy Moderne (Files) D\u00e9tail cl\u00e9 Copier fichier Boucle flux manuelle <code>Files.copy(Path, Path, \u2026)</code> Options: <code>REPLACE_EXISTING</code>, <code>COPY_ATTRIBUTES</code> Copier flux InputStream/OutputStream <code>Files.copy(InputStream, Path, \u2026)</code> Utile pour upload/download et piping Copier r\u00e9pertoire R\u00e9cursion manuelle <code>walkFileTree + Files.copy</code> Aucun one-liner pour copy compl\u00e8te d\u2019arbre <p></p>"},{"location":"fr/module-08/io-streams-api/#3535-deplacement-et-renommage","title":"35.3.5 D\u00e9placement et renommage","text":"<p>Le renommage legacy utilise souvent <code>File.renameTo()</code>, notoirement peu fiable et d\u00e9pendant de la plateforme.</p> <p>NIO.2 fournit <code>Files.move()</code> avec s\u00e9mantique pr\u00e9cise et options.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#35351-api-legacy","title":"35.3.5.1 API legacy","text":"<pre><code>boolean ok = new File(\"a.txt\").renameTo(new File(\"b.txt\"));\n</code></pre> <p><code>renameTo()</code> retourne false sans explication, et peut \u00e9chouer entre filesystem.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#35352-api-moderne","title":"35.3.5.2 API moderne","text":"<pre><code>Files.move(Path.of(\"a.txt\"), Path.of(\"b.txt\"));\n</code></pre> <p>Les options rendent le comportement explicite.</p> <pre><code>Files.move(\n    Path.of(\"a.txt\"),\n    Path.of(\"b.txt\"),\n    StandardCopyOption.REPLACE_EXISTING,\n    StandardCopyOption.ATOMIC_MOVE\n);\n</code></pre> <p>Note</p> <p>ATOMIC_MOVE est garanti seulement si le d\u00e9placement arrive dans le m\u00eame filesystem. Sinon une exception est lanc\u00e9e.</p> Objectif Legacy (File) Moderne (Files) D\u00e9tail cl\u00e9 Renommage / move <code>renameTo()</code> <code>move()</code> Exceptions + options explicites Move atomique Non support\u00e9 <code>move(\u2026, ATOMIC_MOVE)</code> Garanti seulement m\u00eame filesystem Replace existing Non explicite <code>REPLACE_EXISTING</code> Intention d\u2019overwrite explicite <p></p>"},{"location":"fr/module-08/io-streams-api/#3536-lecture-et-ecriture-de-texte-et-doctets-ameliorations-de-files","title":"35.3.6 Lecture et \u00e9criture de texte et d\u2019octets (am\u00e9liorations de Files)","text":"<p>Une grande am\u00e9lioration de NIO.2 est la classe utilitaire <code>Files</code>, avec des m\u00e9thodes de haut niveau pour lecture/\u00e9criture communes.</p> <p>Elle r\u00e9duit le boilerplate et am\u00e9liore la justesse.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#35361-lectureecriture-texte-legacy","title":"35.3.6.1 Lecture/\u00e9criture texte legacy","text":"<pre><code>try (BufferedReader r = new BufferedReader(new FileReader(\"file.txt\"))) {\n    String line = r.readLine();\n}\n</code></pre> <pre><code>try (BufferedWriter w = new BufferedWriter(new FileWriter(\"file.txt\"))) {\n    w.write(\"hello\");\n}\n</code></pre> <p>Ces classes legacy utilisent souvent le charset par d\u00e9faut si on n\u2019utilise pas un bridge explicite.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#35362-lectureecriture-texte-moderne","title":"35.3.6.2 Lecture/\u00e9criture texte moderne","text":"<pre><code>List&lt;String&gt; lines = Files.readAllLines(Path.of(\"file.txt\"), StandardCharsets.UTF_8);\nFiles.write(Path.of(\"file.txt\"), lines, StandardCharsets.UTF_8);\n\nFiles.lines(Path.of(\"file.txt\")).forEach(System.out::println);\n\nString string = Files.readString(Path.of(\"file.txt\"));\nFiles.writeString(Path.of(\"file.txt\"), string);\n</code></pre>"},{"location":"fr/module-08/io-streams-api/#35363-lectureecriture-binaire-moderne","title":"35.3.6.3 Lecture/\u00e9criture binaire moderne","text":"<pre><code>byte[] data = Files.readAllBytes(Path.of(\"data.bin\"));\nFiles.write(Path.of(\"out.bin\"), data);\n</code></pre> <p>Important</p> <p><code>readAllBytes</code> et <code>readAllLines</code> chargent tout en m\u00e9moire.</p> <p>Utilise <code>Files.lines()</code> (lazy) ou, pour de gros fichiers, pr\u00e9f\u00e8re des API streaming comme newBufferedReader/newInputStream.</p> T\u00e2che M\u00e9thode legacy M\u00e9thode NIO.2 Files D\u00e9tail cl\u00e9 Lire tous les octets Boucle InputStream manuelle <code>readAllBytes()</code> Charge tout en m\u00e9moire Lire toutes les lignes Boucle BufferedReader <code>readAllLines()</code> Charge tout en m\u00e9moire Lire lignes lazy Boucle BufferedReader <code>lines()</code> Lazy, stream \u00e0 fermer \u00c9crire octets OutputStream <code>write(Path, byte[])</code> Concis \u00c9crire lignes Boucle BufferedWriter <code>write(Path, Iterable, \u2026)</code> Charset sp\u00e9cifiable Append texte FileWriter(true) <code>write(\u2026, APPEND)</code> Options explicites <p></p>"},{"location":"fr/module-08/io-streams-api/#3537-newinputstreamnewoutputstream-et-newbufferedreadernewbufferedwriter","title":"35.3.7 newInputStream/newOutputStream et newBufferedReader/newBufferedWriter","text":"<p>Ces <code>factory method</code> cr\u00e9ent des flux/reader \u00e0 partir d\u2019un Path.</p> <p>Ils sont le bridge recommand\u00e9 entre streaming classique et gestion Path NIO.2.</p> <pre><code>try (InputStream in = Files.newInputStream(Path.of(\"a.bin\"))) { }\ntry (OutputStream out = Files.newOutputStream(Path.of(\"b.bin\"))) { }\n</code></pre> <pre><code>try (BufferedReader r = Files.newBufferedReader(Path.of(\"t.txt\"), StandardCharsets.UTF_8)) { }\ntry (BufferedWriter w = Files.newBufferedWriter(Path.of(\"t.txt\"), StandardCharsets.UTF_8)) { }\n</code></pre> <p></p>"},{"location":"fr/module-08/io-streams-api/#3538-listing-de-repertoires-et-traversee-darbres","title":"35.3.8 Listing de r\u00e9pertoires et travers\u00e9e d\u2019arbres","text":"<p>Dans le legacy, le listing de r\u00e9pertoires se base sur <code>File.list()</code> et <code>File.listFiles()</code>.</p> <p>Ces m\u00e9thodes retournent des array et offrent peu de diagnostics.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#35381-listing-legacy","title":"35.3.8.1 Listing legacy","text":"<pre><code>File dir = new File(\".\");\nFile[] children = dir.listFiles();\n</code></pre> <p>NIO.2 offre plus d\u2019approches selon le besoin.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#35382-listing-moderne-directorystream","title":"35.3.8.2 Listing moderne (DirectoryStream)","text":"<pre><code>try (DirectoryStream&lt;Path&gt; ds = Files.newDirectoryStream(Path.of(\".\"))) {\n    for (Path p : ds) {\n        System.out.println(p);\n    }\n}\n</code></pre>"},{"location":"fr/module-08/io-streams-api/#35383-walking-moderne-fileswalk","title":"35.3.8.3 Walking moderne (Files.walk)","text":"<pre><code>Files.walk(Path.of(\".\"))\n    .filter(Files::isRegularFile)\n    .forEach(System.out::println);\n</code></pre> <p>Note</p> <p><code>Files.walk</code> retourne un Stream qui doit \u00eatre ferm\u00e9. Utilise <code>try-with-resources</code>.</p> <pre><code>try (Stream&lt;Path&gt; s = Files.walk(Path.of(\".\"))) {\n    s.forEach(System.out::println);\n}\n</code></pre> <p></p>"},{"location":"fr/module-08/io-streams-api/#35384-traversal-avec-filevisitor","title":"35.3.8.4 Traversal avec FileVisitor","text":"<p>Pour un contr\u00f4le complet (skip subtree, gestion erreurs, follow link), utilise <code>walkFileTree + FileVisitor</code>.</p> <pre><code>Files.walkFileTree(Path.of(\".\"), new SimpleFileVisitor&lt;&gt;() {\n    @Override\n    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {\n        System.out.println(file);\n        return FileVisitResult.CONTINUE;\n    }\n});\n</code></pre> Objectif Legacy Moderne D\u00e9tail cl\u00e9 Listing dir <code>list()</code> / <code>listFiles()</code> <code>newDirectoryStream()</code> Lazy, doit \u00eatre ferm\u00e9 Walk tree (simple) R\u00e9cursion manuelle <code>walk()</code> (Stream) Stream doit \u00eatre ferm\u00e9 Walk tree (contr\u00f4le) R\u00e9cursion manuelle <code>walkFileTree()</code> Contr\u00f4le fin et gestion erreurs <p></p>"},{"location":"fr/module-08/io-streams-api/#3539-recherche-et-filtre","title":"35.3.9 Recherche et filtre","text":"<p>La recherche est typiquement <code>traversal + filtre</code>.</p> <p>NIO.2 offre building block: glob pattern, stream, visitor.</p> <pre><code>try (DirectoryStream&lt;Path&gt; ds =\n    Files.newDirectoryStream(Path.of(\".\"), \"*.txt\")) {\n    for (Path p : ds) {\n        System.out.println(p);\n    }\n}\n</code></pre> <pre><code>try (Stream&lt;Path&gt; s = Files.find(Path.of(\".\"), 10,\n    (p, a) -&gt; a.isRegularFile() &amp;&amp; p.toString().endsWith(\".log\"))) {\n    s.forEach(System.out::println);\n}\n</code></pre> <p></p>"},{"location":"fr/module-08/io-streams-api/#35310-attributs-lecture-ecriture-et-view","title":"35.3.10 Attributs: lecture, \u00e9criture et view","text":"<p>Le File legacy expose peu d\u2019attributs (size, lastModified).</p> <p>NIO.2 supporte des metadata riches via attribute view.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#353101-attributs-legacy","title":"35.3.10.1 Attributs legacy","text":"<pre><code>long size = new File(\"a.txt\").length();\nlong lm = new File(\"a.txt\").lastModified();\n</code></pre>"},{"location":"fr/module-08/io-streams-api/#353102-attributs-modernes","title":"35.3.10.2 Attributs modernes","text":"<pre><code>BasicFileAttributes a =\n    Files.readAttributes(Path.of(\"a.txt\"), BasicFileAttributes.class);\n\nlong size = a.size();\nFileTime modified = a.lastModifiedTime();\n</code></pre> <p>Acc\u00e8s via noms string-based:</p> <pre><code>Object v = Files.getAttribute(Path.of(\"a.txt\"), \"basic:size\");\nFiles.setAttribute(Path.of(\"a.txt\"), \"basic:lastModifiedTime\", FileTime.fromMillis(0));\n</code></pre> <p>Note</p> <p>Les attribute view d\u00e9pendent du filesystem.</p> <p>Les attributs non support\u00e9s g\u00e9n\u00e8rent des exceptions.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#35311-liens-symboliques-et-follow-des-liens","title":"35.3.11 Liens symboliques et follow des liens","text":"<p>NIO.2 peut d\u00e9tecter et lire des liens symboliques de mani\u00e8re explicite.</p> <pre><code>Path link = Path.of(\"mylink\");\nboolean isLink = Files.isSymbolicLink(link);\n\nif (isLink) {\n    Path target = Files.readSymbolicLink(link);\n}\n</code></pre> <p>Beaucoup de m\u00e9thodes suivent les liens par d\u00e9faut.</p> <p>Pour l\u2019\u00e9viter, passe <code>LinkOption.NOFOLLOW_LINKS</code> quand support\u00e9.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#35312-synthese-pourquoi-files-est-une-amelioration","title":"35.3.12 Synth\u00e8se: pourquoi Files est une am\u00e9lioration","text":"<p>La classe utilitaire <code>Files</code> am\u00e9liore la programmation filesystem parce que: - r\u00e9duit le boilerplate (copy/move/read/write) - fournit des options explicites (overwrite, atomic move, follow links) - offre des metadata plus riches (attributes/views) - supporte traversal et recherche scalables</p> <p>Les API legacy restent surtout pour compatibilit\u00e9 ou quand requises par des librairies legacy.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#354-serialisation-object-stream-compatibilite-et-pieges","title":"35.4 S\u00e9rialisation \u2014 Object stream, compatibilit\u00e9 et pi\u00e8ges","text":"<p>La s\u00e9rialisation est le processus de convertir un graphe d\u2019objets en un flux d\u2019octets pour le m\u00e9moriser ou le transmettre, et le reconstruire ensuite.</p> <p>En Java, la s\u00e9rialisation classique est impl\u00e9ment\u00e9e par <code>java.io.ObjectOutputStream</code> et <code>java.io.ObjectInputStream</code>.</p> <p>Ce sujet est important parce qu\u2019il combine: - flux E/S et graphes d\u2019objets - versioning et backward compatibility - consid\u00e9rations de s\u00e9curit\u00e9 et pattern d\u2019usage s\u00fbrs - r\u00e8gles du langage (<code>transient</code>, static, <code>serialVersionUID</code>)</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#3541-ce-que-fait-la-serialisation-et-ce-quelle-ne-fait-pas","title":"35.4.1 Ce que fait la s\u00e9rialisation (et ce qu\u2019elle ne fait pas)","text":"<p>Quand un objet est s\u00e9rialis\u00e9, Java \u00e9crit des informations suffisantes pour le reconstruire: - nom de la classe - serialVersionUID - valeurs des champs d\u2019instance s\u00e9rialisables - r\u00e9f\u00e9rences entre objets (identit\u00e9)</p> <p>La s\u00e9rialisation n\u2019inclut pas automatiquement: - champs static (\u00e9tat de classe) - champs transient (exclus explicitement) - objets r\u00e9f\u00e9renc\u00e9s non s\u00e9rialisables (\u00e0 moins de gestion sp\u00e9ciale)</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#3542-les-deux-principales-marker-interface","title":"35.4.2 Les deux principales marker interface","text":"<p>La s\u00e9rialisation Java est activ\u00e9e en impl\u00e9mentant une de ces interfaces.</p> Interface Signification Niveau de contr\u00f4le <code>Serializable</code> Marker opt-in, m\u00e9canisme par d\u00e9faut Moyen (hook possibles) <code>Externalizable</code> Requiert impl\u00e9mentation manuelle read/write Haut (contr\u00f4le total sur le format) <p>Note</p> <p><code>Serializable</code> n\u2019a pas de m\u00e9thodes: c\u2019est une marker interface.</p> <p><code>Externalizable</code> \u00e9tend Serializable et ajoute readExternal/writeExternal.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#3543-exemple-de-base-ecrire-et-lire-un-objet","title":"35.4.3 Exemple de base: \u00e9crire et lire un objet","text":"<p>Pattern minimal utilis\u00e9 en pratique.</p> <pre><code>import java.io.*;\n\nclass Person implements Serializable {\n\n    private String name;\n    private int age;\n\n    Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n}\n\npublic class Demo {\n\n    public static void main(String[] args) throws Exception {\n\n        Person p = new Person(\"Alice\", 30);\n\n        try (ObjectOutputStream out =\n                 new ObjectOutputStream(new FileOutputStream(\"p.bin\"))) {\n            out.writeObject(p);\n        }\n\n        try (ObjectInputStream in =\n                 new ObjectInputStream(new FileInputStream(\"p.bin\"))) {\n            Person copy = (Person) in.readObject();\n        }\n    }\n\n}\n</code></pre> <p>Note</p> <p><code>readObject()</code> retourne Object: un cast est n\u00e9cessaire. <code>readObject()</code> peut lancer ClassNotFoundException.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#3544-graphes-dobjets-references-et-identite","title":"35.4.4 Graphes d\u2019objets, r\u00e9f\u00e9rences et identit\u00e9","text":"<p>La s\u00e9rialisation pr\u00e9serve l\u2019identit\u00e9 des objets \u00e0 l\u2019int\u00e9rieur du m\u00eame flux.</p> <p>Si la m\u00eame r\u00e9f\u00e9rence appara\u00eet plusieurs fois, Java l\u2019\u00e9crit une seule fois puis \u00e9crit une back-reference.</p> <pre><code>Person p = new Person(\"Bob\", 40);\nObject[] arr = { p, p }; // m\u00eame r\u00e9f\u00e9rence deux fois\n\nout.writeObject(arr);\nObject[] restored = (Object[]) in.readObject();\n\n// restored[0] et restored[1] pointent vers le m\u00eame objet\n</code></pre> <p>Note</p> <p>Cela pr\u00e9vient la r\u00e9cursion infinie dans des graphes cycliques.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#3545-serialversionuid-la-cle-de-versioning","title":"35.4.5 <code>serialVersionUID</code>: la cl\u00e9 de versioning","text":"<p><code>serialVersionUID</code> est un identifiant <code>long</code> utilis\u00e9 pour v\u00e9rifier la compatibilit\u00e9 entre flux s\u00e9rialis\u00e9 et d\u00e9finition de la classe.</p> <p>Si l\u2019UID diff\u00e8re, la d\u00e9s\u00e9rialisation \u00e9choue typiquement avec InvalidClassException.</p> <p>Si tu ne d\u00e9clares pas <code>serialVersionUID</code>, la JVM en calcule un depuis la structure de la classe: de petites modifications peuvent le compromettre.</p> <pre><code>class Person implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private String name;\n    private int age;\n}\n</code></pre> Type de modification Impact compatibilit\u00e9 (par d\u00e9faut) Ajouter un champ Souvent compatible (champ nouveau avec d\u00e9faut) Supprimer un champ Souvent compatible (champ manquant ignor\u00e9) Changer type de champ Souvent incompatible Changer nom/paquet Incompatible Changer serialVersionUID Incompatible <p>Note</p> <p>D\u00e9clarer un serialVersionUID stable est la mani\u00e8re standard de contr\u00f4ler la compatibilit\u00e9.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#3546-champs-transient-et-static","title":"35.4.6 Champs <code>transient</code> et <code>static</code>","text":"<p>Les champs <code>transient</code> sont exclus de la s\u00e9rialisation.</p> <p>\u00c0 la d\u00e9s\u00e9rialisation, les champs transient prennent des valeurs par d\u00e9faut (0, false, null) sauf restauration manuelle.</p> <p>Les champs <code>static</code> appartiennent \u00e0 la classe, pas \u00e0 l\u2019instance, donc ils ne sont pas s\u00e9rialis\u00e9s.</p> <pre><code>class Session implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    static int counter = 0;      // non s\u00e9rialis\u00e9\n    transient String token;      // non s\u00e9rialis\u00e9\n    String user;                 // s\u00e9rialis\u00e9\n}\n</code></pre> <p>Note</p> <p>Si un transient est n\u00e9cessaire apr\u00e8s la d\u00e9s\u00e9rialisation, il doit \u00eatre recalcul\u00e9 ou restaur\u00e9 manuellement.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#3547-champs-non-serialisables-et-notserializableexception","title":"35.4.7 Champs non s\u00e9rialisables et NotSerializableException","text":"<p>Si un objet contient un champ dont le type n\u2019est pas s\u00e9rialisable, la s\u00e9rialisation \u00e9choue avec NotSerializableException.</p> <pre><code>class Holder implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private Thread t; // Thread n\u2019est pas s\u00e9rialisable\n}\n</code></pre> <p>Solutions typiques: - marquer le champ transient - le remplacer par une repr\u00e9sentation s\u00e9rialisable - utiliser des hook de s\u00e9rialisation custom</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#3548-constructeurs-et-serialisation","title":"35.4.8 Constructeurs et s\u00e9rialisation","text":"<p>Le comportement des constructeurs en d\u00e9s\u00e9rialisation est une source fr\u00e9quente de confusion.</p> <p>Java restaure l\u2019\u00e9tat principalement depuis le flux d\u2019octets, sans ex\u00e9cuter les constructeurs.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#35481-regle-les-constructeurs-des-classes-serializable-ne-sont-pas-appeles","title":"35.4.8.1 R\u00e8gle: les constructeurs des classes Serializable NE sont pas appel\u00e9s","text":"<p>Pendant la d\u00e9s\u00e9rialisation d\u2019une classe Serializable, ses constructeurs NE sont pas ex\u00e9cut\u00e9s.</p> <p>L\u2019instance est cr\u00e9\u00e9e sans appeler ces constructeurs et les champs sont inject\u00e9s depuis le flux.</p> <p>Note</p> <p>Pour cela les constructeurs des classes Serializable ne doivent pas contenir une logique d\u2019initialisation essentielle: elle ne serait pas ex\u00e9cut\u00e9e en d\u00e9s\u00e9rialisation.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#35482-regle-dheritage-la-premiere-superclass-non-serializable-est-appelee","title":"35.4.8.2 R\u00e8gle d\u2019h\u00e9ritage: la premi\u00e8re superclass non-Serializable est appel\u00e9e","text":"<p>Si une classe Serializable a une superclasse non Serializable, la d\u00e9s\u00e9rialisation doit initialiser cette partie.</p> <p>Donc Java appelle le constructeur no-arg de la premi\u00e8re superclasse non-Serializable.</p> <p>Implications: - la superclasse non Serializable doit avoir un no-arg accessible - les sous-classes Serializable sautent les constructeurs, les superclasses non Serializable non</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#35483-tableau-quels-constructeurs-sont-executes","title":"35.4.8.3 Tableau: quels constructeurs sont ex\u00e9cut\u00e9s","text":"Type de classe Constructeur appel\u00e9 en d\u00e9s\u00e9rialisation Classe Serializable Non Sous-classe Serializable Non Premi\u00e8re superclasse non Serializable Oui (no-arg) Classe Externalizable Oui (public no-arg requis)"},{"location":"fr/module-08/io-streams-api/#35484-exemple-quels-constructeurs-sont-appeles","title":"35.4.8.4 Exemple: quels constructeurs sont appel\u00e9s","text":"<pre><code>import java.io.*;\n\nclass A {\n    A() {\n        System.out.println(\"A constructor\");\n    }\n}\n\nclass B extends A implements Serializable {\n    private static final long serialVersionUID = 1L;\n    B() {\n        System.out.println(\"B constructor\");\n    }\n}\n\nclass C extends B {\n    private static final long serialVersionUID = 1L;\n    C() {\n        System.out.println(\"C constructor\");\n    }\n}\n\npublic class Demo {\n    public static void main(String[] args) throws Exception {\n\n        C obj = new C();\n\n        try (ObjectOutputStream out =\n                 new ObjectOutputStream(new FileOutputStream(\"c.bin\"))) {\n            out.writeObject(obj);\n        }\n\n        try (ObjectInputStream in =\n                 new ObjectInputStream(new FileInputStream(\"c.bin\"))) {\n            Object restored = in.readObject();\n        }\n    }\n}\n</code></pre> <p>Output attendu et explication Pendant la construction normale (new C()):</p> <pre><code>A constructor\nB constructor\nC constructor\n</code></pre> <p>Pendant la d\u00e9s\u00e9rialisation (readObject):</p> <pre><code>A constructor\n</code></pre> <p>Explication: - C est Serializable \u2192 C() n\u2019est pas appel\u00e9 - B est Serializable \u2192 B() n\u2019est pas appel\u00e9 - A n\u2019est pas Serializable \u2192 A() est appel\u00e9 (no-arg) - Les champs de B et C sont restaur\u00e9s depuis le flux</p> <p>Note</p> <p>Si la premi\u00e8re superclasse non-Serializable n\u2019a pas un no-arg accessible, la d\u00e9s\u00e9rialisation \u00e9choue.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#3549-hook-de-serialisation-custom-writeobject-et-readobject","title":"35.4.9 Hook de s\u00e9rialisation custom: <code>writeObject</code> et <code>readObject</code>","text":"<p>Les hook custom servent quand la s\u00e9rialisation par d\u00e9faut ne suffit pas (\u00e9tat transient, champs d\u00e9riv\u00e9s, chiffrement, validation, compatibilit\u00e9).</p> <p>Ils sont avanc\u00e9s mais importants pour une d\u00e9s\u00e9rialisation correcte.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#35491-pourquoi-la-serialisation-custom-existe","title":"35.4.9.1 Pourquoi la s\u00e9rialisation custom existe","text":"<p>Par d\u00e9faut, Java s\u00e9rialise automatiquement tous les champs d\u2019instance non static et non transient.</p> <p>C\u2019est commode, mais cela ne couvre pas des besoins fr\u00e9quents.</p> <p>Motifs typiques: - un champ ne doit pas \u00eatre sauvegard\u00e9 directement (donn\u00e9es sensibles) - un champ est d\u00e9riv\u00e9/cache et doit \u00eatre recalcul\u00e9 - validation en lecture est n\u00e9cessaire (refuser un \u00e9tat invalide) - logique de backward/forward compatibility est n\u00e9cessaire - un objet r\u00e9f\u00e9renc\u00e9 n\u2019est pas Serializable et doit \u00eatre g\u00e9r\u00e9</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#35492-ce-que-sont-vraiment-writeobject-et-readobject","title":"35.4.9.2 Ce que sont vraiment <code>writeObject</code> et <code>readObject</code>","text":"<p>Pour personnaliser s\u00e9rialisation/d\u00e9s\u00e9rialisation, une classe peut d\u00e9finir deux m\u00e9thodes priv\u00e9es sp\u00e9ciales appel\u00e9es <code>writeObject</code> et <code>readObject</code>.</p> <p>Ce ne sont pas des override de m\u00e9thodes d\u2019interfaces ou de superclass: elles ne font pas partie du flux normal du programme.</p> <p>Tu ne les appelles jamais toi.</p> <p>Le framework de s\u00e9rialisation (ObjectOutputStream/ObjectInputStream) les identifie via reflection, seulement si nom et signature sont exacts, et les invoque automatiquement.</p> <p>S\u2019ils n\u2019existent pas (ou la signature est mauvaise), la s\u00e9rialisation par d\u00e9faut est utilis\u00e9e.</p> <p>Note</p> <p>Si la signature est erron\u00e9e (visibilit\u00e9, param\u00e8tres, return type, exceptions), le framework ne la reconna\u00eet pas et revient silencieusement au d\u00e9faut.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#35493-signatures-requises-exactes","title":"35.4.9.3 Signatures requises (exactes)","text":"<pre><code>private void writeObject(ObjectOutputStream out) throws IOException\n\nprivate void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException\n</code></pre> <p>Contraintes: - elles doivent \u00eatre private - elles doivent retourner void - les types des param\u00e8tres doivent correspondre exactement - les exceptions doivent \u00eatre compatibles</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#35494-ce-qui-se-passe-en-serialisation-step-by-step","title":"35.4.9.4 Ce qui se passe en s\u00e9rialisation: step-by-step","text":"<p>Quand tu s\u00e9rialises:</p> <pre><code>out.writeObject(obj);\n</code></pre> <p>M\u00e9canisme: - v\u00e9rifie Serializable - cherche un private writeObject(ObjectOutputStream) - si absent \u2192 s\u00e9rialisation par d\u00e9faut - si pr\u00e9sent \u2192 ton writeObject est appel\u00e9</p> <p>Point cl\u00e9: \u00e0 l\u2019int\u00e9rieur de writeObject, Java n\u2019\u00e9crit pas automatiquement les champs \u201cnormaux\u201d si tu ne le demandes pas. Pour cela existe:</p> <pre><code>out.defaultWriteObject();\n</code></pre> <p><code>defaultWriteObject()</code> signifie: \u201cs\u00e9rialise les champs s\u00e9rialisables normaux avec le m\u00e9canisme standard\u201d.</p> <p>Ensuite tu peux \u00e9crire des donn\u00e9es extra comme tu veux.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#35495-pattern-typique-et-regle-de-lordre-writeread","title":"35.4.9.5 Pattern typique et r\u00e8gle de l\u2019ordre write/read","text":"<p>Pattern typique: utiliser default puis \u00e9tendre.</p> <p>L\u2019ordre de lecture doit co\u00efncider avec l\u2019ordre d\u2019\u00e9criture.</p> <pre><code>private void writeObject(ObjectOutputStream out) throws IOException {\n    out.defaultWriteObject(); // \u00e9crit les champs normaux\n    out.writeInt(42);         // \u00e9crit des donn\u00e9es extra\n}\n\nprivate void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n    in.defaultReadObject();   // lit les champs normaux\n    int x = in.readInt();     // lit les donn\u00e9es extra dans le m\u00eame ordre\n}\n</code></pre> <p>Note</p> <p>Si tu \u00e9cris des valeurs extra (int/string/etc.), tu dois les lire dans la m\u00eame s\u00e9quence, sinon la d\u00e9s\u00e9rialisation \u00e9choue ou corrompt l\u2019\u00e9tat.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#35410-exemple-dusage-restaurer-un-champ-derive-transient","title":"35.4.10 Exemple d\u2019usage: restaurer un champ d\u00e9riv\u00e9 transient","text":"<p>Cas typique: recalculer une valeur cached transient apr\u00e8s d\u00e9s\u00e9rialisation.</p> <pre><code>class User implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private String firstName;\n    private String lastName;\n\n    private transient String fullName;\n\n    User(String firstName, String lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n        this.fullName = firstName + \" \" + lastName;\n    }\n\n    private void readObject(ObjectInputStream in)\n            throws IOException, ClassNotFoundException {\n\n        in.defaultReadObject();                 // restaure firstName et lastName\n        fullName = firstName + \" \" + lastName; // recalcule le transient\n    }\n}\n</code></pre> <p></p>"},{"location":"fr/module-08/io-streams-api/#35411-externalizable-controle-total-et-responsabilite-totale","title":"35.4.11 Externalizable: contr\u00f4le total (et responsabilit\u00e9 totale)","text":"<p>Externalizable requiert de d\u00e9finir manuellement comment \u00e9crire et lire l\u2019objet.</p> <p>Il requiert aussi un constructeur public no-arg, parce que la d\u00e9s\u00e9rialisation instancie d\u2019abord l\u2019objet.</p> <pre><code>import java.io.*;\n\nclass Point implements Externalizable {\n    int x;\n    int y;\n\n    public Point() { } // requis\n\n    public Point(int x, int y) { this.x = x; this.y = y; }\n\n    @Override\n    public void writeExternal(ObjectOutput out) throws IOException {\n        out.writeInt(x);\n        out.writeInt(y);\n    }\n\n    @Override\n    public void readExternal(ObjectInput in) throws IOException {\n        x = in.readInt();\n        y = in.readInt();\n    }\n}\n</code></pre> <p>Note</p> <p>Avec Externalizable tu contr\u00f4les le format. Si tu le changes, tu dois g\u00e9rer toi la backward compatibility.</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#35412-considerations-de-securite-sur-readobject","title":"35.4.12 Consid\u00e9rations de s\u00e9curit\u00e9 sur <code>readObject()</code>","text":"<p>La d\u00e9s\u00e9rialisation de donn\u00e9es non fiables est dangereuse parce qu\u2019elle peut ex\u00e9cuter du code indirectement via: - hook readObject - logique d\u2019initialisation - gadget chain dans des librairies</p> <p>Lignes directrices: - ne d\u00e9s\u00e9rialise jamais des octets non fiables sans un motif fort - pr\u00e9f\u00e9rer des formats s\u00fbrs (JSON, protobuf) pour des inputs externes - si oblig\u00e9, utiliser object filter et validation rigoureuse</p> <p></p>"},{"location":"fr/module-08/io-streams-api/#35413-pieges-communs-et-conseils-pratiques","title":"35.4.13 Pi\u00e8ges communs et conseils pratiques","text":"<ul> <li>Serializable est seulement marker: il ne requiert pas de m\u00e9thodes</li> <li><code>readObject</code> retourne Object et peut lancer ClassNotFoundException</li> <li>les champs <code>static</code> ne sont jamais s\u00e9rialis\u00e9s</li> <li>les champs <code>transient</code> reviennent \u00e0 d\u00e9faut sauf restauration</li> <li>sans <code>serialVersionUID</code> la compatibilit\u00e9 peut se casser \u201cpar surprise\u201d</li> <li>Externalizable requiert public no-arg constructor</li> <li>NotSerializableException quand un champ r\u00e9f\u00e9renc\u00e9 n\u2019est pas s\u00e9rialisable</li> </ul>"},{"location":"fr/module-08/io-streams-api/#35414-quand-utiliser-ou-eviter-la-serialisation-java","title":"35.4.14 Quand utiliser (ou \u00e9viter) la s\u00e9rialisation Java","text":"<p>Utilise la s\u00e9rialisation classique surtout pour: - persistance locale de courte dur\u00e9e avec versions contr\u00f4l\u00e9es - caching en m\u00e9moire quand les deux extr\u00e9mit\u00e9s sont fiables - syst\u00e8mes legacy qui l\u2019utilisent d\u00e9j\u00e0</p> <p>\u00c9vite-la pour: - protocoles de r\u00e9seau publics - stockage \u00e0 long terme avec sch\u00e9ma \u00e9volutif - inputs non fiables</p>"},{"location":"fr/module-08/io-streams/","title":"34. Streams I/O Java","text":""},{"location":"fr/module-08/io-streams/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>34.1 Qu\u2019est-ce qu\u2019un flux I/O en Java</li> <li>34.2 Flux d\u2019octets vs flux de caract\u00e8res<ul> <li>34.2.1 Flux d\u2019octets</li> <li>34.2.2 Flux de caract\u00e8res</li> <li>34.2.3 Tableau r\u00e9capitulatif</li> </ul> </li> <li>34.3 Flux de bas niveau vs flux de haut niveau<ul> <li>34.3.1 Flux de bas niveau Node-Streams</li> <li>34.3.2 Flux de bas niveau courants</li> <li>34.3.3 Flux de haut niveau Filter--Processing-Streams</li> <li>34.3.4 Flux de haut niveau courants</li> <li>34.3.5 R\u00e8gles de cha\u00eenage des flux et erreurs courantes<ul> <li>34.3.5.1 R\u00e8gle fondamentale de cha\u00eenage</li> <li>34.3.5.2 Incompatibilit\u00e9 flux d\u2019octets vs flux de caract\u00e8res</li> <li>34.3.5.3 Cha\u00eenage invalide erreur-de-compilation</li> <li>34.3.5.4 Pont entre flux d\u2019octets et flux de caract\u00e8res</li> <li>34.3.5.5 Patron correct de conversion</li> <li>34.3.5.6 R\u00e8gles d\u2019ordre dans les cha\u00eenes de flux</li> <li>34.3.5.7 Ordre logique correct</li> <li>34.3.5.8 R\u00e8gle de gestion des ressources</li> <li>34.3.5.9 Pi\u00e8ges courants</li> </ul> </li> </ul> </li> <li>34.4 Classes de base principales de javaio et m\u00e9thodes cl\u00e9s<ul> <li>34.4.1 InputStream<ul> <li>34.4.1.1 M\u00e9thodes cl\u00e9s</li> <li>34.4.1.2 Exemple d\u2019utilisation typique</li> </ul> </li> <li>34.4.2 OutputStream<ul> <li>34.4.2.1 M\u00e9thodes cl\u00e9s</li> <li>34.4.2.2 Exemple d\u2019utilisation typique</li> </ul> </li> <li>34.4.3 Reader et Writer<ul> <li>34.4.3.1 Gestion du charset</li> </ul> </li> </ul> </li> <li>34.5 Flux tamponn\u00e9s et performance<ul> <li>34.5.1 Pourquoi la mise en tampon compte</li> <li>34.5.2 Comment fonctionne la lecture non tamponn\u00e9e</li> <li>34.5.3 Comment fonctionne BufferedInputStream</li> <li>34.5.4 Exemple de sortie tamponn\u00e9e</li> <li>34.5.5 BufferedReader vs Reader</li> <li>34.5.6 Exemple de BufferedWriter</li> </ul> </li> <li>34.6 java io vs java nio et java nio file<ul> <li>34.6.1 Diff\u00e9rences conceptuelles</li> <li>34.6.2 java-nio I/O de fichier moderne</li> </ul> </li> <li>34.7 Quand utiliser quelle API</li> <li>34.8 Pi\u00e8ges courants et conseils</li> </ul> <p>Ce chapitre fournit une explication d\u00e9taill\u00e9e des <code>flux I/O Java</code>.</p> <p>Il couvre les flux classiques java.io, les compare \u00e0 java.nio / java.nio.file, et explique les principes de conception, les API, les cas limites et les distinctions pertinentes.</p> <p></p>"},{"location":"fr/module-08/io-streams/#341-quest-ce-quun-flux-io-en-java","title":"34.1 Qu\u2019est-ce qu\u2019un flux I/O en Java ?","text":"<p>Un <code>flux I/O</code> repr\u00e9sente un flux de donn\u00e9es entre un programme Java et une source ou une destination externe.</p> <p>Les donn\u00e9es circulent de mani\u00e8re s\u00e9quentielle, comme de l\u2019eau dans un tuyau.</p> <ul> <li>Un flux n\u2019est pas une structure de donn\u00e9es ; il ne stocke pas les donn\u00e9es de mani\u00e8re permanente</li> <li>Les flux sont unidirectionnels (entr\u00e9e OU sortie)</li> <li>Les flux abstraient la source sous-jacente (fichier, r\u00e9seau, m\u00e9moire, p\u00e9riph\u00e9rique)</li> <li>Les flux fonctionnent de mani\u00e8re bloquante, synchrone (I/O classique)</li> </ul> <p>En Java, les flux sont organis\u00e9s autour de deux dimensions majeures :</p> <ul> <li><code>Direction</code> : Entr\u00e9e vs Sortie</li> <li><code>Type de donn\u00e9es</code> : Octets vs Caract\u00e8res</li> </ul> <p></p>"},{"location":"fr/module-08/io-streams/#342-flux-doctets-vs-flux-de-caracteres","title":"34.2 Flux d\u2019octets vs flux de caract\u00e8res","text":"<p>Java distingue les flux selon l\u2019unit\u00e9 de donn\u00e9es qu\u2019ils traitent.</p> <p></p>"},{"location":"fr/module-08/io-streams/#3421-flux-doctets","title":"34.2.1 Flux d\u2019octets","text":"<ul> <li>Fonctionnent avec des octets bruts 8 bits</li> <li>Utilis\u00e9s pour les donn\u00e9es binaires (images, audio, PDF, ZIP)</li> <li>Classes de base : <code>InputStream</code> et <code>OutputStream</code></li> </ul>"},{"location":"fr/module-08/io-streams/#3422-flux-de-caracteres","title":"34.2.2 Flux de caract\u00e8res","text":"<ul> <li>Fonctionnent avec des caract\u00e8res Unicode 16 bits</li> <li>G\u00e8rent automatiquement l\u2019encodage des caract\u00e8res</li> <li>Classes de base : <code>Reader</code> et <code>Writer</code></li> </ul>"},{"location":"fr/module-08/io-streams/#3423-tableau-recapitulatif","title":"34.2.3 Tableau r\u00e9capitulatif","text":"Aspect Flux d\u2019octets Flux de caract\u00e8res <code>Unit\u00e9 de donn\u00e9es</code> byte (8 bits) char (16 bits) <code>Gestion de l\u2019encodage</code> Aucune Oui (conscient du charset) <code>Classes de base</code> InputStream / OutputStream Reader / Writer <code>Usage typique</code> Fichiers binaires Fichiers texte <code>Focus</code> I/O bas niveau Traitement de texte"},{"location":"fr/module-08/io-streams/#343-flux-de-bas-niveau-vs-flux-de-haut-niveau","title":"34.3 Flux de bas niveau vs flux de haut niveau","text":"<p>Les flux dans <code>java.io</code> suivent un pattern decorator. Les flux sont empil\u00e9s pour ajouter des fonctionnalit\u00e9s.</p> <p></p>"},{"location":"fr/module-08/io-streams/#3431-flux-de-bas-niveau-node-streams","title":"34.3.1 Flux de bas niveau (Node Streams)","text":"<p>Les flux de bas niveau se connectent directement \u00e0 une source ou un puits de donn\u00e9es.</p> <ul> <li>Ils savent lire/\u00e9crire des octets ou des caract\u00e8res</li> <li>Ils ne fournissent PAS de mise en tampon, de formatage ou de gestion d\u2019objets</li> </ul> <p></p>"},{"location":"fr/module-08/io-streams/#3432-flux-de-bas-niveau-courants","title":"34.3.2 Flux de bas niveau courants","text":"Classe de flux Objectif <code>FileInputStream</code> Lire des octets depuis un fichier <code>FileOutputStream</code> \u00c9crire des octets dans un fichier <code>FileReader</code> Lire des caract\u00e8res depuis un fichier <code>FileWriter</code> \u00c9crire des caract\u00e8res dans un fichier <ul> <li>Exemple : flux d\u2019octets de bas niveau</li> </ul> <pre><code>try (InputStream in = new FileInputStream(\"data.bin\")) {\n    int b;\n    while ((b = in.read()) != -1) {\n        System.out.println(b);\n    }\n}\n</code></pre> <p>Note</p> <p>Les flux de bas niveau sont rarement utilis\u00e9s seuls dans des applications r\u00e9elles en raison de performances m\u00e9diocres et de fonctionnalit\u00e9s limit\u00e9es.</p> <p></p>"},{"location":"fr/module-08/io-streams/#3433-flux-de-haut-niveau-filter-processing-streams","title":"34.3.3 Flux de haut niveau (Filter / Processing Streams)","text":"<p>Les flux de haut niveau enveloppent d\u2019autres flux pour ajouter des fonctionnalit\u00e9s.</p> <ul> <li>Mise en tampon</li> <li>Conversion de type de donn\u00e9es</li> <li>S\u00e9rialisation d\u2019objets</li> <li>Lecture/\u00e9criture de primitifs</li> </ul> <p></p>"},{"location":"fr/module-08/io-streams/#3434-flux-de-haut-niveau-courants","title":"34.3.4 Flux de haut niveau courants","text":"Classe de flux Ajoute des fonctionnalit\u00e9s <code>BufferedInputStream</code> Mise en tampon <code>BufferedReader</code> Lecture par lignes <code>DataInputStream</code> Types primitifs <code>ObjectInputStream</code> S\u00e9rialisation d\u2019objets <code>PrintWriter</code> Sortie texte format\u00e9e <ul> <li>Exemple : cha\u00eenage de flux</li> </ul> <pre><code>try (BufferedReader reader =\n    new BufferedReader(\n        new InputStreamReader(\n            new FileInputStream(\"text.txt\")))) {\n\n    String line;\n    while ((line = reader.readLine()) != null) {\n        System.out.println(line);\n    }\n}\n</code></pre>"},{"location":"fr/module-08/io-streams/#3435-regles-de-chainage-des-flux-et-erreurs-courantes","title":"34.3.5 R\u00e8gles de cha\u00eenage des flux et erreurs courantes","text":"<p>L\u2019exemple pr\u00e9c\u00e9dent illustre le cha\u00eenage des flux, un concept central de <code>java.io</code> bas\u00e9 sur le pattern decorator.</p> <p>Chaque flux enveloppe un autre flux, ajoutant des fonctionnalit\u00e9s tout en pr\u00e9servant une hi\u00e9rarchie de types stricte.</p> <p></p>"},{"location":"fr/module-08/io-streams/#34351-regle-fondamentale-de-chainage","title":"34.3.5.1 R\u00e8gle fondamentale de cha\u00eenage","text":"<p>Un flux ne peut envelopper qu\u2019un autre flux d\u2019un niveau d\u2019abstraction compatible.</p> <ul> <li>Les flux d\u2019octets ne peuvent envelopper que des flux d\u2019octets</li> <li>Les flux de caract\u00e8res ne peuvent envelopper que des flux de caract\u00e8res</li> <li>Les flux de haut niveau n\u00e9cessitent un flux de bas niveau sous-jacent</li> </ul> <p>Note</p> <p>Vous ne pouvez pas m\u00e9langer arbitrairement <code>InputStream</code> avec <code>Reader</code> ou <code>OutputStream</code> avec <code>Writer</code>.</p> <p></p>"},{"location":"fr/module-08/io-streams/#34352-incompatibilite-flux-doctets-vs-flux-de-caracteres","title":"34.3.5.2 Incompatibilit\u00e9 flux d\u2019octets vs flux de caract\u00e8res","text":"<p>Une erreur tr\u00e8s courante consiste \u00e0 tenter d\u2019envelopper un flux d\u2019octets directement avec une classe bas\u00e9e sur les caract\u00e8res (ou inversement).</p> <p></p>"},{"location":"fr/module-08/io-streams/#34353-chainage-invalide-erreur-de-compilation","title":"34.3.5.3 Cha\u00eenage invalide (erreur de compilation)","text":"<pre><code>BufferedReader reader =\n    new BufferedReader(new FileInputStream(\"text.txt\"));\n</code></pre> <p>Note</p> <p>Cela \u00e9choue parce que <code>BufferedReader</code> attend un <code>Reader</code>, pas un <code>InputStream</code>.</p> <p></p>"},{"location":"fr/module-08/io-streams/#34354-pont-entre-flux-doctets-et-flux-de-caracteres","title":"34.3.5.4 Pont entre flux d\u2019octets et flux de caract\u00e8res","text":"<p>Pour convertir entre les flux bas\u00e9s sur les octets et ceux bas\u00e9s sur les caract\u00e8res, Java fournit des classes passerelles qui effectuent un d\u00e9codage/encodage explicite du charset.</p> <ul> <li><code>InputStreamReader</code> convertit octets \u2192 caract\u00e8res</li> <li><code>OutputStreamWriter</code> convertit caract\u00e8res \u2192 octets</li> </ul> <p></p>"},{"location":"fr/module-08/io-streams/#34355-patron-correct-de-conversion","title":"34.3.5.5 Patron correct de conversion","text":"<pre><code>BufferedReader reader =\n    new BufferedReader(\n        new InputStreamReader(new FileInputStream(\"text.txt\")));\n</code></pre> <p>Note</p> <p>La passerelle g\u00e8re le d\u00e9codage des caract\u00e8res en utilisant un charset (par d\u00e9faut ou explicite).</p> <p></p>"},{"location":"fr/module-08/io-streams/#34356-regles-dordre-dans-les-chaines-de-flux","title":"34.3.5.6 R\u00e8gles d\u2019ordre dans les cha\u00eenes de flux","text":"<p>L\u2019ordre d\u2019enveloppement n\u2019est pas arbitraire.</p> <ul> <li>Le flux de bas niveau doit \u00eatre le plus interne</li> <li>Les passerelles (si n\u00e9cessaires) viennent ensuite</li> <li>Les flux tamponn\u00e9s ou de traitement viennent en dernier</li> </ul> <p></p>"},{"location":"fr/module-08/io-streams/#34357-ordre-logique-correct","title":"34.3.5.7 Ordre logique correct","text":"<pre><code>FileInputStream \u2192 InputStreamReader \u2192 BufferedReader\n</code></pre>"},{"location":"fr/module-08/io-streams/#34358-regle-de-gestion-des-ressources","title":"34.3.5.8 R\u00e8gle de gestion des ressources","text":"<p>Fermer le flux le plus externe ferme automatiquement tous les flux envelopp\u00e9s.</p> <p>Note</p> <p>C\u2019est pourquoi try-with-resources devrait r\u00e9f\u00e9rencer uniquement le flux de plus haut niveau.</p> <p></p>"},{"location":"fr/module-08/io-streams/#34359-pieges-courants","title":"34.3.5.9 Pi\u00e8ges courants","text":"<ul> <li>Essayer de tamponner un flux du mauvais type</li> <li>Oublier la passerelle entre flux d\u2019octets et flux de caract\u00e8res</li> <li>Supposer que <code>Reader</code> fonctionne avec des donn\u00e9es binaires</li> <li>Utiliser le charset par d\u00e9faut involontairement</li> <li>Fermer manuellement les flux internes (risque de double-close) : <code>close()</code> sur l\u2019enveloppe externe suffit et est recommand\u00e9</li> </ul>"},{"location":"fr/module-08/io-streams/#344-classes-de-base-principales-de-javaio-et-methodes-cles","title":"34.4 Classes de base principales de <code>java.io</code> et m\u00e9thodes cl\u00e9s","text":"<p>Le package <code>java.io</code> est construit autour d\u2019un petit ensemble de classes de base abstraites. Comprendre ces classes et leurs contrats est essentiel, car toutes les classes I/O concr\u00e8tes s\u2019appuient sur elles.</p> <p></p>"},{"location":"fr/module-08/io-streams/#3441-inputstream","title":"34.4.1 InputStream","text":"<p>Classe de base abstraite pour l\u2019entr\u00e9e orient\u00e9e octets. Tous les flux d\u2019entr\u00e9e lisent des octets bruts (valeurs 8 bits) depuis une source telle qu\u2019un fichier, un socket r\u00e9seau, ou un buffer m\u00e9moire.</p> <p></p>"},{"location":"fr/module-08/io-streams/#34411-methodes-cles","title":"34.4.1.1 M\u00e9thodes cl\u00e9s","text":"M\u00e9thode Description int <code>read()</code> Lit un octet (0\u2013255) ; retourne -1 \u00e0 la fin du flux int <code>read(byte[])</code> Lit des octets dans un buffer ; retourne le nombre d\u2019octets lus ou -1 int <code>read(byte[], int, int)</code> Lit jusqu\u2019\u00e0 length octets dans une tranche de buffer int <code>available()</code> Octets lisibles sans bloquer (indice, pas garantie) void <code>close()</code> Lib\u00e8re la ressource sous-jacente <p>Note</p> <p>Les m\u00e9thodes <code>read()</code> sont bloquantes par d\u00e9faut.</p> <p>Elles suspendent le thread appelant jusqu\u2019\u00e0 ce que des donn\u00e9es soient disponibles, que la fin de flux soit atteinte, ou qu\u2019une erreur I/O se produise.</p> <p>La m\u00e9thode <code>read()</code> \u00e0 octet unique est principalement un primitif de bas niveau.</p> <p>En pratique, lire un octet \u00e0 la fois est inefficace et devrait presque toujours \u00eatre \u00e9vit\u00e9 au profit de lectures tamponn\u00e9es.</p> <p></p>"},{"location":"fr/module-08/io-streams/#34412-exemple-dutilisation-typique","title":"34.4.1.2 Exemple d\u2019utilisation typique","text":"<pre><code>try (InputStream in = new FileInputStream(\"data.bin\")) {\n    byte[] buffer = new byte[1024];\n    int count;\n    while ((count = in.read(buffer)) != -1) {\n        // traiter buffer[0..count-1]\n    }\n}\n</code></pre>"},{"location":"fr/module-08/io-streams/#3442-outputstream","title":"34.4.2 OutputStream","text":"<p>Classe de base abstraite pour la sortie orient\u00e9e octets.</p> <p>Elle repr\u00e9sente une destination o\u00f9 des octets bruts peuvent \u00eatre \u00e9crits.</p> <p></p>"},{"location":"fr/module-08/io-streams/#34421-methodes-cles","title":"34.4.2.1 M\u00e9thodes cl\u00e9s","text":"M\u00e9thode Description void <code>write(int b)</code> \u00c9crit les 8 bits de poids faible de l\u2019entier void <code>write(byte[])</code> \u00c9crit un tableau d\u2019octets entier void <code>write(byte[], int, int)</code> \u00c9crit une tranche d\u2019un tableau d\u2019octets void <code>flush()</code> Force l\u2019\u00e9criture des donn\u00e9es tamponn\u00e9es void <code>close()</code> Effectue flush et lib\u00e8re la ressource <p>Note</p> <p>Appeler <code>close()</code> appelle implicitement <code>flush()</code>.</p> <p>Ne pas faire flush ou close sur un OutputStream peut entra\u00eener une perte de donn\u00e9es.</p> <p></p>"},{"location":"fr/module-08/io-streams/#34422-exemple-dutilisation-typique","title":"34.4.2.2 Exemple d\u2019utilisation typique","text":"<pre><code>try (OutputStream out = new FileOutputStream(\"out.bin\")) {\n    out.write(new byte[] {1, 2, 3, 4});\n    out.flush();\n}\n</code></pre>"},{"location":"fr/module-08/io-streams/#3443-reader-et-writer","title":"34.4.3 Reader et Writer","text":"<p><code>Reader</code> et <code>Writer</code> sont les \u00e9quivalents <code>orient\u00e9s caract\u00e8res</code> de InputStream et OutputStream.</p> <p>Ils fonctionnent sur des caract\u00e8res Unicode 16 bits au lieu d\u2019octets bruts.</p> Classe Direction Bas\u00e9e sur caract\u00e8res Consciente de l\u2019encodage <code>Reader</code> Entr\u00e9e Oui Oui <code>Writer</code> Sortie Oui Oui <p>Readers et Writers impliquent toujours un <code>charset</code>, explicitement ou implicitement.</p> <p>Cela en fait l\u2019abstraction correcte pour le traitement de texte.</p> <p></p>"},{"location":"fr/module-08/io-streams/#34431-gestion-du-charset","title":"34.4.3.1 Gestion du charset","text":"<pre><code>Reader reader = new InputStreamReader(\n    new FileInputStream(\"file.txt\"),\n    StandardCharsets.UTF_8\n);\n</code></pre> <p>Note</p> <p><code>InputStreamReader</code> et <code>OutputStreamWriter</code> sont des classes passerelles.</p> <p>Ils convertissent entre <code>flux d\u2019octets</code> et <code>flux de caract\u00e8res</code> en utilisant un <code>charset</code>.</p> <p></p>"},{"location":"fr/module-08/io-streams/#345-flux-tamponnes-et-performance","title":"34.5 Flux tamponn\u00e9s et performance","text":"<p>Les <code>flux tamponn\u00e9s</code> enveloppent un autre flux et ajoutent un buffer en m\u00e9moire.</p> <p>Au lieu d\u2019interagir avec le syst\u00e8me d\u2019exploitation \u00e0 chaque read ou write, les donn\u00e9es sont accumul\u00e9es en m\u00e9moire et transf\u00e9r\u00e9es en plus gros blocs.</p> <ul> <li><code>BufferedInputStream</code> / <code>BufferedOutputStream</code> pour les flux d\u2019octets</li> <li><code>BufferedReader</code> / <code>BufferedWriter</code> pour les flux de caract\u00e8res</li> </ul> <p>Note</p> <p>Les <code>flux tamponn\u00e9s</code> sont des <code>decorators</code> : ils ne remplacent pas le flux sous-jacent, ils l\u2019am\u00e9liorent en ajoutant un comportement de mise en tampon.</p> <p></p>"},{"location":"fr/module-08/io-streams/#3451-pourquoi-la-mise-en-tampon-compte","title":"34.5.1 Pourquoi la mise en tampon compte","text":"Aspect Non tamponn\u00e9 Tamponn\u00e9 <code>Appels syst\u00e8me</code> Fr\u00e9quents R\u00e9duits <code>Performance</code> M\u00e9diocre \u00c9lev\u00e9e <code>Utilisation m\u00e9moire</code> Minimale L\u00e9g\u00e8rement plus \u00e9lev\u00e9e <p>Les appels syst\u00e8me sont des op\u00e9rations co\u00fbteuses.</p> <p>La mise en tampon les minimise en regroupant plusieurs lectures ou \u00e9critures logiques en moins d\u2019op\u00e9rations I/O physiques.</p> <p></p>"},{"location":"fr/module-08/io-streams/#3452-comment-fonctionne-la-lecture-non-tamponnee","title":"34.5.2 Comment fonctionne la lecture non tamponn\u00e9e","text":"<p>Dans un flux non tamponn\u00e9, chaque appel \u00e0 read() peut entra\u00eener un appel syst\u00e8me natif.</p> <p>C\u2019est particuli\u00e8rement inefficace lorsqu\u2019on lit de grandes quantit\u00e9s de donn\u00e9es.</p> <pre><code>try (InputStream in = new FileInputStream(\"data.bin\")) {\n    int b;\n    while ((b = in.read()) != -1) {\n        // chaque read() peut d\u00e9clencher un appel syst\u00e8me\n    }\n}\n</code></pre> <p>Note</p> <p>Lire octet par octet sans mise en tampon est presque toujours un anti-pattern de performance.</p> <p></p>"},{"location":"fr/module-08/io-streams/#3453-comment-fonctionne-bufferedinputstream","title":"34.5.3 Comment fonctionne BufferedInputStream","text":"<p><code>BufferedInputStream</code> lit en interne un grand bloc d\u2019octets dans un buffer.</p> <p>Les appels <code>read()</code> suivants sont servis directement depuis la m\u00e9moire jusqu\u2019\u00e0 ce que le buffer soit vide.</p> <pre><code>try (InputStream in =\n    new BufferedInputStream(new FileInputStream(\"data.bin\"))) {\n        int b;\n        while ((b = in.read()) != -1) {\n            // la plupart des lectures sont servies depuis la m\u00e9moire, pas depuis l\u2019OS\n        }\n}\n</code></pre> <p>Note</p> <p>Le programme appelle toujours <code>read()</code> de mani\u00e8re r\u00e9p\u00e9t\u00e9e, mais le syst\u00e8me d\u2019exploitation n\u2019est acc\u00e9d\u00e9 que lorsque le buffer interne doit \u00eatre rempli \u00e0 nouveau.</p> <p></p>"},{"location":"fr/module-08/io-streams/#3454-exemple-de-sortie-tamponnee","title":"34.5.4 Exemple de sortie tamponn\u00e9e","text":"<p>La sortie tamponn\u00e9e accumule les donn\u00e9es en m\u00e9moire et les \u00e9crit en plus gros blocs.</p> <p>L\u2019op\u00e9ration <code>flush()</code> force l\u2019\u00e9criture imm\u00e9diate du buffer.</p> <pre><code>try (OutputStream out =\n    new BufferedOutputStream(new FileOutputStream(\"out.bin\"))) {\n        for (int i = 0; i &lt; 1_000; i++) {\n            out.write(i);\n        }\n        out.flush(); // force les donn\u00e9es tamponn\u00e9es sur disque\n}\n</code></pre> <p>Note</p> <p><code>close()</code> appelle automatiquement flush().</p> <p>Appeler <code>flush()</code> explicitement est utile lorsque les donn\u00e9es doivent \u00eatre visibles imm\u00e9diatement.</p> <p></p>"},{"location":"fr/module-08/io-streams/#3455-bufferedreader-vs-reader","title":"34.5.5 BufferedReader vs Reader","text":"<p><code>BufferedReader</code> ajoute une <code>**lecture par lignes**</code> efficace au-dessus d\u2019un Reader.</p> <p>Sans mise en tampon, chaque caract\u00e8re lu peut impliquer un appel syst\u00e8me.</p> <pre><code>try (BufferedReader reader =\n    new BufferedReader(new FileReader(\"file.txt\"))) {\n\n        String line;\n        while ((line = reader.readLine()) != null) {\n            System.out.println(line);\n        }\n}\n</code></pre> <p>Note</p> <p>La m\u00e9thode <code>readLine()</code> n\u2019est disponible que sur <code>BufferedReader</code> (pas sur <code>Reader</code>), car elle s\u2019appuie sur la mise en tampon pour d\u00e9tecter efficacement les limites de ligne.</p> <p></p>"},{"location":"fr/module-08/io-streams/#3456-exemple-de-bufferedwriter","title":"34.5.6 Exemple de BufferedWriter","text":"<pre><code>try (BufferedWriter writer =\n    new BufferedWriter(new FileWriter(\"file.txt\"))) {\n\n        writer.write(\"Hello\");\n        writer.newLine();\n        writer.write(\"World\");\n}\n</code></pre> <p><code>BufferedWriter</code> minimise l\u2019acc\u00e8s disque et fournit des m\u00e9thodes pratiques telles que newLine().</p> <p>Note</p> <p>Enveloppez toujours les flux de fichiers avec une mise en tampon sauf s\u2019il y a une forte raison de ne pas le faire</p> <p>Pr\u00e9f\u00e9rez BufferedReader / BufferedWriter pour le texte</p> <p>Pr\u00e9f\u00e9rez BufferedInputStream / BufferedOutputStream pour les donn\u00e9es binaires</p> <p></p>"},{"location":"fr/module-08/io-streams/#346-javaio-vs-javanio-et-javaniofile","title":"34.6 java.io vs java.nio (et java.nio.file)","text":"<p>Les applications Java modernes favorisent de plus en plus les API NIO et NIO.2, mais java.io reste fondamental et largement utilis\u00e9.</p> <p></p>"},{"location":"fr/module-08/io-streams/#3461-differences-conceptuelles","title":"34.6.1 Diff\u00e9rences conceptuelles","text":"Aspect java.io java.nio / nio.2 <code>Mod\u00e8le de programmation</code> Bas\u00e9 sur les flux Bas\u00e9 sur buffers / channels <code>I/O bloquantes</code> bloquantes par d\u00e9faut Capable de non-bloquant <code>API fichiers</code> File Path + Files <code>Scalabilit\u00e9</code> Limit\u00e9e \u00c9lev\u00e9e <code>Introduit</code> Java 1.0 Java 4 / Java 7 <p>Note</p> <p><code>java.nio</code> ne remplace pas <code>java.io</code>.</p> <p>De nombreuses classes NIO s\u2019appuient en interne sur des flux ou coexistent avec eux.</p> <p></p>"},{"location":"fr/module-08/io-streams/#3462-javanio-io-de-fichier-moderne","title":"34.6.2 java.nio (I/O de fichier moderne)","text":"<p>Le package <code>java.nio.file</code> (NIO.2) fournit une API fichiers de haut niveau, expressive et plus s\u00fbre. C\u2019est l\u2019approche pr\u00e9f\u00e9r\u00e9e pour les op\u00e9rations sur fichiers en Java 11+.</p> <p>Exemple : lire un fichier (NIO)</p> <pre><code>Path path = Path.of(\"file.txt\");\nList&lt;String&gt; lines = Files.readAllLines(path);\n</code></pre> <p>Code java.io \u00e9quivalent</p> <pre><code>try (BufferedReader reader = new BufferedReader(new FileReader(\"file.txt\"))) {\n    String line;\n    while ((line = reader.readLine()) != null) {\n        System.out.println(line);\n    }\n}\n</code></pre> <p></p>"},{"location":"fr/module-08/io-streams/#347-quand-utiliser-quelle-api","title":"34.7 Quand utiliser quelle API","text":"Sc\u00e9nario API recommand\u00e9e <code>Lecture/\u00e9criture simple de fichier</code> java.nio.file.Files <code>Streaming binaire</code> InputStream / OutputStream <code>Traitement de texte en caract\u00e8res</code> Reader / Writer <code>Serveurs haute performance</code> java.nio.channels <code>API legacy</code> java.io"},{"location":"fr/module-08/io-streams/#348-pieges-courants-et-conseils","title":"34.8 Pi\u00e8ges courants et conseils","text":"<ul> <li>La fin de fichier est indiqu\u00e9e par -1, pas par une exception</li> <li>Fermer un flux wrapper ferme automatiquement le flux envelopp\u00e9</li> <li><code>BufferedReader.readLine()</code> supprime les s\u00e9parateurs de ligne</li> <li><code>InputStreamReader</code> implique toujours un charset</li> <li>Les m\u00e9thodes utilitaires Files lancent des IOException checked</li> <li><code>available()</code> ne doit pas \u00eatre utilis\u00e9 pour d\u00e9tecter EOF</li> </ul> <p>Note</p> <p>La plupart des bugs I/O proviennent d\u2019hypoth\u00e8ses incorrectes sur le blocking, la mise en tampon ou l\u2019encodage des caract\u00e8res.</p>"},{"location":"fr/module-08/io-user/","title":"36. Interagir avec l\u2019Utilisateur (Flux E/S Standard)","text":""},{"location":"fr/module-08/io-user/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>36.1 Les Flux E/S Standard</li> <li>36.2 PrintStream Quest-ce et Pourquoi il Existe<ul> <li>36.2.1 Caract\u00e9ristiques Cl\u00e9s de PrintStream</li> <li>36.2.2 Utilisation de Base de PrintStream</li> <li>36.2.3 Formater l'Output avec PrintStream</li> </ul> </li> <li>36.3 Lire l'Input comme Flux E/S<ul> <li>36.3.1 Lecture de Bas Niveau depuis Systemin</li> <li>36.3.2 Utilisation de InputStreamReader et BufferedReader</li> </ul> </li> <li>36.4 La Classe Scanner Pratique mais Subtile<ul> <li>36.4.1 Probl\u00e8mes Communs de Scanner</li> </ul> </li> <li>36.5 Fermeture des Flux Syst\u00e8me</li> <li>36.6 Acqu\u00e9rir l'Input avec Console<ul> <li>36.6.1 Lire l'Input depuis Console</li> <li>36.6.2 Lire des Mots de Passe de Mani\u00e8re S\u00e9curis\u00e9e</li> </ul> </li> <li>36.7 Formater l'Output de la Console</li> <li>36.8 Comparaison entre Console Scanner et BufferedReader</li> <li>36.9 Redirection et Flux Standard</li> <li>36.10 Pi\u00e8ges Communs et Bonnes Pratiques</li> <li>36.11 Synth\u00e8se Finale</li> </ul> <p>Les programmes Java doivent souvent interagir avec l\u2019utilisateur: afficher des informations, lire une entr\u00e9e et formater la sortie.</p> <p>Cette interaction est impl\u00e9ment\u00e9e en utilisant les flux E/S standard, qui sont des flux Java normaux connect\u00e9s au syst\u00e8me d\u2019exploitation.</p> <p>Ce chapitre explique comment Java interagit avec la console et l\u2019entr\u00e9e/sortie standard, en partant des concepts les plus basiques et en passant aux API de niveau plus \u00e9lev\u00e9.</p> <p></p>"},{"location":"fr/module-08/io-user/#361-les-flux-es-standard","title":"36.1 Les Flux E/S Standard","text":"<p>Chaque programme Java commence avec trois flux pr\u00e9d\u00e9finis fournis par la JVM.</p> <p>Ils sont connect\u00e9s \u00e0 l\u2019environnement du processus (en g\u00e9n\u00e9ral un terminal ou une console).</p> Flux Champ Type But Sortie standard <code>System.out</code> PrintStream Sortie normale Erreur standard <code>System.err</code> PrintStream Sortie d\u2019erreur Entr\u00e9e standard <code>System.in</code> InputStream Entr\u00e9e de l\u2019utilisateur <p>Note</p> <p>Ces flux sont cr\u00e9\u00e9s par la JVM, pas par le programme.</p> <p>Ils existent pendant toute la dur\u00e9e du processus.</p> <p></p>"},{"location":"fr/module-08/io-user/#362-printstream-quest-ce-et-pourquoi-il-existe","title":"36.2 <code>PrintStream</code>: Qu\u2019est-ce et Pourquoi il Existe","text":"<p><code>PrintStream</code> est un flux de sortie orient\u00e9 octets con\u00e7u pour une sortie lisible par l\u2019utilisateur.</p> <p>Il enveloppe un autre OutputStream et ajoute des m\u00e9thodes d\u2019impression pratiques.</p> <p><code>System.out</code> et <code>System.err</code> sont tous deux des instances de <code>PrintStream</code>.</p> <p></p>"},{"location":"fr/module-08/io-user/#3621-caracteristiques-cles-de-printstream","title":"36.2.1 Caract\u00e9ristiques Cl\u00e9s de PrintStream","text":"<ul> <li>Flux orient\u00e9 octets avec des helpers pour l\u2019impression de texte</li> <li>Fournit des m\u00e9thodes <code>print()</code> et <code>println()</code></li> <li>Convertit automatiquement les valeurs en texte</li> <li>Ne lance pas <code>IOException</code> sur erreurs d\u2019\u00e9criture</li> <li>Supporte optionnellement l\u2019auto-flush sur newline / <code>println()</code></li> </ul> <p>Note</p> <p>Contrairement \u00e0 la plupart des flux, PrintStream supprime les IOExceptions.</p> <p>Les erreurs doivent \u00eatre v\u00e9rifi\u00e9es en utilisant checkError().</p> <p></p>"},{"location":"fr/module-08/io-user/#3622-utilisation-de-base-de-printstream","title":"36.2.2 Utilisation de Base de PrintStream","text":"<pre><code>System.out.println(\"Hello\");\nSystem.out.print(\"Value: \");\nSystem.out.println(42);\n</code></pre> <p><code>println()</code> ajoute automatiquement le s\u00e9parateur de ligne sp\u00e9cifique \u00e0 la plateforme.</p> <p></p>"},{"location":"fr/module-08/io-user/#3623-formater-loutput-avec-printstream","title":"36.2.3 Formater l\u2019Output avec PrintStream","text":"<p>PrintStream supporte une sortie format\u00e9e en utilisant <code>printf()</code> et <code>format()</code>, qui sont bas\u00e9s sur la m\u00eame syntaxe que String.format().</p> <pre><code>System.out.printf(\"Name: %s, Age: %d%n\", \"Alice\", 30);\n</code></pre> Sp\u00e9cificateur Signification <code>%s</code> Cha\u00eene <code>%d</code> Entier <code>%f</code> Virgule flottante <code>%n</code> Nouvelle ligne ind\u00e9pendante de la plateforme <p>Note</p> <p><code>printf()</code> n\u2019ajoute pas automatiquement une nouvelle ligne \u00e0 moins qu\u2019on sp\u00e9cifie <code>%n</code>.</p> <p></p>"},{"location":"fr/module-08/io-user/#363-lire-linput-comme-flux-es","title":"36.3 Lire l\u2019Input comme Flux E/S","text":"<p>L\u2019entr\u00e9e standard (System.in) est un InputStream connect\u00e9 \u00e0 l\u2019entr\u00e9e de l\u2019utilisateur.</p> <p>Elle fournit des octets bruts et doit \u00eatre adapt\u00e9e pour un usage pratique.</p> <p></p>"},{"location":"fr/module-08/io-user/#3631-lecture-de-bas-niveau-depuis-systemin","title":"36.3.1 Lecture de Bas Niveau depuis System.in","text":"<p>Au niveau le plus bas, tu peux lire des octets bruts depuis System.in.</p> <p>Ceci est rarement pratique pour des programmes interactifs.</p> <pre><code>int b = System.in.read();\n</code></pre> <p>Note</p> <p><code>System.in.read()</code> bloque jusqu\u2019\u00e0 ce que l\u2019entr\u00e9e soit disponible.</p> <p></p>"},{"location":"fr/module-08/io-user/#3632-utilisation-de-inputstreamreader-et-bufferedreader","title":"36.3.2 Utilisation de InputStreamReader et BufferedReader","text":"<p>Pour lire une entr\u00e9e textuelle, <code>System.in</code> est typiquement envelopp\u00e9 dans un Reader et bufferis\u00e9.</p> <pre><code>BufferedReader reader =\nnew BufferedReader(new InputStreamReader(System.in));\n\nString line = reader.readLine();\n</code></pre> <p>Ceci convertit <code>octets \u2192 caract\u00e8res</code> et permet une entr\u00e9e bas\u00e9e sur des lignes.</p> <p></p>"},{"location":"fr/module-08/io-user/#364-la-classe-scanner-pratique-mais-subtile","title":"36.4 La Classe Scanner (Pratique mais Subtile)","text":"<p><code>Scanner</code> est un utilitaire de haut niveau pour le parsing d\u2019entr\u00e9e textuelle.</p> <p>Il est souvent utilis\u00e9 pour l\u2019interaction avec la console, surtout dans de petits programmes.</p> <pre><code>Scanner sc = new Scanner(System.in);\nint value = sc.nextInt();\nString text = sc.nextLine();\n</code></pre> <p>Note</p> <p><code>Scanner</code> effectue tokenisation et parsing, pas une simple lecture.</p> <p>Cela la rend pratique mais plus lente et parfois surprenante.</p> <p></p>"},{"location":"fr/module-08/io-user/#3641-problemes-communs-de-scanner","title":"36.4.1 Probl\u00e8mes Communs de Scanner","text":"<ul> <li>M\u00e9langer <code>nextInt()</code> (et autres <code>nextXxx()</code>) avec <code>nextLine()</code> peut sembler \u201csauter\u201d l\u2019entr\u00e9e car le newline final du token num\u00e9rique est encore dans le buffer.</li> <li>Les erreurs de parsing lancent InputMismatchException</li> <li>Scanner est relativement lente pour des entr\u00e9es de grande taille</li> </ul>"},{"location":"fr/module-08/io-user/#365-fermeture-des-flux-systeme","title":"36.5 Fermeture des Flux Syst\u00e8me","text":"<p>Les <code>flux syst\u00e8me</code> sont sp\u00e9ciaux et doivent \u00eatre g\u00e9r\u00e9s avec attention.</p> Flux Fermer explicitement? <code>System.out</code> Non <code>System.err</code> Non <code>System.in</code> En g\u00e9n\u00e9ral non <p>Fermer <code>System.out</code> ou <code>System.err</code> ferme le flux sous-jacent du syst\u00e8me d\u2019exploitation et affecte l\u2019ensemble de la JVM: fermer ces flux affecte l\u2019ensemble du processus JVM, pas seulement la classe ou la m\u00e9thode courante.</p> <p>Note</p> <p>Dans presque toutes les applications, tu ne devrais PAS fermer <code>System.out</code> ou <code>System.err</code>.</p> <p></p>"},{"location":"fr/module-08/io-user/#366-acquerir-linput-avec-console","title":"36.6 Acqu\u00e9rir l\u2019Input avec <code>Console</code>","text":"<p>La classe <code>Console</code> fournit une mani\u00e8re de niveau plus \u00e9lev\u00e9 et plus s\u00fbre d\u2019interagir avec l\u2019utilisateur.</p> <p>Elle est con\u00e7ue sp\u00e9cifiquement pour des programmes de console interactifs.</p> <pre><code>Console console = System.console();\nif (console == null) {\n    throw new IllegalStateException(\"No console available\");\n}\n</code></pre> <p>Note</p> <p><code>System.console()</code> peut retourner <code>null</code> quand aucune console n\u2019est disponible (par ex. IDE, entr\u00e9e redirig\u00e9e).</p> <p>La pr\u00e9sence d\u2019une console d\u00e9pend de la plateforme sous-jacente et de la mani\u00e8re dont la JVM est lanc\u00e9e.</p> <p>Si la JVM est d\u00e9marr\u00e9e depuis une ligne de commande interactive et que les flux d\u2019entr\u00e9e/sortie standard ne sont pas redirig\u00e9s, une console est g\u00e9n\u00e9ralement disponible. Dans ce cas, la console est habituellement connect\u00e9e au clavier et \u00e0 l\u2019affichage \u00e0 partir desquels le programme a \u00e9t\u00e9 lanc\u00e9.</p> <p>Si la JVM est d\u00e9marr\u00e9e dans un contexte non interactif \u2014 par exemple depuis un IDE, un planificateur de t\u00e2ches en arri\u00e8re-plan, un gestionnaire de services, ou avec des flux standard redirig\u00e9s \u2014 une console ne sera g\u00e9n\u00e9ralement pas disponible.</p> <p>Lorsqu\u2019une console existe, elle est repr\u00e9sent\u00e9e par une instance unique de la classe Console, qui peut \u00eatre obtenue en invoquant la m\u00e9thode <code>System.console()</code>. Si aucun p\u00e9riph\u00e9rique console n\u2019est disponible, cette m\u00e9thode retourne <code>null</code>.</p> <p></p>"},{"location":"fr/module-08/io-user/#3661-lire-linput-depuis-console","title":"36.6.1 Lire l\u2019Input depuis Console","text":"<pre><code>String name = console.readLine(\"Name: \");\n</code></pre> <p><code>readLine()</code> affiche un prompt et lit une ligne compl\u00e8te d\u2019entr\u00e9e.</p> <p></p>"},{"location":"fr/module-08/io-user/#3662-lire-des-mots-de-passe-de-maniere-securisee","title":"36.6.2 Lire des Mots de Passe de Mani\u00e8re S\u00e9curis\u00e9e","text":"<p>Console permet de lire des mots de passe sans afficher les caract\u00e8res.</p> <pre><code>char[] password = console.readPassword(\"Password: \");\n</code></pre> <p>Note</p> <p>Les mots de passe sont retourn\u00e9s en <code>char[]</code> afin qu\u2019ils puissent \u00eatre effac\u00e9s de la m\u00e9moire.</p> <p></p>"},{"location":"fr/module-08/io-user/#367-formater-loutput-de-la-console","title":"36.7 Formater l\u2019Output de la Console","text":"<p>Console supporte aussi une sortie format\u00e9e, similaire \u00e0 PrintStream.</p> <pre><code>console.printf(\"Welcome %s%n\", name);\n</code></pre> <p>Ceci utilise les m\u00eames sp\u00e9cificateurs de format que <code>printf()</code>.</p> <p></p>"},{"location":"fr/module-08/io-user/#368-comparaison-entre-console-scanner-et-bufferedreader","title":"36.8 Comparaison entre Console, Scanner et BufferedReader","text":"API Cas d\u2019usage Points forts Limitations <code>BufferedReader</code> Entr\u00e9e textuelle simple Rapide, pr\u00e9visible, charset explicite Parsing manuel <code>Scanner</code> Entr\u00e9e bas\u00e9e sur tokens / parsing Pratique, expressive Plus lente, comportement des tokens subtil <code>Console</code> Apps console interactives Mots de passe, prompts, E/S format\u00e9es Peut ne pas \u00eatre disponible (<code>null</code>)"},{"location":"fr/module-08/io-user/#369-redirection-et-flux-standard","title":"36.9 Redirection et Flux Standard","text":"<p>Les flux standard peuvent \u00eatre redirig\u00e9s par le syst\u00e8me d\u2019exploitation. Le code Java ne doit pas changer.</p> <pre><code>java App &lt; input.txt &gt; output.txt\n</code></pre> <p>Du point de vue du programme, <code>System.in</code> et <code>System.out</code> se comportent encore comme des flux normaux.</p> <p>Note</p> <p>La redirection est g\u00e9r\u00e9e par le syst\u00e8me d\u2019exploitation ou par le shell. Le code Java ne doit pas changer pour la supporter.</p> <p></p>"},{"location":"fr/module-08/io-user/#3610-pieges-communs-et-bonnes-pratiques","title":"36.10 Pi\u00e8ges Communs et Bonnes Pratiques","text":"<ul> <li>PrintStream supprime les IOExceptions</li> <li><code>System.console()</code> peut retourner null</li> <li>Ne pas fermer <code>System.out</code> ou <code>System.err</code></li> <li>Scanner m\u00e9lange parsing et lecture</li> <li>Console est pr\u00e9f\u00e9rable pour les mots de passe</li> <li>Si tu utilises <code>Scanner</code> sur <code>System.in</code>, ne ferme pas le Scanner si d\u2019autres parties du programme doivent encore lire depuis <code>System.in</code> (fermer le Scanner ferme <code>System.in</code>).</li> </ul>"},{"location":"fr/module-08/io-user/#3611-synthese-finale","title":"36.11 Synth\u00e8se Finale","text":"<ul> <li><code>System.out</code> et <code>System.err</code> sont des PrintStream pour la sortie</li> <li><code>System.in</code> est un flux d\u2019octets qui doit \u00eatre adapt\u00e9 pour le texte</li> <li><code>BufferedReader</code> et <code>Scanner</code> sont des strat\u00e9gies communes d\u2019entr\u00e9e</li> <li><code>Console</code> fournit une entr\u00e9e et une sortie interactives s\u00fbres</li> <li>Les flux standard s\u2019int\u00e8grent naturellement avec la redirection du syst\u00e8me d\u2019exploitation</li> </ul>"},{"location":"fr/module-09/jpms-compiling/","title":"38. Compiler, Empaqueter et Ex\u00e9cuter des Modules","text":""},{"location":"fr/module-09/jpms-compiling/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>38.1 Le Module Path vs le Classpath</li> <li>38.2 Options de Ligne de Commande Relatives aux Modules<ul> <li>38.2.1 Options Disponibles dans java et javac</li> <li>38.2.2 Options Applicables Uniquement \u00e0 javac</li> <li>38.2.3 Options Applicables Uniquement \u00e0 java</li> <li>38.2.4 Distinctions Importantes</li> </ul> </li> <li>38.3 Compiler un Module Unique</li> <li>38.4 Compiler des Modules Multiples Interd\u00e9pendants</li> <li>38.5 Empaqueter un Module dans un JAR Modulaire</li> <li>38.6 Ex\u00e9cuter une Application Modulaire</li> <li>38.7 Explication des Directives de Module<ul> <li>38.7.1 requires</li> <li>38.7.2 requires transitive</li> <li>38.7.3 exports</li> <li>38.7.4 exports-to-qualified-exports</li> <li>38.7.5 opens</li> <li>38.7.6 opens-to-qualified-opens</li> <li>38.7.7 Table des Directives Principales</li> <li>38.7.8 Exports vs Opens \u2014 Acc\u00e8s \u00e0 la Compilation vs \u00e0 lEx\u00e9cution</li> </ul> </li> <li>38.8 Modules Nomm\u00e9s, Automatiques et Unnamed<ul> <li>38.8.1 Modules Nomm\u00e9s</li> <li>38.8.2 Modules Automatiques</li> <li>38.8.3 Module Unnamed</li> <li>38.8.4 R\u00e9sum\u00e9 Comparatif</li> </ul> </li> <li>38.9 Inspection des Modules et des D\u00e9pendances<ul> <li>38.9.1 D\u00e9crire les Modules avec java</li> <li>38.9.2 D\u00e9crire les JAR Modulaires</li> <li>38.9.3 Analyser les D\u00e9pendances avec jdeps</li> </ul> </li> <li>38.10 Cr\u00e9er des Images Runtime Personnalis\u00e9es avec jlink</li> <li>38.11 Cr\u00e9er des Applications Autonomes avec jpackage</li> <li>38.12 R\u00e9sum\u00e9 Final JPMS en Pratique</li> </ul> <p>Une fois qu\u2019un <code>module</code> est d\u00e9fini avec un fichier <code>module-info.java</code>, il doit \u00eatre compil\u00e9, empaquet\u00e9 et ex\u00e9cut\u00e9 \u00e0 l\u2019aide d\u2019outils conscients des modules.</p> <p>Cette section explique comment la <code>toolchain Java</code> change lorsque des modules sont impliqu\u00e9s.</p> <p></p>"},{"location":"fr/module-09/jpms-compiling/#381-le-module-path-vs-le-classpath","title":"38.1 Le Module Path vs le Classpath","text":"<p><code>JPMS</code> introduit un nouveau concept : le module path.</p> <p>Il existe aux c\u00f4t\u00e9s du classpath traditionnel, mais les deux se comportent de mani\u00e8re tr\u00e8s diff\u00e9rente.</p> Aspect Classpath Module path Structure Liste plate de JAR Modules avec identit\u00e9 Encapsulation Aucune Forte V\u00e9rification des d\u00e9pendances Aucune Stricte Split packages Autoris\u00e9s Interdits (modules nomm\u00e9s) Ordre de r\u00e9solution D\u00e9pendant de l\u2019ordre D\u00e9terministe <p>Note</p> <ul> <li>Un JAR plac\u00e9 sur le <code>module path</code> devient un <code>module nomm\u00e9 (ou automatique)</code>.</li> <li>Un JAR plac\u00e9 sur le classpath est trait\u00e9 comme faisant partie du <code>module non nomm\u00e9</code>.</li> <li>Les split packages sont autoris\u00e9s sur le classpath mais interdits pour les modules nomm\u00e9s sur le module path.</li> </ul> <p></p>"},{"location":"fr/module-09/jpms-compiling/#382-options-de-ligne-de-commande-relatives-aux-modules","title":"38.2 Options de Ligne de Commande Relatives aux Modules","text":"<p>Lorsqu\u2019on travaille avec le Java Module System, <code>java</code> et <code>javac</code> fournissent des options sp\u00e9cifiques pour compiler et ex\u00e9cuter des applications modulaires. </p> <p>Certaines options sont communes, tandis que d\u2019autres sont sp\u00e9cifiques \u00e0 un outil.</p> <p></p>"},{"location":"fr/module-09/jpms-compiling/#3821-options-disponibles-dans-java-et-javac","title":"38.2.1 Options Disponibles dans <code>java</code> et <code>javac</code>","text":"<p>Ces options peuvent \u00eatre utilis\u00e9es aussi bien lors de la compilation que lors de l\u2019ex\u00e9cution :</p> <ul> <li> <p><code>--module</code> ou <code>-m</code>   Utilis\u00e9e pour compiler ou ex\u00e9cuter uniquement le module sp\u00e9cifi\u00e9.</p> </li> <li> <p><code>--module-path</code> ou <code>-p</code>   Sp\u00e9cifie les chemins dans lesquels <code>java</code> ou <code>javac</code> rechercheront les d\u00e9finitions de modules.</p> </li> </ul> <p></p>"},{"location":"fr/module-09/jpms-compiling/#3822-options-applicables-uniquement-a-javac","title":"38.2.2 Options Applicables Uniquement \u00e0 <code>javac</code>","text":"<p>Ces options s\u2019appliquent uniquement \u00e0 la phase de compilation :</p> <ul> <li> <p><code>--module-source-path</code>   (aucun raccourci)   Utilis\u00e9e par <code>javac</code> pour localiser les d\u00e9finitions des modules source.</p> </li> <li> <p><code>-d</code>   Sp\u00e9cifie le r\u00e9pertoire de sortie dans lequel les fichiers <code>.class</code> seront g\u00e9n\u00e9r\u00e9s apr\u00e8s la compilation.</p> </li> </ul> <p></p>"},{"location":"fr/module-09/jpms-compiling/#3823-options-applicables-uniquement-a-java","title":"38.2.3 Options Applicables Uniquement \u00e0 <code>java</code>","text":"<p>Ces options s\u2019appliquent uniquement \u00e0 la phase d\u2019ex\u00e9cution :</p> <ul> <li> <p><code>--list-modules</code>   (aucun raccourci)   Liste tous les modules observables puis termine.</p> </li> <li> <p><code>--show-module-resolution</code>   (aucun raccourci)   Affiche les d\u00e9tails de la r\u00e9solution des modules lors du d\u00e9marrage de l\u2019application.</p> </li> <li> <p><code>--describe-module</code> ou <code>-d</code>   D\u00e9crit un module sp\u00e9cifi\u00e9 puis termine.</p> </li> </ul> <p></p>"},{"location":"fr/module-09/jpms-compiling/#3824-distinctions-importantes","title":"38.2.4 Distinctions Importantes","text":"<p>L\u2019option <code>-d</code> a des significations diff\u00e9rentes selon l\u2019outil :</p> <ul> <li>Dans <code>javac</code>, <code>-d</code> d\u00e9finit le r\u00e9pertoire de sortie des fichiers de classes compil\u00e9s.</li> <li>Dans <code>java</code>, <code>-d</code> est un raccourci pour <code>--describe-module</code>.</li> </ul> <p>De plus, <code>-d</code> ne doit pas \u00eatre confondue avec <code>-D</code> (D majuscule).</p> <ul> <li><code>-D</code> est utilis\u00e9e lors de l\u2019ex\u00e9cution d\u2019un programme Java pour d\u00e9finir des propri\u00e9t\u00e9s syst\u00e8me sous forme de paires nom-valeur sur la ligne de commande.</li> </ul> <pre><code>java -Dconfig.file=app.properties com.example.Main\n</code></pre> <p>Dans cet exemple, <code>-Dconfig.file=app.properties</code> d\u00e9finit une propri\u00e9t\u00e9 syst\u00e8me accessible \u00e0 l\u2019ex\u00e9cution via <code>System.getProperty(\"config.file\")</code>.</p> <p></p>"},{"location":"fr/module-09/jpms-compiling/#383-compiler-un-module-unique","title":"38.3 Compiler un Module Unique","text":"<p>Pour compiler un module, vous devez sp\u00e9cifier le chemin des sources du module et le r\u00e9pertoire de destination.</p> <pre><code>javac -d out \\\nsrc/com.example.hello/module-info.java \\\nsrc/com.example.hello/com/example/hello/Main.java\n</code></pre> <p>Une approche plus \u00e9volutive utilise <code>--module-source-path</code>.</p> <pre><code>javac --module-source-path src \\\n      -d out \\\n      $(find src -name \"*.java\")\n</code></pre> <p>Note</p> <p><code>--module-source-path</code> indique \u00e0 javac o\u00f9 trouver plusieurs modules \u00e0 la fois.</p> <p></p>"},{"location":"fr/module-09/jpms-compiling/#384-compiler-des-modules-multiples-interdependants","title":"38.4 Compiler des Modules Multiples Interd\u00e9pendants","text":"<p>Lorsque des modules d\u00e9pendent les uns des autres, leurs d\u00e9pendances doivent \u00eatre r\u00e9solubles \u00e0 la compilation.</p> <p><code>--module-path</code> mods (r\u00e9pertoire d\u2019exemple contenant des modules interd\u00e9pendants) doit contenir des JAR modulaires d\u00e9j\u00e0 compil\u00e9s ou des r\u00e9pertoires de modules compil\u00e9s (chacun avec son propre module-info.class).</p> <pre><code>javac -d out \\\n--module-source-path src \\\n--module-path mods \\\n$(find src -name \"*.java\")\n</code></pre> <p>Ici : - <code>--module-source-path</code> localise les arbres de sources des modules - <code>--module-path</code> fournit des modules d\u00e9j\u00e0 compil\u00e9s</p> <p></p>"},{"location":"fr/module-09/jpms-compiling/#385-empaqueter-un-module-dans-un-jar-modulaire","title":"38.5 Empaqueter un Module dans un JAR Modulaire","text":"<p>Apr\u00e8s la compilation, les modules sont g\u00e9n\u00e9ralement empaquet\u00e9s sous forme de fichiers JAR.</p> <p>Un JAR modulaire contient un <code>module-info.class</code> \u00e0 sa racine.</p> <p>Si <code>module-info.class</code> est pr\u00e9sent, le JAR devient automatiquement un <code>module nomm\u00e9</code> et son <code>nom</code> est pris depuis le descripteur (et non depuis le nom du fichier).</p> <pre><code>jar --create \\\n--file mods/com.example.hello.jar \\\n--main-class com.example.hello.Main \\\n-C out/com.example.hello .\n</code></pre> <p>Note</p> <p>Un JAR avec <code>module-info.class</code> est un <code>module nomm\u00e9, pas un module automatique</code>. Lorsqu\u2019un JAR contient un <code>module-info.class</code>, son nom de module est pris depuis ce fichier et n\u2019est pas d\u00e9duit du nom du fichier.</p> <p></p>"},{"location":"fr/module-09/jpms-compiling/#386-executer-une-application-modulaire","title":"38.6 Ex\u00e9cuter une Application Modulaire","text":"<p>Pour ex\u00e9cuter une application modulaire, vous utilisez le <code>module path</code> et sp\u00e9cifiez le <code>nom du module</code>.</p> <pre><code>java --module-path mods \\\n--module com.example.hello/com.example.hello.Main\n</code></pre> <p>Vous pouvez raccourcir cela en utilisant les options <code>-p</code> et <code>-m</code>.</p> <pre><code>java -p mods -m com.example.hello/com.example.hello.Main\n</code></pre> <p>Note</p> <p>Lors de l\u2019utilisation de modules nomm\u00e9s, le classpath est ignor\u00e9 pour la r\u00e9solution des d\u00e9pendances entre modules.</p> <p></p>"},{"location":"fr/module-09/jpms-compiling/#387-explication-des-directives-de-module","title":"38.7 Explication des Directives de Module","text":"<p>Le fichier <code>module-info.java</code> contient des directives qui d\u00e9crivent les d\u00e9pendances, la visibilit\u00e9 et les services.</p> <p>Chaque directive a une signification pr\u00e9cise.</p> <p></p>"},{"location":"fr/module-09/jpms-compiling/#3871-requires","title":"38.7.1 <code>requires</code>","text":"<p>La directive <code>requires</code> d\u00e9clare une d\u00e9pendance vers un autre module.</p> <p>Sans elle, les types du module d\u00e9pendant ne peuvent pas \u00eatre utilis\u00e9s.</p> <pre><code>module com.example.app {\n    requires com.example.lib;\n}\n</code></pre> <p>Effets de requires : - La d\u00e9pendance doit \u00eatre pr\u00e9sente \u00e0 la compilation et \u00e0 l\u2019ex\u00e9cution - Les packages export\u00e9s du module requis deviennent accessibles</p> <p></p>"},{"location":"fr/module-09/jpms-compiling/#3872-requires-transitive","title":"38.7.2 <code>requires transitive</code>","text":"<p><code>requires transitive</code> expose une d\u00e9pendance aux modules en aval.</p> <p>Il propage la lisibilit\u00e9.</p> <pre><code>module com.example.lib {\n    requires transitive com.example.util;\n    exports com.example.lib.api;\n}\n</code></pre> <p>Signification : - Tout module qui requiert com.example.lib lit automatiquement com.example.util - Les appelants n\u2019ont pas besoin de d\u00e9clarer requires com.example.util explicitement</p> <p>Note</p> <p>Cela est similaire aux \u00ab d\u00e9pendances publiques \u00bb dans d\u2019autres syst\u00e8mes de modules.</p> <p>Lisible \u2260 export\u00e9 : une d\u00e9pendance transitive n\u2019exporte pas automatiquement vos packages.</p> <p></p>"},{"location":"fr/module-09/jpms-compiling/#3873-exports","title":"38.7.3 <code>exports</code>","text":"<p><code>exports</code> rend un package accessible aux autres modules.</p> <p>Seuls les packages export\u00e9s sont visibles \u00e0 l\u2019ext\u00e9rieur du module.</p> <pre><code>module com.example.lib {\n    exports com.example.lib.api;\n}\n</code></pre> <p>Les packages non export\u00e9s restent fortement encapsul\u00e9s.</p> <p></p>"},{"location":"fr/module-09/jpms-compiling/#3874-exports-to-exports-qualifies","title":"38.7.4 <code>exports ... to</code> (Exports Qualifi\u00e9s)","text":"<p>Un export qualifi\u00e9 restreint l\u2019acc\u00e8s \u00e0 des modules sp\u00e9cifiques.</p> <pre><code>module com.example.lib {\n    exports com.example.internal to com.example.friend;\n}\n</code></pre> <p>Seuls les modules list\u00e9s peuvent acc\u00e9der au package export\u00e9.</p> <p></p>"},{"location":"fr/module-09/jpms-compiling/#3875-opens","title":"38.7.5 <code>opens</code>","text":"<p><code>opens</code> permet un acc\u00e8s r\u00e9flexif profond \u00e0 un package.</p> <p>Il est principalement utilis\u00e9 par des frameworks utilisant la r\u00e9flexion.</p> <pre><code>module com.example.app {\n    opens com.example.app.model;\n}\n</code></pre> <p>Note</p> <p>opens NE rend PAS un package accessible \u00e0 la compilation. Il affecte uniquement la r\u00e9flexion \u00e0 l\u2019ex\u00e9cution.</p> <p></p>"},{"location":"fr/module-09/jpms-compiling/#3876-opens-to-opens-qualifies","title":"38.7.6 <code>opens ... to</code> (Opens Qualifi\u00e9s)","text":"<p>Vous pouvez restreindre l\u2019acc\u00e8s r\u00e9flexif \u00e0 des modules sp\u00e9cifiques.</p> <pre><code>module com.example.app {\n    opens com.example.app.model to com.fasterxml.jackson.databind;\n}\n</code></pre> <p>Note</p> <p><code>opens</code> affecte la r\u00e9flexion ; <code>exports</code> affecte la compilation et la visibilit\u00e9 des types.</p> <p></p>"},{"location":"fr/module-09/jpms-compiling/#3877-table-des-directives-principales","title":"38.7.7 Table des Directives Principales","text":"Directive But <code>requires</code> D\u00e9clarer une d\u00e9pendance <code>requires transitive</code> Propager une d\u00e9pendance <code>exports</code> Exposer un package <code>exports ... to</code> Exposer \u00e0 des modules sp\u00e9cifiques <code>opens</code> Autoriser la r\u00e9flexion \u00e0 l\u2019ex\u00e9cution <code>opens ... to</code> Restreindre l\u2019acc\u00e8s r\u00e9flexif"},{"location":"fr/module-09/jpms-compiling/#3878-exports-vs-opens-acces-a-la-compilation-vs-a-lexecution","title":"38.7.8 Exports vs Opens \u2014 Acc\u00e8s \u00e0 la Compilation vs \u00e0 lEx\u00e9cution","text":"Visibilit\u00e9 Compilation ? R\u00e9flexion \u00e0 l\u2019ex\u00e9cution ? <code>exports</code> Oui Non <code>opens</code> Non Oui <code>exports ... to</code> Oui (modules limit\u00e9s) Non <code>opens ... to</code> Non Oui (modules limit\u00e9s) <p>Important</p> <p><code>JPMS</code> ajoute un <code>module path</code>, mais le <code>classpath</code> existe toujours. Ils peuvent coexister, mais les modules nomm\u00e9s ont la priorit\u00e9.</p> <p></p>"},{"location":"fr/module-09/jpms-compiling/#388-modules-nommes-automatiques-et-unnamed","title":"38.8 Modules Nomm\u00e9s, Automatiques et Unnamed","text":"<p><code>JPMS</code> supporte diff\u00e9rents types de modules afin de permettre une migration progressive depuis le classpath.</p> <p>JPMS doit interop\u00e9rer avec du code legacy.</p> <p>Pour supporter l\u2019adoption progressive, la JVM reconna\u00eet trois cat\u00e9gories diff\u00e9rentes de modules.</p> <p></p>"},{"location":"fr/module-09/jpms-compiling/#3881-modules-nommes","title":"38.8.1 Modules Nomm\u00e9s","text":"<p>Un <code>module nomm\u00e9</code> poss\u00e8de un <code>module-info.class</code> et une identit\u00e9 stable.</p> <ul> <li>Encapsulation forte</li> <li>D\u00e9pendances explicites</li> <li>Support complet JPMS</li> </ul> <p></p>"},{"location":"fr/module-09/jpms-compiling/#3882-modules-automatiques","title":"38.8.2 Modules Automatiques","text":"<p>Un JAR sans <code>module-info</code> plac\u00e9 sur le <code>module path</code> devient un <code>module automatique</code>.</p> <p>Son nom est d\u00e9riv\u00e9 du nom du fichier JAR.</p> <ul> <li>Lit tous les autres modules</li> <li>Exporte tous les packages</li> <li>Pas d\u2019encapsulation forte</li> </ul> <p>Note</p> <p>Les modules automatiques existent pour faciliter la migration. Ils ne conviennent pas comme conception \u00e0 long terme.</p> <p></p>"},{"location":"fr/module-09/jpms-compiling/#3883-module-unnamed","title":"38.8.3 Module Unnamed","text":"<p>Le code sur le classpath appartient au <code>module unnamed</code>.</p> <ul> <li>Lit tous les modules nomm\u00e9s</li> <li>Tous les packages sont ouverts</li> <li>Ne peut pas \u00eatre requis par des modules nomm\u00e9s</li> </ul> <p>Note</p> <p>Le <code>module unnamed</code> pr\u00e9serve le comportement legacy du classpath.</p> <p></p>"},{"location":"fr/module-09/jpms-compiling/#3884-resume-comparatif","title":"38.8.4 R\u00e9sum\u00e9 Comparatif","text":"Type de module module-info pr\u00e9sent ? Encapsulation Lit <code>Named</code> Oui Forte D\u00e9clar\u00e9s seulement <code>Automatic</code> Non Faible Tous les modules <code>Unnamed</code> Non Aucune Tous les modules"},{"location":"fr/module-09/jpms-compiling/#389-inspection-des-modules-et-des-dependances","title":"38.9 Inspection des Modules et des D\u00e9pendances","text":""},{"location":"fr/module-09/jpms-compiling/#3891-decrire-les-modules-avec-java","title":"38.9.1 D\u00e9crire les Modules avec java","text":"<pre><code>java --describe-module java.sql\n</code></pre> <p>Cela affiche <code>exports</code>, <code>requires</code> et <code>services</code> d\u2019un module.</p> <p></p>"},{"location":"fr/module-09/jpms-compiling/#3892-decrire-les-jar-modulaires","title":"38.9.2 D\u00e9crire les JAR Modulaires","text":"<pre><code>jar --describe-module --file mylib.jar\n</code></pre>"},{"location":"fr/module-09/jpms-compiling/#3893-analyser-les-dependances-avec-jdeps","title":"38.9.3 Analyser les D\u00e9pendances avec <code>jdeps</code>","text":"<p><code>jdeps</code> analyse statiquement les d\u00e9pendances de classes et de modules.</p> <pre><code>jdeps myapp.jar\n</code></pre> <pre><code>jdeps --module-path mods --check my.module\n</code></pre> <p>Pour d\u00e9tecter l\u2019utilisation d\u2019API internes du JDK :</p> <pre><code>jdeps --jdk-internals myapp.jar\n</code></pre> <p></p>"},{"location":"fr/module-09/jpms-compiling/#3810-creer-des-images-runtime-personnalisees-avec-jlink","title":"38.10 Cr\u00e9er des Images Runtime Personnalis\u00e9es avec <code>jlink</code>","text":"<p><code>jlink</code> construit un runtime Java minimal contenant uniquement les modules requis par une application.</p> <pre><code>jlink\n--module-path $JAVA_HOME/jmods:mods\n--add-modules com.example.app\n--output runtime-image\n</code></pre> <p>Avantages : - runtime plus petit - d\u00e9marrage plus rapide - aucun module JDK inutilis\u00e9</p> <p></p>"},{"location":"fr/module-09/jpms-compiling/#3811-creer-des-applications-autonomes-avec-jpackage","title":"38.11 Cr\u00e9er des Applications Autonomes avec <code>jpackage</code>","text":"<p><code>jpackage</code> construit des installateurs sp\u00e9cifiques \u00e0 la plateforme ou des images applicatives.</p> <pre><code>jpackage\n--name MyApp\n--input mods\n--main-module com.example.app/com.example.Main\n</code></pre> <p><code>jpackage</code> peut produire : - .exe / .msi (Windows) - .pkg / .dmg (macOS) - .deb / .rpm (Linux)</p> <p></p>"},{"location":"fr/module-09/jpms-compiling/#3812-resume-final-jpms-en-pratique","title":"38.12 R\u00e9sum\u00e9 Final JPMS en Pratique","text":"<ul> <li><code>JPMS</code> introduit une <code>encapsulation forte</code> et des d\u00e9pendances fiables</li> <li>Les <code>modules</code> remplacent les conventions fragiles du classpath</li> <li>Les <code>services</code> permettent des architectures d\u00e9coupl\u00e9es</li> <li>Les <code>modules automatiques</code> et le <code>module unnamed</code> supportent la migration</li> <li><code>jlink</code> et <code>jpackage</code> permettent des mod\u00e8les modernes de d\u00e9ploiement</li> </ul>"},{"location":"fr/module-09/jpms-services/","title":"39. Services dans JPMS (Le Mod\u00e8le ServiceLoader)","text":""},{"location":"fr/module-09/jpms-services/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>39.1 Le Probl\u00e8me que les Services R\u00e9solvent<ul> <li>39.1.1 R\u00f4les dans le Mod\u00e8le de Service</li> <li>39.1.2 Module Interface de Service</li> <li>39.1.3 Module Fournisseur de Service</li> <li>39.1.4 Module Consommateur de Service</li> <li>39.1.5 Chargement des Services \u00e0 lEx\u00e9cution</li> <li>39.1.6 R\u00e8gles de R\u00e9solution des Services</li> <li>39.1.7 Couche Service Locator</li> <li>39.1.8 Sch\u00e9ma S\u00e9quentiel dInvocation</li> <li>39.1.9 Tableau R\u00e9capitulatif des Composants</li> </ul> </li> </ul> <p><code>JPMS</code> inclut un m\u00e9canisme de service int\u00e9gr\u00e9 qui permet aux <code>modules</code> de d\u00e9couvrir et dutiliser des impl\u00e9mentations \u00e0 l\u2019ex\u00e9cution sans coder en dur des d\u00e9pendances entre <code>fournisseurs</code> et <code>consommateurs</code>.</p> <p>Ce m\u00e9canisme est bas\u00e9 sur l\u2019<code>API ServiceLoader</code> existante, mais les modules le rendent fiable, explicite et s\u00fbr.</p> <p></p>"},{"location":"fr/module-09/jpms-services/#391-le-probleme-que-les-services-resolvent","title":"39.1 Le Probl\u00e8me que les Services R\u00e9solvent","text":"<p>Parfois un module doit utiliser une capacit\u00e9, mais ne devrait pas d\u00e9pendre dune impl\u00e9mentation sp\u00e9cifique.</p> <p>Des exemples typiques incluent : - frameworks de journalisation - pilotes de base de donn\u00e9es - syst\u00e8mes de plugins - fournisseurs de service s\u00e9lectionn\u00e9s \u00e0 l\u2019ex\u00e9cution</p> <p>Sans services, le consommateur devrait d\u00e9pendre directement dune impl\u00e9mentation concr\u00e8te.</p> <p>Cela cr\u00e9e un couplage fort et r\u00e9duit la flexibilit\u00e9.</p> <p></p>"},{"location":"fr/module-09/jpms-services/#3911-roles-dans-le-modele-de-service","title":"39.1.1 R\u00f4les dans le Mod\u00e8le de Service","text":"<p>Le <code>mod\u00e8le de service JPMS</code> implique quatre r\u00f4les distincts.</p> R\u00f4le Description <code>Interface de service</code> D\u00e9finit le contrat <code>Fournisseur de service</code> Impl\u00e9mente le service <code>Consommateur de service</code> Utilise le service <code>Service loader</code> D\u00e9couvre les impl\u00e9mentations \u00e0 l\u2019ex\u00e9cution <p></p>"},{"location":"fr/module-09/jpms-services/#3912-module-interface-de-service","title":"39.1.2 Module Interface de Service","text":"<p>L\u2019<code>interface de service</code> d\u00e9finit l\u2019API dont les <code>consommateurs</code> d\u00e9pendent.</p> <p>Elle doit \u00eatre export\u00e9e afin que les autres modules puissent la voir.</p> <pre><code>package com.example.service;\n\npublic interface GreetingService {\n    String greet(String name);\n}\n</code></pre> <pre><code>module com.example.service {\n    exports com.example.service;\n}\n</code></pre> <p>Note</p> <p>Le module d\u2019interface de service ne devrait contenir aucune impl\u00e9mentation.</p> <p></p>"},{"location":"fr/module-09/jpms-services/#3913-module-fournisseur-de-service","title":"39.1.3 Module Fournisseur de Service","text":"<p>Un <code>module fournisseur</code> impl\u00e9mente l\u2019interface de service et d\u00e9clare quil fournit le service.</p> <pre><code>package com.example.service.impl;\n\nimport com.example.service.GreetingService;\n\npublic class EnglishGreeting implements GreetingService {\n    public String greet(String name) {\n        return \"Hello \" + name;\n    }\n}\n</code></pre> <pre><code>module com.example.provider.english {\n    requires com.example.service;\n    provides com.example.service.GreetingService with com.example.service.impl.EnglishGreeting;\n}\n</code></pre> <p>Points cl\u00e9s : - Le <code>fournisseur</code> d\u00e9pend de l\u2019<code>interface de service</code> - La classe d\u2019impl\u00e9mentation n\u2019a pas besoin d\u2019\u00eatre export\u00e9e - La directive <code>provides</code> enregistre l\u2019impl\u00e9mentation</p> <p></p>"},{"location":"fr/module-09/jpms-services/#3914-module-consommateur-de-service","title":"39.1.4 Module Consommateur de Service","text":"<p>Le <code>module consommateur</code> d\u00e9clare quil utilise un service, mais ne nomme aucune impl\u00e9mentation.</p> <pre><code>module com.example.consumer {\n    requires com.example.service;\n    uses com.example.service.GreetingService;\n}\n</code></pre> <p>Note</p> <p><code>uses</code> d\u00e9clare l\u2019intention de d\u00e9couvrir des impl\u00e9mentations \u00e0 l\u2019ex\u00e9cution.</p> <p>Un module qui d\u00e9clare <code>uses</code> mais ne poss\u00e8de aucun fournisseur correspondant sur le module path compile normalement, mais <code>ServiceLoader</code> retourne un r\u00e9sultat vide \u00e0 l\u2019ex\u00e9cution.</p> <p></p>"},{"location":"fr/module-09/jpms-services/#3915-chargement-des-services-a-lexecution","title":"39.1.5 Chargement des Services \u00e0 lEx\u00e9cution","text":"<p>L\u2019<code>API ServiceLoader</code> effectue la d\u00e9couverte de service.</p> <p>Elle trouve tous les fournisseurs visibles pour le graphe des modules.</p> <pre><code>ServiceLoader&lt;GreetingService&gt; loader =\n    ServiceLoader.load(GreetingService.class);\n\nfor (GreetingService service : loader) {\n    System.out.println(service.greet(\"World\"));\n}\n</code></pre> <p><code>JPMS</code> garantit que seuls les fournisseurs d\u00e9clar\u00e9s sont d\u00e9couverts.</p> <p>La d\u00e9couverte \u201caccidentelle\u201d bas\u00e9e sur le classpath est emp\u00each\u00e9e.</p> <p></p>"},{"location":"fr/module-09/jpms-services/#3916-regles-de-resolution-des-services","title":"39.1.6 R\u00e8gles de R\u00e9solution des Services","text":"<p>Pour qu\u2019un service soit d\u00e9couvrable par <code>ServiceLoader</code>, plusieurs conditions doivent \u00eatre satisfaites :</p> R\u00e8gle Signification Le module fournisseur doit \u00eatre lisible R\u00e9solu par le graphe <code>requires</code> L\u2019interface de service doit \u00eatre export\u00e9e Les consommateurs doivent la voir Le consommateur doit d\u00e9clarer <code>uses</code> Sinon ServiceLoader \u00e9choue Le fournisseur doit d\u00e9clarer <code>provides</code> La d\u00e9couverte implicite est interdite <p></p>"},{"location":"fr/module-09/jpms-services/#3917-couche-service-locator","title":"39.1.7 Couche Service Locator","text":"<p>Il est possible dintroduire une couche suppl\u00e9mentaire appel\u00e9e <code>Service Locator</code>.</p> <p>Dans cette architecture :</p> <ul> <li>Le <code>consommateur</code> n\u2019utilise pas directement <code>ServiceLoader</code></li> <li>Le <code>Service Locator</code> est le seul composant qui d\u00e9clare <code>uses</code></li> <li>Le <code>consommateur</code> d\u00e9pend du <code>Service Locator</code></li> </ul> <p>Structure architecturale :</p> <pre><code>Consommateur \u2192 Service Locator \u2192 ServiceLoader \u2192 Fournisseur\n</code></pre> <p>Module du Service Locator :</p> <pre><code>module com.example.locator {\n    requires com.example.service;\n    uses com.example.service.GreetingService;\n}\n</code></pre> <p>Classe Service Locator :</p> <pre><code>package com.example.locator;\n\nimport java.util.ServiceLoader;\nimport com.example.service.GreetingService;\n\npublic class GreetingLocator {\n\n    public static GreetingService getService() {\n        return ServiceLoader\n                .load(GreetingService.class)\n                .findFirst()\n                .orElseThrow();\n    }\n}\n</code></pre> <p>Module Consommateur :</p> <pre><code>module com.example.consumer {\n    requires com.example.locator;\n}\n</code></pre> <p>Le consommateur ne d\u00e9clare pas <code>uses</code> parce quil ninvoque pas directement <code>ServiceLoader</code>.</p> <p></p>"},{"location":"fr/module-09/jpms-services/#3918-schema-sequentiel-dinvocation","title":"39.1.8 Sch\u00e9ma S\u00e9quentiel dInvocation","text":"<p>S\u00e9quence dex\u00e9cution :</p> <ol> <li>Le <code>Consommateur</code> invoque <code>GreetingLocator.getService()</code></li> <li>Le <code>Service Locator</code> invoque <code>ServiceLoader.load(...)</code></li> <li>Le <code>ServiceLoader</code> consulte le graphe des modules</li> <li>Le syst\u00e8me identifie les modules qui d\u00e9clarent <code>provides</code></li> <li>L\u2019impl\u00e9mentation du <code>Fournisseur</code> est instanci\u00e9e</li> <li>L\u2019instance est retourn\u00e9e au <code>Consommateur</code></li> </ol> <p>Sch\u00e9ma s\u00e9quentiel :</p> <pre><code>Consommateur\n   \u2502\n   \u2502 1. getService()\n   \u25bc\nService Locator\n   \u2502\n   \u2502 2. ServiceLoader.load()\n   \u25bc\nServiceLoader\n   \u2502\n   \u2502 3. R\u00e9solution du fournisseur\n   \u25bc\nImpl\u00e9mentation Fournisseur\n   \u2502\n   \u2502 4. Instance retourn\u00e9e\n   \u25bc\nConsommateur\n</code></pre> <p></p>"},{"location":"fr/module-09/jpms-services/#3919-tableau-recapitulatif-des-composants","title":"39.1.9 Tableau R\u00e9capitulatif des Composants","text":"Composant R\u00f4le exports requires uses provides SPI D\u00e9finit le contrat \u2705 \u274c \u274c \u274c Fournisseur Impl\u00e9mente le service \u274c \u2705 \u274c \u2705 Service Locator Effectue la d\u00e9couverte (optionnel) \u2705 \u2705 \u274c Consommateur Utilise le service \u274c \u2705 \u274c \u274c"},{"location":"fr/module-09/jpms/","title":"37. Java Platform Module System (JPMS)","text":""},{"location":"fr/module-09/jpms/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>37.1 Pourquoi les modules ont \u00e9t\u00e9 introduits<ul> <li>37.1.1 Probl\u00e8mes avec le classpath</li> <li>37.1.2 Exemple d\u2019un probl\u00e8me de classpath</li> </ul> </li> <li>37.2 Qu\u2019est-ce qu\u2019un module<ul> <li>37.2.1 Propri\u00e9t\u00e9s fondamentales des modules</li> <li>37.2.2 Module vs package vs JAR</li> </ul> </li> <li>37.3 Le descripteur module-infojava<ul> <li>37.3.1 Descripteur de module minimal</li> </ul> </li> <li>37.4 Structure des r\u00e9pertoires d\u2019un module</li> <li>37.5 Un premier programme modulaire<ul> <li>37.5.1 Classe principale</li> <li>37.5.2 Descripteur du module</li> </ul> </li> <li>37.6 Explication de l\u2019encapsulation forte</li> <li>37.7 Synth\u00e8se des id\u00e9es cl\u00e9s</li> </ul> <p>Le <code>Java Platform Module System</code> (JPMS) a \u00e9t\u00e9 introduit en Java 9.</p> <p>C\u2019est un m\u00e9canisme au niveau du langage et au niveau du runtime pour structurer les applications Java en unit\u00e9s fortement encapsul\u00e9es appel\u00e9es <code>modules</code>.</p> <p>JPMS influence la mani\u00e8re dont le code est : - organis\u00e9 - compil\u00e9 - li\u00e9 - empaquet\u00e9 - charg\u00e9 au runtime</p> <p>Comprendre JPMS est essentiel pour le Java moderne, en particulier pour les grandes applications, les biblioth\u00e8ques, les images de runtime et les outils de d\u00e9ploiement.</p> <p></p>"},{"location":"fr/module-09/jpms/#371-pourquoi-les-modules-ont-ete-introduits","title":"37.1 Pourquoi les modules ont \u00e9t\u00e9 introduits","text":"<p>Avant Java 9, les applications Java \u00e9taient construites en utilisant uniquement : - des <code>packages</code> - des fichiers <code>JAR</code> - le <code>classpath</code></p> <p>Ce mod\u00e8le pr\u00e9sentait des limitations s\u00e9rieuses \u00e0 mesure que les applications grandissaient.</p> <p></p>"},{"location":"fr/module-09/jpms/#3711-problemes-avec-le-classpath","title":"37.1.1 Probl\u00e8mes avec le classpath","text":"<p>Le classpath est une liste plate de JAR dans laquelle : - toutes les classes publiques sont accessibles \u00e0 tous - il n\u2019existe pas de d\u00e9claration fiable des d\u00e9pendances - les versions en conflit sont courantes - l\u2019encapsulation est faible ou inexistante - des classes dupliqu\u00e9es s\u2019\u00e9crasent silencieusement en fonction de l\u2019ordre du classpath</p> <p>Cela a conduit \u00e0 des probl\u00e8mes bien connus tels que : - \u201cJAR hell\u201d - des bugs li\u00e9s \u00e0 l\u2019ordre du classpath - l\u2019utilisation accidentelle d\u2019API internes - des erreurs d\u2019ex\u00e9cution qui n\u2019\u00e9taient pas d\u00e9tect\u00e9es \u00e0 la compilation</p> <p></p>"},{"location":"fr/module-09/jpms/#3712-exemple-dun-probleme-de-classpath","title":"37.1.2 Exemple d\u2019un probl\u00e8me de classpath","text":"<p>Supposons que deux biblioth\u00e8ques d\u00e9pendent de versions diff\u00e9rentes du m\u00eame JAR tiers.</p> <p>Une seule version peut \u00eatre plac\u00e9e sur le classpath.</p> <p>La version choisie d\u00e9pend uniquement de l\u2019ordre du classpath, et non de l\u2019appropriation r\u00e9elle.</p> <p>Note</p> <p>Ce probl\u00e8me ne peut pas \u00eatre r\u00e9solu de mani\u00e8re fiable avec le seul outil du classpath.</p> <p></p>"},{"location":"fr/module-09/jpms/#372-quest-ce-quun-module","title":"37.2 Qu\u2019est-ce qu\u2019un module ?","text":"<p>Un <code>module</code> est une unit\u00e9 de code nomm\u00e9e et auto-descriptive.</p> <p>De mani\u00e8re synth\u00e9tique, un module est un ensemble d\u2019un ou plusieurs packages li\u00e9s, accompagn\u00e9 d\u2019un fichier descripteur de module qui d\u00e9finit explicitement ses d\u00e9pendances et les fonctionnalit\u00e9s qu\u2019il met \u00e0 disposition.  </p> <p>Un module fournit ainsi \u00e0 ses utilisateurs un ensemble de fonctionnalit\u00e9s clairement d\u00e9fini et contr\u00f4l\u00e9.</p> <p>Chaque module nomm\u00e9 poss\u00e8de un nom unique qui l\u2019identifie aupr\u00e8s du compilateur et du syst\u00e8me de modules.</p> <p>Il d\u00e9clare explicitement : - de quoi il d\u00e9pend - ce qu\u2019il expose aux autres modules - ce qu\u2019il garde cach\u00e9</p> <p>Un module est plus fort qu\u2019un package et plus structur\u00e9 qu\u2019un JAR.</p> <p></p>"},{"location":"fr/module-09/jpms/#3721-proprietes-fondamentales-des-modules","title":"37.2.1 Propri\u00e9t\u00e9s fondamentales des modules","text":"Propri\u00e9t\u00e9 Description Encapsulation forte Les packages sont cach\u00e9s par d\u00e9faut D\u00e9pendances explicites Les d\u00e9pendances doivent \u00eatre d\u00e9clar\u00e9es Configuration fiable Les d\u00e9pendances manquantes provoquent des erreurs pr\u00e9coces Identit\u00e9 nomm\u00e9e Chaque module poss\u00e8de un nom unique"},{"location":"fr/module-09/jpms/#3722-module-vs-package-vs-jar","title":"37.2.2 Module vs package vs JAR","text":"Concept But Encapsulation Package Regroupement d\u2019espace de noms Faible (public reste visible) JAR Empaquetage / d\u00e9ploiement Aucune (toutes les classes visibles lorsqu\u2019elles sont sur le classpath) Module Encapsulation + unit\u00e9 de d\u00e9pendance Forte (packages non export\u00e9s cach\u00e9s)"},{"location":"fr/module-09/jpms/#373-le-descripteur-module-infojava","title":"37.3 Le descripteur <code>module-info.java</code>","text":"<p>Chaque <code>module nomm\u00e9</code> est d\u00e9fini par un fichier descripteur de module appel\u00e9 :</p> <pre><code>module-info.java\n</code></pre> <p>Ce fichier d\u00e9crit le module au compilateur et au runtime.</p> <p></p>"},{"location":"fr/module-09/jpms/#3731-descripteur-de-module-minimal","title":"37.3.1 Descripteur de module minimal","text":"<p>Un descripteur de module minimal d\u00e9clare uniquement le nom du module. Le nom du fichier doit \u00eatre exactement <code>module-info.java</code>, et il doit se trouver \u00e0 la racine de l\u2019arbre des sources du module.</p> <pre><code>module com.example.hello {\n}\n</code></pre> <p>Note</p> <p>Un module sans directives n\u2019exporte rien et ne d\u00e9pend de rien.</p> <p></p>"},{"location":"fr/module-09/jpms/#374-structure-des-repertoires-dun-module","title":"37.4 Structure des r\u00e9pertoires d\u2019un module","text":"<p>Un projet modulaire suit une structure standard de r\u00e9pertoires.</p> <p>Le descripteur du module se trouve \u00e0 la racine de l\u2019arbre des sources du module.</p> <pre><code>src/\n\u2514\u2500 com.example.hello/\n    \u251c\u2500 module-info.java\n    \u2514\u2500 com/\n        \u2514\u2500 example/\n            \u2514\u2500 hello/\n                \u2514\u2500 Main.java\n</code></pre> <p>Points cl\u00e9s : - Le nom du r\u00e9pertoire correspond au nom du module - <code>module-info.java</code> se trouve en haut de la racine des sources du module - les packages suivent les r\u00e8gles standard de nommage Java</p> <p>Note</p> <p>Dans les projets IDE et build-tool, la structure des fichiers peut diff\u00e9rer (par ex. Maven utilise <code>src/main/java</code>). Ce qui reste toujours vrai : <code>module-info.java</code> se trouve \u00e0 la racine de l\u2019arbre des sources du module et les chemins des packages suivent le nommage standard Java.</p> <p></p>"},{"location":"fr/module-09/jpms/#375-un-premier-programme-modulaire","title":"37.5 Un premier programme modulaire","text":"<p>Cr\u00e9ons une application modulaire minimale.</p> <p></p>"},{"location":"fr/module-09/jpms/#3751-classe-principale","title":"37.5.1 Classe principale","text":"<pre><code>package com.example.hello;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, modular world!\");\n    }\n}\n</code></pre>"},{"location":"fr/module-09/jpms/#3752-descripteur-du-module","title":"37.5.2 Descripteur du module","text":"<pre><code>module com.example.hello {\n    exports com.example.hello;\n}\n</code></pre> <p>La <code>directive exports</code> rend le package accessible aux autres modules.</p> <p>Sans elle, le package est encapsul\u00e9 et inaccessible.</p> <p></p>"},{"location":"fr/module-09/jpms/#376-explication-de-lencapsulation-forte","title":"37.6 Explication de l\u2019encapsulation forte","text":"<p>Dans <code>JPMS</code>, les packages NE sont PAS accessibles par d\u00e9faut.</p> <p>M\u00eame les classes public sont cach\u00e9es \u00e0 moins d\u2019\u00eatre export\u00e9es explicitement.</p> <p>Dans les modules, <code>public</code> signifie \u201cpublic vers les autres modules seulement si le package conteneur est export\u00e9.\u201d</p> Situation Accessible depuis un autre module ? Classe public dans un package non export\u00e9 Non Classe public dans un package export\u00e9 Oui Membre protected dans un package export\u00e9 Oui, mais seulement via h\u00e9ritage (pas acc\u00e8s g\u00e9n\u00e9ral) Classe/membre package-private (n\u2019importe quel package) Non Membre private Non <p>Note</p> <p>C\u2019est une diff\u00e9rence fondamentale par rapport au mod\u00e8le bas\u00e9 sur le classpath.</p> <p></p>"},{"location":"fr/module-09/jpms/#377-synthese-des-idees-cles","title":"37.7 Synth\u00e8se des id\u00e9es cl\u00e9s","text":"<ul> <li><code>JPMS</code> introduit les modules comme unit\u00e9s fortes d\u2019encapsulation</li> <li>Les d\u00e9pendances sont explicites et v\u00e9rifi\u00e9es</li> <li><code>module-info.java</code> est le descripteur central</li> <li>Les packages sont cach\u00e9s sauf s\u2019ils sont export\u00e9s</li> <li>La visibilit\u00e9 bas\u00e9e sur le classpath ne s\u2019applique plus dans les modules</li> <li>La visibilit\u00e9 public n\u2019est plus suffisante : les exports du module contr\u00f4lent l\u2019accessibilit\u00e9</li> </ul>"},{"location":"it/","title":"Indice","text":"<p>\ud83c\udf0d Lingua: English | Italiano | Fran\u00e7ais</p>"},{"location":"it/#indice-del-corso-java-21","title":"Indice del corso (Java 21)","text":""},{"location":"it/#module-00-prerequisites-setup","title":"Module 00 \u2014 Prerequisites &amp; Setup","text":"<ul> <li>Materiale propedeutico</li> <li>Eclipse shortcuts</li> </ul>"},{"location":"it/#module-01-java-language-basics","title":"Module 01 \u2014 Java Language Basics","text":"<ul> <li>1. Mattoni Sintattici di Base</li> <li>2. Mattoni di base del linguaggio Java</li> <li>3. Regole di naming Java</li> <li>4. Tipi di dato Java e casting</li> <li>5. Operatori Java</li> <li>6. Istanziazione dei tipi</li> </ul>"},{"location":"it/#module-02-control-flow","title":"Module 02 \u2014 Control Flow","text":"<ul> <li>7. Flusso di controllo</li> <li>8. Costrutti di iterazione in Java</li> </ul>"},{"location":"it/#module-03-core-standard-apis","title":"Module 03 \u2014 Core Standard APIs","text":"<ul> <li>9. Stringhe in Java</li> <li>10. Array in Java</li> <li>11. Matematica in Java</li> <li>12. Data e ora in Java</li> <li>13. Formattazione e Localizzazione in Java</li> </ul>"},{"location":"it/#module-04-object-oriented-fundamentals","title":"Module 04 \u2014 Object-Oriented Fundamentals","text":"<ul> <li>14. Metodi, Attributi e Variabili</li> <li>15. Caricamento delle Classi, Inizializzazione e Costruzione degli Oggetti</li> <li>16. Ereditariet\u00e0 in Java</li> <li>17. Oltre le Classi</li> <li>18. Generics in Java</li> <li>19. Eccezioni e Gestione degli Errori</li> </ul>"},{"location":"it/#module-05-functional-programming","title":"Module 05 \u2014 Functional Programming","text":"<ul> <li>20. Programmazione Funzionale in Java</li> <li>21. Java Optional e Streams</li> </ul>"},{"location":"it/#module-06-collections-framework","title":"Module 06 \u2014 Collections Framework","text":"<ul> <li>22. Introduzione al Framework delle Collezioni</li> <li>23. Operazioni Condivise delle Collezioni &amp; Uguaglianza</li> <li>24. Comparable, Comparator &amp; Ordinamento in Java</li> <li>25. La API List</li> <li>26. Set API</li> <li>27. API Queue &amp; Deque</li> <li>28. Map API</li> <li>29. Collezioni Sequenziate &amp; Map Sequenziate</li> </ul>"},{"location":"it/#module-07-concurrency-and-threads","title":"Module 07 \u2014 Concurrency and Threads","text":"<ul> <li>30. Thread Java \u2013 Fondamenti e Modello di Esecuzione</li> <li>31. Java Concurrency APIs</li> </ul>"},{"location":"it/#module-08-java-io-and-nio","title":"Module 08 \u2014 Java I/O and NIO","text":"<ul> <li>32. Fondamenti di File e Path</li> <li>33. API di Files e Path</li> <li>34. Stream I/O in Java</li> <li>35. API di I/O Java (Legacy e NIO)</li> <li>36. Interagire con l\u2019Utente (Stream I/O Standard)</li> </ul>"},{"location":"it/#module-09-java-platform-module-system-jpms","title":"Module 09 \u2014 Java Platform Module System (JPMS)","text":"<ul> <li>37. Java Platform Module System (JPMS)</li> <li>38. Compilare, Impacchettare ed Eseguire Moduli</li> <li>39. Servizi in JPMS (Il Modello ServiceLoader)</li> </ul>"},{"location":"it/module-00/eclipse-shortcuts/","title":"Eclipse main shortcuts","text":"WIN APPLE DESCRIPTION <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + 3</code> <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + 3</code> Go to quick access search for available views, actions, wizards, menus and more <code>&lt;kbd&gt;Alt&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + Q Q</code> <code>&lt;kbd&gt;\u2325&lt;/kbd&gt; + &lt;kbd&gt;\u2318&lt;/kbd&gt; + Q Q</code> Show all available views and select one or more to open <code>F2</code> <code>F2</code> Show Javadoc for the selected element <code>F3 or &lt;kbd&gt;Ctrl&lt;/kbd&gt; + Left click</code> <code>F3 or &lt;kbd&gt;\u2318&lt;/kbd&gt; + Left click</code> In a code editor, go to the declaration of the selected symbol <code>F4</code> <code>F4</code> Show selected symbol in the \u201cType Hierarchy\u201d view <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + T</code> <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + T</code> Open dialog to search for a type (class, interface, enum) <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + Alt + H</code> <code>^ + &lt;kbd&gt;\u2325&lt;/kbd&gt; + H</code> Open selected callable symbol in the \u201cCall Hierarchy\u201d view <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + G</code> <code>&lt;kbd&gt;\u21e7&lt;/kbd&gt; + &lt;kbd&gt;\u2318&lt;/kbd&gt; + G</code> Search workspace for all references to the symbol <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + R</code> <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + R</code> Open dialog to search resources (e.g. text files) by filename <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + F</code> <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + F</code> Find/replace in the current file <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + H</code> <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + H</code> Find/replace in current file, project, or workspace <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + L</code> <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + L</code> Go to a line number <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + .</code> <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + .</code> Jump to next occurrence, warning or error <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + ,</code> <code>&lt;kbd&gt;\u21e7&lt;/kbd&gt; + &lt;kbd&gt;\u2318&lt;/kbd&gt; + .</code> Jump to previous occurrence, warning or error <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + D</code> <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + D</code> Delete line at cursor position <code>&lt;kbd&gt;Alt&lt;/kbd&gt; + \u2191</code> or <code>&lt;kbd&gt;Alt&lt;/kbd&gt; + \u2193</code> <code>&lt;kbd&gt;\u2325&lt;/kbd&gt; + \u2191</code> or <code>&lt;kbd&gt;\u2325&lt;/kbd&gt; + \u2193</code> Move current line one line above or one line below <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + Space</code> <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + Space</code> Open content assist dialog (based on current context) <code>Type \"main\", \"if\", \"for\", \"while\", \"do\", \"syso\" + &lt;kbd&gt;Ctrl&lt;/kbd&gt; + Space</code> (same as before) +  <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + Space</code> Autocomplete element <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + F</code> Format code <code>&lt;kbd&gt;Alt&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + Z</code> <code>&lt;kbd&gt;\u2325&lt;/kbd&gt; + &lt;kbd&gt;\u2318&lt;/kbd&gt; + Z</code> Toggle Try Catch and other predefined blocks of code <code>&lt;kbd&gt;Alt&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + A</code> <code>&lt;kbd&gt;\u2325&lt;/kbd&gt; + &lt;kbd&gt;\u2318&lt;/kbd&gt; + A</code> Toggle block / column selection in the current text editor <code>&lt;kbd&gt;Alt&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + R</code> <code>&lt;kbd&gt;\u2325&lt;/kbd&gt; + &lt;kbd&gt;\u2318&lt;/kbd&gt; + R</code> Rename (variable, field, method, class...) <code>&lt;kbd&gt;Alt&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + S</code> <code>&lt;kbd&gt;\u2325&lt;/kbd&gt; + &lt;kbd&gt;\u2318&lt;/kbd&gt; + S</code> Show advanced editing operations for current selection <code>&lt;kbd&gt;Alt&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + T</code> <code>&lt;kbd&gt;\u2325&lt;/kbd&gt; + &lt;kbd&gt;\u2318&lt;/kbd&gt; + T</code> Show available refactoring operations for current selection <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + 1</code> <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + 1</code> Show all possible fixes for a problem (on a text element with a problem marker, or in the problem view) <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + C</code> <code>&lt;kbd&gt;\u2318&lt;/kbd&gt; + /</code> Add/Remove line comment <code>&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;\u21e7&lt;/kbd&gt; + /</code> <code>^ + &lt;kbd&gt;\u2318&lt;/kbd&gt; + /</code> Add/Remove block line comment"},{"location":"it/module-00/prerequisites/","title":"Prerequisite material for the course","text":"<p>This is all the prerequisite material you will need for the course</p> <p></p>"},{"location":"it/module-00/prerequisites/#documentation","title":"DOCUMENTATION","text":"<ul> <li>Java 21 APIs -  Java 21 API Specification</li> <li>Eclipse shortcuts - Eclipse IDE shortcuts</li> </ul>"},{"location":"it/module-00/prerequisites/#editor","title":"EDITOR","text":"<ul> <li>Eclipse IDE - Download Eclipse here</li> </ul>"},{"location":"it/module-00/prerequisites/#pandoc","title":"PANDOC","text":"<ul> <li>Pandoc - Download Pandoc here</li> </ul>"},{"location":"it/module-01/basic-building-blocks/","title":"2. Mattoni di base del linguaggio Java","text":""},{"location":"it/module-01/basic-building-blocks/#indice","title":"Indice","text":"<ul> <li>2.1 Definizione di classe</li> <li>2.2 Commenti</li> <li>2.3 Modificatori di accesso</li> <li>2.4 Package<ul> <li>2.4.1 Organizzazione e scopo</li> <li>2.4.2 Mappatura con il file system e dichiarazione di un package</li> <li>2.4.3 Appartenere allo stesso package</li> <li>2.4.4 Importare da un package</li> <li>2.4.5 Import statici<ul> <li>2.4.5.1 Regole di precedenza</li> </ul> </li> <li>2.4.6 Package standard vs. package definiti dall\u2019utente</li> </ul> </li> <li>2.5 Il metodo main<ul> <li>2.5.1 Firma del metodo main</li> </ul> </li> <li>2.6 Compilare ed eseguire il codice<ul> <li>2.6.1 Compilare un file, package di default (singola directory)</li> <li>2.6.2 Pi\u00f9 file, package di default (singola directory)</li> <li>2.6.3 Codice dentro package (layout standard src \u2192 out)</li> <li>2.6.4 Compilare verso un\u2019altra directory (-d)</li> <li>2.6.5 Pi\u00f9 file su pi\u00f9 package (compilare l\u2019intero albero sorgente)</li> <li>2.6.6 Esecuzione di un singolo sorgente (run veloce senza javac)</li> <li>2.6.7 Passare parametri a un programma Java</li> </ul> </li> </ul> <p>Questo capitolo introduce gli elementi strutturali essenziali di un programma Java: <code>class</code>, <code>method</code>, <code>comment</code>, <code>access modifier</code>, <code>package</code>, il metodo <code>main</code> e i comandi di base da riga di comando (<code>javac</code> e <code>java</code>).</p> <p>Questi sono gli elementi minimi indispensabili per scrivere, compilare, organizzare ed eseguire codice Java utilizzando il JDK (Java Development Kit) \u2014 senza ricorrere ad alcun IDE (Integrated Development Environment).</p> <p></p>"},{"location":"it/module-01/basic-building-blocks/#21-definizione-di-classe","title":"2.1 Definizione di classe","text":"<p>Una <code>class</code> Java \u00e8 il mattone fondamentale di un programma Java. </p> <p>Una <code>classe</code> rappresenta un tipo di dato definito dall\u2019utente, costituito da un insieme di dati interni (<code>fields</code>) e dalle operazioni che possono agire su di essi (<code>methods</code>).</p> <p>Una <code>class</code> \u00e8 un blueprint (modello), mentre gli <code>object</code> sono istanze concrete create a runtime sulla base di questo modello.</p> <p>Una classe Java \u00e8 composta da due elementi principali, detti membri della classe:</p> <ul> <li>Field (o variabili): rappresentano i dati che definiscono lo stato del nuovo tipo.</li> <li>Method (o funzioni): rappresentano le operazioni che possono essere eseguite su questi dati.</li> </ul> <p>Alcuni membri possono essere dichiarati con la keyword static.</p> <p>Un membro static appartiene alla classe stessa, non agli oggetti creati da essa.</p> <p>Ci\u00f2 significa che:</p> <ul> <li>esiste una sola copia condivisa tra tutte le istanze</li> <li>il membro pu\u00f2 essere utilizzato senza dover creare un oggetto della classe</li> <li>esso \u00e8 caricato in memoria quando la classe viene caricata dalla JVM</li> </ul> <p>I membri non statici (detti di istanza) appartengono invece ai singoli oggetti e ogni istanza ne possiede la propria copia.</p> <p>Normalmente, ogni classe \u00e8 definita nel proprio file \".java\"; per esempio, una classe chiamata <code>Person</code> sar\u00e0 definita nel corrispondente file <code>Person.java</code>.</p> <p>Qualsiasi classe definita in modo indipendente nel proprio file sorgente \u00e8 detta top-level class.</p> <p>Una classe di questo tipo pu\u00f2 essere dichiarata solo come <code>public</code> oppure con il modificatore di accesso di default (<code>package-private</code>, cio\u00e8 senza alcun access modifier esplicito).</p> <p>Un singolo file, tuttavia, pu\u00f2 contenere pi\u00f9 di una definizione di classe. In questo caso, solo una classe pu\u00f2 essere dichiarata <code>public</code>, e il nome del file deve corrispondere a quella classe.</p> <p>Le nested class, ovvero classi dichiarate all\u2019interno di un\u2019altra classe, possono usare qualunque modificatore di accesso: <code>public</code>, <code>protected</code>, <code>private</code>, <code>default</code> (package-private).</p> <ul> <li>Esempio:</li> </ul> <pre><code>public class Person {\n\n    // This is a comment: explains the code but is ignored by the compiler. See section below.\n\n    // Field \u2192 defines data/state\n    String personName;\n\n    // Method \u2192 defines behavior (this one take a parameter, newName, in input but does not return a value)\n    void setPersonName(String newName) {\n        personName = newName;\n    }\n\n    // Method \u2192 defines behavior  (this one does not take parameters in input but does return a String)\n    String getPersonName(){\n        return personName;\n    }\n}\n</code></pre> <p>Note</p> <p>Nella sua forma pi\u00f9 semplice, potremmo teoricamente avere una classe senza metodi e senza field. Sebbene una classe del genere venga compilata, avrebbe ben poco senso pratico.</p> Token / Identifier Category Meaning Optional? public Keyword / access modifier determina quali altre classi possono usare o vedere quell\u2019elemento Mandatory (quando assente \u00e8, per default, package-private) class Keyword Dichiara un tipo di classe. Mandatory Person Class name (identifier) Il nome della classe. Mandatory personName Field name (identifier) Memorizza il nome della persona. Optional String Type / Keyword Tipo del field <code>personName</code> e del parametro <code>newName</code>. Mandatory setPersonName, getPersonName Method names (identifier) denominano un comportamento della classe. Optional newName Parameter name (identifier) input passato al metodo <code>setPersonName</code>. Mandatory (se il metodo richiede un parametro) return Keyword Termina un metodo e restituisce un valore. Mandatory (nei metodi con tipo di ritorno non void) void Return Type / Keyword Indica che il metodo non restituisce alcun valore. Mandatory (se il metodo non restituisce alcun valore) <p>Note</p> <p>Mandatory = richiesto dalla sintassi Java, Optional = non richiesto dalla sintassi; dipende dal design.</p> <p></p>"},{"location":"it/module-01/basic-building-blocks/#22-commenti","title":"2.2 Commenti","text":"<p>I commenti non sono codice eseguibile: spiegano il codice ma vengono ignorati dal compilatore.</p> <p>In Java esistono 3 tipi di commenti: - Single-line (<code>//</code>) - Multi-line (<code>/* ... */</code>) - Javadoc (<code>/** ... */</code>)</p> <p>Un single-line comment inizia con 2 slash: tutto il testo che segue sulla stessa riga viene ignorato dal compilatore.</p> <ul> <li>Esempio:</li> </ul> <pre><code>// This is a single-line comment. It starts with 2 slashes and ends at the end of the line. \n</code></pre> <p>Un multiline comment include tutto ci\u00f2 che si trova tra i simboli <code>/*</code> e <code>*/</code>.</p> <ul> <li>Esempio:</li> </ul> <pre><code>/*  \n * This is a multi-line comment.\n * It can span multiple lines.\n * All the text between its opening and closing symbols is ignored by the compiler.\n *\n */\n</code></pre> <p>Un Javadoc comment \u00e8 simile a un multiline comment, tranne per il fatto che inizia con <code>/**</code>: tutto il testo compreso tra i simboli di apertura e chiusura viene elaborato dallo strumento Javadoc per generare la documentazione delle API.</p> <pre><code>/**\n * This is a Javadoc comment\n *\n * This class represents a Person.\n * It stores a name and provides methods\n * to set and retrieve it.\n *\n * &lt;p&gt;Javadoc comments can include HTML tags,\n * and special annotations like @param and @return.&lt;/p&gt;\n */\n</code></pre> <p>Warning</p> <p>In Java, ogni block comment deve essere chiuso correttamente con <code>*/</code>.</p> <ul> <li>Esempio:</li> </ul> <pre><code>/* valid block comment */\n</code></pre> <p>va bene, ma</p> <pre><code>/* */ */\n</code></pre> <p>produrr\u00e0 un errore di compilazione perch\u00e9, mentre i primi due simboli fanno parte del commento, l\u2019ultimo no. Il simbolo extra <code>*/</code> non \u00e8 sintassi valida, quindi il compilatore segnaler\u00e0 il problema.</p> <p></p>"},{"location":"it/module-01/basic-building-blocks/#23-modificatori-di-accesso","title":"2.3 Modificatori di accesso","text":"<p>In Java, un access modifier \u00e8 una keyword che specifica la visibilit\u00e0 (o accessibilit\u00e0) di una class, method o field.  Questo modificatore determina quali altre classi possono usare o vedere quel particolare elemento.</p> <p>Note</p> <p>Tabella dei modificatori di accesso disponibili in Java</p> Token / Identifier Category Meaning Optional? public Keyword / access modifier Visibile da qualsiasi classe in qualunque package S\u00ec no modifier (default) Keyword / access modifier Visibile solo all\u2019interno dello stesso package S\u00ec protected Keyword / access modifier Visibile nello stesso package e dalle sottoclassi (anche in altri package) S\u00ec private Keyword / access modifier Visibile solo all\u2019interno della stessa classe S\u00ec <p>Tip</p> <p>private &gt; default &gt; protected &gt; public La \u201cvisibilit\u00e0 si amplia\" secondo questo schema.</p> <p></p>"},{"location":"it/module-01/basic-building-blocks/#24-package","title":"2.4 Package","text":"<p>I package Java sono raggruppamenti logici di classi, interfacce e sotto-package. Aiutano a organizzare codebase grandi, evitare conflitti di nomi e fornire accesso controllato tra parti diverse di un\u2019applicazione.</p> <p></p>"},{"location":"it/module-01/basic-building-blocks/#241-organizzazione-e-scopo","title":"2.4.1 Organizzazione e scopo","text":"<ul> <li>I nomi dei package seguono le stesse regole dei nomi di variabile. Vedi Regole di naming Java.</li> <li>I package sono come cartelle per il codice sorgente Java.  </li> <li>Permettono di raggruppare classi correlate (ad esempio tutte le utility in <code>java.util</code>, tutte le classi di rete in <code>java.net</code>).  </li> <li>Usando i package puoi evitare conflitti di nomi; ad esempio, puoi avere due classi chiamate <code>Date</code>, ma una \u00e8 <code>java.util.Date</code> e l\u2019altra \u00e8 <code>java.sql.Date</code>.</li> </ul>"},{"location":"it/module-01/basic-building-blocks/#242-mappatura-con-il-file-system-e-dichiarazione-di-un-package","title":"2.4.2 Mappatura con il file system e dichiarazione di un package","text":"<ul> <li>I package corrispondono direttamente alla gerarchia di directory sul file system.</li> <li>Il package va dichiarato all\u2019inizio del file sorgente (prima di qualsiasi import).</li> <li>Se non dichiari un package, la classe appartiene al package di default.</li> <li> <p>Questo non \u00e8 raccomandato nei progetti reali, perch\u00e9 rende pi\u00f9 complicate l\u2019organizzazione e gli import.</p> </li> <li> <p>Esempio:</p> </li> </ul> <pre><code>package com.example.myapp.utils;\n\npublic class MyApp{\n\n}\n</code></pre> <p>Important</p> <p>Questa dichiarazione ci dice che la classe appartiene al package <code>com.example.myapp.utils</code> e che il suo file deve trovarsi nel path fisico: com/example/myapp/utils/MyApp.java</p> <p></p>"},{"location":"it/module-01/basic-building-blocks/#243-appartenere-allo-stesso-package","title":"2.4.3 Appartenere allo stesso package","text":"<p>Due classi appartengono allo stesso package se e solo se:</p> <ul> <li>Sono dichiarate con la stessa istruzione <code>package</code> all\u2019inizio del rispettivo file sorgente.</li> <li> <p>Sono collocate nella stessa directory della gerarchia dei sorgenti.</p> </li> <li> <p>Esempio:</p> </li> </ul> <p>Una classe nel package <code>A.B.C</code> appartiene solo a <code>A.B.C</code>, non a <code>A.B</code>. Le classi in <code>A.B</code> non possono accedere direttamente ai membri package-private delle classi in <code>A.B.C</code>, perch\u00e9 si tratta di package diversi.</p> <p>Le classi nello stesso package:</p> <ul> <li>Possono accedere ai membri <code>package-private</code> l\u2019una dell\u2019altra (cio\u00e8 membri senza modificatore di accesso esplicito).</li> <li>Condividono lo stesso namespace, quindi non si ha bisogno di importarle per poterle usare.</li> </ul> <p>Esempio: Due file nello stesso package</p> <pre><code>// File: src/com/example/tools/Tool.java\npackage com.example.tools;\n\npublic class Tool {\n    static void hello() { System.out.println(\"Hi!\"); }\n}\n</code></pre> <pre><code>// File: src/com/example/tools/Runner.java\npackage com.example.tools;\n\npublic class Runner {\n    public static void main(String[] args) {\n        Tool.hello();    // OK: stesso package, nessun import necessario\n    }\n}\n</code></pre> <p></p>"},{"location":"it/module-01/basic-building-blocks/#244-importare-da-un-package","title":"2.4.4 Importare da un package","text":"<p>Per usare classi da un altro package, si deve importarle:</p> <ul> <li>Esempio:</li> </ul> <pre><code>import java.util.List;       // importa una specifica classe\nimport java.util.*;          // importa tutte le classi in java.util\n\nimport java.nio.file.*.*     // ERROR! solo una wildcard \u00e8 permessa e deve comparire alla fine!\n</code></pre> <p>Note</p> <p>Il carattere wildcard <code>*</code> importa tutti i tipi nel package, ma non i sotto-package.</p> <p>Nel codice comunque, puoi sempre usare il nome completo (fully qualified name) della classe invece di importare tutte le classi del package:</p> <pre><code>java.util.List myList = new java.util.ArrayList&lt;&gt;();\n</code></pre> <p>Note</p> <p>Se importi esplicitamente un nome di classe, questo ha precedenza su qualsiasi import con wildcard;</p> <p>Se vuoi usare due classi con lo stesso nome (ad esempio <code>Date</code> da <code>java.util</code> e da <code>java.sql</code>), \u00e8 piu prudente usare una import con nome completamente qualificato.</p> <p></p>"},{"location":"it/module-01/basic-building-blocks/#245-import-statici","title":"2.4.5 Import statici","text":"<p>Oltre a importare classi da un package, Java permette un altro tipo di import: lo static import.</p> <p>Uno static import ti consente di importare i membri statici di una classe \u2014 come <code>metodi statici</code> e <code>variabili statiche</code> \u2014 in modo da poterli usare senza dover specificare il nome della classe.</p> <p>Puoi importare membri statici specifici oppure usare una wildcard per importare tutti i membri statici di una particolare classe.</p> <p>Esempio \u2014 Static import specifico</p> <pre><code>import static java.util.Arrays.asList;   // Imports Arrays.asList()\n\npublic class Example {\n\n    List&lt;String&gt; arr = asList(\"first\", \"second\");\n    // Puoi invocare asList() direttamente, senza usare Arrays.asList()\n}\n</code></pre> <p>Esempio \u2014 Static import di una costante</p> <pre><code>import static java.lang.Math.PI;\nimport static java.lang.Math.sqrt;\n\npublic class Circle {\n    double radius = 3;\n\n    double area = PI * radius * radius;\n    double diagonal = sqrt(2); \n}\n</code></pre> <p>Esempio \u2014 Static import con wildcard</p> <pre><code>import static java.lang.Math.*;\n\npublic class Calculator {\n    double x = sqrt(49);   // 7.0\n    double y = max(10, 20); \n    double z = random();   // invoca Math.random()\n}\n</code></pre> <p>Gli static import con wildcard si comportano esattamente come gli import normali con wildcard: portano in scope tutti i membri statici della classe.</p> <p>Warning</p> <p>Puoi sempre chiamare un membro statico usando il nome della classe: <code>Math.sqrt(16)</code> funziona sempre \u2014 anche se \u00e8 stato importato staticamente.</p> <p></p>"},{"location":"it/module-01/basic-building-blocks/#2451-regole-di-precedenza","title":"2.4.5.1 Regole di precedenza","text":"<p>Se la classe corrente dichiara gi\u00e0 un metodo o una variabile con lo stesso nome di quella importata staticamente:</p> <ul> <li>Il membro locale ha la precedenza.</li> <li>Il membro statico importato viene oscurato (shadowing).</li> </ul> <p>Esempio:</p> <pre><code>import static java.lang.Math.max;\n\npublic class Test {\n\n    static int max(int a, int b) {   // versione locale\n        return a &gt; b ? a : b;\n    }\n\n    void run() {\n        System.out.println(max(2, 5));  \n        // Chiama il max() LOCALE, non Math.max()\n    }\n}\n</code></pre> <p>Warning</p> <p>Uno static import deve sempre seguire l\u2019esatta sintassi: <code>import static</code>.</p> <p>Il compilatore proibisce di importare due membri statici con lo stesso simple name se questo crea ambiguit\u00e0 \u2014 anche se provengono da classi o package diversi.</p> <p>Esempio \u2014 Non consentito:</p> <pre><code>import static java.util.Collections.emptyList;\n\nimport static java.util.List.of;\nimport static java.util.Set.of;\n// \u274c ERROR: entrambi hanno lo stesso nome di metodo `of()`\n</code></pre> <p>Il compilatore non sa quale <code>of()</code> si intenda usare \u2192 errore di compilazione.</p> <p>Tip</p> <ul> <li>Se due static import introducono lo stesso nome, qualsiasi tentativo di usare quel nome provoca un errore di compilazione.</li> <li>Gli static import non importano le classi, solo i membri statici.  </li> <li>Puoi sempre chiamare il membro statico usando il nome della classe, anche se lo hai importato staticamente.</li> </ul> <p>Esempio:</p> <pre><code>import static java.lang.Math.sqrt;\n\ndouble a = sqrt(16);        // importato\ndouble b = Math.sqrt(25);   // fully qualified \u2014 sempre permesso\n</code></pre> <p></p>"},{"location":"it/module-01/basic-building-blocks/#246-package-standard-vs-package-definiti-dallutente","title":"2.4.6 Package standard vs package definiti dall\u2019utente","text":"<ul> <li>Package standard: forniti con il JDK (ad esempio <code>java.lang</code>, <code>java.util</code>, <code>java.io</code>).</li> <li>Package definiti dall\u2019utente: creati dagli sviluppatori per organizzare il codice dell\u2019applicazione.</li> </ul>"},{"location":"it/module-01/basic-building-blocks/#25-il-metodo-main","title":"2.5 Il metodo <code>main</code>","text":"<p>In Java, il metodo <code>main</code> funge da punto di ingresso di un\u2019applicazione standalone. </p> <p>La sua dichiarazione corretta \u00e8 fondamentale perch\u00e9 la JVM possa riconoscerlo.</p> <p></p>"},{"location":"it/module-01/basic-building-blocks/#251-firma-del-metodo-main","title":"2.5.1 Firma del metodo main","text":"<p>Analizziamo la firma del metodo <code>main</code> all\u2019interno di due delle classi tra le pi\u00f9 semplici possibili:</p> <ul> <li>Esempio: senza modificatori opzionali</li> </ul> <pre><code>public class MainFirstExample {\n\n    public static void main(String[] args){\n\n        System.out.print(\"Hello World!!\");\n\n    }\n\n}\n</code></pre> <ul> <li>Esempio: con entrambi i modificatori opzionali <code>final</code></li> </ul> <pre><code>public class MainSecondExample {\n\n    public final static void main(final String options[]){\n\n        System.out.print(\"Hello World!!\");\n\n    }\n\n}\n</code></pre> <p>Note</p> <p>Tabella dei modificatori per il metodo main</p> Token / Identifier Category Meaning Optional? <code>public</code> Keyword / Access Modifier Rende il metodo accessibile da qualunque punto. Necessario perch\u00e9 la JVM possa chiamarlo dall\u2019esterno della classe. Mandatory <code>static</code> Keyword Indica che il metodo appartiene alla classe stessa e pu\u00f2 essere chiamato senza creare un oggetto. Necessario perch\u00e9 la JVM non ha un\u2019istanza quando avvia il programma. Mandatory <code>final</code> (before return type) Modifier Impedisce che il metodo venga sovrascritto (overridden). Pu\u00f2 comparire legalmente prima del tipo di ritorno, ma non ha effetti pratici su <code>main</code> e non \u00e8 richiesto. Optional <code>main</code> Method name (predefined) Il nome esatto che la JVM cerca come punto di ingresso del programma. Deve essere scritto esattamente <code>main</code> (minuscolo). Mandatory <code>void</code> Return Type / Keyword Dichiara che il metodo non restituisce alcun valore alla JVM. Mandatory <code>String[] args</code> Parameter list Array di <code>String</code> che contiene gli argomenti da riga di comando passati al programma. Pu\u00f2 essere scritto anche come <code>String args[]</code> o <code>String... args</code>. Il nome del parametro (<code>args</code>) \u00e8 arbitrario. Mandatory (il tipo del parametro \u00e8 richiesto, il nome pu\u00f2 variare) <code>final (in parameter)</code> Modifier Indica che il parametro non pu\u00f2 essere riassegnato all\u2019interno del metodo (non puoi riassegnare <code>args</code> a un altro array). Optional <p>Important</p> <p>I modificatori <code>public</code>, <code>static</code> (obbligatori) e <code>final</code> (se presente) possono essere scambiati d\u2019ordine; <code>public</code> e <code>static</code> non possono essere omessi.</p> <p>Java considera <code>String[] args</code> e <code>String... args</code> equivalenti. Entrambe le firme compilano e funzionano correttamente come punti di ingresso.</p> <p></p>"},{"location":"it/module-01/basic-building-blocks/#26-compilare-ed-eseguire-il-codice","title":"2.6 Compilare ed eseguire il codice","text":"<p>Questa sezione mostra l'uso dei comandi <code>javac</code> e <code>java</code> per i casi pi\u00f9 comuni in Java 21: file singoli, pi\u00f9 file, package, directory di output separate, uso di classpath/module-path.</p> <p>Segui i layout delle directory esattamente.</p> <p>check your tools</p> <pre><code>javac -version   # output atteso: javac 21.x\njava  -version   # output atteso: java version \"21.0.7\" ... (l'output potrebbe variare a seconda della jvm in uso)\n</code></pre> <p>Warning</p> <p>Quando esegui una classe all\u2019interno di un package, java richiede il nome completamente qualificato, MAI il path:</p> <p><code>java com.example.app.Main</code> \u2714 <code>java src/com/example/app/Main</code> \u274c</p> <p></p>"},{"location":"it/module-01/basic-building-blocks/#261-compilare-un-file-package-di-default-singola-directory","title":"2.6.1 Compilare un file, package di default (singola directory)","text":"<p>File <pre><code>.\n\u2514\u2500\u2500 Hello.java\n</code></pre></p> <p>Hello.java <pre><code>public class Hello {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, Java 21!\");\n    }\n}\n</code></pre></p> <p>Compilare (nella stessa directory)</p> <pre><code>javac Hello.java\n</code></pre> <p>Questo comando creer\u00e0, nella stessa directory, un file con lo stesso nome del file \".java\" ma con estensione \".class\"; questo \u00e8 il file di bytecode che verr\u00e0 interpretato ed eseguito dalla JVM.</p> <p>Una volta che hai il file <code>.class</code>, in questo caso <code>Hello.class</code>, puoi eseguire il programma con:</p> <p>Esecuzione</p> <pre><code>java Hello\n</code></pre> <p>Important</p> <p>Non devi specificare l\u2019estensione \".class\" quando esegui il programma.</p> <p></p>"},{"location":"it/module-01/basic-building-blocks/#262-piu-file-package-di-default-singola-directory","title":"2.6.2 Pi\u00f9 file, package di default (singola directory)","text":"<p>File <pre><code>.\n\u251c\u2500\u2500 A.java\n\u2514\u2500\u2500 B.java\n</code></pre></p> <p>Compilare tutto <pre><code>javac *.java\n</code></pre></p> <p>Oppure, se le classi appartengono a uno specifico package:</p> <pre><code>javac packagex/*.java\n</code></pre> <p>Oppure specificando singolarmente:</p> <pre><code>javac A.java B.java\n</code></pre> <p>e</p> <pre><code>javac packagex/A.java packagey/B.java\n</code></pre> <p>Eseguire il punto di ingresso del programma: la classe che contiene un metodo <code>main</code></p> <pre><code>java A    # se A ha main(...)\n# oppure\njava B\n</code></pre> <p>Important</p> <p>Il path verso le classi \u00e8, in Java, il classpath. Puoi specificare il classpath con una delle seguenti opzioni:</p> <ul> <li><code>-cp &lt;classpath&gt;</code> </li> <li><code>-classpath &lt;classpath&gt;</code> </li> <li><code>--class-path &lt;classpath&gt;</code></li> </ul> <p></p>"},{"location":"it/module-01/basic-building-blocks/#263-codice-dentro-package-layout-standard-src-out","title":"2.6.3 Codice dentro package (layout standard src \u2192 out)","text":"<p>File <pre><code>.\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 com/\n\u2502       \u2514\u2500\u2500 example/\n\u2502           \u2514\u2500\u2500 app/\n\u2502               \u2514\u2500\u2500 Main.java\n\u2514\u2500\u2500 out/\n</code></pre></p> <p>Note</p> <p>Le cartelle <code>src</code> e <code>out</code> non fanno parte dei nostri package: sono solo le directory che contengono tutti i file sorgenti e i file <code>.class</code> compilati.</p> <p>Main.java</p> <pre><code>package com.example.app;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Packages done right.\");\n    }\n}\n</code></pre> <p>Compilare nella stessa directory</p> <pre><code># Crea il file .class accanto al file sorgente\njavac src/com/example/app/Main.java\n</code></pre> <p></p>"},{"location":"it/module-01/basic-building-blocks/#264-compilare-verso-unaltra-directory-d","title":"2.6.4 Compilare verso un\u2019altra directory (<code>-d</code>)","text":"<p>L\u2019opzione <code>-d out</code> colloca i file <code>.class</code> compilati nella directory <code>out/</code>, creando sottocartelle che rispecchiano i nomi dei package:</p> <pre><code>javac -d out -sourcepath src src/com/example/app/Main.java\n</code></pre> <p>Eseguire (usa il classpath puntando a out/)</p> <pre><code># Unix/macOS\njava -cp out com.example.app.Main\n\n# Windows\njava -cp out com.example.app.Main\n</code></pre> <p></p>"},{"location":"it/module-01/basic-building-blocks/#265-piu-file-su-piu-package-compilare-lintero-albero-sorgente","title":"2.6.5 Pi\u00f9 file su pi\u00f9 package (compilare l\u2019intero albero sorgente)","text":"<p>File <pre><code>.\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 com/\n\u2502       \u2514\u2500\u2500 example/\n\u2502           \u251c\u2500\u2500 util/\n\u2502           \u2502   \u2514\u2500\u2500 Utils.java\n\u2502           \u2514\u2500\u2500 app/\n\u2502               \u2514\u2500\u2500 Main.java\n\u2514\u2500\u2500 out/\n</code></pre></p> <p>Compilare l\u2019intero albero sorgente in <code>out/</code></p> <pre><code># Opzione A: indicare a javac i package di livello pi\u00f9 alto\njavac -d out   src/com/example/util/Utils.java   src/com/example/app/Main.java\n\n# Opzione B: usare -sourcepath per far trovare a javac le dipendenze\njavac -d out -sourcepath src   src/com/example/app/Main.java\n</code></pre> <p>Important</p> <p><code>-sourcepath &lt;sourcepath&gt;</code> dice a <code>javac</code> dove cercare altri file <code>.java</code> da cui i sorgenti dipendono.</p> <p></p>"},{"location":"it/module-01/basic-building-blocks/#266-esecuzione-di-un-singolo-sorgente-run-veloce-senza-javac","title":"2.6.6 Esecuzione di un singolo sorgente (run veloce senza <code>javac</code>)","text":"<p>Java 21 (a partire da Java 11) permette di eseguire piccoli programmi direttamente dal sorgente:</p> <pre><code># Solo package di default\njava Hello.java\n</code></pre> <p>Sono consentiti pi\u00f9 file sorgente se si trovano nel package di default e nella stessa directory:</p> <pre><code>java Main.java Helper.java\n</code></pre> <p>Se usi i package, \u00e8 preferibile compilare in <code>out/</code> ed eseguire con <code>-cp</code>.</p> <p></p>"},{"location":"it/module-01/basic-building-blocks/#267-passare-parametri-a-un-programma-java","title":"2.6.7 Passare parametri a un programma Java","text":"<p>Puoi inviare dati al tuo programma Java attraverso i parametri del punto di ingresso <code>main</code>.</p> <p>Come abbiamo visto, il metodo <code>main</code> pu\u00f2 ricevere un array di stringhe nella forma: <code>String[] args</code>. Vedi la sezione sul main.</p> <p>Main.java che stampa due parametri ricevuti in ingresso dal metodo <code>main</code>:</p> <pre><code>package com.example.app;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(args[0]);\n        System.out.println(args[1]);\n    }\n}\n</code></pre> <p>Per passare i parametri, ti basta scrivere (per esempio):</p> <pre><code>java Main.java Hello World  # spaces are used to separate the two arguments\n</code></pre> <p>Se vuoi passare un argomento contenente spazi, usa le virgolette:</p> <pre><code>java Main.java Hello \"World Mario\" # spaces are used to separate the two arguments\n</code></pre> <p>Se dichiari di usare (in questo caso stampare) i primi due elementi dell\u2019array di parametri (come nel nostro esempio), ma in realt\u00e0 passi meno argomenti, la JVM ti segnaler\u00e0 il problema con una <code>java.lang.ArrayIndexOutOfBoundsException</code>.  </p> <p>Se, al contrario, passi pi\u00f9 argomenti di quelli che il metodo usa, verranno semplicemente utilizzati (in questo caso) solo i primi due.  </p> <p><code>args.length</code> ti dice quanti argomenti sono stati forniti.</p>"},{"location":"it/module-01/data-types/","title":"4. Tipi di dato Java e casting","text":""},{"location":"it/module-01/data-types/#indice","title":"Indice","text":"<ul> <li>4.1 Tipi primitivi</li> <li>4.2 Tipi reference</li> <li>4.3 Tabella dei tipi primitivi</li> <li>4.4 Note</li> <li>4.5 Riepilogo</li> <li>4.6 Aritmetica e promozione numerica dei primitivi<ul> <li>4.6.1 Regole di promozione numerica in Java<ul> <li>4.6.1.1 Regola 1 \u2013 Tipi misti \u2192 il tipo pi\u00f9 piccolo viene promosso a quello pi\u00f9 grande</li> <li>4.6.1.2 Regola 2 \u2013 Integrale + floating-point \u2192 l\u2019integrale viene promosso a floating-point</li> <li>4.6.1.3 Regola 3 \u2013 byte, short e char vengono promossi a int durante l\u2019aritmetica</li> <li>4.6.1.4 Regola 4 \u2013 Il tipo del risultato coincide con il tipo promosso</li> </ul> </li> <li>4.6.2 Riepilogo del comportamento di promozione numerica<ul> <li>4.6.2.1 Punti chiave</li> </ul> </li> </ul> </li> <li>4.7 Casting in Java<ul> <li>4.7.1 Casting dei primitivi<ul> <li>4.7.1.1 Widening implicit casting</li> <li>4.7.1.2 Narrowing explicit casting</li> <li>4.7.1.3 Narrowing Implicito a Compile-Time</li> </ul> </li> <li>4.7.2 Perdita di dati, overflow e underflow</li> <li>4.7.3 Casting di valori vs. variabili</li> <li>4.7.4 Casting di reference (oggetti)<ul> <li>4.7.4.1 Upcasting (widening reference cast)</li> <li>4.7.4.2 Downcasting (narrowing reference cast)</li> </ul> </li> <li>4.7.5 Riepilogo dei punti chiave</li> <li>4.7.6 Esempi</li> </ul> </li> <li>4.8 Sommario</li> </ul> <p>Come abbiamo visto in Mattoni Sintattici di Base, Java ha due categorie di tipi di dato:</p> <ul> <li>Primitive types </li> <li>Reference types</li> </ul> <p>\ud83d\udc49 Per una panoramica completa dei tipi primitivi con dimensioni, range, valori di default ed esempi, vedi la Tabella dei tipi primitivi.</p> <p></p>"},{"location":"it/module-01/data-types/#41-tipi-primitivi","title":"4.1 Tipi primitivi","text":"<p>I <code>primitive</code> rappresentano singoli valori grezzi memorizzati direttamente in memoria.</p> <p>Ogni tipo primitivo ha una dimensione fissa che determina quanti byte occupa.</p> <p>Concettualmente, un primitivo \u00e8 semplicemente una cella di memoria che contiene un valore:</p> <pre><code>+-------+\n|  42   |   \u2190 value of type short (2 bytes in memory)\n+-------+\n</code></pre> <p></p>"},{"location":"it/module-01/data-types/#42-tipi-reference","title":"4.2 Tipi reference","text":"<p>Un tipo <code>reference</code> contiene l'indirizzo di memoria di un istanza di un tipo complesso; esso non contiene l\u2019<code>object</code> stesso, ma un reference (puntatore), appunto, ad esso.</p> <p>Il reference ha dimensione fissa (dipende dalla JVM, spesso 4 o 8 byte) e punta a una locazione di memoria dove \u00e8 memorizzato l\u2019oggetto reale.</p> <ul> <li>Esempio: una variabile reference di tipo <code>String</code> punta a un oggetto stringa nello heap, che internamente \u00e8 composto da un array di primitivi <code>char</code>.</li> </ul> <p>Diagramma:</p> <pre><code>Reference (4 or 8 bytes)\n+---------+\n| address | \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba  Object in Heap\n+---------+                  +-------------------+\n                             |   \"Hello\"         |\n                             | ['H','e','l','l','o']  \u2190 array of char\n                             +-------------------+\n</code></pre> <p></p>"},{"location":"it/module-01/data-types/#43-tabella-dei-tipi-primitivi","title":"4.3 Tabella dei tipi primitivi","text":"Keyword Type Size Min Value Max Value Default Value Example <code>byte</code> 8-bit int 1 byte \u2013128 127 0 <code>byte b = 100;</code> <code>short</code> 16-bit int 2 bytes \u201332,768 32,767 0 <code>short s = 2000;</code> <code>int</code> 32-bit int 4 bytes \u20132,147,483,648 (<code>\u20132^31</code>) 2,147,483,647 (<code>2^31\u20131</code>) 0 <code>int i = 123456;</code> <code>long</code> 64-bit int 8 bytes \u20132^63 2^63\u20131 0L <code>long l = 123456789L;</code> <code>float</code> 32-bit FP 4 bytes see note see note 0.0f <code>float f = 3.14f;</code> <code>double</code> 64-bit FP 8 bytes see note see note 0.0 <code>double d = 2.718;</code> <code>char</code> UTF-16 2 bytes <code>'\\u0000'</code> (0) <code>'\\uffff'</code> (65,535) <code>'\\u0000'</code> <code>char c = 'A';</code> <code>boolean</code> true/false JVM-dep. (often 1 byte) <code>false</code> <code>true</code> <code>false</code> <code>boolean b = true;</code>"},{"location":"it/module-01/data-types/#44-note","title":"4.4 Note","text":"<p><code>float</code> e <code>double</code> non hanno limiti interi fissi come i tipi interi. Invece, seguono lo standard IEEE 754:</p> <ul> <li>Pi\u00f9 piccoli valori positivi non nulli:  </li> <li><code>Float.MIN_VALUE \u2248 1.4E\u201345</code> </li> <li> <p><code>Double.MIN_VALUE \u2248 4.9E\u2013324</code> </p> </li> <li> <p>Valori finiti massimi:  </p> </li> <li><code>Float.MAX_VALUE \u2248 3.4028235E+38</code> </li> <li><code>Double.MAX_VALUE \u2248 1.7976931348623157E+308</code> </li> </ul> <p>Supportano anche valori speciali: <code>+Infinity</code>, <code>-Infinity</code> e <code>NaN</code> (Not a Number).</p> <ul> <li>FP = floating point.  </li> <li>La dimensione di <code>boolean</code> dipende dalla JVM ma il comportamento logico \u00e8 semplicemente <code>true</code>/<code>false</code>.  </li> <li>I valori di default si applicano ai field (variabili di istanza e di classe).   Le variabili locali devono essere inizializzate esplicitamente prima dell\u2019uso.</li> </ul> <p></p>"},{"location":"it/module-01/data-types/#45-riepilogo","title":"4.5 Riepilogo","text":"<ul> <li>Primitive = valore reale, memorizzato direttamente in memoria.  </li> <li>Reference = puntatore a un oggetto; l\u2019oggetto stesso pu\u00f2 contenere primitivi e altri reference.  </li> <li>Per i dettagli sui primitivi, vedi la Tabella dei tipi primitivi.</li> </ul>"},{"location":"it/module-01/data-types/#46-aritmetica-e-promozione-numerica-dei-primitivi","title":"4.6 Aritmetica e promozione numerica dei primitivi","text":"<p>Quando si applicano operatori aritmetici o di confronto ai tipi primitivi, Java converte automaticamente (o promuove) i valori a tipi compatibili secondo regole ben definite di numeric promotion.</p> <p>Queste regole garantiscono calcoli coerenti e riducono il rischio di perdita di dati quando si mescolano tipi numerici differenti.</p> <p></p>"},{"location":"it/module-01/data-types/#461-regole-di-promozione-numerica-in-java","title":"4.6.1 Regole di promozione numerica in Java","text":""},{"location":"it/module-01/data-types/#4611-regola-1-tipi-misti-il-tipo-piu-piccolo-viene-promosso-a-quello-piu-grande","title":"4.6.1.1 Regola 1 \u2013 Tipi misti \u2192 il tipo pi\u00f9 piccolo viene promosso a quello pi\u00f9 grande","text":"<p>Se due operandi appartengono a tipi numerici diversi, Java promuove automaticamente il tipo pi\u00f9 piccolo al tipo pi\u00f9 grande prima di eseguire l\u2019operazione.</p> Example Explanation <code>int x = 10; double y = 5.5;</code><code>double result = x + y;</code> La variabile <code>x</code> di tipo <code>int</code> viene promossa a <code>double</code>, quindi il risultato \u00e8 un <code>double</code> (<code>15.5</code>). <p>Ordine di promozione valido (dal pi\u00f9 piccolo al pi\u00f9 grande): <code>byte \u2192 short \u2192 int \u2192 long \u2192 float \u2192 double</code></p> <p></p>"},{"location":"it/module-01/data-types/#4612-regola-2-intero-floating-point-lintero-viene-promosso-a-floating-point","title":"4.6.1.2 Regola 2 \u2013 Intero + floating-point \u2192 l\u2019intero viene promosso a floating-point","text":"<p>Se un operando \u00e8 di tipo intero (<code>byte</code>, <code>short</code>, <code>char</code>, <code>int</code>, <code>long</code>) e l\u2019altro \u00e8 di tipo floating-point (<code>float</code>, <code>double</code>), il valore intero viene promosso al tipo floating-point prima dell\u2019operazione.</p> Example Explanation <code>float f = 2.5F; int n = 3;</code><code>float result = f * n;</code> <code>n</code> (int) viene promosso a <code>float</code>. Il risultato \u00e8 un <code>float</code> (<code>7.5</code>). <code>double d = 10.0; long l = 3;</code><code>double result = d / l;</code> <code>l</code> (long) \u00e8 promosso a <code>double</code>. Il risultato \u00e8 un <code>double</code> (<code>3.333...</code>). <p></p>"},{"location":"it/module-01/data-types/#4613-regola-3-byte-short-e-char-vengono-promossi-a-int-durante-laritmetica","title":"4.6.1.3 Regola 3 \u2013 <code>byte</code>, <code>short</code> e <code>char</code> vengono promossi a <code>int</code> durante l\u2019aritmetica","text":"<p>Quando effettui operazioni aritmetiche con variabili (non costanti letterali) di tipo <code>byte</code>, <code>short</code> o <code>char</code>, Java le promuove automaticamente a <code>int</code>, anche se entrambi gli operandi sono pi\u00f9 piccoli di <code>int</code>.</p> Example Explanation <code>byte a = 10, b = 20;</code><code>byte c = a + b;</code> \u274c Errore di compilazione: il risultato di <code>a + b</code> \u00e8 di tipo <code>int</code>, non <code>byte</code>. Serve il cast \u2192 <code>byte c = (byte)(a + b);</code> <code>short s1 = 1000, s2 = 2000;</code><code>short sum = (short)(s1 + s2);</code> Gli operandi sono promossi a <code>int</code>, quindi \u00e8 richiesto un cast esplicito per assegnare a <code>short</code>. <code>char c1 = 'A', c2 = 2;</code><code>int result = c1 + c2;</code> <code>'A'</code> (65) e <code>2</code> sono promossi a <code>int</code>, risultato = <code>67</code>. <p>Note</p> <p>Questa regola si applica quando si usano variabili.</p> <p>Quando si usano letterali costanti, il compilatore pu\u00f2 a volte valutare l\u2019espressione a compile-time e assegnarla in sicurezza.</p> <pre><code>byte a = 10 + 20;   // \u2705 OK: espressione costante che rientra in byte\nbyte b = 10;\nbyte c = 20;\nbyte d = b + c;     // \u274c Errore: b + c \u00e8 valutato a runtime \u2192 int\n</code></pre> <p></p>"},{"location":"it/module-01/data-types/#4614-regola-4-il-tipo-del-risultato-coincide-con-il-tipo-promosso","title":"4.6.1.4 Regola 4 \u2013 Il tipo del risultato coincide con il tipo promosso","text":"<p>Dopo l\u2019applicazione delle promozioni, quando entrambi gli operandi sono dello stesso tipo, il risultato dell\u2019espressione avr\u00e0 quel medesimo tipo promosso.</p> Example Explanation <code>int i = 5; double d = 6.0;</code><code>var result = i * d;</code> <code>i</code> viene promosso a <code>double</code>, il risultato \u00e8 <code>double</code>. <code>float f = 3.5F; long l = 4L;</code><code>var result = f + l;</code> <code>l</code> viene promosso a <code>float</code>, il risultato \u00e8 <code>float</code>. <code>int x = 10, y = 4;</code><code>var div = x / y;</code> Entrambi sono <code>int</code>, il risultato \u00e8 <code>int</code> (<code>2</code>), la parte frazionaria viene troncata. <p>Warning</p> <p>La divisione tra interi produce sempre un risultato intero.</p> <p>Per ottenere un risultato decimale, almeno un operando deve essere di tipo floating-point:</p> <pre><code>double result = 10.0 / 4; // \u2705 2.5\nint result = 10 / 4;      // \u274c 2 (la parte frazionaria \u00e8 scartata)\n</code></pre> <p></p>"},{"location":"it/module-01/data-types/#462-riepilogo-del-comportamento-di-promozione-numerica","title":"4.6.2 Riepilogo del comportamento di promozione numerica","text":"Situation Promotion Result Example Mix di tipi numerici piccoli e grandi Il tipo pi\u00f9 piccolo \u00e8 promosso a quello pi\u00f9 grande <code>int + double \u2192 double</code> Integrale + floating-point L\u2019integrale \u00e8 promosso a floating-point <code>long + float \u2192 float</code> Aritmetica con <code>byte</code>, <code>short</code>, <code>char</code> Promozione a <code>int</code> <code>byte + byte \u2192 int</code> Risultato dopo la promozione Il risultato ha il tipo promosso <code>float + long \u2192 float</code>"},{"location":"it/module-01/data-types/#4621-punti-chiave","title":"4.6.2.1 Punti chiave","text":"<ul> <li>Considera sempre la promozione di tipo quando misceli tipi diversi in un\u2019espressione aritmetica.  </li> <li>Per i tipi piccoli (<code>byte</code>, <code>short</code>, <code>char</code>), la promozione a <code>int</code> \u00e8 automatica quando si usano variabili in un\u2019operazione aritmetica.  </li> <li>Usa il casting esplicito solo quando sei sicuro che il risultato rientri nel tipo di destinazione.  </li> <li>Ricorda: la divisione tra interi tronca, la divisione tra floating-point mantiene i decimali.  </li> <li>Comprendere le regole di promozione \u00e8 cruciale per evitare perdite di precisione inattese o errori di compilazione.</li> </ul>"},{"location":"it/module-01/data-types/#47-casting-in-java","title":"4.7 Casting in Java","text":"<p>Il <code>casting</code> in Java \u00e8 il processo con cui si converte esplicitamente un valore da un tipo a un altro. Si applica sia ai <code>primitive types</code> (numeri) sia ai <code>reference types</code> (oggetti in una gerarchia di classi).</p> <p></p>"},{"location":"it/module-01/data-types/#471-casting-dei-primitivi","title":"4.7.1 Casting dei primitivi","text":"<p>Il casting dei primitivi cambia il tipo di un valore numerico.</p> <p>Esistono due categorie di casting:</p> Type Description Example Explicit? Risk Widening tipo pi\u00f9 piccolo \u2192 tipo pi\u00f9 grande int \u2192 double No nessuna perdita Narrowing tipo pi\u00f9 grande \u2192 tipo pi\u00f9 piccolo double \u2192 int S\u00ec possible loss <p></p>"},{"location":"it/module-01/data-types/#4711-widening-implicit-casting","title":"4.7.1.1 Widening implicit casting","text":"<p>Conversione automatica da un tipo \u201cpi\u00f9 piccolo\u201d a un tipo \u201cpi\u00f9 grande\u201d compatibile. Gestita dal compilatore, non richiede sintassi esplicita.</p> <pre><code>int i = 100;\ndouble d = i;  // implicit cast: int \u2192 double\nSystem.out.println(d); // 100.0\n</code></pre> <p>\u2705 Sicuro \u2013 nessun overflow (anche se bisogna comunque essere consapevoli della precisione dei floating-point).</p> <p></p>"},{"location":"it/module-01/data-types/#4712-narrowing-explicit-casting","title":"4.7.1.2 Narrowing Explicit Casting","text":"<p>Conversione manuale da un tipo \u201cpi\u00f9 grande\u201d a uno \u201cpi\u00f9 piccolo\u201d. Richiede una cast expression perch\u00e9 pu\u00f2 causare perdita di dati.</p> <pre><code>double d = 9.78;\nint i = (int) d;  // explicit cast: double \u2192 int\nSystem.out.println(i); // 9 (fraction discarded)\n</code></pre> <p>Warning</p> <p>\u26a0 Usare solo quando si \u00e8 sicuri che il valore rientri nel tipo di destinazione.</p> <p></p>"},{"location":"it/module-01/data-types/#4713-narrowing-implicito-a-compile-time","title":"4.7.1.3 Narrowing Implicito a Compile-Time","text":"<p>In alcuni casi specifici, il compilatore permette una conversione di narrowing senza un cast esplicito.</p> <p>Se una variabile \u00e8 dichiarata <code>final</code> ed \u00e8 inizializzata con una constant expression il cui valore rientra nel tipo di destinazione, il compilatore pu\u00f2 eseguire la conversione in modo sicuro a compile time.</p> <pre><code>final int k = 11;\nbyte b = k;  // allowed: value 11 fits into byte range\n\nfinal int x = 200;\nbyte c = x;  // does NOT compile: 200 is outside byte range\n</code></pre> <p>Questo funziona perch\u00e9 il compilatore conosce il valore esatto di una variabile <code>final</code> e pu\u00f2 verificare che sia all'interno dell'intervallo del tipo pi\u00f9 piccolo.</p> <p>Questo tipo di narrowing \u00e8 consentito tra: - <code>byte</code> - <code>short</code> - <code>char</code> - <code>int</code></p> <p>Tuttavia, non si applica a: - <code>long</code> - <code>float</code> - <code>double</code></p> <p>Per esempio:</p> <pre><code>final float f = 10.0f;\nint n = f;   // does not compile\n</code></pre> <p>Anche se il valore sembra compatibile, i tipi floating-point non sono idonei per questa forma di narrowing implicito.</p> <p></p>"},{"location":"it/module-01/data-types/#472-perdita-di-dati-overflow-e-underflow","title":"4.7.2 Perdita di dati, overflow e underflow","text":"<p>Quando un valore eccede la capacit\u00e0 di un tipo, puoi ottenere:</p> <ul> <li>Overflow: il risultato \u00e8 maggiore del massimo valore rappresentabile</li> <li>Underflow: il risultato \u00e8 minore del minimo valore rappresentabile</li> <li> <p>Troncamento: la parte di dato che non entra viene persa (ad esempio, i decimali)</p> </li> <li> <p>Esempio \u2013 overflow/underflow con <code>int</code></p> </li> </ul> <pre><code>int max = Integer.MAX_VALUE;\nint overflow = max + 1;     // \"wrap-around\" verso il negativo\n\nint min = Integer.MIN_VALUE;\nint underflow = min - 1;    // \"wrap-around\" verso il positivo\n</code></pre> <ul> <li>Esempio: troncamento</li> </ul> <pre><code>double d = 9.99;\nint i = (int) d; // 9 (fraction discarded)\n</code></pre> <p>Note</p> <p>I tipi floating-point (<code>float</code>, <code>double</code>) non fanno wrap-around: - overflow \u2192 <code>Infinity</code> / <code>-Infinity</code> - underflow (valori molto piccoli) \u2192 0.0 o valori denormalizzati.</p> <p></p>"},{"location":"it/module-01/data-types/#473-casting-di-valori-vs-variabili","title":"4.7.3 Casting di valori vs. variabili","text":"<p>Java tratta:</p> <ul> <li>I letterali interi come <code>int</code> di default</li> <li>I letterali floating-point come <code>double</code> di default</li> </ul> <p>Il compilatore non richiede cast quando un letterale rientra nel range del tipo di destinazione:</p> <pre><code>byte first = 10;        // OK: 10 rientra in byte\nshort second = 9 * 10;  // OK: espressione costante valutata a compile time\n</code></pre> <p>Ma:</p> <pre><code>long a = 5729685479;    // \u274c errore: letterale int fuori range\nlong b = 5729685479L;   // \u2705 letterale long (suffisso L)\n\nfloat c = 3.14;         // \u274c double \u2192 float: richiede F o cast\nfloat d = 3.14F;        // \u2705 letterale float\n\nint e = 0x7FFF_FFFF;    // \u2705 max int in esadecimale\nint f = 0x8000_0000;    // \u274c fuori range int (serve L)\n</code></pre> <p>Tuttavia, quando si applicano le regole di promozione numerica:</p> <p>Con variabili di tipo <code>byte</code>, <code>short</code> e <code>char</code> in un\u2019espressione aritmetica, gli operandi vengono promossi a <code>int</code> e il risultato \u00e8 <code>int</code>.</p> <pre><code>byte first = 10;\nshort second = 9 + first;       // \u274c 9 (int literal) + first (byte \u2192 int) = int\n// second = (short) (9 + first);  // \u2705 cast dell\u2019intera espressione\n</code></pre> <pre><code>short b = 10;\nshort a = 5 + b;               // \u274c 5 (int) + b (short \u2192 int) = int\nshort a2 = (short) (5 + b);    // \u2705 cast dell\u2019intera espressione\n</code></pre> <p>Warning</p> <p>Il cast \u00e8 un operatore unario:</p> <p><code>short a = (short) 5 + b;</code> Il cast si applica solo a <code>5</code> \u2192 il risultato dell\u2019espressione resta di tipo <code>int</code> \u2192 l\u2019assegnazione fallisce comunque.</p> <p></p>"},{"location":"it/module-01/data-types/#474-casting-di-reference-oggetti","title":"4.7.4 Casting di reference (oggetti)","text":"<p>Il casting si applica anche ai reference a oggetti in una gerarchia di classi. Non modifica l\u2019oggetto in memoria \u2014 cambia solo il tipo di reference usato per accedervi.</p> <p>Regole fondamentali:</p> <ul> <li>Il tipo reale dell\u2019oggetto determina quali field/metodi esistono effettivamente.</li> <li>Il tipo del reference determina cosa puoi accedere in quel punto del codice.</li> </ul> <p></p>"},{"location":"it/module-01/data-types/#4741-upcasting-widening-reference-cast","title":"4.7.4.1 Upcasting (widening reference cast)","text":"<p>Conversione da sottoclasse a superclasse.</p> <p>\u00c8 implicita e sempre sicura: ogni <code>Dog</code> \u00e8 anche un <code>Animal</code>.</p> <pre><code>class Animal { }\nclass Dog extends Animal { }\n\nDog dog = new Dog();\nAnimal a = dog;    // implicit upcast: Dog \u2192 Animal\n</code></pre> <p></p>"},{"location":"it/module-01/data-types/#4742-downcasting-narrowing-reference-cast","title":"4.7.4.2 Downcasting (narrowing reference cast)","text":"<p>Conversione da superclasse a sottoclasse.</p> <ul> <li>\u00c8 esplicita</li> <li>Pu\u00f2 fallire a runtime con <code>ClassCastException</code> se l\u2019oggetto non \u00e8 realmente di quel tipo</li> </ul> <pre><code>Animal a = new Dog();\nDog d = (Dog) a;   // OK: a punta davvero a un Dog\n\nAnimal x = new Animal();\nDog d2 = (Dog) x;  // \u26a0 Errore a runtime: ClassCastException\n</code></pre> <p>Per sicurezza, usa <code>instanceof</code>:</p> <pre><code>if (x instanceof Dog) {\n    Dog safeDog = (Dog) x;   // cast sicuro\n}\n</code></pre> <p></p>"},{"location":"it/module-01/data-types/#475-riepilogo-dei-punti-chiave","title":"4.7.5 Riepilogo dei punti chiave","text":"Casting Type Applies To Direction Syntax Safe? Performed By Widening Primitive Primitives small \u2192 large Implicit S\u00ec Compiler Narrowing Primitive Primitives large \u2192 small Explicit No Programmer Upcasting Objects subclass \u2192 superclass Implicit S\u00ec Compiler Downcasting Objects superclass \u2192 subclass Explicit Runtime check Programmer"},{"location":"it/module-01/data-types/#476-esempi","title":"4.7.6 Esempi","text":"<pre><code>// Primitive casting\nshort s = 50;\nint i = s;           // widening\nbyte b = (byte) i;   // narrowing (possible loss)\n\n// Object casting\nObject obj = \"Hello\";\nString str = (String) obj; // OK: obj points to a String\n\nObject n = Integer.valueOf(10);\n// String fail = (String) n;  // ClassCastException at runtime\n</code></pre>"},{"location":"it/module-01/data-types/#48-sommario","title":"4.8 Sommario","text":"<ul> <li>Il casting dei primitivi cambia il tipo numerico.  </li> <li>Il casting delle reference cambia la \u201cvista\u201d di un oggetto nella gerarchia.  </li> <li>Upcasting \u2192 sicuro e implicito.  </li> <li>Downcasting \u2192 esplicito, da usare con cautela (spesso dopo <code>instanceof</code>).</li> </ul>"},{"location":"it/module-01/instantiating-types/","title":"6. Istanziazione dei tipi","text":""},{"location":"it/module-01/instantiating-types/#indice","title":"Indice","text":"<ul> <li>6.1 Introduzione<ul> <li>6.1.1 Gestione dei tipi primitivi<ul> <li>6.1.1.1 Dichiarare un primitivo</li> <li>6.1.1.2 Assegnare un primitivo</li> </ul> </li> <li>6.1.2 Gestione dei tipi reference<ul> <li>6.1.2.1 Creare e assegnare un reference</li> <li>6.1.2.2 Costruttori</li> <li>6.1.2.3 Blocchi di inizializzazione-istanza</li> </ul> </li> </ul> </li> <li>6.2 Inizializzazione predefinita delle variabili<ul> <li>6.2.1 Variabili di istanza e di classe</li> <li>6.2.2 Variabili final di istanza</li> <li>6.2.3 Variabili locali<ul> <li>6.2.3.1 Inferire i tipi con var</li> </ul> </li> </ul> </li> <li>6.3 Tipi wrapper<ul> <li>6.3.1 Scopo dei tipi wrapper</li> <li>6.3.2 Autoboxing e unboxing</li> <li>6.3.3 Parsing e conversione</li> <li>6.3.4 Metodi di supporto</li> <li>6.3.5 Valori null</li> </ul> </li> <li>6.4 Uguaglianza in Java<ul> <li>6.4.1 Uguaglianza con i tipi primitivi<ul> <li>6.4.1.1 Punti chiave</li> </ul> </li> <li>6.4.2 Uguaglianza con i tipi reference<ul> <li>6.4.2.1 Confronto di identit\u00e0</li> <li>6.4.2.2 equals Confronto logico</li> <li>6.4.2.3 Punti chiave</li> </ul> </li> <li>6.4.3 String Pool e uguaglianza<ul> <li>6.4.3.1 Il metodo intern</li> </ul> </li> <li>6.4.4 Uguaglianza con i tipi wrapper</li> <li>6.4.5 Uguaglianza e null</li> <li>6.4.6 Tabella riepilogativa</li> </ul> </li> </ul>"},{"location":"it/module-01/instantiating-types/#61-introduzione","title":"6.1 Introduzione","text":"<p>In Java, un tipo pu\u00f2 essere un tipo primitivo (come <code>int</code>, <code>double</code>, <code>boolean</code>, ecc.) oppure un tipo reference (classi, interfacce, array, enum, record, ecc.). Vedi: Tipi di dato Java e casting</p> <p>Il modo in cui vengono create le istanze dipende dalla categoria del tipo:</p> <ul> <li>Tipi primitivi   Le istanze dei tipi primitivi vengono create semplicemente dichiarando una variabile.   La JVM alloca automaticamente la memoria per contenere il valore e non \u00e8 necessaria alcuna keyword esplicita. </li> </ul> <pre><code>int age = 30;         // crea un primitivo int con valore 30\nboolean flag = true;  // crea un primitivo boolean con valore true\ndouble pi = 3.14159;  // crea un primitivo double con valore 3.14159\n</code></pre> <ul> <li>Tipi reference (oggetti)     Le istanze dei tipi classe vengono create usando la keyword <code>new</code> (eccetto alcuni casi speciali come i letterali String, i record con costruttori canonici, o i metodi factory).     La keyword <code>new</code> alloca memoria nell\u2019heap e invoca un costruttore della classe.</li> </ul> <pre><code>String name = new String(\"Alice\"); // crea esplicitamente un nuovo oggetto String\nPerson p = new Person();           // crea un nuovo oggetto Person usando il suo costruttore\n</code></pre> <p>\u00c8 anche comune affidarsi a letterali o metodi factory per la creazione degli oggetti.</p> <pre><code>String text = \"Hello World\";\n\nList&lt;String&gt; list = List.of(\"A\", \"B\", \"C\");              // factory method immutabile\nMap&lt;String, Integer&gt; map = Map.of(\"one\", 1, \"two\", 2);   // factory method immutabile\nOptional&lt;String&gt; opt = Optional.of(\"value\");             // factory method\n\nLocalDate date = LocalDate.of(2025, 3, 15);\nInteger boxed = Integer.valueOf(10);\n</code></pre> <p>Important</p> <p>I letterali String non richiedono <code>new</code> e sono memorizzati nello String pool. Usare <code>new String(\"x\")</code> crea invece sempre un nuovo oggetto nell\u2019heap.</p> <p></p>"},{"location":"it/module-01/instantiating-types/#611-gestione-dei-tipi-primitivi","title":"6.1.1 Gestione dei tipi primitivi","text":""},{"location":"it/module-01/instantiating-types/#6111-dichiarare-un-primitivo","title":"6.1.1.1 Dichiarare un primitivo","text":"<p>Dichiarare un tipo primitivo (come per i tipi reference) significa riservare spazio in memoria per una variabile di un determinato tipo, senza necessariamente assegnarle un valore.  </p> <p>Warning</p> <p>A differenza dei primitivi, la cui dimensione dipende dal tipo specifico (es. <code>int</code> vs <code>long</code>), i tipi reference occupano sempre la stessa dimensione fissa in memoria \u2014 ci\u00f2 che varia \u00e8 la dimensione dell\u2019oggetto a cui puntano.</p> <ul> <li>Esempi di sintassi (solo dichiarazione):</li> </ul> <pre><code>int number;\n\nboolean active;\n\nchar letter;\n\nint x, y, z;          // Dichiarazioni multiple in un\u2019unica istruzione: Java consente di dichiarare pi\u00f9 variabili dello stesso tipo\n</code></pre> <p>Important</p> <p>I <code>modificatori</code> e il <code>tipo</code> dichiarati all\u2019inizio di una dichiarazione multipla di variabili si applicano a tutte le variabili dichiarate in quella stessa istruzione.</p> <p>Eccezione: quando si dichiarano array usando le parentesi quadre dopo il nome della variabile, le parentesi fanno parte del dichiaratore della singola variabile, non del tipo base.</p> <ul> <li>Esempi</li> </ul> <pre><code>static int a, b, c;\n\n// \u00e8 equivalente a:\n\nstatic int a;\nstatic int b;\nstatic int c;\n\n\nint[] a, b;   // entrambi sono arrays di int\nint c[], d;   // solo c \u00e8 un array, d \u00e8 un normale int\n</code></pre> <p></p>"},{"location":"it/module-01/instantiating-types/#6112-assegnare-un-primitivo","title":"6.1.1.2 Assegnare un primitivo","text":"<p>Assegnare un tipo primitivo (come per i tipi reference) significa memorizzare un valore in una variabile dichiarata di quel tipo.</p> <p>Per i primitivi, la variabile contiene il valore stesso; per i tipi reference, la variabile contiene l\u2019indirizzo di memoria (un reference) dell\u2019oggetto puntato.</p> <ul> <li>Esempi di sintassi:</li> </ul> <pre><code>int number;                     // Dichiarazione di un int: variabile chiamata \"number\"\n\nnumber = 10;                    // Assegnazione del valore 10 a questa variabile\n\nchar letter = 'A';              // Dichiarazione e assegnazione in un\u2019unica istruzione: dichiarazione e assegnazione possono essere combinate \n\nint a1, a2;                      // Dichiarazioni multiple  \n\nint a = 1, b = 2, c = 3;        // Dichiarazioni multiple e assegnazioni\n\nchar b1, b2, b3 = 'C';          // Dichiarazioni miste (2 dichiarazioni + 1 assegnazione)\n\ndouble d1, double d2;            // ERROR - NOT LEGAL\n\nint v1; v2;                      // ERROR - NOT LEGAL\n</code></pre> <p>Important</p> <p>Quando scrivi un numero direttamente nel codice (un letterale numerico), Java assume per default che sia di tipo int. Se il valore non entra in un <code>int</code>, il codice non compila a meno che il letterale non sia marcato esplicitamente con il suffisso corretto.</p> <ul> <li>Esempio di sintassi per un letterale numerico:</li> </ul> <pre><code>long exNumLit = 5729685479; // \u274c Does not compile.\n                          // Anche se il valore potrebbe rientrare in un long,\n                          // un literal numerico semplice \u00e8 considerato un int,\n                          // e questo numero \u00e8 troppo grande per un int.\n\n// Changing the declaration adding the correct suffix (L or l) will solve:\n\nlong exNumLit = 5729685479L;\n\nor\n\nlong exNumLit = 5729685479l;\n</code></pre> <p>Dichiarare un tipo <code>reference</code> significa riservare spazio in memoria per una variabile che conterr\u00e0 un reference (puntatore) a un oggetto del tipo specificato.</p> <p>A questo stadio non viene ancora creato alcun oggetto \u2014 la variabile ha solo la potenzialit\u00e0 di puntarne uno.</p> <p>Warning</p> <p>A differenza dei primitivi, la cui dimensione dipende dal tipo specifico (es. <code>int</code> vs <code>long</code>), le variabili reference occupano sempre la stessa dimensione fissa in memoria (sufficiente per memorizzare un reference). Ci\u00f2 che varia \u00e8 la dimensione dell\u2019oggetto puntato, che viene allocato separatamente nell\u2019heap.</p> <ul> <li>Esempi di sintassi (solo dichiarazione):</li> </ul> <pre><code>String name;\nPerson person;\nList&lt;Integer&gt; numbers;\n\nPerson p1, p2, p3;   // Dichiarazioni multiple in un\u2019unica istruzione\n\nString a = \"abc\", b = \"def\", c = \"ghi\";     // Dichiarazioni multiple e assegnazioni\n\nString b1, b2, b3 = \"abc\"                   // Dichiarazioni miste (b1, b2) con una assegnazione (b3)\n\nString d1, String d2;                   // ERROR - NOT LEGAL\n\nString v1; v2;                          // ERROR - NOT LEGAL\n</code></pre> <p></p>"},{"location":"it/module-01/instantiating-types/#612-gestione-dei-tipi-reference","title":"6.1.2 Gestione dei tipi reference","text":""},{"location":"it/module-01/instantiating-types/#6121-creare-e-assegnare-un-reference","title":"6.1.2.1 Creare e assegnare un reference","text":"<p>Assegnare un tipo <code>reference</code> significa memorizzare nella variabile l\u2019indirizzo di memoria di un oggetto.</p> <p>Questo si fa normalmente dopo la creazione dell\u2019oggetto con la keyword new e un costruttore, oppure usando un letterale o un metodo factory.</p> <p>Un reference pu\u00f2 anche essere assegnato a un altro oggetto dello stesso tipo o di tipo compatibile.</p> <p>I tipi reference possono anche essere assegnati a null, il che significa che non faranno riferimento ad alcun oggetto.</p> <ul> <li>Esempi di sintassi:</li> </ul> <pre><code>Person person = new Person(); // Esempio con 'new' e un costruttore 'Person()':\n                            // 'new Person()' crea un nuovo oggetto Person nell\u2019heap\n                            // e restituisce il suo reference, che viene memorizzato nella variabile 'person'.\n\nString greeting = \"Hello\";   // Esempio con letterale (per String).\n\nList&lt;Integer&gt; numbers = List.of(1, 2, 3);   // Esempio con un metodo factory.\n</code></pre> <p></p>"},{"location":"it/module-01/instantiating-types/#6122-costruttori","title":"6.1.2.2 Costruttori","text":"<p>Nell\u2019esempio, <code>Person()</code> \u00e8 un costruttore \u2014 un tipo speciale di metodo usato per inizializzare nuovi oggetti.</p> <p>Ogni volta che chiami <code>new Person()</code>, il costruttore viene eseguito e imposta la nuova istanza creata.</p> <p>I costruttori hanno tre caratteristiche principali:</p> <ul> <li>Il nome del costruttore deve corrispondere esattamente al nome della classe (case-sensitive).  </li> <li>I costruttori non dichiarano un tipo di ritorno (nemmeno <code>void</code>).  </li> <li>Se non definisci alcun costruttore nella tua classe, il compilatore fornisce automaticamente un costruttore di default senza argomenti che non fa nulla.</li> </ul> <p>Warning</p> <p>Se vedi un metodo che ha lo stesso nome della classe ma dichiara anche un tipo di ritorno, non \u00e8 un costruttore. \u00c8 semplicemente un metodo normale (anche se iniziare i nomi dei metodi con una lettera maiuscola va contro le convenzioni di naming in Java).</p> <p>Lo scopo di un costruttore \u00e8 inizializzare lo stato di un oggetto appena creato \u2014 tipicamente assegnando valori ai suoi campi, con valori di default oppure usando parametri passati al costruttore.</p> <ul> <li>Esempio 1: Costruttore di default (senza parametri)</li> </ul> <pre><code>public class Person {\n    String name;\n    int age;\n\n    // Default constructor\n    public Person() {\n        name = \"Unknown\";\n        age = 0;\n    }\n}\n\nPerson p1 = new Person(); // name = \"Unknown\", age = 0\n</code></pre> <ul> <li>Esempio 2: Costruttore con parametri</li> </ul> <pre><code>public class Person {\n    String name;\n    int age;\n\n    // Constructor with parameters\n    public Person(String newName, int newAge) {\n        name = newName;\n        age = newAge;\n    }\n}\n\nPerson p2 = new Person(\"Alice\", 30); // name = \"Alice\", age = 30\n</code></pre> <ul> <li>Esempio 3: Costruttori multipli (overloading dei costruttori)</li> </ul> <pre><code>public class Person {\n    String name;\n    int age;\n\n    // Default constructor\n    public Person() {\n        this(\"Unknown\", 0); // calls the other constructor\n    }\n\n    // Constructor with parameters\n    public Person(String newName, int newAge) {\n        name = newName;\n        age = newAge;\n    }\n}\n\nPerson p1 = new Person();            // name = \"Unknown\", age = 0\nPerson p2 = new Person(\"Bob\", 25);   // name = \"Bob\", age = 25\n</code></pre> <p>Important</p> <ul> <li>I costruttori non sono ereditati: se una superclasse definisce costruttori, non sono automaticamente disponibili nella sottoclasse \u2014 devi dichiararli esplicitamente.</li> <li>Se dichiari un qualsiasi costruttore in una classe, il compilatore non genera il costruttore di default senza argomenti: se ti serve ancora un costruttore senza argomenti, devi dichiararlo manualmente.</li> </ul> <p></p>"},{"location":"it/module-01/instantiating-types/#6123-blocchi-di-inizializzazione-istanza","title":"6.1.2.3 Blocchi di inizializzazione istanza","text":"<p>Oltre ai costruttori, Java offre un meccanismo chiamato initializer blocks per l'inizializzazione degli oggetti.  </p> <p>Sono blocchi di codice all\u2019interno di una classe, racchiusi tra <code>{ }</code>, che vengono eseguiti ogni volta che viene creata un\u2019istanza, subito prima dell\u2019esecuzione del corpo del costruttore.</p> <p>Caratteristiche</p> <ul> <li>Chiamati anche instance initializer blocks.  </li> <li>Eseguiti, insieme all'inizializzazione dei campi, nell\u2019ordine in cui appaiono nella definizione della classe ma sempre prima dei costruttori.    </li> <li>Utili quando pi\u00f9 costruttori devono condividere un codice comune di inizializzazione.</li> </ul> <p>Esempio: usare un Instance Initializer Block</p> <pre><code>public class Person {\n    String name;\n    int age;\n\n    // Instance initializer block\n    {\n        System.out.println(\"Instance initializer block executed\");\n        age = 18; // default age for every Person\n    }\n\n    // Default constructor\n    public Person() {\n        name = \"Unknown\";\n    }\n\n    // Constructor with parameters\n    public Person(String newName) {\n        name = newName;\n    }\n}\n\nPerson p1 = new Person();          // prints \"Instance initializer block executed\"\nPerson p2 = new Person(\"Alice\");   // prints \"Instance initializer block executed\"\n</code></pre> <p>Note</p> <p>In questo esempio, il blocco di inizializzazione viene eseguito prima del corpo di entrambi i costruttori. Sia p1 che p2 partiranno con age = 18, indipendentemente da quale costruttore viene usato.</p> <p>Blocchi di inizializzazione multipli: se una classe contiene pi\u00f9 initializer blocks, essi vengono eseguiti nell\u2019ordine in cui compaiono nel file sorgente:</p> <ul> <li>Esempio: </li> </ul> <pre><code>public class Example {\n    {\n        System.out.println(\"First block\");\n    }\n\n    {\n        System.out.println(\"Second block\");\n    }\n}\n\nExample ex = new Example();\n// Output:\n// First block\n// Second block\n</code></pre> <p>Note</p> <p>I blocchi di inizializzazione d\u2019istanza sono meno comuni nella pratica, perch\u00e9 una logica simile pu\u00f2 spesso essere messa direttamente nei costruttori. \u00c8 importante sapere che: - Vengono sempre eseguiti prima del corpo del costruttore. - Sono eseguiti nell\u2019ordine di dichiarazione nella classe. - Possono essere combinati con i costruttori per evitare duplicazioni di codice.</p> <p>Warning</p> <p>Ordine di inizializzazione quando si crea un oggetto 1. Campi statici 2. Blocchi di inizializzazione statici 3. Campi di istanza 4. Blocchi di inizializzazione d\u2019istanza 5. Corpo del costruttore</p> <p></p>"},{"location":"it/module-01/instantiating-types/#62-inizializzazione-predefinita-delle-variabili","title":"6.2 Inizializzazione predefinita delle variabili","text":""},{"location":"it/module-01/instantiating-types/#621-variabili-di-istanza-e-di-classe","title":"6.2.1 Variabili di istanza e di classe","text":"<ul> <li>Una variabile di istanza (un field) \u00e8 un valore definito all\u2019interno di un\u2019istanza di un oggetto;</li> <li>Una variabile di classe (definita con la keyword static) \u00e8 definita a livello di classe ed \u00e8 condivisa tra tutti gli oggetti (istanze della classe)</li> </ul> <p>Se non inizializzate, variabili di istanza e di classe ricevono un valore di default dal compilatore.</p> <ul> <li>Tabella dei valori di default per variabili di istanza e di classe:</li> </ul> Type Default Value Object null Numeric 0 boolean false char '\\u0000' (NUL) <p></p>"},{"location":"it/module-01/instantiating-types/#622-variabili-final-di-istanza","title":"6.2.2 Variabili final di istanza","text":"<p>A differenza delle normali variabili di istanza e di classe, le variabili <code>final</code> non vengono inizializzate di default dal compilatore. </p> <p>Una variabile <code>final</code> deve essere assegnata esplicitamente esattamente una sola volta, altrimenti il codice non compila.</p> <p>Questo vale sia per:</p> <ul> <li>variabili final di istanza</li> <li>variabili di classe static final</li> </ul> <p>Note</p> <p>Possiamo assegnare un valore <code>null</code> a una variabile final di istanza o di classe, purch\u00e9 venga impostato esplicitamente.</p> <p>Java impone questa regola perch\u00e9 una variabile <code>final</code> rappresenta un valore che deve essere noto e fissato prima dell\u2019uso.</p> <p><code>Final Instance Variables</code></p> <p>Una variabile final di istanza deve essere assegnata esattamente una sola volta, e l\u2019assegnazione deve avvenire in una delle seguenti modalit\u00e0:</p> <ol> <li>Nel punto di dichiarazione</li> <li>In un blocco di inizializzazione d\u2019istanza</li> <li>All\u2019interno di ogni costruttore</li> </ol> <p>Se la classe ha pi\u00f9 costruttori, la variabile deve essere assegnata in tutti.</p> <ul> <li>Esempio: <pre><code>public class Person {\n    final int id;   // deve essere assegnata prima che il costruttore termini\n    String name;\n\n    // Costruttore 1\n    public Person(int id, String name) {\n        this.id = id;        // ok\n        this.name = name;\n    }\n\n    // Costruttore 2\n    public Person() {\n        this.id = 0;         // richiesto anche qui\n        this.name = \"Unknown\";\n    }\n}\n</code></pre></li> </ul> <p>Warning</p> <p>Provare a compilare senza assegnare <code>id</code> dentro ogni costruttore produce un errore a compile-time: variable id might not have been initialized</p> <p>Variabili di classe <code>static final</code> (Costanti)</p> <p>Una variabile static final appartiene alla classe, non a una specifica istanza.  </p> <p>Deve anch\u2019essa essere assegnata esattamente una sola volta, ma l\u2019assegnazione pu\u00f2 avvenire in uno dei seguenti punti:</p> <ol> <li>Nel punto di dichiarazione</li> <li> <p>Dentro un blocco di inizializzazione statico</p> </li> <li> <p>Esempio: <pre><code>public class AppConfig {\n\n    static final int TIMEOUT = 5000;    // assegnata nella dichiarazione\n\n    static final String VERSION;        // assegnata nel blocco static\n\n    static {\n        VERSION = \"1.0.0\";              // ok\n    }\n}\n</code></pre></p> </li> </ol> <p>Tentare di assegnare una <code>static final</code> in un costruttore non \u00e8 consentito.</p> <p>Regole chiave per i campi <code>final</code></p> Scenario Allowed? Notes Assign at declaration \u2714 Most common pattern Assign in constructor \u2714 All constructors must assign it Assign in instance initializer \u2714 Before constructor body runs Assign in static initializer (static final only) \u2714 For class-level constants Assign multiple times \u274c Compilation error Default initialization \u274c Must be explicitly assigned <p>Esempio di situazione illegale: <pre><code>public class Example {\n    final int x;        // non inizializzata\n}\n\nExample e = new Example(); // \u274c compile-time error\n</code></pre></p> <p>Perch\u00e9 le variabili <code>final</code> non vengono inizializzate di default?</p> <p>Perch\u00e9:</p> <ul> <li>Il loro valore deve essere noto e immutabile, e</li> <li>Java deve garantire che il valore sia impostato prima dell\u2019uso,</li> <li>L\u2019inizializzazione di default creerebbe una situazione in cui <code>0</code>, <code>null</code>, o <code>false</code> potrebbero diventare involontariamente il valore permanente.</li> </ul> <p>Per questo Java costringe gli sviluppatori a inizializzare esplicitamente i campi <code>final</code>.</p> <p>Tip</p> <p><code>final</code> significa assegnato una volta, non oggetto immutabile.</p> <p>Un reference final pu\u00f2 comunque puntare a un oggetto mutabile.</p> <pre><code>final List&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"ok\");      // consentito\nlist = new ArrayList&lt;&gt;(); // \u274c non puoi riassegnare il reference\n</code></pre> <p></p>"},{"location":"it/module-01/instantiating-types/#623-variabili-locali","title":"6.2.3 Variabili locali","text":"<p>Le variabili locali sono variabili definite all\u2019interno di un <code>costruttore</code>, di un <code>metodo</code> o di un <code>blocco di inizializzazione</code>;</p> <p>Le variabili locali non hanno valori di default e devono essere inizializzate prima di poter essere usate. Se provi a usare una variabile locale non inizializzata, il compilatore segnaler\u00e0 un ERRORE.</p> <ul> <li>Esempio </li> </ul> <pre><code>public int localMethod {\n\n    int firstVar = 25;\n    int secondVar;\n    secondVar = 35;\n    int firstSum = firstVar + secondVar;    // OK: entrambe le variabili sono inizializzate prima dell\u2019uso\n\n    int thirdVar;\n    int secondSum = firstSum + thirdVar;    // ERROR: la variabile thirdVar non \u00e8 stata inizializzata prima dell\u2019uso; se non provi a usare thirdVar il compilatore non segnaler\u00e0 nulla\n}\n</code></pre> <p></p>"},{"location":"it/module-01/instantiating-types/#6231-inferire-i-tipi-con-var","title":"6.2.3.1 Inferire i tipi con var","text":"<p>In certe condizioni puoi usare la keyword var al posto del tipo appropriato quando dichiari variabili locali;</p> <p>Warning</p> <ul> <li>var NON \u00e8 una parola riservata in Java;</li> <li>var pu\u00f2 essere usata solo per variabili locali: NON pu\u00f2 essere usata per parametri del costruttore, variabili di istanza o parametri dei metodi;</li> <li>Il compilatore inferisce il tipo guardando SOLO il codice sulla riga della dichiarazione; una volta inferito il tipo, non puoi riassegnare a un altro tipo.</li> </ul> <ul> <li>Esempio</li> </ul> <pre><code>public int localMethod {\n\n    var inferredInt = 10;   // Il compilatore inferisce int dal contesto\n    inferredInt = 25;       // OK\n\n    inferredInt = \"abcd\";   // ERROR: il compilatore ha gi\u00e0 inferito il tipo della variabile come int\n\n    var notInferred;\n    notInferred = 30;       // ERROR: per inferire il tipo, il compilatore guarda SOLO la riga con la dichiarazione\n\n    var first, second = 15; // ERROR: var non pu\u00f2 essere usata per definire due variabili nella stessa istruzione\n\n    var x = null;           // ERROR: var non pu\u00f2 essere inizializzata con null ma pu\u00f2 essere riassegnata a null purch\u00e9 il tipo sottostante sia un tipo reference.\n}\n</code></pre> <p>Warning</p> <p>Le variabili locali non ricevono mai valori di default. Le variabili di istanza e di classe (static) s\u00ec, sempre.</p> <p></p>"},{"location":"it/module-01/instantiating-types/#63-tipi-wrapper","title":"6.3 Tipi wrapper","text":"<p>In Java, i tipi wrapper sono rappresentazioni a oggetti degli otto tipi primitivi. </p> <p>Ogni primitivo ha una corrispondente classe wrapper nel package <code>java.lang</code>:</p> Primitive Wrapper Class <code>byte</code> <code>Byte</code> <code>short</code> <code>Short</code> <code>int</code> <code>Integer</code> <code>long</code> <code>Long</code> <code>float</code> <code>Float</code> <code>double</code> <code>Double</code> <code>char</code> <code>Character</code> <code>boolean</code> <code>Boolean</code> <p>Gli oggetti wrapper sono immutabili \u2014 una volta creati, il loro valore non pu\u00f2 cambiare.</p> <p></p>"},{"location":"it/module-01/instantiating-types/#631-scopo-dei-tipi-wrapper","title":"6.3.1 Scopo dei tipi wrapper","text":"<ul> <li>Consentono di usare i primitivi in contesti che richiedono oggetti (es. collezioni, generics).  </li> <li>Forniscono metodi di utilit\u00e0 per parsing, conversione e manipolazione dei valori.  </li> <li>Supportano costanti come <code>Integer.MAX_VALUE</code> o <code>Double.MIN_VALUE</code>.  </li> </ul>"},{"location":"it/module-01/instantiating-types/#632-autoboxing-e-unboxing","title":"6.3.2 Autoboxing e unboxing","text":"<p>Da Java 5, il compilatore converte automaticamente tra primitivi e wrapper:</p> <ul> <li>Autoboxing: primitivo \u2192 wrapper  </li> <li>Unboxing: wrapper \u2192 primitivo  </li> </ul> <pre><code>Integer i = 10;       // autoboxing: int \u2192 Integer\nint n = i;            // unboxing: Integer \u2192 int\n\nInteger int1 = Integer.valueOf(11);\nlong long1 = int1;  // Unboxing --&gt; implicit cast OK\n\nLong long2 = 11;   // \u274c Does not compile. \n                   // 11 is an int literal \u2192 requires autoboxing + widening \u2192 illegal\n\nCharacter char1 = null;\nchar char2 = char1;  // WARNING: NullPointerException\n\nInteger  arr1 = {11.5, 13.6}  // WARNING: Does not compile!!\nDouble[] arr2 = {11, 22};     // WARNING: Does not compile!!\n</code></pre> <p>Tip</p> <p>Java non esegue mai <code>autoboxing + widening/narrowing</code> in un solo passo.</p> <p>Warning</p> <ul> <li>AUTOBOXING e cast implicito non sono consentiti nella stessa istruzione: non puoi fare entrambe le cose contemporaneamente. (vedi esempio sopra)</li> <li>Questa regola vale anche nelle chiamate ai metodi.</li> </ul> <p></p>"},{"location":"it/module-01/instantiating-types/#633-parsing-e-conversione","title":"6.3.3 Parsing e conversione","text":"<p>I wrapper forniscono metodi statici per convertire stringhe o altri tipi in primitivi:</p> <pre><code>int x = Integer.parseInt(\"123\");    // returns primitive int\nInteger y = Integer.valueOf(\"456\"); // returns Integer object\ndouble d = Double.parseDouble(\"3.14\");\n\n// On the numeric wrapper class valueOf() throws a NumberFormatException on invalid input.\n// Example:\n\nInteger w = Integer.valueOf(\"two\"); // NumberFormatException\n\n// On Boolean, the method returns Boolean.TRUE for any value that matches \"true\" ignoring case, otherwise Boolean.false\n// Example:\n\nBoolean.valueOf(\"true\");    // true\nBoolean.valueOf(\"TrUe\");    // true\nBoolean.valueOf(\"TRUE\");    // true\nBoolean.valueOf(\"false\");   // false\nBoolean.valueOf(\"FALSE\");   // false\nBoolean.valueOf(\"xyz\");     // false\nBoolean.valueOf(null);      // false\n\n// The numeric integral classes Byte, Short, Integer and Long include an overloaded **valueOf(String str, int base)** method which takes a base value\n// Example with base 16 (hexadecimal) which includes character 0 -&gt; 9 and A -&gt; F (ignore case)\n\nInteger.valueOf(\"6\", 16);   // 6\nInteger.valueOf(\"a\", 16);   // 10\nInteger.valueOf(\"A\", 16);   // 10\nInteger.valueOf(\"F\", 16);   // 15\nInteger.valueOf(\"G\", 16);   // NumberFormatException\n</code></pre> <p>Note</p> <p>I metodi parseXxx() restituiscono un primitivo mentre valueOf() restituisce un oggetto wrapper.</p> <p></p>"},{"location":"it/module-01/instantiating-types/#634-metodi-di-supporto","title":"6.3.4 Metodi di supporto","text":"<p>Tutte le classi wrapper numeriche estendono la classe <code>Number</code> e, per questo, ereditano alcuni metodi di supporto come: <code>byteValue()</code>, <code>shortValue()</code>, <code>intValue()</code>, <code>longValue()</code>, <code>floatValue()</code>, <code>doubleValue()</code>.</p> <p>Le classi wrapper <code>Boolean</code> e <code>Character</code> includono: <code>booleanValue()</code> e <code>charValue()</code>.</p> <ul> <li>Esempio:</li> </ul> <pre><code>// In trying to convert those helper methods can result in a loss of precision.\n\nDouble baseDouble = Double.valueOf(\"300.56\");\n\ndouble wrapDouble = baseDouble.doubleValue();\nSystem.out.println(\"baseDouble.doubleValue(): \" + wrapDouble);  // 300.56\n\nbyte wrapByte = baseDouble.byteValue();\nSystem.out.println(\"baseDouble.byteValue(): \" + wrapByte);      // 44  -&gt; There is no 300 in byte\n\nint wrapInt = baseDouble.intValue();\nSystem.out.println(\"baseDouble.intValue(): \" + wrapInt);        // 300 -&gt; The value is truncated\n</code></pre> <p></p>"},{"location":"it/module-01/instantiating-types/#635-valori-null","title":"6.3.5 Valori null","text":"<p>A differenza dei primitivi, i tipi wrapper possono contenere null. Tentare di fare unboxing di null causa una <code>NullPointerException</code>:</p> <pre><code>Integer val = null;\nint z = val; // \u274c NullPointerException at runtime\n</code></pre> <p></p>"},{"location":"it/module-01/instantiating-types/#64-uguaglianza-in-java","title":"6.4 Uguaglianza in Java","text":"<p>Java fornisce due meccanismi distinti per verificare l\u2019uguaglianza:</p> <ul> <li><code>==</code> (operatore di uguaglianza)</li> <li><code>.equals()</code> (metodo definito in <code>Object</code> e ridefinito in molte classi)</li> </ul> <p>Capirne la differenza \u00e8 essenziale.</p> <p></p>"},{"location":"it/module-01/instantiating-types/#641-uguaglianza-con-i-tipi-primitivi","title":"6.4.1 Uguaglianza con i tipi primitivi","text":"<p>Per i valori primitivi (<code>int</code>, <code>double</code>, <code>char</code>, <code>boolean</code>, ecc.), l\u2019operatore <code>==</code> confronta il loro reale valore numerico o booleano.</p> <p>Esempio: <pre><code>int a = 5;\nint b = 5;\nSystem.out.println(a == b);     // true\n\nchar c1 = 'A';\nchar c2 = 65;                   // stesso code point Unicode\nSystem.out.println(c1 == c2);   // true\n</code></pre></p> <p></p>"},{"location":"it/module-01/instantiating-types/#6411-punti-chiave","title":"6.4.1.1 Punti chiave","text":"<ul> <li><code>==</code> esegue un confronto di valori per i primitivi.</li> <li>I tipi primitivi non hanno un metodo <code>.equals()</code>.</li> <li>Tipi primitivi misti seguono le regole di promozione numerica   (es. <code>int == long</code> \u2192 <code>int</code> promosso a <code>long</code>).</li> </ul>"},{"location":"it/module-01/instantiating-types/#642-uguaglianza-con-i-tipi-reference","title":"6.4.2 Uguaglianza con i tipi reference","text":"<p>Con gli oggetti (tipi reference), il significato di <code>==</code> cambia.</p> <p></p>"},{"location":"it/module-01/instantiating-types/#6421-confronto-di-identita","title":"6.4.2.1 <code>==</code> (Confronto di identit\u00e0)","text":"<p><code>==</code> verifica se due riferimenti puntano allo stesso oggetto in memoria.</p> <pre><code>String s1 = new String(\"Hi\");\nString s2 = new String(\"Hi\");\n\nSystem.out.println(s1 == s2);      // false \u2192 oggetti diversi\n</code></pre> <p>Anche se i contenuti sono identici, <code>==</code> \u00e8 false a meno che entrambe le variabili non si riferiscano allo stesso identico oggetto.</p> <p></p>"},{"location":"it/module-01/instantiating-types/#6422-equals-confronto-logico","title":"6.4.2.2 <code>.equals()</code> (Confronto logico)","text":"<p>Molte classi ridefiniscono <code>.equals()</code> per confrontare i valori, non gli indirizzi di memoria.</p> <pre><code>System.out.println(s1.equals(s2)); // true \u2192 stesso contenuto\n</code></pre> <p></p>"},{"location":"it/module-01/instantiating-types/#6423-punti-chiave","title":"6.4.2.3 Punti chiave","text":"<ul> <li><code>.equals()</code> \u00e8 definito in <code>Object</code>.</li> <li>Se una classe non ridefinisce <code>.equals()</code>, si comporta come <code>==</code>.</li> <li>Classi come <code>String</code>, <code>Integer</code>, <code>List</code>, ecc. ridefiniscono <code>.equals()</code>   per fornire un confronto di valori significativo.</li> </ul>"},{"location":"it/module-01/instantiating-types/#643-string-pool-e-uguaglianza","title":"6.4.3 String Pool e uguaglianza","text":"<p>I letterali String sono memorizzati nello String pool, quindi letterali identici che si riferiscono allo stesso oggetto.</p> <pre><code>String a = \"Java\";\nString b = \"Java\";\nSystem.out.println(a == b);       // true \u2192 stesso literal nel pool\n</code></pre> <p>Ma usare <code>new</code> crea un oggetto diverso:</p> <pre><code>String x = new String(\"Java\");\nString y = \"Java\";\n\nSystem.out.println(x == y);       // false \u2192 x non \u00e8 nello pool\nSystem.out.println(x.equals(y));  // true\n</code></pre> <p>Errori comuni</p> <pre><code>String x = \"Java string literal\";\nString y = \" Java string literal\".trim();\n\nSystem.out.println(x == y);       // false \u2192 x e y non sono lo stesso a compile-time\n\nString a = \"Java string literal\";\nString b = \"Java \";\nb += \"string literal\";\n\nSystem.out.println(a == b);  // false\n</code></pre> <p>Warning</p> <p>Qualsiasi String creata a runtime non entra nel pool automaticamente. Si usi <code>intern()</code> se si vuole il pooling.</p> <p>Tip</p> <p><code>\"Hello\" == \"Hel\" + \"lo\"</code> \u2192 true (costante a compile-time)</p> <p><code>\"Hello\" == getHello()</code> \u2192 false (concatenazione a runtime)</p> <pre><code>String x = \"Hello\";\nString y = \"Hel\" + \"lo\";   // compile-time \u2192 stesso literal\nString z = \"Hel\";\nz += \"lo\";                 // runtime \u2192 nuova String\n\nSystem.out.println(x == y); // true\nSystem.out.println(x == z); // false\n</code></pre> <p></p>"},{"location":"it/module-01/instantiating-types/#6431-il-metodo-intern","title":"6.4.3.1 Il metodo intern","text":"<p>Puoi anche dire a Java di usare una String dallo String Pool (nel caso esista gi\u00e0) tramite il metodo <code>intern()</code>:</p> <pre><code>String x = \"Java\";\nString y = new String(\"Java\").intern();\n\nSystem.out.println(x == y);       // true\n</code></pre> <p></p>"},{"location":"it/module-01/instantiating-types/#644-uguaglianza-con-i-tipi-wrapper","title":"6.4.4 Uguaglianza con i tipi wrapper","text":"<p>Le classi wrapper (<code>Integer</code>, <code>Double</code>, ecc.) si comportano come oggetti:</p> <ul> <li><code>==</code> \u2192 confronta i riferimenti  </li> <li><code>.equals()</code> \u2192 confronta i valori  </li> </ul> <p>Tuttavia, alcuni wrapper vengono cache-ati (Integer da \u2212128 a 127):</p> <pre><code>Integer a = 100;\nInteger b = 100;\nSystem.out.println(a == b);        // true \u2192 cached\n\nInteger c = 1000;\nInteger d = 1000;\nSystem.out.println(c == d);        // false \u2192 non cached\n\nSystem.out.println(c.equals(d));   // true \u2192 stesso valore numerico\n</code></pre> <p>Warning</p> <p>Attenzione alla cache dei wrapper.</p> <p></p>"},{"location":"it/module-01/instantiating-types/#645-uguaglianza-e-null","title":"6.4.5 Uguaglianza e <code>null</code>","text":"<ul> <li><code>== null</code> \u00e8 sempre sicuro.</li> <li>Chiamare <code>.equals()</code> su un reference <code>null</code> genera una <code>NullPointerException</code>.</li> </ul> <pre><code>String s = null;\nSystem.out.println(s == null);   // true\n// s.equals(\"Hi\");               // \u274c NullPointerException\n</code></pre>"},{"location":"it/module-01/instantiating-types/#646-tabella-riepilogativa","title":"6.4.6 Tabella riepilogativa","text":"Comparison Primitives Objects / Wrappers Strings <code>==</code> compares value compares reference identity (affected by String pool) <code>.equals()</code> N/A compares content if overridden content comparison"},{"location":"it/module-01/java-operators/","title":"5. Operatori Java","text":""},{"location":"it/module-01/java-operators/#indice","title":"Indice","text":"<ul> <li>5.1 Definizione</li> <li>5.2 Tipi di operatori</li> <li>5.3 Categorie di operatori</li> <li>5.4 Precedenza degli operatori e ordine di valutazione</li> <li>5.5 Tabella riassuntiva degli operatori Java<ul> <li>5.5.1 Note aggiuntive</li> </ul> </li> <li>5.6 Operatori unari<ul> <li>5.6.1 Categorie di operatori unari</li> <li>5.6.2 Esempi</li> </ul> </li> <li>5.7 Operatori binari<ul> <li>5.7.1 Categorie di operatori binari</li> <li>5.7.2 Operatori di divisione e resto (modulus)<ul> <li>5.7.2.1 Operatore di divisione</li> <li>5.7.2.2 Operatore Modulo</li> </ul> </li> <li>5.7.3 Il valore di ritorno dell\u2019operatore di assegnazione</li> <li>5.7.4 Operatori di assegnazione composta</li> <li>5.7.5 Operatori di uguaglianza == e !=<ul> <li>5.7.5.1 Uguaglianza con tipi primitivi</li> <li>5.7.5.2 Uguaglianza con tipi reference (oggetti)</li> </ul> </li> <li>5.7.6 L\u2019operatore instanceof<ul> <li>5.7.6.1 Controllo in fase di compilazione vs fase di esecuzione</li> <li>5.7.6.2 Pattern matching per instanceof</li> <li>5.7.6.3 Flow scoping e logica short-circuit</li> <li>5.7.6.4 Array e tipi reificabili</li> </ul> </li> </ul> </li> <li>5.8 Operatore Ternario<ul> <li>5.8.1 Regole di Tipo per l\u2019Operatore Ternario<ul> <li>5.8.1.1 Operandi Numerici</li> <li>5.8.1.2 Tipi di Riferimento</li> </ul> </li> <li>5.8.2 Sintassi</li> <li>5.8.3 Esempio</li> <li>5.8.4 Esempio di Ternario Annidato</li> <li>5.8.5 Note</li> </ul> </li> </ul>"},{"location":"it/module-01/java-operators/#51-definizione","title":"5.1 Definizione","text":"<p>In Java, gli operatori sono simboli speciali che eseguono operazioni su variabili e valori. Sono i mattoni fondamentali delle espressioni e permettono agli sviluppatori di manipolare i dati, confrontare valori, eseguire operazioni aritmetiche e controllare il flusso logico.</p> <p>Un\u2019espressione \u00e8 una combinazione di operatori e operandi che produce un risultato.</p> <p>Per esempio: <pre><code>int result = (a + b) * c;\n</code></pre></p> <p>Qui, <code>+</code> e <code>*</code> sono operatori, e <code>a</code>, <code>b</code> e <code>c</code> sono operandi.</p> <p></p>"},{"location":"it/module-01/java-operators/#52-tipi-di-operatori","title":"5.2 Tipi di operatori","text":"<p>Java definisce tre tipi di operatori, raggruppati in base al numero di operandi che utilizzano:</p> Type Descrizione Esempi Unary Opera su un singolo operando <code>+x</code>, <code>-x</code>, <code>++x</code>, <code>--x</code>, <code>!flag</code>, <code>~num</code> Binary Opera su due operandi <code>a + b</code>, <code>a - b</code>, <code>x * y</code>, <code>x / y</code>, <code>x % y</code> Ternary Opera su tre operandi (ce n\u2019\u00e8 uno solo in Java) <code>condition ? valueIfTrue : valueIfFalse</code> <p></p>"},{"location":"it/module-01/java-operators/#53-categorie-di-operatori","title":"5.3 Categorie di operatori","text":"<p>Gli operatori possono anche essere raggruppati, in base al loro scopo, in categorie:</p> Categoria Descrizione Esempi Assignment Assegna valori alle variabili <code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code> Relational Confronta valori <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> Logical Combina o inverte espressioni booleane <code>|</code>, <code>&amp;</code>, <code>^</code> Conditional Combina o inverte espressioni booleane <code>||</code>, <code>&amp;&amp;</code> Bitwise Manipola i bit <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>~</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code> Instanceof Verifica il tipo di un oggetto <code>obj instanceof ClassName</code> Lambda Usato nelle espressioni lambda <code>(x, y) -&gt; x + y</code> <p></p>"},{"location":"it/module-01/java-operators/#54-precedenza-degli-operatori-e-ordine-di-valutazione","title":"5.4 Precedenza degli operatori e ordine di valutazione","text":"<p>La precedenza degli operatori determina come gli operatori sono raggruppati in un\u2019espressione \u2014 cio\u00e8, quali operazioni vengono eseguite per prime.</p> <p>L\u2019associativit\u00e0 (o ordine di valutazione) determina se l\u2019espressione viene valutata da sinistra a destra o da destra a sinistra quando gli operatori hanno la stessa precedenza.</p> <p>Esempio:</p> <pre><code>int result = 10 + 5 * 2;  // La moltiplicazione avviene prima dell\u2019addizione \u2192 result = 20\n</code></pre> <p>Le parentesi tonde <code>()</code> possono essere usate per forzare la precedenza:</p> <pre><code>int result = (10 + 5) * 2;  // Le parentesi vengono valutate per prime \u2192 result = 30\n</code></pre> <p>Note</p> <ul> <li>La precedenza degli operatori riguarda il raggruppamento, non l\u2019ordine effettivo di valutazione nel bytecode.</li> <li>Usa sempre le parentesi per rendere esplicita la precedenza e migliorare la leggibilit\u00e0 nelle espressioni complesse.</li> </ul> <p></p>"},{"location":"it/module-01/java-operators/#55-tabella-riassuntiva-degli-operatori-java","title":"5.5 Tabella riassuntiva degli operatori Java","text":"Precedenza (Alta \u2192 Bassa) Tipo Operatori Esempio Ordine di valutazione Applicabile a 1 Postfix Unary <code>expr++</code>, <code>expr--</code> <code>x++</code> Sinistra \u2192 Destra Tipi numerici 2 Prefix Unary <code>++expr</code>, <code>--expr</code> <code>--x</code> Sinistra \u2192 Destra Numerici 3 Other Unary <code>(type)</code>, <code>+</code>, <code>-</code>, <code>~</code>, <code>!</code> <code>-x</code>, <code>!flag</code> Destra \u2192 Sinistra Numerici, boolean 4 Cast Unary <code>(Type) reference</code> <code>(short) 22</code> Destra \u2192 Sinistra reference, primitivi 5 Multiplication/division/modulus <code>*</code>, <code>/</code>, <code>%</code> <code>a * b</code> Sinistra \u2192 Destra Tipi numerici 6 Additive <code>+</code>, <code>-</code> <code>a + b</code> Sinistra \u2192 Destra Numerici, String (concatenazione) 7 Shift <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code> <code>a &lt;&lt; 2</code> Sinistra \u2192 Destra Tipi interi 8 Relational <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>instanceof</code> <code>a &lt; b</code>, <code>obj instanceof Person</code> Sinistra \u2192 Destra Numerici, reference 9 Equality <code>==</code>, <code>!=</code> <code>a == b</code> Sinistra \u2192 Destra Tutti i tipi (eccetto boolean per <code>&lt;</code>, <code>&gt;</code>) 10 Logical AND <code>&amp;</code> <code>a &amp; b</code> Sinistra \u2192 Destra boolean 11 Logical exclusive OR <code>^</code> <code>a ^ b</code> Sinistra \u2192 Destra boolean 12 Logical inclusive OR <code>|</code> <code>a</code><code>|</code><code>b</code> Sinistra \u2192 Destra boolean 13 Conditional AND <code>&amp;&amp;</code> <code>a</code><code>&amp;&amp;</code><code>b</code> Sinistra \u2192 Destra boolean 14 Conditional OR <code>||</code> <code>a</code><code>||</code><code>b</code> Sinistra \u2192 Destra boolean 15 Ternary (Conditional) <code>? :</code> <code>a &gt; b ? x : y</code> Destra \u2192 Sinistra Tutti i tipi 16 Assignment <code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code> <code>x += 5</code> Destra \u2192 Sinistra Tutti i tipi assegnabili 17 Arrow operator <code>-&gt;</code> <code>(x, y) -&gt; x + y</code> Destra \u2192 Sinistra Espressioni lambda, switch rules"},{"location":"it/module-01/java-operators/#551-note-aggiuntive","title":"5.5.1 Note aggiuntive","text":"<ul> <li>La concatenazione di stringhe (<code>+</code>) ha una precedenza pi\u00f9 bassa rispetto all\u2019<code>+</code> aritmetico sui numeri.</li> <li>Usa le parentesi <code>()</code> per la precedenza e la leggibilit\u00e0 \u2014 non cambiano la semantica ma rendono l\u2019intento pi\u00f9 chiaro.</li> </ul>"},{"location":"it/module-01/java-operators/#56-operatori-unari","title":"5.6 Operatori unari","text":"<p>Gli operatori unari operano su un solo operando per produrre un nuovo valore. Sono usati per operazioni come incremento/decremento, negazione di un valore, inversione di un booleano o complemento bit a bit.</p> <p></p>"},{"location":"it/module-01/java-operators/#561-categorie-di-operatori-unari","title":"5.6.1 Categorie di operatori unari","text":"Operatore Nome Descrizione Esempio Risultato <code>+</code> Unary plus Indica un valore positivo (di solito ridondante). <code>+x</code> Uguale a <code>x</code> <code>-</code> Unary minus Indica che un numero letterale \u00e8 negativo o nega un\u2019espressione. <code>-5</code> <code>-5</code> <code>++</code> Increment Incrementa una variabile di 1. Pu\u00f2 essere prefisso o postfisso. <code>++x</code>, <code>x++</code> <code>x+1</code> <code>--</code> Decrement Decrementa una variabile di 1. Pu\u00f2 essere prefisso o postfisso. <code>--x</code>, <code>x--</code> <code>x-1</code> <code>!</code> Logical complement Inverte un valore booleano. <code>!true</code> <code>false</code> <code>~</code> Bitwise complement Inverte ogni bit di un intero. <code>~5</code> <code>-6</code> <code>(type)</code> Cast Converte il valore in un altro tipo. <code>(int) 3.9</code> <code>3</code>"},{"location":"it/module-01/java-operators/#562-esempi","title":"5.6.2 Esempi","text":"<pre><code>int x = 5;\nSystem.out.println(++x);  // 6  (prefisso: incrementa x a 6, poi restituisce 6)\nSystem.out.println(x++);  // 6  (postfisso: restituisce 6, poi incrementa x a 7)\nSystem.out.println(x);    // 7\n\nboolean flag = false;\nSystem.out.println(!flag);  // true\n\nint a = 5;                  // binario: 0000 0101\nSystem.out.println(~a);     // -6 \u2192 binario: 1111 1010 (complemento a due)\n</code></pre> <p>Note</p> <ul> <li>Prefisso (<code>++x</code> / <code>--x</code>): aggiorna prima il valore, poi restituisce il nuovo valore.</li> <li>Postfisso (<code>x++</code> / <code>x--</code>): restituisce prima il valore corrente, poi lo aggiorna.</li> <li>L\u2019operatore <code>!</code> si applica a valori boolean; <code>~</code> si applica a tipi numerici interi.</li> </ul> <p></p>"},{"location":"it/module-01/java-operators/#57-operatori-binari","title":"5.7 Operatori binari","text":"<p>Gli operatori binari richiedono due operandi. Eseguono operazioni aritmetiche, relazionali, logiche, bit a bit e di assegnazione.</p> <p></p>"},{"location":"it/module-01/java-operators/#571-categorie-di-operatori-binari","title":"5.7.1 Categorie di operatori binari","text":"Categoria Operatori Esempio Descrizione Arithmetic <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code> <code>a + b</code> Operazioni matematiche di base. Relational <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code>, <code>!=</code> <code>a &lt; b</code> Confrontano valori. Logical (boolean) <code>&amp;</code>, <code>|</code>, <code>^</code> <code>a</code><code>&amp;</code><code>b</code> Vedi nota sotto. Conditional <code>&amp;&amp;</code>, <code>||</code> <code>a</code><code>&amp;&amp;</code><code>b</code> Vedi nota sotto. Bitwise (integral) <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code> <code>a &lt;&lt; 2</code> Operano sui bit. Assignment <code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code> <code>x += 3</code> Modificano e assegnano. String Concatenation <code>+</code> <code>\"Hello \" + name</code> Uniscono stringhe. <p>Important</p> <ul> <li>Gli operatori logici (<code>&amp;</code>, <code>|</code>, <code>^</code>) valutano sempre entrambi i lati.</li> <li>Gli operatori condizionali (<code>&amp;&amp;</code>, <code>||</code>) sono short-circuit:</li> <li><code>a &amp;&amp; b</code> \u2192 <code>b</code> \u00e8 valutato solo se <code>a</code> \u00e8 true</li> <li><code>a || b</code> \u2192 <code>b</code> \u00e8 valutato solo se <code>a</code> \u00e8 false</li> </ul> <p>Esempi:</p> <p>Esempio aritmetico: <pre><code>int a = 10, b = 4;\nSystem.out.println(a + b);  // 14\nSystem.out.println(a - b);  // 6\nSystem.out.println(a * b);  // 40\nSystem.out.println(a / b);  // 2\nSystem.out.println(a % b);  // 2\n</code></pre></p> <p>Esempio relazionale: <pre><code>int a = 5, b = 8;\nSystem.out.println(a &lt; b);   // true\nSystem.out.println(a &gt;= b);  // false\nSystem.out.println(a == b);  // false\nSystem.out.println(a != b);  // true\n</code></pre></p> <p>Esempio logico: <pre><code>boolean x = true, y = false;\nSystem.out.println(x &amp;&amp; y);  // false\nSystem.out.println(x || y);  // true\nSystem.out.println(!x);      // false\n</code></pre></p> <p>Esempio bit a bit: <pre><code>int a = 5;   // 0101\nint b = 3;   // 0011\nSystem.out.println(a &amp; b);  // 1  (0001)\nSystem.out.println(a | b);  // 7  (0111)\nSystem.out.println(a ^ b);  // 6  (0110)\nSystem.out.println(a &lt;&lt; 1); // 10 (1010)\nSystem.out.println(a &gt;&gt; 1); // 2  (0010)\n</code></pre></p> <p></p>"},{"location":"it/module-01/java-operators/#572-operatori-di-divisione-e-resto-modulus","title":"5.7.2 Operatori di divisione e resto (modulus)","text":""},{"location":"it/module-01/java-operators/#5721-operatore-di-divisione","title":"5.7.2.1 Operatore di Divisione","text":"<p>Dividere un <code>intero</code> per zero (ad esempio, 10 / 0) provoca il lancio da parte della JVM di una <code>java.lang.ArithmeticException: / by zero</code>.</p> <p>Tuttavia, la divisione in virgola mobile si comporta in modo diverso.</p> <p>Quando un valore <code>float</code> o <code>double</code> viene diviso per 0 o 0.0, non viene lanciata alcuna eccezione. Invece, il risultato \u00e8:</p> <ul> <li>Float.POSITIVE_INFINITY oppure Float.NEGATIVE_INFINITY</li> <li>Double.POSITIVE_INFINITY oppure Double.NEGATIVE_INFINITY</li> </ul> <p>Il segno dipende dagli operandi coinvolti nell\u2019operazione.</p> <p>Per determinare se un valore in virgola mobile rappresenta l\u2019infinito, le classi <code>Float</code> e <code>Double</code> forniscono metodi di utilit\u00e0:</p> <p>Metodi statici:</p> <ul> <li>Float.isInfinite(float value)</li> <li>Double.isInfinite(double value)</li> </ul> <p>Metodi di istanza:</p> <ul> <li>Float.isInfinite()</li> <li>Double.isInfinite()</li> </ul> <p>Questi metodi restituiscono <code>true</code> se il valore corrisponde a infinito positivo o infinito negativo.</p> <p></p>"},{"location":"it/module-01/java-operators/#5722-operatore-modulo","title":"5.7.2.2 Operatore Modulo","text":"<p>L\u2019operatore di resto (modulus) restituisce il resto della divisione tra due numeri. Se due numeri si dividono esattamente, il resto \u00e8 0: per esempio 10 % 5 \u00e8 0. Al contrario, 13 % 4 restituisce il resto 1.</p> <p>Possiamo usare il resto anche con numeri negativi secondo le regole seguenti:</p> <ul> <li>se il divisore \u00e8 negativo (es.: 7 % -5), il segno viene ignorato e il risultato \u00e8 2;</li> <li>se il dividendo \u00e8 negativo (es.: -7 % 5), il segno viene preservato e il risultato \u00e8 -2;</li> </ul> <pre><code>System.out.println(8 % 5);      // GIVES 3\nSystem.out.println(10 % 5);     // GIVES 0\nSystem.out.println(10 % 3);     // GIVES 1    \nSystem.out.println(-10 % 3);    // GIVES -1    \nSystem.out.println(10 % -3);    // GIVES 1   \nSystem.out.println(-10 % -3);   // GIVES -1 \n\nSystem.out.println(8 % 9);      // GIVES 8\nSystem.out.println(3 % 4);      // GIVES 3    \nSystem.out.println(2 % 4);      // GIVES 2\nSystem.out.println(-8 % 9);     // GIVES -8\n</code></pre> <p></p>"},{"location":"it/module-01/java-operators/#573-il-valore-di-ritorno-delloperatore-di-assegnazione","title":"5.7.3 Il valore di ritorno dell\u2019operatore di assegnazione","text":"<p>In Java, l\u2019operatore di assegnazione (<code>=</code>) non si limita a memorizzare un valore in una variabile \u2014 restituisce anche il valore assegnato come risultato dell\u2019intera espressione.</p> <p>Questo significa che l\u2019operazione di assegnazione pu\u00f2 essere usata come parte di un\u2019altra espressione, ad esempio all\u2019interno di un\u2019istruzione <code>if</code>, nella condizione di un ciclo o perfino in un\u2019altra assegnazione.</p> <pre><code>int x;\nint y = (x = 10);   // l\u2019assegnazione (x = 10) restituisce 10\nSystem.out.println(y);  // 10\n\n// x = 10 assegna 10 a x.\n// L\u2019espressione (x = 10) viene valutata a 10.\n// Questo valore viene poi assegnato a y.\n// Quindi sia x che y finiscono con lo stesso valore (10).\n</code></pre> <p>Poich\u00e9 l\u2019assegnazione restituisce un valore, pu\u00f2 comparire anche all\u2019interno di un\u2019istruzione if. Tuttavia, ci\u00f2 porta spesso a errori logici se usata involontariamente.</p> <pre><code>boolean flag = false;\n\nif (flag = true) {\n    System.out.println(\"This will always execute!\");\n}\n\n// Qui la condizione (flag = true) assegna true a flag, poi viene valutata a true,\n// quindi il blocco if viene sempre eseguito.\n\n// Uso corretto (confronto invece di assegnazione):\n\nif (flag == true) {\n    System.out.println(\"Condition checked, not assigned\");\n}\n</code></pre> <p>Warning</p> <p>Se vedi <code>if (x = qualcosa)</code>, fermati: \u00e8 una assegnazione, non un confronto.</p> <p></p>"},{"location":"it/module-01/java-operators/#574-operatori-di-assegnazione-composta","title":"5.7.4 Operatori di assegnazione composta","text":"<p>Gli operatori di assegnazione composta in Java combinano un\u2019operazione aritmetica o bit a bit con l\u2019assegnazione in un unico passaggio. Invece di scrivere <code>x = x + 5</code>, puoi usare la forma abbreviata <code>x += 5</code>. Essi eseguono automaticamente un cast di tipo verso il tipo della variabile a sinistra quando necessario.</p> <p>Gli operatori composti pi\u00f9 comuni includono: <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&amp;=</code>, <code>|=</code>, <code>^=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, e <code>&gt;&gt;&gt;=</code>.</p> <pre><code>int x = 10;\n\n// Assegnazioni composte aritmetiche\nx += 5;   // equivale a x = x + 5 \u2192 x = 15\nx -= 3;   // equivale a x = x - 3 \u2192 x = 12\nx *= 2;   // equivale a x = x * 2 \u2192 x = 24\nx /= 4;   // equivale a x = x / 4 \u2192 x = 6\nx %= 5;   // equivale a x = x % 5 \u2192 x = 1\n\n// Assegnazioni composte bit a bit\nint y = 6;   // 0110 (binario)\ny &amp;= 3;      // y = y &amp; 3 \u2192 0110 &amp; 0011 = 0010 \u2192 y = 2\ny |= 4;      // y = y | 4 \u2192 0010 | 0100 = 0110 \u2192 y = 6\ny ^= 5;      // y = y ^ 5 \u2192 0110 ^ 0101 = 0011 \u2192 y = 3\n\n// Assegnazioni composte con shift\nint z = 8;   // 0000 1000\nz &lt;&lt;= 2;     // z = z &lt;&lt; 2 \u2192 0010 0000 \u2192 z = 32\nz &gt;&gt;= 1;     // z = z &gt;&gt; 1 \u2192 0001 0000 \u2192 z = 16\nz &gt;&gt;&gt;= 2;    // z = z &gt;&gt;&gt; 2 \u2192 0000 0100 \u2192 z = 4\n\n// Esempio di cast di tipo\nbyte b = 10;\n// b = b + 1;   // \u274c errore di compilazione: il risultato int non pu\u00f2 essere assegnato a byte\nb += 1;         // \u2705 funziona: cast implicito di nuovo verso byte\n</code></pre> <p>Note</p> <p>Gli operatori di assegnazione composta eseguono un cast implicito verso il tipo della variabile a sinistra. Per questo motivo <code>b += 1</code> compila anche se <code>b = b + 1</code> non compila.</p> <p></p>"},{"location":"it/module-01/java-operators/#575-operatori-di-uguaglianza-e","title":"5.7.5 Operatori di uguaglianza (<code>==</code> e <code>!=</code>)","text":"<p>Gli operatori di uguaglianza in Java <code>==</code> (uguale a) e <code>!=</code> (diverso da) vengono usati per confrontare due operandi. Tuttavia, il loro comportamento differisce a seconda che siano applicati a tipi primitivi o a tipi reference (oggetti).</p> <p>Note</p> <ul> <li><code>==</code> confronta i valori per i tipi primitivi</li> <li><code>==</code> confronta i riferimenti per gli oggetti  </li> <li><code>.equals()</code> confronta il contenuto dell\u2019oggetto (se implementato)</li> </ul> <p></p>"},{"location":"it/module-01/java-operators/#5751-uguaglianza-con-tipi-primitivi","title":"5.7.5.1 Uguaglianza con tipi primitivi","text":"<p>Quando si confrontano valori primitivi, <code>==</code> e <code>!=</code> confrontano i valori effettivamente memorizzati.</p> <pre><code>int a = 5, b = 5;\nSystem.out.println(a == b);  // true  \u2192 hanno lo stesso valore\nSystem.out.println(a != b);  // false \u2192 i valori sono uguali\n</code></pre> <p>Important</p> <ul> <li>Se gli operandi sono di tipi numerici diversi, Java li promuove automaticamente a un tipo comune prima del confronto.</li> <li>Tuttavia, confrontare float e double pu\u00f2 produrre risultati inattesi a causa di errori di precisione (vedi esempio sotto).</li> </ul> <pre><code>int x = 10;\ndouble y = 10.0;\nSystem.out.println(x == y);  // true \u2192 x \u00e8 promosso a double (10.0)\n\ndouble d = 0.1 + 0.2;\nSystem.out.println(d == 0.3); // false \u2192 problema di arrotondamento dei floating point\n</code></pre> <p></p>"},{"location":"it/module-01/java-operators/#5752-uguaglianza-con-tipi-reference-oggetti","title":"5.7.5.2 Uguaglianza con tipi reference (oggetti)","text":"<p>Per gli oggetti, <code>==</code> e <code>!=</code> confrontano i riferimenti, non il contenuto dell\u2019oggetto. Restituiscono true solo se entrambi i riferimenti puntano allo stesso oggetto in memoria.</p> <pre><code>String s1 = new String(\"Java\");\nString s2 = new String(\"Java\");\nSystem.out.println(s1 == s2);      // false \u2192 oggetti diversi in memoria\nSystem.out.println(s1 != s2);      // true  \u2192 non lo stesso riferimento\n</code></pre> <p>Anche se due oggetti hanno contenuto identico, <code>==</code> confronta i loro indirizzi, non i valori. Per confrontare il contenuto degli oggetti, usa il metodo <code>.equals()</code>.</p> <pre><code>System.out.println(s1.equals(s2)); // true \u2192 stesso contenuto della stringa\n</code></pre> <p>Caso speciale: null e letterali String</p> <ul> <li>Qualsiasi reference pu\u00f2 essere confrontato con <code>null</code> usando <code>==</code> o <code>!=</code>.</li> </ul> <pre><code>String text = null;\nSystem.out.println(text == null);  // true\n</code></pre> <ul> <li>I letterali String sono internati dalla Java Virtual Machine (JVM): ci\u00f2 significa che letterali identici possono puntare allo stesso riferimento in memoria:</li> </ul> <pre><code>String a = \"Java\";\nString b = \"Java\";\nSystem.out.println(a == b);       // true \u2192 stesso letterale internato\n</code></pre> <ul> <li>Uguaglianza con tipi misti: quando si usa <code>==</code> tra operandi di categorie diverse (es. primitivo vs oggetto), il compilatore prova a eseguire l\u2019unboxing se uno dei due \u00e8 una wrapper class.</li> </ul> <pre><code>Integer i = 100;\nint j = 100;\nSystem.out.println(i == j);   // true \u2192 unboxing prima del confronto\n</code></pre> <p></p>"},{"location":"it/module-01/java-operators/#576-loperatore-instanceof","title":"5.7.6 L\u2019operatore <code>instanceof</code>","text":"<p><code>instanceof</code> \u00e8 un operatore relazionale che verifica se un valore reference \u00e8 un\u2019istanza di un certo tipo reference a runtime. Restituisce un <code>boolean</code>.</p> <pre><code>Object o = \"Java\";\nboolean b1 = (o instanceof String);   // true\nboolean b2 = (o instanceof Number);   // false\n</code></pre> <p>Comportamento con null: se l\u2019espressione \u00e8 null, expr instanceof Type \u00e8 sempre false.</p> <pre><code>Object n = null;\nSystem.out.println(n instanceof Object);  // false\n</code></pre> <p>Warning</p> <p><code>instanceof</code> restituisce sempre <code>false</code> quando l\u2019operando a sinistra \u00e8 <code>null</code>.</p> <p></p>"},{"location":"it/module-01/java-operators/#5761-controllo-in-fase-di-compilazione-vs-fase-di-esecuzione","title":"5.7.6.1 Controllo in fase di compilazione vs fase di esecuzione","text":"<ul> <li>In fase di compilazione, il compilatore rifiuta tipi inconvertibili (che non possono essere in relazione a runtime).</li> <li>A runtime, se il controllo in compilazione \u00e8 passato, la JVM valuta il tipo reale dell\u2019oggetto.</li> </ul> <pre><code>// \u274c Errore di compilazione: tipi inconvertibili (String non \u00e8 correlato a Integer)\nboolean bad = (\"abc\" instanceof Integer);\n\n// \u2705 Compila, ma il risultato a runtime dipende dall\u2019oggetto reale:\n\nNumber num = Integer.valueOf(10);\nSystem.out.println(num instanceof Integer); // true a runtime\nSystem.out.println(num instanceof Double);  // false a runtime\n</code></pre>"},{"location":"it/module-01/java-operators/#5762-pattern-matching-per-instanceof","title":"5.7.6.2 Pattern matching per instanceof","text":"<p>Java supporta i type pattern con <code>instanceof</code>, che eseguono sia il test sia il binding della variabile quando il test ha successo. Aggiungere una variabile dopo il tipo indica al compilatore di trattare il costrutto come Pattern Matching.</p> <p>Sintassi (forma pattern):</p> <pre><code>Object obj = \"Hello\";\n\nif (obj instanceof String str) {\n    // Aggiungere la variabile str dopo il tipo istruisce il compilatore a usare il Pattern Matching\n\n    System.out.println(str.toUpperCase()); // l\u2019identificatore \u00e8 in scope qui, di tipo String (sicuro).\n}\n</code></pre> <p>Propriet\u00e0 fondamentali:</p> <ul> <li>Se il test ha successo, la variabile di pattern (es. <code>str</code>) \u00e8 sicuramente assegnata ed \u00e8 in scope nel ramo <code>true</code>.</li> <li>Le variabili di pattern sono implicitamente <code>final</code> (non possono essere riassegnate).</li> <li>Il nome non deve entrare in conflitto con una variabile esistente nello stesso scope.</li> </ul> <p></p>"},{"location":"it/module-01/java-operators/#5763-flow-scoping-e-logica-short-circuit","title":"5.7.6.3 Flow scoping e logica short-circuit","text":"<p>Le variabili di pattern diventano disponibili in base all\u2019analisi di flusso:</p> <pre><code>Object obj = \"data\";\n\n// Test negato, variabile disponibile nel ramo else\nif (!(obj instanceof String s)) {\n    // s non \u00e8 in scope qui\n} else {\n    System.out.println(s.length()); // s \u00e8 in scope qui\n}\n\n// Con &amp;&amp;, la variabile di pattern pu\u00f2 essere usata a destra se a sinistra \u00e8 stata stabilita\nif (obj instanceof String s &amp;&amp; s.length() &gt; 3) {\n    System.out.println(s.substring(0, 3)); // s in scope\n}\n\n// Con ||, la variabile di pattern NON \u00e8 sicura a destra (lo short-circuit pu\u00f2 impedire che venga stabilita)\nif (obj instanceof String s || s.length() &gt; 3) {  // \u274c s non \u00e8 in scope qui\n    // ...\n}\n\n// Le parentesi possono aiutare a raggruppare la logica\nif ((obj instanceof String s) &amp;&amp; s.contains(\"a\")) { // \u2705 s in scope dopo il test raggruppato\n    System.out.println(s);\n}\n</code></pre> <p>Il pattern matching con <code>null</code> viene valutato, come sempre per <code>instanceof</code>, a <code>false</code>:</p> <pre><code>String str = null;\n\n// instanceof normale\nif (str instanceof String) {  \n    System.out.print(\"NOT EXECUTED\"); // instanceof \u00e8 false\n}\n\n// Pattern matching\nif (str instanceof String s) {  \n    System.out.print(\"NOT EXECUTED\"); // instanceof \u00e8 comunque false\n}\n</code></pre> <p>Tipi supportati:</p> <p>Il tipo della variabile di pattern deve essere un sottotipo, un supertipo o lo stesso tipo della variabile reference.</p> <pre><code>Number num = Short.valueOf(10);\n\nif (num instanceof String s) {}  // \u274c Errore di compilazione\nif (num instanceof Short s) {}   // \u2705 Ok\nif (num instanceof Object s) {}  // \u2705 Ok\nif (num instanceof Number s) {}  // \u2705 Ok\n</code></pre> <p></p>"},{"location":"it/module-01/java-operators/#5764-array-e-tipi-reificabili","title":"5.7.6.4 Array e tipi reificabili","text":"<p><code>instanceof</code> funziona con gli array (che sono reificabili) e con forme generiche erased o con wildcard. I tipi reificabili sono quelli la cui rappresentazione a runtime preserva completamente il tipo (per esempio: raw types, array, classi non generiche, wildcard <code>?</code>). A causa del type erasure, <code>List&lt;String&gt;</code> non pu\u00f2 essere testata direttamente a runtime.</p> <pre><code>Object arr = new int[]{1,2,3};\nSystem.out.println(arr instanceof int[]); // true\n\nObject list = java.util.List.of(1,2,3);\n// System.out.println(list instanceof List&lt;Integer&gt;); // \u274c Errore di compilazione: tipo parametrizzato non reificabile\nSystem.out.println(list instanceof java.util.List&lt;?&gt;); // \u2705 true\n</code></pre> <p></p>"},{"location":"it/module-01/java-operators/#58-operatore-ternario","title":"5.8 Operatore ternario","text":"<p>L\u2019operatore ternario (<code>? :</code>) \u00e8 l\u2019unico operatore in Java che accetta tre operandi. Rappresenta una forma compatta dell\u2019istruzione <code>if-else</code>.</p> <p></p>"},{"location":"it/module-01/java-operators/#581-regole-di-tipo-per-loperatore-ternario","title":"5.8.1 Regole di Tipo per l\u2019Operatore Ternario","text":"<p>Il tipo di un\u2019espressione condizionale (ternaria) \u00e8 determinato dai tipi del secondo e del terzo operando.</p> <p></p>"},{"location":"it/module-01/java-operators/#5811-operandi-numerici","title":"5.8.1.1 Operandi Numerici","text":"<ul> <li>Se un operando \u00e8 di tipo <code>byte</code> e l\u2019altro \u00e8 di tipo <code>short</code>, il tipo risultante \u00e8 <code>short</code>.</li> <li>Se un operando \u00e8 di tipo <code>T</code> (<code>byte</code>, <code>short</code> o <code>char</code>) e l\u2019altro \u00e8 un\u2019espressione costante di tipo <code>int</code> il cui valore \u00e8 rappresentabile in <code>T</code>, allora il tipo risultante \u00e8 <code>T</code>.</li> <li>In tutti gli altri casi numerici si applica la binary numeric promotion ai due operandi.   Il tipo dell\u2019espressione condizionale diventa il tipo promosso.</li> </ul> <p>La binary numeric promotion include unboxing conversion e value set conversion.</p> <p></p>"},{"location":"it/module-01/java-operators/#5812-tipi-di-riferimento","title":"5.8.1.2 Tipi di Riferimento","text":"<ul> <li>Se un operando \u00e8 <code>null</code> e l\u2019altro \u00e8 un tipo di riferimento, il tipo risultante \u00e8 quel tipo di riferimento.</li> <li>Se i due operandi sono tipi di riferimento diversi, uno deve essere assegnabile all\u2019altro (compatibilit\u00e0 per assegnazione).   Il tipo risultante \u00e8 il tipo pi\u00f9 generale, cio\u00e8 quello a cui l\u2019altro pu\u00f2 essere assegnato.</li> <li>Se nessuno dei due tipi \u00e8 compatibile per assegnazione con l\u2019altro, si verifica un errore a compile-time.</li> </ul> <p>In sintesi, l\u2019operatore ternario determina il proprio tipo applicando:</p> <ul> <li>Regole speciali di narrowing per piccoli tipi integrali  </li> <li>Binary numeric promotion per i valori numerici  </li> <li>Regole di compatibilit\u00e0 per assegnazione per i tipi di riferimento  </li> </ul> <p>Tip</p> <p>L\u2019operatore ternario deve produrre un valore di tipo compatibile. Se i due rami restituiscono tipi non correlati, la compilazione fallisce.</p> <pre><code>String s = true ? \"ok\" : 5; // \u274c errore di compilazione: tipi incompatibili\n</code></pre> <p></p>"},{"location":"it/module-01/java-operators/#582-sintassi","title":"5.8.2 Sintassi","text":"<pre><code>condition ? expressionIfTrue : expressionIfFalse;\n</code></pre>"},{"location":"it/module-01/java-operators/#583-esempio","title":"5.8.3 Esempio","text":"<pre><code>int age = 20;\nString access = (age &gt;= 18) ? \"Consentito\" : \"Negato\";\nSystem.out.println(access);  // \"Consentito\"\n</code></pre>"},{"location":"it/module-01/java-operators/#584-esempio-di-ternario-annidato","title":"5.8.4 Esempio di Ternario Annidato","text":"<pre><code>int score = 85;\nString grade = (score &gt;= 90) ? \"A\" :\n               (score &gt;= 75) ? \"B\" :\n               (score &gt;= 60) ? \"C\" : \"F\";\nSystem.out.println(grade);  // \"B\"\n</code></pre>"},{"location":"it/module-01/java-operators/#585-note","title":"5.8.5 Note","text":"<p>Warning</p> <ul> <li>Le espressioni ternarie annidate possono ridurre la leggibilit\u00e0. Usare le parentesi per maggiore chiarezza.</li> <li>L\u2019operatore ternario restituisce un valore, a differenza di <code>if-else</code>, che \u00e8 un\u2019istruzione.</li> </ul>"},{"location":"it/module-01/naming-rules/","title":"3. Regole di naming Java","text":""},{"location":"it/module-01/naming-rules/#indice","title":"Indice","text":"<ul> <li>3.1 Regole per gli identificatori<ul> <li>3.1.1 Parole riservate<ul> <li>3.1.1.1 Keyword Java riservate</li> <li>3.1.1.2 Letterali riservati</li> </ul> </li> <li>3.1.2 Sensibilit\u00e0 alle maiuscole/minuscole</li> <li>3.1.3 Inizio degli identificatori</li> <li>3.1.4 Numeri negli identificatori</li> <li>3.1.5 Singolo token _</li> <li>3.1.6 Letterali numerici e carattere underscore</li> </ul> </li> </ul> <p>Java definisce regole precise per gli identificatori, ovvero i nomi assegnati a variabili, metodi, classi, interfacce e package.</p> <p>Finch\u00e9 si rispettano le regole di naming descritte di seguito, si \u00e8 liberi di scegliere nomi significativi per gli elementi del programma.</p> <p></p>"},{"location":"it/module-01/naming-rules/#31-regole-per-gli-identificatori","title":"3.1 Regole per gli identificatori","text":""},{"location":"it/module-01/naming-rules/#311-parole-riservate","title":"3.1.1 Parole riservate","text":"<p>Gli <code>identifier</code> non possono coincidere con le keyword Java o con i letterali riservati.</p> <p>Le <code>keyword</code> sono parole speciali predefinite nel linguaggio Java che non si possono usare come identificatori (vedi tabella qui sotto).</p> <p>I <code>literal</code> come <code>true</code>, <code>false</code> e <code>null</code> sono anch\u2019essi riservati e non possono essere usati come identificatori.</p> <ul> <li>Esempio: <pre><code>int class = 5;        // non valido: 'class' \u00e8 una keyword\nboolean true = false; // non valido: 'true' \u00e8 un literal\nint year = 2024;      // valido\n</code></pre></li> </ul> <p></p>"},{"location":"it/module-01/naming-rules/#3111-keyword-java-riservate","title":"3.1.1.1 Keyword Java riservate","text":"a -&gt; c c -&gt; f f -&gt; n n -&gt; s s -&gt; w abstract continue for new switch assert default goto* package synchronized boolean do if private this break double implements protected throw byte else import public throws case enum instanceof return transient catch extends int short try char final interface static void class finally long strictfp volatile const* float native super while <p>Note</p> <p><code>goto</code> e <code>const</code> sono riservate ma non utilizzate.</p> <p></p>"},{"location":"it/module-01/naming-rules/#3112-letterali-riservati","title":"3.1.1.2 Letterali riservati","text":"<ul> <li><code>true</code> </li> <li><code>false</code> </li> <li><code>null</code> </li> </ul>"},{"location":"it/module-01/naming-rules/#312-sensibilita-alle-maiuscoleminuscole","title":"3.1.2 Sensibilit\u00e0 alle maiuscole/minuscole","text":"<p>Gli identificatori in Java sono case sensitive. Questo significa che <code>myVar</code>, <code>MyVar</code> e <code>MYVAR</code> sono tutti identificatori diversi.</p> <ul> <li>Esempio: <pre><code>int myVar = 1;\nint MyVar = 2;\nint MYVAR = 3;\nint CLASS = 6; // legale ma, please, non farlo!!\n</code></pre></li> </ul> <p>Tip</p> <p>Java tratta gli identificatori letteralmente: <code>Count</code>, <code>count</code> e <code>COUNt</code> sono entit\u00e0 distinte e possono coesistere.</p> <p>A causa della sensibilit\u00e0 a maiuscole/minuscole, si potrebbero usare varianti delle keyword che differiscono solo nel case. Anche se \u00e8 legale, questo stile \u00e8 fortemente sconsigliato perch\u00e9 riduce la leggibilit\u00e0 ed \u00e8 considerata una pessima pratica.</p> <p></p>"},{"location":"it/module-01/naming-rules/#313-inizio-degli-identificatori","title":"3.1.3 Inizio degli identificatori","text":"<p>Gli identificatori in Java devono iniziare con una lettera, un simbolo di valuta (<code>$</code>, <code>\u20ac</code>, <code>\u00a3</code>, <code>\u20b9</code>...) oppure il simbolo <code>_</code>.</p> <p>Esempio: <pre><code>int myVarA;\nint $myVarB;\nint _myVarC;\nString \u20acuro = \"currency\"; // legale (usato raramente in pratica)\n</code></pre></p> <p>Note</p> <p>I simboli di valuta sono legali ma non raccomandati nel codice reale.</p> <p></p>"},{"location":"it/module-01/naming-rules/#314-numeri-negli-identificatori","title":"3.1.4 Numeri negli identificatori","text":"<p>Gli identificatori in Java possono includere numeri, ma non possono iniziare con un numero.</p> <p>Esempio: <pre><code>int my33VarA;\nint $myVar44;\nint 3myVarC; // non valido: identifier non possono iniziare con una cifra\nint var2024 = 10; // valido\n</code></pre></p> <p></p>"},{"location":"it/module-01/naming-rules/#315-singolo-token-_","title":"3.1.5 Singolo token <code>_</code>","text":"<ul> <li>Un singolo underscore (<code>_</code>) non \u00e8 consentito come identificatore.</li> <li> <p>A partire da Java 9, <code>_</code> \u00e8 un token riservato per un possibile uso futuro del linguaggio.</p> </li> <li> <p>Esempio: <pre><code>int _;  // invalid since Java 9\n</code></pre></p> </li> </ul> <p>Warning</p> <p><code>_</code> \u00e8 legale all\u2019interno dei letterali numerici (vedi sezione successiva), ma non come identificatore a s\u00e9 stante.</p> <p></p>"},{"location":"it/module-01/naming-rules/#316-letterali-numerici-e-carattere-underscore","title":"3.1.6 Letterali numerici e carattere underscore","text":"<p>Si possono usare uno o pi\u00f9 caratteri <code>_</code> (underscore) nei letterali numerici per renderli pi\u00f9 facili da leggere.</p> <p>Puoi inserire underscore quasi ovunque, tranne all\u2019inizio, alla fine o immediatamente prima/dopo il punto decimale.</p> <ul> <li>Esempio: <pre><code>int firstNum = 1_000_000;\nint secondNum = 1 _____________ 2;\n\ndouble firstDouble = _1000.00   // DOES NOT COMPILE\ndouble secondDouble = 1000_.00  // DOES NOT COMPILE\ndouble thirdDouble = 1000._00   // DOES NOT COMPILE\ndouble fourthDouble = 1000.00_  // DOES NOT COMPILE\n\ndouble pi = 3.14_159_265; // valid\nlong mask = 0b1111_0000;  // valid in binary literals\n</code></pre></li> </ul> <p>Tip</p> <p>Gli underscore migliorano la leggibilit\u00e0: <code>1_000_000</code> \u00e8 pi\u00f9 leggibile di <code>1000000</code>.</p>"},{"location":"it/module-01/syntax-building-blocks/","title":"1. Mattoni Sintattici di Base","text":""},{"location":"it/module-01/syntax-building-blocks/#indice","title":"Indice","text":"<ul> <li>1.1 Valore</li> <li>1.2 Letterale</li> <li>1.3 Identificatore</li> <li>1.4 Variabile</li> <li>1.5 Tipo</li> <li>1.6 Operatore</li> <li>1.7 Espressione</li> <li>1.8 Istruzione</li> <li>1.9 Blocco di Codice</li> <li>1.10 Funzione / Metodo</li> <li>1.11 Classe / Oggetto</li> <li>1.12 Modulo / Package</li> <li>1.13 Programma</li> <li>1.14 Sistema</li> <li>1.15 Riepilogo come scala crescente</li> <li>1.16 Diagramma gerarchico ASCII</li> <li>1.17 Diagramma gerarchico Mermaid</li> </ul> <p>Ogni sistema software o programma informatico \u00e8 composto da un insieme di dati e da un insieme di operazioni che vengono applicate a questi ultimi per produrre un risultato.</p> <p>Pi\u00f9 formalmente:</p> <p>Un programma informatico consiste in una collezione di strutture dati che rappresentano lo stato del sistema, insieme ad algoritmi che specificano le operazioni da eseguire su questo stato per produrre degli output.</p> <p>Questo documento descrive una gerarchia di astrazioni: i mattoni elementari che, combinati in strutture via via pi\u00f9 complesse, formano il software.</p> <p>La sequenza \u00e8 presentata in ordine crescente di complessit\u00e0, con definizioni generali (informatica) e riferimenti a Java.</p> <p></p>"},{"location":"it/module-01/syntax-building-blocks/#11-valore","title":"1.1 Valore","text":"<ul> <li>Definizione: Entit\u00e0 astratta che rappresenta informazione (numero, carattere, boolean, stringa, ecc.).</li> <li>Teoria: Un valore appartiene a un dominio (insieme) matematico, come \u2115 per i numeri naturali o \u03a3* per le stringhe.</li> <li>Esempio (astratto): il numero quarantadue, il valore di verit\u00e0 true, il carattere \"a\".</li> </ul> <p>Esempio Java (valori):</p> <pre><code>// Questi sono valori:\n42        // un valore int\ntrue      // un valore boolean\n'a'       // un valore char\n\"Hello\"   // un valore String\n</code></pre> <p></p>"},{"location":"it/module-01/syntax-building-blocks/#12-letterale","title":"1.2 Letterale","text":"<ul> <li>Definizione: Un letterale \u00e8 la notazione concreta nel codice sorgente che denota direttamente un valore fisso.</li> <li>In Java: <code>42</code>, <code>'a'</code>, <code>true</code>, <code>\"Hello\"</code>.</li> <li>Teoria: Un letterale \u00e8 sintassi, mentre il valore \u00e8 la sua semantica.</li> <li>Nota: I letterali sono il modo pi\u00f9 comune per introdurre valori nei programmi.</li> </ul> <p>Esempio Java (letterali):</p> <pre><code>int answer = 42;          // 42 \u00e8 un letterale int\nchar letter = 'a';        // 'a' \u00e8 un letterale char\nboolean flag = true;      // true \u00e8 un letterale boolean\nString msg = \"Hello\";     // \"Hello\" \u00e8 un letterale String\n</code></pre> <p></p>"},{"location":"it/module-01/syntax-building-blocks/#13-identificatore","title":"1.3 Identificatore","text":"<ul> <li>Definizione: Un nome simbolico che associa un valore (o una struttura) a un\u2019etichetta leggibile.</li> <li>In Java:</li> <li>Identificatori definiti dall\u2019utente: scelti dal programmatore per nominare variabili, metodi, classi, ecc.     Esempi: <code>x</code>, <code>counter</code>, <code>MyClass</code>, <code>calculateSum</code>.</li> <li>Parole chiave (keyword, riservate): nomi predefiniti riservati dal linguaggio Java che non possono essere ridefiniti.     Esempi: <code>class</code>, <code>public</code>, <code>static</code>, <code>if</code>, <code>return</code>.</li> </ul> <p>Note</p> <p>Gli identificatori devono rispettare le regole di naming di Java: vedi Regole di naming Java</p> <ul> <li>Teoria: Funzione di binding: collega un nome a un valore o a una risorsa.</li> </ul> <p>Esempio Java (identificatori):</p> <pre><code>int counter = 0;          // counter \u00e8 un identificatore (nome di variabile)\nString userName = \"Bob\";  // userName \u00e8 un identificatore\nclass MyService { }       // MyService \u00e8 un identificatore di classe\n</code></pre> <p></p>"},{"location":"it/module-01/syntax-building-blocks/#14-variabile","title":"1.4 Variabile","text":"<ul> <li>Definizione: Una \u201ccella di memoria\u201d etichettata da un identificatore, che pu\u00f2 contenere e cambiare valore.</li> <li>In Java: <code>int counter = 0; counter = counter + 1;</code>.</li> <li>Teoria: Uno stato mutabile che pu\u00f2 variare nel tempo durante l\u2019esecuzione.</li> </ul> <p>Esempio Java (variabile che cambia nel tempo):</p> <pre><code>int counter = 0;       // variabile inizializzata\ncounter = counter + 1; // variabile aggiornata\ncounter++;             // altro aggiornamento (post-incremento)\n</code></pre> <p></p>"},{"location":"it/module-01/syntax-building-blocks/#15-tipo","title":"1.5 Tipo","text":"<ul> <li>Definizione: Un tipo \u00e8 un insieme di valori e un insieme di operazioni consentite su tali valori.</li> <li>In Java:</li> <li>Tipi primitivi (semplici): rappresentano direttamente valori di base.     Esempi: <code>int</code>, <code>double</code>, <code>boolean</code>, <code>char</code>, <code>byte</code>, <code>short</code>, <code>long</code>, <code>float</code>.</li> <li>Tipi reference: rappresentano riferimenti (puntatori) a oggetti in memoria.     Esempi: <code>String</code>, array (ad es. <code>int[]</code>), classi, interfacce e tipi definiti dall\u2019utente.</li> </ul> <p>Note</p> <p>Vedi Tipi di dato Java e casting.</p> <ul> <li>Teoria: Un sistema di tipi \u00e8 l\u2019insieme di regole che associa insiemi di valori e operazioni ammissibili.</li> </ul> <p>Esempio Java (tipi):</p> <pre><code>int age = 30;           // tipo int\ndouble price = 9.99;    // tipo double\nboolean active = true;  // tipo boolean\nString name = \"Alice\";  // tipo reference (classe String)\n</code></pre> <p></p>"},{"location":"it/module-01/syntax-building-blocks/#16-operatore","title":"1.6 Operatore","text":"<ul> <li>Definizione: Un simbolo o parola chiave che esegue un calcolo o un\u2019azione su uno o pi\u00f9 operandi.</li> <li>Ruolo: Gli operatori combinano valori, variabili ed espressioni per produrre nuovi valori o modificare lo stato del programma.</li> <li>In Java:</li> </ul> <p>Note</p> <p>Vedi Operatori Java.</p> <ul> <li>Teoria: Gli operatori definiscono le computazioni ammesse sui tipi; insieme a valori e variabili formano le espressioni.</li> </ul> <p>Esempio Java (operatori nel contesto):</p> <pre><code>int a = 5 + 3;          // + aritmetico\nboolean ok = a &gt; 3;     // &gt; di confronto\nok = ok &amp;&amp; true;        // &amp;&amp; logico\na += 2;                 // += assegnazione\nint sign = (a &gt;= 0) ? 1 : -1; // ?: ternario\n</code></pre> <p></p>"},{"location":"it/module-01/syntax-building-blocks/#17-espressione","title":"1.7 Espressione","text":"<ul> <li>Definizione: Una combinazione di valori, letterali, variabili, operatori e funzioni che produce un nuovo valore.</li> <li>In Java: <code>x + 3</code>, <code>Math.sqrt(25)</code>, <code>\"Hello\" + \" world\"</code>.</li> <li>Teoria: Un albero sintattico (syntax tree) che viene valutato producendo un risultato.</li> </ul> <p>Esempio Java (espressioni):</p> <pre><code>int x = 10;\nint y = x + 3;               // x + 3 \u00e8 un\u2019espressione\ndouble r = Math.sqrt(25);    // Math.sqrt(25) \u00e8 un\u2019espressione\nString msg = \"Hello\" + \" \";  // \"Hello\" + \" \" \u00e8 un\u2019espressione\nmsg = msg + \"world\";         // msg + \"world\" \u00e8 un\u2019altra espressione\n</code></pre> <p></p>"},{"location":"it/module-01/syntax-building-blocks/#18-istruzione","title":"1.8 Istruzione","text":"<ul> <li>Definizione: Unit\u00e0 di esecuzione che modifica lo stato o controlla il flusso.</li> <li>In Java: <code>x = x + 1;</code>, <code>if (x &gt; 0) { ... }</code>.</li> <li>Teoria: Sequenza di azioni che non restituisce un valore come risultato dell\u2019istruzione stessa, ma cambia la configurazione della macchina astratta.</li> </ul> <p>Esempio Java (istruzioni):</p> <pre><code>int x = 0;                // istruzione di dichiarazione\nx = x + 1;                // istruzione di assegnazione\n\nif (x &gt; 0) {              // istruzione if\n    System.out.println(\"Positivo\");\n}\n</code></pre> <p></p>"},{"location":"it/module-01/syntax-building-blocks/#19-blocco-di-codice","title":"1.9 Blocco di Codice","text":"<ul> <li>Definizione: Insieme di istruzioni racchiuse tra delimitatori che formano un\u2019unit\u00e0 eseguibile.</li> <li>In Java: <code>{ int y = 5; x = x + y; }</code>.</li> <li>Teoria: Composizione sequenziale di istruzioni, con regole di scope (visibilit\u00e0).</li> </ul> <p>Esempio Java (blocco di codice e scope):</p> <pre><code>int x = 10;\n\n{\n    int y = 5;        // y \u00e8 visibile solo dentro questo blocco\n    x = x + y;        // OK: x \u00e8 visibile qui\n}\n\n// y non \u00e8 visibile qui\n// x \u00e8 ancora visibile qui\n</code></pre> <p></p>"},{"location":"it/module-01/syntax-building-blocks/#110-funzione-metodo","title":"1.10 Funzione / Metodo","text":"<ul> <li>Definizione: Sequenza di istruzioni incapsulata, identificata da un nome, che pu\u00f2 ricevere input (parametri) e restituire un output (valore).</li> <li>In Java:</li> </ul> <pre><code>int square(int n) {\n    return n * n;\n}\n</code></pre> <ul> <li>Teoria: Una mappatura tra domini di input e di output, con un corpo operativo.</li> </ul> <p>Esempio di utilizzo in Java:</p> <pre><code>int result = square(5); // result = 25\n</code></pre> <p></p>"},{"location":"it/module-01/syntax-building-blocks/#111-classe-oggetto","title":"1.11 Classe / Oggetto","text":"<ul> <li>Definizione:</li> <li>Classe: descrizione astratta di un insieme di oggetti (stato + comportamento).</li> <li> <p>Oggetto: istanza concreta della classe.</p> </li> <li> <p>In Java:</p> </li> </ul> <pre><code>class Point {\n    int x, y;\n\n    void move(int dx, int dy) {\n        x += dx;\n        y += dy;\n    }\n}\n\nPoint p = new Point();   // p \u00e8 un oggetto (istanza di Point)\np.move(1, 2);            // chiamata di metodo sull\u2019oggetto\n</code></pre> <ul> <li>Teoria: Astrazione di un ADT (Abstract Data Type, tipo di dato astratto).</li> </ul> <p></p>"},{"location":"it/module-01/syntax-building-blocks/#112-modulo-package","title":"1.12 Modulo / Package","text":"<ul> <li>Definizione: Raggruppamento logico di classi, funzioni e risorse con uno scopo comune.</li> <li>In Java: <code>package java.util;</code> \u2192 raccoglie utilit\u00e0 varie.</li> <li>Teoria: Meccanismo di organizzazione e riuso, riduce la complessit\u00e0.</li> </ul> <p>Esempio Java (package):</p> <pre><code>package com.example.app;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Hello\");\n    }\n}\n</code></pre> <p></p>"},{"location":"it/module-01/syntax-building-blocks/#113-programma","title":"1.13 Programma","text":"<ul> <li>Definizione: Insieme coerente di moduli, classi e funzioni che, quando eseguiti su una macchina, realizzano un comportamento globale.</li> <li>In Java: Il metodo <code>main</code> e tutto ci\u00f2 che esso invoca.</li> <li>Teoria: Specifica di trasformazioni da input a output su una macchina astratta.</li> </ul> <p>Esempio Java (programma minimale):</p> <pre><code>public class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, Java 21!\");\n    }\n}\n</code></pre> <p></p>"},{"location":"it/module-01/syntax-building-blocks/#114-sistema","title":"1.14 Sistema","text":"<ul> <li>Definizione: Insieme di programmi cooperanti che interagiscono con risorse esterne (utente, rete, dispositivi).</li> <li>Esempio: Una piattaforma Java enterprise con database, servizi REST, interfaccia utente.</li> <li>Teoria: Architettura complessa di componenti software e hardware.</li> </ul> <p>Esempio (concettuale):</p> <ul> <li>Un backend Java (servizio Spring Boot)</li> <li>Un database (PostgreSQL)</li> <li>Una web app front-end</li> <li>Servizi esterni (API REST, code di messaggi)</li> </ul> <p>Insieme formano un sistema.</p> <p></p>"},{"location":"it/module-01/syntax-building-blocks/#115-riepilogo-come-scala-crescente","title":"1.15 \ud83d\udccc Riepilogo come scala crescente","text":"<p><code>Valore \u2192 Letterale \u2192 Identificatore \u2192 Variabile \u2192 Tipo \u2192 Operatore \u2192 Espressione \u2192 Istruzione \u2192 Blocco di Codice \u2192 Funzione/Metodo \u2192 Classe/Oggetto \u2192 Modulo/Package \u2192 Programma \u2192 Sistema</code></p> <p>Questa scala mostra come unit\u00e0 concettuali piccole vengano combinate in strutture progressivamente pi\u00f9 grandi e complesse.</p> <p></p>"},{"location":"it/module-01/syntax-building-blocks/#116-diagramma-gerarchico-ascii","title":"1.16 \ud83d\udcca Diagramma gerarchico (ASCII)","text":"<p>Descrizione: Questo diagramma ASCII mostra la relazione gerarchica tra i mattoni, dal pi\u00f9 complesso (Sistema) al pi\u00f9 semplice (Valore e la sua forma concreta, il Letterale).</p> <pre><code>Sistema\n\u2514\u2500\u2500 Programma\n    \u2514\u2500\u2500 Modulo / Package\n        \u2514\u2500\u2500 Classe / Oggetto\n            \u2514\u2500\u2500 Funzione / Metodo\n                \u2514\u2500\u2500 Blocco di Codice\n                    \u2514\u2500\u2500 Istruzione\n                        \u2514\u2500\u2500 Espressione\n                            \u2514\u2500\u2500 Operatore\n                                \u2514\u2500\u2500 Tipo\n                                    \u2514\u2500\u2500 Variabile\n                                        \u2514\u2500\u2500 Identificatore\n                                            \u2514\u2500\u2500 Letterale\n                                                \u2514\u2500\u2500 Valore\n</code></pre> <p></p>"},{"location":"it/module-01/syntax-building-blocks/#117-diagramma-gerarchico-mermaid","title":"1.17 \ud83d\udcca Diagramma gerarchico (Mermaid)","text":"<p>Descrizione: Il diagramma Mermaid rende la stessa gerarchia in un albero dall\u2019alto verso il basso. Evidenzia che il Letterale \u00e8 la forma sintattica di un Valore.</p> <pre><code>graph TD\n    A[Sistema]\n    A --&gt; B[Programma]\n    B --&gt; C[Modulo / Package]\n    C --&gt; D[Classe / Oggetto]\n    D --&gt; E[Funzione / Metodo]\n    E --&gt; F[Blocco di Codice]\n    F --&gt; G[Istruzione]\n    G --&gt; H[Espressione]\n    H --&gt; H2[Operatore]\n    H2 --&gt; I[Tipo]\n    I --&gt; J[Variabile]\n    J --&gt; K[Identificatore]\n    K --&gt; L[Letterale]\n    L --&gt; M[Valore]\n</code></pre>"},{"location":"it/module-02/control-flow/","title":"7. Flusso di controllo","text":""},{"location":"it/module-02/control-flow/#indice","title":"Indice","text":"<ul> <li>7.1 L\u2019istruzione if</li> <li>7.2 L\u2019istruzione Switch &amp; la Switch Expression<ul> <li>7.2.1 La variabile target dello switch pu\u00f2 essere</li> <li>7.2.2 Valori case accettabili</li> <li>7.2.3 Compatibilit\u00e0 di tipo tra selector e case</li> <li>7.2.4 Pattern Matching nello Switch<ul> <li>7.2.4.1 Nomi delle variabili e scope tra i rami</li> <li>7.2.4.2 Ordinamento, dominanza ed esaustivit\u00e0 negli switch con pattern</li> </ul> </li> </ul> </li> <li>7.3 Due forme di switch: switch Statement vs switch Expression<ul> <li>7.3.1 L\u2019istruzione switch<ul> <li>7.3.1.1 Comportamento di fall-through</li> </ul> </li> <li>7.3.2 L\u2019espressione switch<ul> <li>7.3.2.1 yield nei blocchi di espressione switch</li> <li>7.3.2.2 Esaustivit\u00e0 per le espressioni switch</li> </ul> </li> </ul> </li> <li>7.4 Gestione di null</li> </ul> <p>Il flusso di controllo in Java si riferisce all\u2019ordine in cui le singole istruzioni, i comandi o le chiamate a metodo vengono eseguiti durante l\u2019esecuzione del programma.</p> <p>Per impostazione predefinita, le istruzioni vengono eseguite sequenzialmente dall\u2019alto verso il basso, ma le istruzioni di controllo del flusso consentono al programma di prendere decisioni, ripetere azioni o diramare i percorsi di esecuzione in base a condizioni.</p> <p>Java fornisce tre categorie principali di costrutti di controllo del flusso:</p> <ul> <li>Istruzioni decisionali \u2014 <code>if</code>, <code>if-else</code>, <code>switch</code></li> <li>Istruzioni di iterazione \u2014 <code>for</code>, <code>while</code>, <code>do-while</code> e il <code>for</code> avanzato</li> <li>Istruzioni di diramazione \u2014 <code>break</code>, <code>continue</code> e <code>return</code></li> </ul> <p>Tip</p> <p>Comprendere il flusso di controllo \u00e8 essenziale per vedere come i dati si muovono all\u2019interno del programma e come ogni decisione logica viene valutata passo dopo passo.</p> <p></p>"},{"location":"it/module-02/control-flow/#71-listruzione-if","title":"7.1 L\u2019istruzione <code>if</code>","text":"<p>L\u2019istruzione <code>if</code> \u00e8 una struttura condizionale di controllo del flusso che esegue un blocco di codice solo se una specifica espressione booleana viene valutata come <code>true</code>. </p> <p>L\u2019istruzione consente al programma di prendere decisioni a runtime.</p> <p>Sintassi:</p> <pre><code>if (condition) {\n    // eseguito solo quando la condizione \u00e8 true\n}\n</code></pre> <p>Una clausola <code>else</code> opzionale gestisce il percorso alternativo:</p> <pre><code>if (score &gt;= 60) {\n    System.out.println(\"Passed\");\n} else {\n    System.out.println(\"Failed\");\n}\n</code></pre> <p>Pi\u00f9 condizioni possono essere concatenate usando <code>else if</code>:</p> <pre><code>if (grade &gt;= 90) {\n    System.out.println(\"A\");\n} else if (grade &gt;= 80) {\n    System.out.println(\"B\");\n} else if (grade &gt;= 70) {\n    System.out.println(\"C\");\n} else {\n    System.out.println(\"D or below\");\n}\n</code></pre> <p>Note</p> <p>La condizione di <code>if</code> deve essere valutata come boolean; i tipi numerici o gli oggetti non possono essere usati direttamente come condizioni.</p> <p>Le parentesi graffe <code>{}</code> sono opzionali per singole istruzioni ma sono fortemente consigliate per prevenire sottili errori di logica.</p> <p>Una catena <code>if-else</code> viene valutata dall\u2019alto verso il basso, e viene eseguito solo il primo ramo con una condizione valutata come <code>true</code>.</p> <p></p>"},{"location":"it/module-02/control-flow/#72-listruzione-switch-la-switch-expression","title":"7.2 L\u2019istruzione <code>switch</code> &amp; la <code>switch Expression</code>","text":"<p>Il costrutto <code>switch</code> \u00e8 una struttura di controllo del flusso che seleziona un ramo tra pi\u00f9 alternative in base al valore di un\u2019espressione (il selector).</p> <p>Rispetto a lunghe catene di <code>if-else-if</code>, uno <code>switch</code>:</p> <ul> <li>\u00c8 spesso pi\u00f9 facile da leggere quando si testano molti valori discreti (costanti, enum, stringhe).</li> <li>Pu\u00f2 essere pi\u00f9 sicuro e pi\u00f9 conciso quando usato come espressione switch </li> </ul> <p>perch\u00e9:</p> <ul> <li>Produce un valore.</li> <li>Il compilatore pu\u00f2 imporre esaustivit\u00e0 e coerenza di tipo.</li> </ul> <p>Java 21 supporta:</p> <ul> <li>La <code>switch</code> classica come istruzione (solo controllo del flusso).</li> <li>La <code>switch</code> come Expression (produce un risultato).</li> <li>Pattern matching dentro <code>switch</code>, inclusi type pattern e guard.</li> </ul> <p>Entrambe le forme di <code>switch</code> condividono le stesse regole riguardanti il selector (la variabile target dello switch) e i valori <code>case</code> accettabili.</p> <p></p>"},{"location":"it/module-02/control-flow/#721-la-variable-target-dello-switch-puo-essere","title":"7.2.1 La <code>variable target</code> dello switch pu\u00f2 essere","text":"Control Variable type <code>byte</code> / <code>Byte</code> <code>short</code> / <code>Short</code> <code>char</code> / <code>Character</code> <code>int</code> / <code>Integer</code> <code>String</code> Enum types (selectors of an <code>enum</code>) Any reference type (with pattern matching) <code>var</code> (if it resolves to one of the allowed types) <p>Warning</p> <p>Non consentiti come type selector per switch:</p> <ul> <li><code>boolean</code></li> <li><code>long</code></li> <li><code>float</code></li> <li><code>double</code></li> </ul> <p></p>"},{"location":"it/module-02/control-flow/#722-valori-case-accettabili","title":"7.2.2 Valori <code>case</code> accettabili","text":"<p>Per uno switch <code>non-pattern</code>, ogni etichetta <code>case</code> deve essere una costante a compile-time compatibile con il tipo del selector.</p> <p>Sono consentite, come etichette <code>case</code>:</p> <ul> <li>Letterali come <code>0</code>, <code>'A'</code>, <code>\"ON\"</code>.</li> <li>Costanti enum, ad es. <code>RED</code> o <code>Color.GREEN</code>.</li> <li>Variabili costanti final (costanti a compile-time).</li> </ul> <p>Una costante a compile-time:</p> <ul> <li>Deve essere dichiarata con <code>final</code> e inizializzata nella stessa istruzione.</li> <li>Il suo inizializzatore deve a sua volta essere un\u2019espressione costante (tipicamente usando letterali e altre costanti a compile-time).</li> </ul> <p></p>"},{"location":"it/module-02/control-flow/#723-compatibilita-di-tipo-tra-selector-e-case","title":"7.2.3 Compatibilit\u00e0 di tipo tra <code>selector</code> e <code>case</code>","text":"<p>Il tipo del <code>selector</code> e ogni etichetta <code>case</code> devono essere compatibili:</p> <ul> <li>Le costanti numeriche dei case devono essere entro l\u2019intervallo del tipo del selector.</li> <li>Per un selector <code>enum</code>, le etichette <code>case</code> devono essere costanti di quell\u2019<code>enum</code>.</li> <li>Per un selector <code>String</code>, le etichette <code>case</code> devono essere costanti stringa.</li> </ul> <p></p>"},{"location":"it/module-02/control-flow/#724-pattern-matching-nello-switch","title":"7.2.4 Pattern Matching nello Switch","text":"<p>Lo switch in Java 21 supporta il <code>pattern matching</code>, includendo:</p> <ul> <li>Type pattern: <code>case String s</code></li> <li>Guarded pattern: <code>case String s when s.length() &gt; 3</code></li> <li>Null pattern: <code>case null</code></li> </ul> <p>Esempio:</p> <pre><code>String describe(Object o) {\n    return switch (o) {\n        case null -&gt; \"null\";\n        case Integer i -&gt; \"int \" + i;\n        case String s when s.isEmpty() -&gt; \"empty string\";\n        case String s -&gt; \"string (\" + s.length() + \")\";\n        default -&gt; \"other\";\n    };\n}\n</code></pre> <p>Punti chiave:</p> <ul> <li>Ogni pattern introduce una <code>pattern variable</code> (come <code>i</code> o <code>s</code>).</li> <li>Le pattern variable sono in scope solo all\u2019interno del proprio <code>ramo</code> (o dei percorsi in cui \u00e8 noto che il pattern corrisponde).</li> <li>L\u2019ordine \u00e8 importante a causa della dominanza: i pattern pi\u00f9 specifici devono precedere quelli pi\u00f9 generali.</li> </ul> <p></p>"},{"location":"it/module-02/control-flow/#7241-nomi-delle-variabili-e-scope-tra-i-rami","title":"7.2.4.1 Nomi delle variabili e scope tra i rami","text":"<p>Con il <code>pattern matching</code>, la variabile di pattern esiste solo nello scope del ramo in cui \u00e8 definita. </p> <p>Questo significa che puoi riutilizzare lo stesso nome di variabile in diversi rami <code>case</code> senza che i nomi entrino in conflitto.</p> <ul> <li>Esempio:</li> </ul> <pre><code>switch (o) {\n    case String str -&gt; System.out.println(str.length());\n    case CharSequence str -&gt; System.out.println(str.charAt(0));\n    default -&gt; { }\n}\n</code></pre> <p>Note</p> <p>Quest\u2019ultimo esempio non restituisce un valore, quindi \u00e8 in realt\u00e0 una istruzione switch, non una switch Expression.</p> <p></p>"},{"location":"it/module-02/control-flow/#7242-ordinamento-dominanza-ed-esaustivita-negli-switch-con-pattern","title":"7.2.4.2 Ordinamento, dominanza ed esaustivit\u00e0 negli switch con pattern","text":"<p>Quando si gestisce il pattern matching, l\u2019ordinamento dei rami \u00e8 cruciale a causa della dominanza e del potenziale codice irraggiungibile.</p> <p>Un pattern pi\u00f9 generale non deve apparire prima di uno pi\u00f9 specifico, altrimenti quello specifico diventa irraggiungibile.</p> <ul> <li>Esempio (ramo irraggiungibile):</li> </ul> <pre><code>return switch (o) {\n    case Object obj -&gt; \"object\";\n    case String s -&gt; \"string\"; // \u274c DOES NOT COMPILE: irraggiungibile, String \u00e8 gi\u00e0 intercettata da Object\n};\n</code></pre> <ul> <li>Un altro esempio con una guard:</li> </ul> <pre><code>return switch (o) {\n    case Integer a -&gt; \"First\";\n    case Integer a when a &gt; 0 -&gt; \"Second\"; // \u274c DOES NOT COMPILE: irraggiungibile, il primo case intercetta tutti gli Integers\n    // ...\n};\n</code></pre> <p>Quando si usa il pattern matching, gli switch devono essere esaustivi; cio\u00e8, devono gestire tutti i possibili valori del selector.</p> <p>Questo pu\u00f2 essere ottenuto tramite:</p> <ul> <li>Fornire un case <code>default</code> che gestisce tutti i valori non corrispondenti a nessun altro case.</li> <li> <p>Fornire una clausola <code>case terminale</code> con un tipo di pattern che corrisponde al tipo reference del selector.</p> </li> <li> <p>Esempio (non esaustivo):</p> </li> </ul> <pre><code>Number number = Short.valueOf(10);\n\nswitch (number) {\n    case Short s -&gt; System.out.println(\"A\"); // \u274c DOES NOT COMPILE: non esaustivo, il selector \u00e8 di tipo Number\n}\n</code></pre> <p>Per correggere questo, puoi:</p> <ul> <li>Cambiare il tipo reference di <code>number</code> in <code>Short</code> (allora l\u2019esaustivit\u00e0 \u00e8 soddisfatta dal singolo case).</li> <li>Aggiungere una clausola <code>default</code> che copre tutti i valori rimanenti.</li> <li>Aggiungere una clausola <code>case</code> finale che copre il tipo della variabile selector, per esempio:</li> </ul> <pre><code>Number number = Short.valueOf(10);\n\nswitch (number) {\n    case Short s -&gt; System.out.println(\"A\");\n    case Number n -&gt; System.out.println(\"B\");\n}\n</code></pre> <p>Warning</p> <p>Il seguente esempio, che usa sia una clausola <code>default</code> sia una clausola finale con lo stesso tipo della variabile selector, non compila: il compilatore considera uno dei due case come sempre dominante rispetto all\u2019altro.</p> <pre><code>Number number = Short.valueOf(10);\n\nswitch (number) {\n    case Short s -&gt; System.out.println(\"A\");\n    case Number n -&gt; System.out.println(\"B\"); // \u274c DOES NOT COMPILE: dominated by either the default or the Number pattern\n    default -&gt; System.out.println(\"C\");\n}\n</code></pre> <p></p>"},{"location":"it/module-02/control-flow/#73-due-forme-di-switch-switch-statement-vs-switch-expression","title":"7.3 Due forme di <code>switch</code>: <code>switch</code> Statement vs <code>switch</code> Expression","text":""},{"location":"it/module-02/control-flow/#731-listruzione-switch","title":"7.3.1 L\u2019istruzione Switch","text":"<p>Una istruzione switch \u00e8 usata come costrutto di controllo del flusso.</p> <p>Non viene valutata, di per s\u00e9, come un valore, anche se i suoi rami possono contenere istruzioni <code>return</code> che ritornano dal metodo contenitore.</p> <pre><code>switch (mode) { // switch statement\n    case \"ON\":\n        start();\n        break; // prevents fall-through\n    case \"OFF\":\n        stop();\n        break;\n    default:\n        reset();\n}\n</code></pre> <p>Punti chiave:</p> <ul> <li>Ogni clausola <code>case</code> include uno o pi\u00f9 valori corrispondenti separati da virgole <code>,</code>. Segue un separatore, che pu\u00f2 essere due punti <code>:</code> o, meno comunemente per le <code>istruzioni</code>, l\u2019operatore freccia <code>-&gt;</code>. Infine, un\u2019espressione o un blocco (racchiuso in <code>{}</code>) definisce il codice da eseguire quando si verifica una corrispondenza. Se si usa l\u2019operatore freccia per una clausola, si deve usare per tutte le clausole in quella istruzione switch.</li> <li>Il fall-through \u00e8 possibile per i <code>case</code> in stile \"due punti\" a meno che un ramo usi <code>break</code>, <code>return</code> o <code>throw</code>. Quando presente, <code>break</code> termina lo switch dopo l\u2019esecuzione del suo case; senza di esso, l\u2019esecuzione continua, in ordine, nei rami successivi.</li> <li>Una clausola <code>default</code> \u00e8 opzionale e pu\u00f2 apparire ovunque nell\u2019istruzione switch. Viene eseguita se non c\u2019\u00e8 corrispondenza per i case precedenti.</li> <li>Un\u2019istruzione switch non produce un valore come nell'Expression; non puoi assegnare un\u2019istruzione switch direttamente a una variabile.</li> </ul> <p></p>"},{"location":"it/module-02/control-flow/#7311-comportamento-di-fall-through","title":"7.3.1.1 Comportamento di Fall-Through","text":"<p>Con i <code>case</code> in stile \"due punti\", l\u2019esecuzione salta all\u2019etichetta <code>case</code> corrispondente.</p> <p>Se non c\u2019\u00e8 un <code>break</code>, continua nel case successivo finch\u00e9 non viene incontrato un <code>break</code>, <code>return</code> o <code>throw</code>.</p> <pre><code>int n = 2;\n\nswitch (n) {\n    case 1:\n        System.out.println(\"1\");\n    case 2:\n        System.out.println(\"2\"); // printed\n    case 3:\n        System.out.println(\"3\"); // printed (fall-through)\n        break;\n    default:\n        System.out.println(\"message default\");\n}\n</code></pre> <p>Output:</p> <pre><code>2\n3\n</code></pre> <p>Note</p> <p>Se nell\u2019esempio precedente rimuoviamo il <code>break</code> sul <code>case 3</code>, verr\u00e0 stampato anche il messaggio del ramo <code>default</code>.</p> <p></p>"},{"location":"it/module-02/control-flow/#732-lespressione-switch","title":"7.3.2 L\u2019espressione Switch","text":"<p>Una espressione switch produce sempre un singolo valore come suo risultato.</p> <ul> <li>Esempio:</li> </ul> <pre><code>int len = switch (s) { // switch expression\n    case null -&gt; 0;\n    case \"\" -&gt; 0;\n    default -&gt; s.length();\n};\n</code></pre> <p>Punti chiave:</p> <ul> <li>Ogni clausola <code>case</code> include uno o pi\u00f9 valori corrispondenti separati da virgole <code>,</code>, seguiti dall\u2019operatore freccia <code>-&gt;</code>. Poi un\u2019espressione o un blocco (racchiuso in <code>{}</code>) definisce il risultato per quel ramo.</li> <li>Quando usata con un\u2019assegnazione o un\u2019istruzione <code>return</code>, un\u2019espressione switch richiede un punto e virgola finale <code>;</code> dopo l\u2019espressione.</li> <li>Non c\u2019\u00e8 fall-through tra i rami in stile \"freccia\". Ogni ramo corrispondente viene eseguito esattamente una volta.</li> <li>Un\u2019espressione switch deve essere esaustiva: tutti i possibili valori del selector devono essere coperti (tramite case espliciti e/o <code>default</code>).</li> <li>Il tipo del risultato deve essere coerente tra tutti i rami. Per esempio, se un ramo produce un <code>int</code>, gli altri rami devono produrre valori compatibili con <code>int</code>.</li> </ul> <p></p>"},{"location":"it/module-02/control-flow/#7321-yield-nei-blocchi-di-espressione-switch","title":"7.3.2.1 <code>yield</code> nei blocchi di espressione switch","text":"<p>Quando un ramo di un\u2019espressione switch usa un blocco invece di una singola espressione, devi usare <code>yield</code> per fornire il risultato di quel ramo.</p> <pre><code>int len = switch (s) {\n    case null -&gt; 0;\n    default -&gt; {\n        int l = s.trim().length();\n        System.out.println(\"Length: \" + l);\n        yield l; // result of this arm\n    }\n};\n</code></pre> <p>Note</p> <p><code>yield</code> \u00e8 usato solo nelle Expressions switch. <code>break value;</code> non \u00e8 consentito come modo per restituire un valore da un\u2019espressione switch.</p> <p></p>"},{"location":"it/module-02/control-flow/#7322-esaustivita-per-le-espressioni-switch","title":"7.3.2.2 Esaustivit\u00e0 per le espressioni switch","text":"<p>Poich\u00e9 un\u2019espressione switch deve restituire un valore, deve anche essere esaustiva; in altre parole, deve gestire tutti i possibili valori del selector.</p> <p>Puoi assicurare questo tramite:</p> <ul> <li>Fornire un case <code>default</code>.</li> <li>Per un selector enum: coprire esplicitamente tutte le costanti enum.</li> <li>Per tipi sealed o pattern switch: coprire tutti i sottotipi permessi o fornire un <code>default</code>.</li> </ul> <p>Esempio, esaustivo tramite <code>default</code>:</p> <pre><code>int val = switch (s) {\n    case \"one\" -&gt; 1;\n    case \"two\" -&gt; 2;\n    default -&gt; 0;\n};\n</code></pre> <p></p>"},{"location":"it/module-02/control-flow/#74-gestione-di-null","title":"7.4 Gestione di null","text":"<p>Switch classico (senza pattern)</p> <p>Se l\u2019espressione selector di uno switch classico (senza pattern matching) viene valutata come <code>null</code>, viene lanciata una <code>NullPointerException</code> a runtime.</p> <p>Per evitare questo, controlla <code>null</code> prima di fare lo switch:</p> <pre><code>if (s == null) {\n    // handle null\n} else {\n    switch (s) {\n        case \"A\" -&gt; ...\n        default -&gt; ...\n    }\n}\n</code></pre> <p>Pattern switch (con <code>case null</code>)</p> <p>Con il pattern matching, puoi gestire <code>null</code> direttamente dentro lo switch:</p> <pre><code>int len = switch (s) {\n    case null -&gt; 0;\n    default -&gt; s.length();\n};\n</code></pre> <p>Note</p> <p>Per le Expressions switch:</p> <p>Se non gestisci <code>null</code> e il selector \u00e8 <code>null</code>, viene lanciata una <code>NullPointerException</code>.</p> <p>Usare <code>case null</code> rende lo switch esplicitamente null-safe.</p> <p>Warning</p> <p>Ogni volta che <code>case null</code> viene usato in uno switch, lo switch viene trattato come un <code>pattern switch</code>, e si applicano tutte le regole per i pattern switch (incluse esaustivit\u00e0 e dominanza).</p>"},{"location":"it/module-02/loops/","title":"8. Costrutti di iterazione in Java","text":""},{"location":"it/module-02/loops/#indice","title":"Indice","text":"<ul> <li>8.1 Il ciclo while</li> <li>8.2 Il ciclo do-while</li> <li>8.3 Il ciclo for</li> <li>8.4 Il ciclo for-each avanzato</li> <li>8.5 Cicli annidati</li> <li>8.6 Cicli infiniti</li> <li>8.7 break e continue</li> <li>8.8 Cicli etichettati</li> <li>8.9 Ambito delle variabili di ciclo</li> <li>8.10 Codice irraggiungibile dopo break continue e return<ul> <li>8.10.1 Codice irraggiungibile dopo break</li> <li>8.10.2 Codice irraggiungibile dopo continue</li> <li>8.10.3 Codice irraggiungibile dopo return</li> </ul> </li> </ul> <p>Java fornisce diversi costrutti di iterazione che consentono l\u2019esecuzione ripetuta di un blocco di codice finch\u00e9 una condizione \u00e8 vera.</p> <p>I cicli sono essenziali per l\u2019iterazione, l\u2019attraversamento di strutture dati, calcoli ripetuti e l\u2019implementazione di algoritmi.</p> <p></p>"},{"location":"it/module-02/loops/#81-il-ciclo-while","title":"8.1 Il ciclo <code>while</code>","text":"<p>Il ciclo <code>while</code> valuta la propria condizione booleana prima di ogni iterazione.</p> <p>Se la condizione \u00e8 <code>false</code> fin dall\u2019inizio, il corpo non viene mai eseguito.</p> <p>Sintassi <pre><code>while (condition) {\n    // loop body\n}\n</code></pre></p> <ul> <li>La condizione deve essere valutata come un booleano.</li> <li>Il ciclo pu\u00f2 essere eseguito zero o pi\u00f9 volte.</li> <li> <p>Tra gli errori comuni c\u2019\u00e8 il dimenticare di aggiornare la variabile del ciclo, causando un ciclo infinito.</p> </li> <li> <p>Esempio: <pre><code>int i = 0;\nwhile (i &lt; 3) {\n    System.out.println(i);\n    i++;\n}\n</code></pre></p> </li> </ul> <p>Output: <pre><code>0\n1\n2\n</code></pre></p> <p></p>"},{"location":"it/module-02/loops/#82-il-ciclo-do-while","title":"8.2 Il ciclo <code>do-while</code>","text":"<p>Il ciclo <code>do-while</code> valuta la propria condizione dopo aver eseguito il corpo, assicurando che il corpo venga eseguito almeno una volta.</p> <p>Sintassi <pre><code>do {\n    // loop body\n} while (condition);\n</code></pre></p> <p>Tip</p> <p><code>do-while</code> richiede un punto e virgola dopo la parentesi di chiusura.</p> <ul> <li>Esempio: <pre><code>int x = 5;\ndo {\n    System.out.println(x);\n    x--;\n} while (x &gt; 5); // il body \u00e8 eseguito almeno una volta anche se la condizione \u00e8 false\n</code></pre></li> </ul> <p>Output: <pre><code>5\n</code></pre></p> <p></p>"},{"location":"it/module-02/loops/#83-il-ciclo-for","title":"8.3 Il ciclo <code>for</code>","text":"<p>Il ciclo <code>for</code> tradizionale \u00e8 pi\u00f9 adatto per cicli con una variabile contatore.</p> <p>\u00c8 composto da tre parti: <code>inizializzazione</code>, <code>condizione</code>, <code>aggiornamento</code>.</p> <p>Sintassi <pre><code>for (initialization; condition; update) {\n    // loop body\n}\n</code></pre></p> <ul> <li>L\u2019<code>inizializzazione</code> viene eseguita una volta prima dell\u2019inizio del ciclo.</li> <li>La <code>condizione</code> viene valutata prima di ogni iterazione.</li> <li>L\u2019<code>aggiornamento</code> viene eseguito dopo ogni iterazione.</li> <li><code>Inizializzazione</code> e <code>aggiornamento</code> possono contenere pi\u00f9 istruzioni separate da virgole.</li> <li>Le variabili nell\u2019inizializzazione devono essere tutte dello stesso tipo.</li> <li> <p>Qualsiasi componente pu\u00f2 essere omesso, ma i punti e virgola rimangono.</p> </li> <li> <p>Esempio: <pre><code>for (int i = 0; i &lt; 3; i++) {\n    System.out.println(i);\n}\n</code></pre></p> </li> </ul> <p>Omettendo parti: <pre><code>int j = 0;\nfor (; j &lt; 3;) {  // valid\n    j++;\n}\n</code></pre></p> <p>Istruzioni multiple: <pre><code>int x = 0;\nfor (long i = 0, c = 3; x &lt; 3 &amp;&amp; i &lt; 12; x++, i++) {\n    System.out.println(i);\n}\n</code></pre></p> <p></p>"},{"location":"it/module-02/loops/#84-il-ciclo-for-each-avanzato","title":"8.4 Il ciclo <code>for-each</code> avanzato","text":"<p>Il <code>for</code> avanzato semplifica l\u2019iterazione su <code>array</code> e <code>collezioni</code>.</p> <p>Sintassi <pre><code>for (ElementType var : arrayOrCollection) {\n    // loop body\n}\n</code></pre></p> <ul> <li>La variabile di ciclo \u00e8 di sola lettura rispetto alla collezione sottostante.</li> <li>Funziona con qualsiasi <code>Iterable</code> o array.</li> <li> <p>Non pu\u00f2 rimuovere elementi senza un iteratore.</p> </li> <li> <p>Esempio: <pre><code>String[] names = {\"A\", \"B\", \"C\"};\nfor (String n : names) {\n    System.out.println(n);\n}\n</code></pre></p> </li> </ul> <p>Output: <pre><code>A\nB\nC\n</code></pre></p> <p></p>"},{"location":"it/module-02/loops/#85-cicli-annidati","title":"8.5 Cicli annidati","text":"<p>I cicli possono essere annidati; ciascuno mantiene le proprie variabili e condizioni.</p> <pre><code>for (int i = 1; i &lt;= 2; i++) {\n    for (int j = 1; j &lt;= 3; j++) {\n        System.out.println(i + \",\" + j);\n    }\n}\n</code></pre> <p>Output: <pre><code>1,1\n1,2\n1,3\n2,1\n2,2\n2,3\n</code></pre></p> <p></p>"},{"location":"it/module-02/loops/#86-cicli-infiniti","title":"8.6 Cicli infiniti","text":"<p>Un ciclo \u00e8 infinito quando la sua condizione viene sempre valutata come <code>true</code> o \u00e8 omessa.</p> <pre><code>while (true) { ... }\n</code></pre> <pre><code>for (;;) { ... }\n</code></pre> <p>Tip</p> <p>I cicli infiniti devono contenere <code>break</code>, <code>return</code> o un controllo esterno.</p> <p></p>"},{"location":"it/module-02/loops/#87-break-e-continue","title":"8.7 <code>break</code> e <code>continue</code>","text":"<p>break Esce immediatamente dal ciclo pi\u00f9 interno. <pre><code>for (int i = 0; i &lt; 5; i++) {\n    if (i == 2) break;\n    System.out.println(i);\n}\n</code></pre></p> <p>continue Salta il resto del corpo del ciclo e continua alla successiva iterazione. <pre><code>for (int i = 0; i &lt; 5; i++) {\n    if (i % 2 == 0) continue;\n    System.out.println(i);\n}\n</code></pre></p> <p>Note</p> <p><code>break</code> e <code>continue</code> si applicano al ciclo pi\u00f9 vicino a meno che non vengano usate etichette.</p> <p></p>"},{"location":"it/module-02/loops/#88-cicli-etichettati","title":"8.8 Cicli etichettati","text":"<p>Un\u2019<code>etichetta</code> (identificatore + due punti) pu\u00f2 essere applicata a un ciclo per consentire a break/continue di influire sui cicli esterni.</p> <pre><code>labelName:\nfor (...) {\n    for (...) {\n        break labelName;\n    }\n}\n</code></pre> <ul> <li>Esempio: <pre><code>outer:\nfor (int i = 1; i &lt;= 3; i++) {\n    for (int j = 1; j &lt;= 3; j++) {\n        if (j == 2) break outer;\n        System.out.println(i + \",\" + j);\n    }\n}\n</code></pre></li> </ul> <p></p>"},{"location":"it/module-02/loops/#89-ambito-delle-variabili-di-ciclo","title":"8.9 Ambito delle variabili di ciclo","text":"<ul> <li>Le variabili dichiarate nell\u2019intestazione del ciclo hanno ambito limitato a quel ciclo.</li> <li>Le variabili dichiarate all\u2019interno del corpo esistono solo all\u2019interno di quel blocco.</li> </ul> <pre><code>for (int i = 0; i &lt; 3; i++) {\n    int x = i * 2;\n}\n// i and x are not accessible here\n</code></pre>"},{"location":"it/module-02/loops/#810-codice-irraggiungibile-dopo-break-continue-e-return","title":"8.10 Codice irraggiungibile dopo <code>break</code>, <code>continue</code> e <code>return</code>","text":"<p>Qualsiasi istruzione posizionata dopo <code>break</code>, <code>continue</code> o <code>return</code> nello stesso blocco \u00e8 considerata irraggiungibile e non compila.</p> <p></p>"},{"location":"it/module-02/loops/#8101-codice-irraggiungibile-dopo-break","title":"8.10.1 Codice irraggiungibile dopo <code>break</code>","text":"<pre><code>for (int i = 0; i &lt; 3; i++) {\n    break;\n    System.out.println(\"Unreachable\"); // \u274c Compile-time error\n}\n</code></pre>"},{"location":"it/module-02/loops/#8102-codice-irraggiungibile-dopo-continue","title":"8.10.2 Codice irraggiungibile dopo <code>continue</code>","text":"<pre><code>for (int i = 0; i &lt; 3; i++) {\n    continue;\n    System.out.println(\"Unreachable\"); // \u274c Compile-time error\n}\n</code></pre> <p>Note</p> <p><code>continue</code> salta alla successiva iterazione, quindi il codice successivo non viene mai eseguito.</p> <p></p>"},{"location":"it/module-02/loops/#8103-codice-irraggiungibile-dopo-return","title":"8.10.3 Codice irraggiungibile dopo <code>return</code>","text":"<pre><code>int test() {\n    return 5;\n    System.out.println(\"Unreachable\"); // \u274c Compile-time error\n}\n</code></pre> <p>Note</p> <p><code>return</code> esce immediatamente dal metodo; nessuna istruzione pu\u00f2 seguirlo.</p>"},{"location":"it/module-03/arrays/","title":"10. Array in Java","text":""},{"location":"it/module-03/arrays/#indice","title":"Indice","text":"<ul> <li>10.1 Che cos\u2019\u00e8 un array<ul> <li>10.1.1 Dichiarare gli array</li> <li>10.1.2 Creare array (istanza)</li> <li>10.1.3 Valori predefiniti negli array</li> <li>10.1.4 Accedere agli elementi</li> <li>10.1.5 Scorciatoie di inizializzazione degli array<ul> <li>10.1.5.1 Creazione di array anonimi</li> <li>10.1.5.2 Sintassi breve (solo in dichiarazione)</li> </ul> </li> </ul> </li> <li>10.2 Array multidimensionali (array di array)<ul> <li>10.2.1 Creare un array rettangolare</li> <li>10.2.2 Creare un array frastagliato (irregolare)</li> </ul> </li> <li>10.3 Lunghezza degli array vs lunghezza delle stringhe</li> <li>10.4 Assegnazioni di riferimenti a array<ul> <li>10.4.1 Assegnare riferimenti compatibili</li> <li>10.4.2 Assegnazioni incompatibili (errori a compile-time)</li> <li>10.4.3 Rischio runtime della covarianza: ArrayStoreException</li> </ul> </li> <li>10.5 Confrontare gli array</li> <li>10.6 Metodi di utilita di Arrays<ul> <li>10.6.1 Arrays.toString</li> <li>10.6.2 Arrays.deepToString per array annidati</li> <li>10.6.3 Arrays.sort</li> <li>10.6.4 Arrays.binarySearch</li> <li>10.6.5 Arrays.compare</li> </ul> </li> <li>10.7 Enhanced for-loop con array</li> <li>10.8 Errori comuni</li> <li>10.9 Riepilogo</li> </ul>"},{"location":"it/module-03/arrays/#101-che-cose-un-array","title":"10.1 Che cos\u2019\u00e8 un array","text":"<p>Gli array in Java sono collezioni a dimensione fissa, indicizzate, ordinate di elementi dello stesso tipo.</p> <p>Sono oggetti, anche quando gli elementi contenuti sono primitivi.</p> <p></p>"},{"location":"it/module-03/arrays/#1011-dichiarare-gli-array","title":"10.1.1 Dichiarare gli array","text":"<p>Puoi dichiarare un array in due modi:</p> <pre><code>int[] a;      // sintassi moderna preferita\nint b[];      // legale, stile vetusto\nString[] names;\nPerson[] people;\n\n// [] possono trovarsi prima o dopo il nome: tutte le seguenti dichiarazioni sono equivalenti.\n\nint[] x;\nint [] x1;\nint []x2;\nint x3[];\nint x5 [];\n\n// MULTIPLE ARRAY DECLARATIONS\n\nint[] arr1, arr2;   // Dichiara due array di interi\n\n// WARNING:\n// QUi arr1 \u00e8 un int[] e arr2 \u00e8 solo un int (NON un array!)\nint arr1[], arr2;\n</code></pre> <p>Dichiarare NON crea l\u2019array \u2014 crea solo una variabile in grado di referenziarne uno.</p> <p></p>"},{"location":"it/module-03/arrays/#1012-creare-array-istanza","title":"10.1.2 Creare array (istanza)","text":"<p>Un array viene creato usando <code>new</code> seguito dal tipo dell\u2019elemento e dalla lunghezza dell\u2019array:</p> <pre><code>int[] numbers = new int[5];\nString[] words = new String[3];\n</code></pre> <p>Regole chiave - La lunghezza deve essere non negativa e specificata al momento della creazione. - La lunghezza non pu\u00f2 essere cambiata in seguito. - La lunghezza dell\u2019array pu\u00f2 essere qualsiasi espressione <code>int</code>.</p> <pre><code>int size = 4;\ndouble[] values = new double[size];\n</code></pre> <ul> <li>Esempi illegali di creazione di array:</li> </ul> <pre><code>// int length = -1;           \n// int[] arr = new int[-1];   // Runtime: NegativeArraySizeException\n\n// int[] arr = new int[2.5];  // Compile error: size must be int\n</code></pre> <p></p>"},{"location":"it/module-03/arrays/#1013-valori-predefiniti-negli-array","title":"10.1.3 Valori predefiniti negli array","text":"<p>Gli array (poich\u00e9 sono oggetti) ricevono sempre una inizializzazione predefinita:</p> Tipo di elemento Valore predefinito Numerico 0 boolean false char '\\u0000' Tipi di riferimento null <ul> <li>Esempio:</li> </ul> <pre><code>int[] nums = new int[3]; \nSystem.out.println(nums[0]); // 0\n\nString[] s = new String[3];\nSystem.out.println(s[0]);    // null\n</code></pre> <p></p>"},{"location":"it/module-03/arrays/#1014-accedere-agli-elementi","title":"10.1.4 Accedere agli elementi","text":"<p>Gli elementi si accedono usando l\u2019indicizzazione a base zero:</p> <pre><code>int[] a = new int[3];\na[0] = 10;\na[1] = 20;\nSystem.out.println(a[1]); // 20\n</code></pre> <p>Eccezione comune - <code>ArrayIndexOutOfBoundsException</code> (runtime)</p> <pre><code>// int[] x = new int[2];\n// System.out.println(x[2]); // \u274c indice 2 out of bounds\n</code></pre> <p></p>"},{"location":"it/module-03/arrays/#1015-scorciatoie-di-inizializzazione-degli-array","title":"10.1.5 Scorciatoie di inizializzazione degli array","text":""},{"location":"it/module-03/arrays/#10151-creazione-di-array-anonimi","title":"10.1.5.1 Creazione di array anonimi","text":"<pre><code>int[] a = new int[] {1,2,3};\n</code></pre>"},{"location":"it/module-03/arrays/#10152-sintassi-breve-solo-in-dichiarazione","title":"10.1.5.2 Sintassi breve (solo in dichiarazione)","text":"<pre><code>int[] b = {1,2,3};\n</code></pre> <p>La sintassi breve <code>{1,2,3}</code> pu\u00f2 essere usata solo nel punto di dichiarazione.</p> <pre><code>// int[] c;\n// c = {1,2,3};  // \u274c does not compile\n</code></pre> <p></p>"},{"location":"it/module-03/arrays/#102-array-multidimensionali-array-di-array","title":"10.2 Array multidimensionali (array di array)","text":"<p>Java implementa gli array multi-dimensionali come array di array.</p> <p>Dichiarazione:</p> <pre><code>int[][] matrix;\nString[][][] cube;\n</code></pre> <p></p>"},{"location":"it/module-03/arrays/#1021-creare-un-array-rettangolare","title":"10.2.1 Creare un array rettangolare","text":"<pre><code>int[][] rect = new int[3][4]; // 3 righe, 4 colonne\n</code></pre>"},{"location":"it/module-03/arrays/#1022-creare-un-array-frastagliato-irregolare","title":"10.2.2 Creare un array frastagliato (irregolare)","text":"<p>Puoi creare righe con lunghezze diverse:</p> <pre><code>int[][] jagged = new int[3][];\njagged[0] = new int[2];\njagged[1] = new int[5];\njagged[2] = new int[1];\n</code></pre> <p></p>"},{"location":"it/module-03/arrays/#103-lunghezza-degli-array-vs-lunghezza-delle-stringhe","title":"10.3 Lunghezza degli array vs lunghezza delle stringhe","text":"<ul> <li>Gli array usano <code>.length</code> (campo <code>public final</code>).</li> <li>Le stringhe usano <code>.length()</code> (metodo).</li> </ul> <p>Tip</p> <p>Questo \u00e8 un classico errore: campi vs metodi.</p> <pre><code>// int x = arr.length;   // OK\n// int y = s.length;     // \u274c does not compile: missing ()\nint yOk = s.length();\n</code></pre> <p></p>"},{"location":"it/module-03/arrays/#104-assegnazioni-di-riferimenti-a-array","title":"10.4 Assegnazioni di riferimenti a array","text":""},{"location":"it/module-03/arrays/#1041-assegnare-riferimenti-compatibili","title":"10.4.1 Assegnare riferimenti compatibili","text":"<pre><code>int[] a = {1,2,3};\nint[] b = a; // entrambi puntano ora allo stesso array\n</code></pre> <p>Modificare un riferimento influisce sull\u2019altro:</p> <pre><code>b[0] = 99;\nSystem.out.println(a[0]); // 99\n</code></pre> <p></p>"},{"location":"it/module-03/arrays/#1042-assegnazioni-incompatibili-errori-a-compile-time","title":"10.4.2 Assegnazioni incompatibili (errori a compile-time)","text":"<pre><code>int[] x = new int[3];\n// long[] y = x;     // \u274c tipo incompatibile\n</code></pre> <p>I riferimenti ad array seguono le normali regole di ereditariet\u00e0:</p> <pre><code>String[] s = new String[3];\nObject[] o = s;      // OK: arrays are covariant\n</code></pre> <p></p>"},{"location":"it/module-03/arrays/#1043-rischio-runtime-della-covarianza-arraystoreexception","title":"10.4.3 Rischio runtime della covarianza: <code>ArrayStoreException</code>","text":"<pre><code>Object[] objs = new String[3];\n// objs[0] = Integer.valueOf(5); // \u274c ArrayStoreException a runtime\n</code></pre>"},{"location":"it/module-03/arrays/#105-confrontare-gli-array","title":"10.5 Confrontare gli array","text":"<p><code>==</code> confronta i riferimenti (identit\u00e0):</p> <pre><code>int[] a = {1,2};\nint[] b = {1,2};\nSystem.out.println(a == b); // false\n</code></pre> <p><code>equals()</code> sugli array non confronta i contenuti (si comporta come <code>==</code>):</p> <pre><code>System.out.println(a.equals(b)); // false\n</code></pre> <p>Per confrontare i contenuti, usa i metodi di <code>java.util.Arrays</code>:</p> <pre><code>Arrays.equals(a, b);         // shallow comparison\nArrays.deepEquals(o1, o2);   // deep comparison per arrays annidati\n</code></pre> <p></p>"},{"location":"it/module-03/arrays/#106-metodi-di-utilita-di-arrays","title":"10.6 Metodi di utilit\u00e0 di <code>Arrays</code>","text":""},{"location":"it/module-03/arrays/#1061-arraystostring","title":"10.6.1 <code>Arrays.toString()</code>","text":"<pre><code>System.out.println(Arrays.toString(new int[]{1,2,3})); // [1, 2, 3]\n</code></pre>"},{"location":"it/module-03/arrays/#1062-arraysdeeptostring-per-array-annidati","title":"10.6.2 <code>Arrays.deepToString()</code> (per array annidati)","text":"<pre><code>System.out.println(Arrays.deepToString(new int[][] {{1,2},{3,4}}));\n// [[1, 2], [3, 4]]\n</code></pre>"},{"location":"it/module-03/arrays/#1063-arrayssort","title":"10.6.3 <code>Arrays.sort()</code>","text":"<pre><code>int[] a = {4,1,3};\nArrays.sort(a); // [1, 3, 4]\n</code></pre> <p>Tip</p> <ul> <li>Le stringhe sono ordinate in ordine naturale (lessicografico).</li> <li>I numeri ordinano prima delle lettere, e le lettere maiuscole ordinano prima delle minuscole (numeri &lt; maiuscole &lt; minuscole).</li> <li>Per i tipi di riferimento, <code>null</code> \u00e8 considerato pi\u00f9 piccolo di qualsiasi valore non-null.</li> </ul> <pre><code>String[] arr = {\"AB\", \"ac\", \"Ba\", \"bA\", \"10\", \"99\"};\n\nArrays.sort(arr);\n\nSystem.out.println(Arrays.toString(arr));  // [10, 99, AB, Ba, ac, bA]\n</code></pre> <p></p>"},{"location":"it/module-03/arrays/#1064-arraysbinarysearch","title":"10.6.4 <code>Arrays.binarySearch()</code>","text":"<p>Requisiti: l\u2019array deve essere ordinato; altrimenti il risultato \u00e8 imprevedibile.</p> <pre><code>int[] a = {1,3,5,7};\nint idx = Arrays.binarySearch(a, 5); // returns 2\n</code></pre> <p>Quando il valore non viene trovato, <code>binarySearch</code> restituisce <code>-(insertionPoint) - 1</code>:</p> <pre><code>int pos = Arrays.binarySearch(a, 4); // returns -3\n// Il punto d'inserimento sarebbe all'indice 2 \u2192 -(2) - 1 = -3\n</code></pre> <p></p>"},{"location":"it/module-03/arrays/#1065-arrayscompare","title":"10.6.5 <code>Arrays.compare()</code>","text":"<p>La classe <code>Arrays</code> offre un <code>equals()</code> sovraccarico che verifica se due array contengono gli stessi elementi (e hanno la stessa lunghezza):</p> <pre><code>System.out.println(Arrays.equals(new int[] {200}, new int[] {100}));        // false\nSystem.out.println(Arrays.equals(new int[] {200}, new int[] {200}));        // true\nSystem.out.println(Arrays.equals(new int[] {200}, new int[] {100, 200}));   // false\n</code></pre> <p>Fornisce anche un metodo <code>compare()</code> con queste regole:</p> <ul> <li>Se il risultato <code>n &lt; 0</code> \u2192 il primo array \u00e8 considerato \u201cpi\u00f9 piccolo\u201d del secondo.</li> <li>Se il risultato <code>n &gt; 0</code> \u2192 il primo array \u00e8 considerato \u201cpi\u00f9 grande\u201d del secondo.</li> <li> <p>Se il risultato <code>n == 0</code> \u2192 gli array sono uguali.</p> </li> <li> <p>Esempi:</p> </li> </ul> <pre><code>int[] arr1 = new int[] {200, 300};\nint[] arr2 = new int[] {200, 300, 400};\nSystem.out.println(Arrays.compare(arr1, arr2));  // -1\n\nint[] arr3 = new int[] {200, 300, 400};\nint[] arr4 = new int[] {200, 300};\nSystem.out.println(Arrays.compare(arr3, arr4));  // 1\n\nString[] arr5 = new String[] {\"200\", \"300\", \"aBB\"};\nString[] arr6 = new String[] {\"200\", \"300\", \"ABB\"};\nSystem.out.println(Arrays.compare(arr5, arr6));     // Positive: \"aBB\" &gt; \"ABB\"\n\nString[] arr7 = new String[] {\"200\", \"300\", \"ABB\"};\nString[] arr8 = new String[] {\"200\", \"300\", \"aBB\"};\nSystem.out.println(Arrays.compare(arr7, arr8));     // Negative: \"ABB\" &lt; \"aBB\"\n\nString[] arr9 = null;\nString[] arr10 = new String[] {\"200\", \"300\", \"ABB\"};\nSystem.out.println(Arrays.compare(arr9, arr10));    // -1 (null considered smaller)\n</code></pre> <p></p>"},{"location":"it/module-03/arrays/#107-enhanced-for-loop-con-array","title":"10.7 Enhanced for-loop con array","text":"<pre><code>for (int value : new int[]{1,2,3}) {\n    System.out.println(value);\n}\n</code></pre> <p>Regole - Il lato destro deve essere un array o un <code>Iterable</code>. - Il tipo della variabile di ciclo deve essere compatibile con il tipo degli elementi (qui non c\u2019\u00e8 widening di primitivi).</p> <p>Errore comune:</p> <pre><code>// for (long v : new int[]{1,2}) {} // \u274c not allowed: int elements cannot be assigned to long in enhanced for-loop\n</code></pre> <p></p>"},{"location":"it/module-03/arrays/#108-errori-comuni","title":"10.8 Errori comuni","text":"<ul> <li> <p>Accesso fuori dai limiti \u2192 lancia <code>ArrayIndexOutOfBoundsException</code>.</p> </li> <li> <p>Uso errato dell\u2019inizializzatore breve</p> </li> </ul> <pre><code>// int[] x;\n// x = {1,2}; // \u274c does not compile\n</code></pre> <ul> <li>Confondere <code>.length</code> e <code>.length()</code></li> <li> <p>Dimenticare che gli array sono oggetti (vivono nell\u2019heap e sono referenziati).</p> </li> <li> <p>Miscelare array di primitivi e array di wrapper</p> </li> </ul> <pre><code>// int[] p = new Integer[3]; // \u274c incompatible\n</code></pre> <ul> <li>Usare <code>binarySearch</code> su array non ordinati \u2192 risultati imprevedibili.</li> <li>Eccezioni runtime dovute a array covarianti (<code>ArrayStoreException</code>).</li> </ul> <p></p>"},{"location":"it/module-03/arrays/#109-riepilogo","title":"10.9 Riepilogo","text":"<p>Gli array in Java sono:</p> <ul> <li>Oggetti (anche se contengono primitivi).</li> <li>Collezioni indicizzate a dimensione fissa.</li> <li>Sempre inizializzati con valori predefiniti.</li> <li>Type-safe, ma soggetti alle regole di covarianza (che possono causare eccezioni a runtime se usate in modo improprio).</li> </ul>"},{"location":"it/module-03/date-time/","title":"12. Data e ora in Java","text":""},{"location":"it/module-03/date-time/#indice","title":"Indice","text":"<ul> <li>12.1 Data e ora<ul> <li>12.1.1 Creare date e ore specifiche</li> <li>12.1.2 Aritmetica su data e ora: metodi plus e minus</li> <li>12.1.3 Pattern comuni</li> <li>12.1.4 Aritmetica su LocalDate</li> <li>12.1.5 Aritmetica su LocalTime</li> <li>12.1.6 Aritmetica su LocalDateTime</li> <li>12.1.7 Aritmetica su ZonedDateTime</li> <li>12.1.8 Tabella riassuntiva</li> </ul> </li> <li>12.2 Metodi withXxx</li> <li>12.3 Conversione e metodi at: collegare data, ora e zona</li> <li>12.4 Period, Duration e Instant</li> <li>12.5 Period \u2014 quantit\u00e0 \u201cumane\u201d di data</li> <li>12.6 Duration \u2014 quantit\u00e0 \u201cmacchina\u201d di tempo</li> <li>12.7 Instant \u2014 punto sulla timeline UTC</li> <li>12.8 Tabella riassuntiva: Period vs Duration vs Instant</li> <li>12.9 TemporalUnit e TemporalAmount<ul> <li>12.9.1 TemporalUnit</li> <li>12.9.2 enum ChronoUnit</li> <li>12.9.3 TemporalAmount</li> <li>12.9.4 Period come TemporalAmount</li> <li>12.9.5 Duration come TemporalAmount</li> <li>12.9.6 Usare TemporalAmount vs TemporalUnit</li> <li>12.9.7 Metodi between</li> <li>12.9.8 Problemi comuni</li> <li>12.9.9 Riepilogo</li> </ul> </li> </ul>"},{"location":"it/module-03/date-time/#121-data-e-ora","title":"12.1 Data e ora","text":"<p>Java fornisce un\u2019API moderna, coerente e immutabile per data/ora nel package <code>java.time.*</code>.</p> <p>Questa API sostituisce le vecchie classi <code>java.util.Date</code> e <code>java.util.Calendar</code>.</p> <p>A seconda del livello di dettaglio richiesto, Java offre quattro classi principali:</p> <ul> <li><code>LocalDate</code> \u2192 rappresenta solo una data (anno\u2013mese\u2013giorno)</li> <li><code>LocalTime</code> \u2192 rappresenta solo un orario (ora\u2013minuto\u2013secondo\u2013nanosecondo)</li> <li><code>LocalDateTime</code> \u2192 combina data + ora, ma senza fuso orario</li> <li><code>ZonedDateTime</code> \u2192 data + ora + offset + fuso orario completi</li> </ul> <p>Note</p> <ul> <li>Un fuso orario definisce regole come i cambi dell\u2019ora legale (ad esempio, <code>Europe/Paris</code>).</li> <li>Un offset di zona \u00e8 uno spostamento fisso rispetto a UTC/GMT (ad esempio, <code>+01:00</code>, <code>-07:00</code>).  </li> <li>Per confrontare due istanti provenienti da fusi orari diversi, convertili in UTC (GMT) applicando l\u2019offset.</li> </ul> <p>Ottenere la data/ora corrente</p> <p>Puoi recuperare i valori correnti del sistema usando i metodi statici <code>now()</code>:</p> <pre><code>System.out.println(LocalDate.now());\nSystem.out.println(LocalTime.now());\nSystem.out.println(LocalDateTime.now());\nSystem.out.println(ZonedDateTime.now());\n</code></pre> <ul> <li>Esempio di output (il tuo sistema potrebbe differire):</li> </ul> <pre><code>2025-12-01\n19:11:53.213856300\n2025-12-01T19:11:53.213856300\n2025-12-01T19:11:53.214856900+01:00[Europe/Paris]\n</code></pre> <ul> <li>Esempio: conversione di <code>ZonedDateTime</code> in GMT (UTC)</li> </ul> <pre><code>// Conceptual examples (codice d'esempio, solo per illustrare l'offsets):\n// 2024-07-01T12:00+09:00[Asia/Tokyo]        ---&gt; 12:00 minus 9 hours ---&gt; 03:00 UTC\n// 2024-07-01T20:00-07:00[America/Los_Angeles] ---&gt; 20:00 plus 7 hours ---&gt; 03:00 UTC\n</code></pre> <p>Entrambi rappresentano lo stesso istante nel tempo, semplicemente espresso in fusi orari diversi.</p> <p></p>"},{"location":"it/module-03/date-time/#1211-creare-date-e-ore-specifiche","title":"12.1.1 Creare date e ore specifiche","text":"<p>Puoi costruire oggetti di data/ora precisi usando i metodi factory <code>of()</code>. Tutte le classi includono pi\u00f9 versioni sovraccaricate di <code>of()</code> (qui sono elencate solo le pi\u00f9 comuni).</p> <p>LocalDate \u2014 forme sovraccaricate di <code>of()</code> - <code>of(int year, int month, int dayOfMonth)</code> - <code>of(int year, Month month, int dayOfMonth)</code></p> <p>LocalTime \u2014 forme sovraccaricate di <code>of()</code> - <code>of(int hour, int minute)</code> - <code>of(int hour, int minute, int second)</code> - <code>of(int hour, int minute, int second, int nanoOfSecond)</code></p> <p>LocalDateTime \u2014 forme sovraccaricate di <code>of()</code> - <code>of(int year, int month, int day, int hour, int minute)</code> - <code>of(int year, int month, int day, int hour, int minute, int second)</code> - <code>of(int year, int month, int day, int hour, int minute, int second, int nano)</code> - <code>of(LocalDate date, LocalTime time)</code></p> <p>**ZonedDateTime \u2014 forme sovraccaricate di <code>of()</code> - <code>of(LocalDate date, LocalTime time, ZoneId zone)</code> - <code>of(int y, int m, int d, int h, int min, int s, int nano, ZoneId zone)</code></p> <ul> <li>Esempi</li> </ul> <pre><code>// Creating specific dates\n\nvar localDate1 = LocalDate.of(2025, 7, 31);\nvar localDate2 = LocalDate.of(2025, Month.JULY, 31);\n\n// Creating specific times\n\nvar localTime1 = LocalTime.of(13, 21);\nSystem.out.println(localTime1);                     // 13:21\nSystem.out.println(LocalTime.of(13, 21, 52));       // 13:21:52\nSystem.out.println(LocalTime.of(13, 21, 52, 200));  // 13:21:52.000000200\n\n// Creating LocalDateTime\n\nvar localDateTime1 = LocalDateTime.of(2025, 7, 31, 13, 55, 22);\nvar localDateTime2 = LocalDateTime.of(localDate1, localTime1);\n\n// Creating a ZonedDateTime\n\nvar zoned = ZonedDateTime.of(2025, 7, 31, 13, 55, 22, 0, ZoneId.of(\"Europe/Paris\"));\n</code></pre> <p></p>"},{"location":"it/module-03/date-time/#1212-aritmetica-su-data-e-ora-metodi-plus-e-minus","title":"12.1.2 Aritmetica su data e ora: metodi <code>plus</code> e <code>minus</code>","text":"<p>Tutte le classi nel package <code>java.time</code> (come <code>LocalDate</code>, <code>LocalTime</code>, <code>LocalDateTime</code>, <code>ZonedDateTime</code>, ecc.) sono immutabili. Ci\u00f2 significa che metodi come <code>plusXxx()</code> e <code>minusXxx()</code> non modificano mai l\u2019oggetto originale \u2014 restituiscono invece una nuova istanza con il valore regolato.</p> <p></p>"},{"location":"it/module-03/date-time/#1213-pattern-comuni","title":"12.1.3 Pattern comuni","text":"<p>La maggior parte delle classi di data/ora supporta tre tipi di metodi aritmetici:</p> <ul> <li>Scorciatoie specifiche per tipo</li> <li><code>plusDays(long daysToAdd)</code></li> <li><code>plusHours(long hoursToAdd)</code></li> <li> <p>ecc.</p> </li> <li> <p>Metodi generici basati su \u201camount\u201d</p> </li> <li><code>plus(TemporalAmount amount)</code> \u2192 ad esempio <code>Period</code>, <code>Duration</code></li> <li> <p><code>minus(TemporalAmount amount)</code></p> </li> <li> <p>Metodi generici basati su \u201cunit\u201d</p> </li> <li><code>plus(long amountToAdd, TemporalUnit unit)</code></li> <li><code>minus(long amountToSubtract, TemporalUnit unit)</code></li> </ul> <p>Questi consentono un\u2019aritmetica su data/ora flessibile e leggibile.</p> <p></p>"},{"location":"it/module-03/date-time/#1214-aritmetica-su-localdate","title":"12.1.4 Aritmetica su <code>LocalDate</code>","text":"<p><code>LocalDate</code> rappresenta solo una data (niente ora, niente zona).</p> <p>Principali metodi <code>plus</code> / <code>minus</code> (overload)</p> Metodo Descrizione <code>plusDays(long days)</code> Aggiunge giorni <code>plusWeeks(long weeks)</code> Aggiunge settimane <code>plusMonths(long months)</code> Aggiunge mesi <code>plusYears(long years)</code> Aggiunge anni <code>minusDays(long days)</code> Sottrae giorni <code>minusWeeks(long weeks)</code> Sottrae settimane <code>minusMonths(long months)</code> Sottrae mesi <code>minusYears(long years)</code> Sottrae anni <code>plus(TemporalAmount amount)</code> Aggiunge un Period <code>minus(TemporalAmount amount)</code> Sottrae un Period <code>plus(long amountToAdd, TemporalUnit unit)</code> Aggiunge usando ChronoUnit (es., DAYS, MONTHS) <code>minus(long amountToSubtract, TemporalUnit unit)</code> Sottrae usando ChronoUnit <ul> <li>Esempi:</li> </ul> <pre><code>LocalDate date = LocalDate.of(2025, 3, 10);\n\nLocalDate d1 = date.plusDays(5);            // 2025-03-15\nLocalDate d2 = date.minusWeeks(2);          // 2025-02-24\nLocalDate d3 = date.plusMonths(1);          // 2025-04-10\nLocalDate d4 = date.plusYears(2);           // 2027-03-10\n\n// Using ChronoUnit\nLocalDate d5 = date.plus(10, ChronoUnit.DAYS);   // 2025-03-20\n\n// Using Period\nPeriod p = Period.of(1, 2, 3);  // 1 year, 2 months, 3 days\nLocalDate d6 = date.plus(p);\n</code></pre> <p></p>"},{"location":"it/module-03/date-time/#1215-aritmetica-su-localtime","title":"12.1.5 Aritmetica su <code>LocalTime</code>","text":"<p><code>LocalTime</code> rappresenta solo un orario (niente data, niente zona).</p> <p>Principali metodi <code>plus</code> / <code>minus</code> (overload)</p> Metodo Descrizione <code>plusNanos(long nanos)</code> Aggiunge nanosecondi <code>plusSeconds(long seconds)</code> Aggiunge secondi <code>plusMinutes(long minutes)</code> Aggiunge minuti <code>plusHours(long hours)</code> Aggiunge ore <code>minusNanos(long nanos)</code> Sottrae nanosecondi <code>minusSeconds(long seconds)</code> Sottrae secondi <code>minusMinutes(long minutes)</code> Sottrae minuti <code>minusHours(long hours)</code> Sottrae ore <code>plus(TemporalAmount amount)</code> Aggiunge una Duration <code>minus(TemporalAmount amount)</code> Sottrae una Duration <code>plus(long amountToAdd, TemporalUnit unit)</code> Aggiunge usando ChronoUnit <code>minus(long amountToSubtract, TemporalUnit unit)</code> Sottrae usando ChronoUnit <ul> <li>Esempi</li> </ul> <pre><code>LocalTime time = LocalTime.of(13, 30);       // 13:30\n\nLocalTime t1 = time.plusHours(2);            // 15:30\nLocalTime t2 = time.minusMinutes(45);        // 12:45\nLocalTime t3 = time.plusSeconds(90);         // 13:31:30\n\n// Using ChronoUnit\nLocalTime t4 = time.plus(3, ChronoUnit.HOURS);    // 16:30\n\n// Using Duration\nDuration d = Duration.ofMinutes(90);\nLocalTime t5 = time.plus(d);                // 15:00\n</code></pre> <p>Note</p> <p>Quando l\u2019aritmetica sull\u2019ora supera la mezzanotte, con <code>LocalTime</code> la data viene ignorata. Per esempio, 23:30 + 2 ore = 01:30 (senza alcuna data coinvolta).</p> <p></p>"},{"location":"it/module-03/date-time/#1216-aritmetica-su-localdatetime","title":"12.1.6 Aritmetica su <code>LocalDateTime</code>","text":"<p><code>LocalDateTime</code> combina data + ora, ma ancora senza fuso orario. Supporta sia le scorciatoie legate alla data sia quelle legate all\u2019ora.</p> <p>Principali metodi <code>plus</code> / <code>minus</code> (overload)</p> Metodo Descrizione <code>plusYears(long years)</code> / <code>minusYears(long years)</code> Regola gli anni <code>plusMonths(long months)</code> / <code>minusMonths(long months)</code> Regola i mesi <code>plusWeeks(long weeks)</code> / <code>minusWeeks(long weeks)</code> Regola le settimane <code>plusDays(long days)</code> / <code>minusDays(long days)</code> Regola i giorni <code>plusHours(long hours)</code> / <code>minusHours(long hours)</code> Regola le ore <code>plusMinutes(long minutes)</code> / <code>minusMinutes(long minutes)</code> Regola i minuti <code>plusSeconds(long seconds)</code> / <code>minusSeconds(long seconds)</code> Regola i secondi <code>plusNanos(long nanos)</code> / <code>minusNanos(long nanos)</code> Regola i nanosecondi <code>plus(TemporalAmount amount)</code> / <code>minus(TemporalAmount amount)</code> Aggiunge/sottrae Period o Duration <code>plus(long amountToAdd, TemporalUnit unit)</code> / <code>minus(long amountToSubtract, TemporalUnit unit)</code> Usando ChronoUnit <ul> <li>Esempi</li> </ul> <pre><code>LocalDateTime ldt = LocalDateTime.of(2025, 3, 10, 13, 30); // 2025-03-10T13:30\n\nLocalDateTime l1 = ldt.plusDays(1);          // 2025-03-11T13:30\nLocalDateTime l2 = ldt.minusHours(3);        // 2025-03-10T10:30\nLocalDateTime l3 = ldt.plusMinutes(90);      // 2025-03-10T15:00\n\n// Using ChronoUnit\nLocalDateTime l4 = ldt.plus(2, ChronoUnit.WEEKS); // 2025-03-24T13:30\n\n// Using Period and Duration\nPeriod p = Period.ofDays(10);\nDuration d = Duration.ofHours(5);\n\nLocalDateTime l5 = ldt.plus(p);    // 2025-03-20T13:30\nLocalDateTime l6 = ldt.plus(d);    // 2025-03-10T18:30\n</code></pre> <p></p>"},{"location":"it/module-03/date-time/#1217-aritmetica-su-zoneddatetime","title":"12.1.7 Aritmetica su <code>ZonedDateTime</code>","text":"<p><code>ZonedDateTime</code> rappresenta data + ora + fuso orario + offset.</p> <p>Supporta gli stessi metodi <code>plus</code>/<code>minus</code> di <code>LocalDateTime</code>, ma con attenzione aggiuntiva ai fusi orari e all\u2019ora legale (DST).</p> <p>Principali metodi <code>plus</code> / <code>minus</code> (overload)</p> Metodo Descrizione <code>plusYears(long years)</code> / <code>minusYears(long years)</code> Regola gli anni <code>plusMonths(long months)</code> / <code>minusMonths(long months)</code> Regola i mesi <code>plusWeeks(long weeks)</code> / <code>minusWeeks(long weeks)</code> Regola le settimane <code>plusDays(long days)</code> / <code>minusDays(long days)</code> Regola i giorni <code>plusHours(long hours)</code> / <code>minusHours(long hours)</code> Regola le ore <code>plusMinutes(long minutes)</code> / <code>minusMinutes(long minutes)</code> Regola i minuti <code>plusSeconds(long seconds)</code> / <code>minusSeconds(long seconds)</code> Regola i secondi <code>plusNanos(long nanos)</code> / <code>minusNanos(long nanos)</code> Regola i nanosecondi <code>plus(TemporalAmount amount)</code> / <code>minus(TemporalAmount amount)</code> Period / Duration <code>plus(long amountToAdd, TemporalUnit unit)</code> / <code>minus(long amountToSubtract, TemporalUnit unit)</code> Usando ChronoUnit <ul> <li>Esempi (con fusi orari e DST):</li> </ul> <pre><code>ZonedDateTime zdt = ZonedDateTime.of(\n    2025, 3, 30, 1, 30, 0, 0,\n    ZoneId.of(\"Europe/Paris\")\n);\n\n// Add 2 hours across a possible DST change\nZonedDateTime z1 = zdt.plusHours(2);\nSystem.out.println(zdt);\nSystem.out.println(z1);\n</code></pre> <p>A seconda delle regole dell\u2019ora legale per quella data:</p> <ul> <li>L\u2019orario locale potrebbe saltare da 02:00 a 03:00 o simile.</li> <li><code>ZonedDateTime</code> regola l\u2019offset e l\u2019orario locale secondo le regole della zona, ma rappresenta comunque l\u2019istante corretto sulla timeline.</li> </ul> <p>Important</p> <p>Per <code>ZonedDateTime</code>, l\u2019aritmetica \u00e8 definita in termini di timeline locale e regole del fuso orario, il che pu\u00f2 causare spostamenti di ore durante le transizioni DST.</p> <p></p>"},{"location":"it/module-03/date-time/#1218-tabella-riassuntiva","title":"12.1.8 Tabella riassuntiva","text":"Classe Metodi shortcut plus/minus Metodi generici LocalDate plusDays, plusWeeks, plusMonths, plusYears (e minus) plus/minus(TemporalAmount), plus/minus(long, TemporalUnit) LocalTime plusNanos, plusSeconds, plusMinutes, plusHours (e minus) plus/minus(TemporalAmount), plus/minus(long, TemporalUnit) LocalDateTime Tutte le scorciatoie di LocalDate + LocalTime plus/minus(TemporalAmount), plus/minus(long, TemporalUnit) ZonedDateTime Come LocalDateTime, ma con consapevolezza della zona plus/minus(TemporalAmount), plus/minus(long, TemporalUnit)"},{"location":"it/module-03/date-time/#122-metodi-withxxx","title":"12.2 Metodi <code>withXxx(...)</code>","text":"<p>I metodi <code>with...</code> restituiscono una copia dell\u2019oggetto con un campo modificato. Non mutano mai l\u2019istanza originale.</p> Classe Metodi with... comuni (non esaustivo) Descrizione <code>LocalDate</code> withYear(int year) Stessa data, ma con un anno diverso LocalDate LocalDate.withMonth(int month) Stessa data, mese diverso (1\u201312) LocalDate LocalDate.withDayOfMonth(int dayOfMonth) Stessa data, giorno del mese diverso LocalDate LocalDate.with(TemporalField field, long newValue) Regolazione generica basata su campo LocalDate LocalDate.with(TemporalAdjuster adjuster) Usa un adjuster (es. firstDayOfMonth()) <code>LocalTime</code> withHour(int hour) Stessa ora, ora (hour) diversa LocalTime LocalTime.withMinute(int minute) Stessa ora, minuto diverso LocalTime LocalTime.withSecond(int second) Stessa ora, secondo diverso LocalTime LocalTime.withNano(int nanoOfSecond) Stessa ora, nanosecondo diverso LocalTime LocalTime.with(TemporalField field, long newValue) Regolazione generica basata su campo LocalTime LocalTime.with(TemporalAdjuster adjuster) Regola usando un temporal adjuster <code>LocalDateTime</code> withYear(int year), withMonth(int month), withDayOfMonth(int day) Cambia solo la parte data LocalDateTime withHour(int hour), withMinute(int minute), withSecond(int second) Cambia solo la parte ora LocalDateTime withNano(int nanoOfSecond) Cambia il nanosecondo LocalDateTime with(TemporalField field, long newValue) Regolazione generica basata su campo LocalDateTime with(TemporalAdjuster adjuster) Regola usando un temporal adjuster <code>ZonedDateTime</code> tutti i withXxx(...) di LocalDateTime Cambia i componenti locali di data/ora ZonedDateTime withZoneSameInstant(ZoneId zone) Stesso istante, zona diversa (cambia l\u2019ora locale) ZonedDateTime withZoneSameLocal(ZoneId zone) Stessa data/ora locale, zona diversa (cambia l\u2019istante) <p></p>"},{"location":"it/module-03/date-time/#123-conversione-e-metodi-at-collegare-data-ora-e-zona","title":"12.3 Conversione e metodi <code>at...</code> (collegare data, ora e zona)","text":"<p>Questi metodi sono usati per combinare o convertire tra <code>LocalDate</code>, <code>LocalTime</code>, <code>LocalDateTime</code> e <code>ZonedDateTime</code>.</p> Da Metodo Risultato Descrizione <code>LocalDate</code> atTime(LocalTime time) LocalDateTime Combina questa data con un\u2019ora data LocalDate atTime(int hour, int minute) LocalDateTime Overload di convenienza con componenti numerici dell\u2019ora LocalDate atTime(int hour, int minute, int second) LocalDateTime \u2014 LocalDate atTime(int hour, int minute, int second, int nano) LocalDateTime \u2014 LocalDate atStartOfDay() LocalDateTime Questa data all\u2019ora 00:00 LocalDate atStartOfDay(ZoneId zone) ZonedDateTime Questa data all\u2019inizio del giorno in una zona specifica <code>LocalTime</code> atDate(LocalDate date) LocalDateTime Combina questa ora con una data data <code>LocalDateTime</code> atZone(ZoneId zone) ZonedDateTime Aggiunge un fuso orario a una data/ora locale LocalDateTime toLocalDate() LocalDate Estrae il componente data LocalDateTime toLocalTime() LocalTime Estrae il componente ora <code>ZonedDateTime</code> toLocalDate() LocalDate Rimuove zona/offset, mantiene la data locale ZonedDateTime toLocalTime() LocalTime Rimuove zona/offset, mantiene l\u2019ora locale ZonedDateTime toLocalDateTime() LocalDateTime Rimuove zona/offset, mantiene la data/ora locale <p></p>"},{"location":"it/module-03/date-time/#124-period-duration-e-instant","title":"12.4 Period, Duration e Instant","text":"<p>Il package <code>java.time</code> fornisce tre classi temporali essenziali che rappresentano quantit\u00e0 di tempo o punti sulla timeline:</p> <ul> <li>Period \u2192 quantit\u00e0 di data \u201cumane\u201d (anni, mesi, giorni)</li> <li>Duration \u2192 quantit\u00e0 di tempo \u201cmacchina\u201d (secondi, nanosecondi)</li> <li>Instant \u2192 un punto sulla timeline UTC</li> </ul> <p></p>"},{"location":"it/module-03/date-time/#125-period-quantita-umane-di-data","title":"12.5 <code>Period</code> \u2014 quantit\u00e0 \u201cumane\u201d di data","text":"<p><code>Period</code> rappresenta una quantit\u00e0 di tempo basata su data, come \u201c3 anni, 2 mesi e 5 giorni\u201d. Si usa con <code>LocalDate</code> e <code>LocalDateTime</code> (perch\u00e9 contengono parti di data).</p> <p>Metodi di creazione</p> Metodo Descrizione Period.ofYears(int years) Solo anni Period.ofMonths(int months) Solo mesi Period.ofWeeks(int weeks) Converte settimane in giorni Period.ofDays(int days) Solo giorni Period.of(int years, int months, int days) Periodo completo Period.parse(CharSequence text) Formato ISO-8601: \"P1Y2M3D\", \"P7D\", \"P1W\", ... <p>Propriet\u00e0 chiave</p> <ul> <li>Non supporta ore, minuti, secondi, nanosecondi.</li> <li>Pu\u00f2 essere negativo.</li> <li> <p>Immutabile.</p> </li> <li> <p>Esempi</p> </li> </ul> <pre><code>Period p1 = Period.ofYears(1);             // P1Y\nPeriod p2 = Period.of(1, 2, 3);            // P1Y2M3D\nPeriod p3 = Period.ofWeeks(2);             // P14D (converted to days)\n\nLocalDate base = LocalDate.of(2025, 1, 10);\nLocalDate result = base.plus(p2);          // 2026-03-13\n</code></pre> <p>Note</p> <p>Period.parse(\"P1W\") is allowed and represents a period of 7 days (equivalent to \"P7D\").</p> <p>Tip</p> <p>Period is calendar-based: adding a period of months/years respects month lengths and leap years.</p> <p></p>"},{"location":"it/module-03/date-time/#126-duration-quantita-macchina-di-tempo","title":"12.6 <code>Duration</code> \u2014 quantit\u00e0 \u201cmacchina\u201d di tempo","text":"<p><code>Duration</code> rappresenta una quantit\u00e0 di tempo basata su secondi e nanosecondi. Si usa con <code>LocalTime</code>, <code>LocalDateTime</code>, <code>ZonedDateTime</code> e <code>Instant</code>.</p> <p>Metodi di creazione</p> Metodo Descrizione Duration.ofDays(long days) Converte i giorni in secondi Duration.ofHours(long hours) Converte le ore in secondi Duration.ofMinutes(long minutes) Converte i minuti in secondi Duration.ofSeconds(long seconds) Rappresentazione base in secondi Duration.ofSeconds(long seconds, long nanoAdjustment) Secondi pi\u00f9 nanos aggiuntivi Duration.ofMillis(long millis) Converte i millisecondi in nanos Duration.ofNanos(long nanos) Solo nanosecondi Duration.between(Temporal start, Temporal end) Calcola la durata tra due istanti Duration.parse(CharSequence text) ISO: \"PT20H\", \"PT15M\", \"PT10S\" <p>Caratteristiche chiave</p> <ul> <li>Supporta ore fino ai nanosecondi, ma non anni/mesi/settimane direttamente.</li> <li>Ideale per calcoli temporali a livello \u201cmacchina\u201d.</li> <li> <p>Immutabile.</p> </li> <li> <p>Esempi</p> </li> </ul> <pre><code>Duration d1 = Duration.ofHours(5);           // PT5H\nDuration d2 = Duration.ofMinutes(90);        // PT1H30M\n\nLocalTime t = LocalTime.of(10, 0);\nLocalTime t2 = t.plus(d2);                   // 11:30\n\nZonedDateTime z1 = ZonedDateTime.of(\n    2024, 3, 30, 1, 0, 0, 0,\n    ZoneId.of(\"Europe/Paris\")\n);\n\nZonedDateTime z2 = z1.plusHours(2);          // DST-aware\nZonedDateTime z3 = z1.plus(d2);              // Duration-based\n</code></pre> <p>Note</p> <p>Duration.ofDays(1) represents exactly 24 hours of machine time. In a zone with DST, 24 hours may not align with \u201cthe same local time tomorrow\u201d.</p> <p></p>"},{"location":"it/module-03/date-time/#127-instant-punto-sulla-timeline-utc","title":"12.7 <code>Instant</code> \u2014 punto sulla timeline UTC","text":"<p><code>Instant</code> rappresenta un singolo momento nel tempo relativo a UTC, con precisione al nanosecondo.</p> <p>Contiene:</p> <ul> <li>Secondi dall\u2019epoca (1970-01-01T00:00Z).</li> <li>Un\u2019aggiunta di nanosecondi.</li> </ul> <p>Metodi di creazione</p> Metodo Descrizione Instant.now() Momento corrente in UTC Instant.ofEpochSecond(long seconds) Da secondi dall\u2019epoca Instant.ofEpochSecond(long seconds, long nanos) Da secondi pi\u00f9 nanos Instant.ofEpochMilli(long millis) Da millisecondi dall\u2019epoca Instant.parse(CharSequence text) ISO: \"2024-01-01T10:15:30Z\" <p>Conversioni</p> Azione Metodo Instant \u2192 ora con zona instant.atZone(zoneId) ZonedDateTime \u2192 Instant zdt.toInstant() LocalDateTime \u2192 Instant Non consentito direttamente (serve una zona) <ul> <li>Esempio</li> </ul> <pre><code>Instant i = Instant.now();\n\nZonedDateTime z = i.atZone(ZoneId.of(\"Europe/Paris\"));\nInstant back = z.toInstant();  // same moment\n\n// Duration between instants\nInstant start = Instant.parse(\"2024-01-01T10:00:00Z\");\nInstant end   = Instant.parse(\"2024-01-01T12:30:00Z\");\n\nDuration between = Duration.between(start, end); // PT2H30M\n</code></pre> <p>Important</p> <p>Instant \u00e8 sempre UTC, senza informazioni di fuso orario associate. Non pu\u00f2 essere combinato con un Period; usa invece Duration.</p> <p></p>"},{"location":"it/module-03/date-time/#128-tabella-riassuntiva-period-vs-duration-vs-instant","title":"12.8 Tabella riassuntiva (Period vs Duration vs Instant)","text":"Concetto Rappresenta Utile per Funziona con Note Period Anni, mesi, giorni Aritmetica di calendario LocalDate, LocalDateTime Unit\u00e0 basate su \u201cumano\u201d Duration Ore fino ai nanosecondi Calcoli temporali precisi LocalTime, LocalDateTime, ZonedDateTime, Instant Basato su \u201cmacchina\u201d Instant Punto esatto sulla timeline UTC Rappresentazione timestamp Convertibile da/a ZonedDateTime Non combinabile con Period <p>Trappole comuni</p> <ul> <li><code>Period.of(1, 0, 0)</code> non \u00e8 la stessa cosa di <code>Duration.ofDays(365)</code> (anni bisestili!).</li> <li><code>Duration.ofDays(1)</code> potrebbe non essere uguale a un \u201cgiorno di calendario\u201d pieno in una zona con DST.</li> <li><code>LocalDateTime</code> non pu\u00f2 essere convertito in un <code>Instant</code> senza un fuso orario.</li> <li><code>Period.parse(\"P1W\")</code> \u00e8 valido e produce un periodo di 7 giorni.</li> </ul> <p></p>"},{"location":"it/module-03/date-time/#129-temporalunit-e-temporalamount","title":"12.9 TemporalUnit e TemporalAmount","text":"<p>L\u2019API <code>java.time</code> si basa su due interfacce chiave che definiscono come date, orari e durate vengono manipolati:</p> <ul> <li><code>TemporalUnit</code> \u2192 rappresenta un\u2019unit\u00e0 di tempo (ad esempio, DAYS, HOURS, MINUTES).</li> <li><code>TemporalAmount</code> \u2192 rappresenta una quantit\u00e0 di tempo (ad esempio, <code>Period</code>, <code>Duration</code>).</li> </ul> <p>Entrambe sono essenziali per capire come funzionano i metodi <code>plus</code>, <code>minus</code> e <code>with</code>.</p> <p></p>"},{"location":"it/module-03/date-time/#1291-temporalunit","title":"12.9.1 <code>TemporalUnit</code>","text":"<p><code>TemporalUnit</code> rappresenta una singola unit\u00e0 di misura di data/ora. L\u2019implementazione principale usata in Java \u00e8:</p> <p></p>"},{"location":"it/module-03/date-time/#1292-enum-chronounit","title":"12.9.2 enum <code>ChronoUnit</code>","text":"<p>Questo enum fornisce le unit\u00e0 standard usate nella cronologia ISO-8601:</p> Categoria Unit\u00e0 Unit\u00e0 di data DAYS, WEEKS, MONTHS, YEARS, DECADES, CENTURIES, MILLENNIA, ERAS Unit\u00e0 di tempo NANOS, MICROS, MILLIS, SECONDS, MINUTES, HOURS, HALF_DAYS Speciale FOREVER <p>Un <code>TemporalUnit</code> pu\u00f2 essere usato direttamente con i metodi <code>plus()</code> e <code>minus()</code>.</p> <ul> <li>Esempi usando <code>ChronoUnit</code>:</li> </ul> <pre><code>LocalDate date = LocalDate.of(2025, 3, 10);\n\nLocalDate d1 = date.plus(10, ChronoUnit.DAYS);     // 2025-03-20\nLocalDate d2 = date.minus(2, ChronoUnit.MONTHS);   // 2025-01-10\n\nLocalTime time = LocalTime.of(10, 0);\nLocalTime t1 = time.plus(90, ChronoUnit.MINUTES);  // 11:30\n</code></pre> <p>Important</p> <p>Non puoi usare unit\u00e0 basate sul tempo con LocalDate, n\u00e9 unit\u00e0 basate sulla data con LocalTime.</p> <ul> <li>Esempi:</li> </ul> <pre><code>// \u274c UnsupportedTemporalTypeException\nLocalDate d = LocalDate.now().plus(5, ChronoUnit.HOURS);\n\n// \u274c UnsupportedTemporalTypeException\nLocalTime t = LocalTime.now().plus(1, ChronoUnit.DAYS);\n</code></pre> <p></p>"},{"location":"it/module-03/date-time/#1293-temporalamount","title":"12.9.3 <code>TemporalAmount</code>","text":"<p><code>TemporalAmount</code> rappresenta una quantit\u00e0 di tempo multi-unit\u00e0 (per esempio, \u201c2 anni, 3 mesi\u201d, o \u201c90 minuti\u201d). \u00c8 implementato da:</p> <ul> <li><code>Period</code> \u2192 anni, mesi, giorni (basato su data)</li> <li><code>Duration</code> \u2192 secondi, nanosecondi (basato su tempo)</li> </ul> <p>Entrambi possono essere passati agli oggetti di data/ora per regolarli usando <code>plus()</code> e <code>minus()</code>.</p> <p></p>"},{"location":"it/module-03/date-time/#1294-period-come-temporalamount","title":"12.9.4 <code>Period</code> come <code>TemporalAmount</code>","text":"<p><code>Period</code> rappresenta una quantit\u00e0 \u201cumana\u201d: anni, mesi, giorni.</p> <ul> <li>Esempi:</li> </ul> <pre><code>Period p = Period.of(1, 2, 3);  // 1 year, 2 months, 3 days\n\nLocalDate base = LocalDate.of(2025, 3, 10);\nLocalDate result = base.plus(p); // 2026-05-13\n</code></pre> <p>Note</p> <ul> <li><code>Period</code> non pu\u00f2 essere usato con <code>LocalTime</code> (nessun componente data).</li> <li><code>Period.ofWeeks(n)</code> viene convertito internamente in giorni (n \u00d7 7).</li> </ul> <p></p>"},{"location":"it/module-03/date-time/#1295-duration-come-temporalamount","title":"12.9.5 <code>Duration</code> come <code>TemporalAmount</code>","text":"<p><code>Duration</code> rappresenta tempo \u201cmacchina\u201d: secondi + nanosecondi.</p> <ul> <li>Esempi:</li> </ul> <pre><code>Duration d = Duration.ofHours(5).plusMinutes(30); // PT5H30M\n\nLocalDateTime ldt = LocalDateTime.of(2025, 3, 10, 10, 0);\nLocalDateTime result = ldt.plus(d); // 2025-03-10T15:30\n</code></pre> <p>Note</p> <ul> <li><code>Duration</code> pu\u00f2 essere usata con classi che hanno componenti di ora (<code>LocalTime</code>, <code>LocalDateTime</code>, <code>ZonedDateTime</code>, <code>Instant</code>).</li> <li><code>Duration</code> non pu\u00f2 essere applicata a <code>LocalDate</code> \u2192 lancer\u00e0 <code>UnsupportedTemporalTypeException</code>.</li> <li><code>Duration</code> interagisce con zone e transizioni DST quando applicata a <code>ZonedDateTime</code>.</li> </ul> <p></p>"},{"location":"it/module-03/date-time/#1296-usare-temporalamount-vs-temporalunit","title":"12.9.6 Usare <code>TemporalAmount</code> vs <code>TemporalUnit</code>","text":"<p>Usare un <code>TemporalUnit</code>:</p> <pre><code>LocalDate d1 = LocalDate.now().plus(5, ChronoUnit.DAYS);\n</code></pre> <p>Usare un <code>TemporalAmount</code>:</p> <pre><code>Period p = Period.ofDays(5);\nLocalDate d2 = LocalDate.now().plus(p);\n</code></pre> <p>Entrambi producono lo stesso risultato quando supportati.</p> <p>Differenze</p> Aspetto TemporalUnit TemporalAmount Rappresenta Una singola unit\u00e0 (es., DAYS) Una quantit\u00e0 strutturata (es. 2Y, 5M, 3D) Esempi ChronoUnit.DAYS Period.of(2,5,3) Supporta pi\u00f9 campi No S\u00ec Utile per Incrementi semplici Incrementi complessi Comune con Tutte le classi data/ora Limitato dal tipo <p></p>"},{"location":"it/module-03/date-time/#1297-metodi-between","title":"12.9.7 Metodi <code>between(...)</code>","text":"<p>Molte classi forniscono un metodo <code>between</code> da <code>ChronoUnit</code>, <code>Duration</code> o <code>Period</code>.</p> <p>Usare <code>Duration.between</code> (per classi basate sul tempo)</p> <pre><code>Duration d = Duration.between(\n    LocalTime.of(10, 0),\n    LocalTime.of(13, 30)\n);\n// PT3H30M\n</code></pre> <p>Usare <code>Period.between</code> (solo per date)</p> <pre><code>Period p = Period.between(\n    LocalDate.of(2025, 3, 1),\n    LocalDate.of(2025, 5, 10)\n);\n// P2M9D\n</code></pre> <p>Usare <code>ChronoUnit</code> <code>between</code></p> <pre><code>long days = ChronoUnit.DAYS.between(\n    LocalDate.of(2025, 3, 1),\n    LocalDate.of(2025, 3, 10)\n);\n// 9\n</code></pre> <p>Important</p> <p>ChronoUnit.between(...) always returns a long, while Period.between returns a Period, and Duration.between returns a Duration.</p> <p></p>"},{"location":"it/module-03/date-time/#1298-problemi-comuni","title":"12.9.8 Problemi comuni","text":"<ul> <li>Applicare il <code>TemporalAmount</code> sbagliato:</li> </ul> <pre><code>// LocalTime.plus(Period.ofDays(1))   // \u274c compile-time error\n// LocalDate.plus(Duration.ofHours(1)) // \u274c runtime error: UnsupportedTemporalTypeException\n</code></pre> <ul> <li>Cambi DST con Duration: aggiungere 24 ore non \u00e8 sempre \u201cdomani\u201d in una zona con cambi DST.</li> <li><code>Period.ofWeeks(1)</code> \u00e8 esattamente 7 giorni; gli effetti DST compaiono quando applicato a tipi consapevoli della zona.</li> <li><code>Instant.plus(Period)</code> \u2192 runtime <code>UnsupportedTemporalTypeException</code>; usa <code>Duration</code> se possibile.</li> <li><code>Instant</code> non puo esser creata direttamente da <code>LocalDateTime</code>; devi applicare prima una time zone: <code>ldt.atZone(zone).toInstant()</code>.</li> </ul>"},{"location":"it/module-03/date-time/#1299-riepilogo","title":"12.9.9 Riepilogo","text":"Feature TemporalUnit TemporalAmount ChronoUnit Period Duration Represents A unit An amount enum of units Y/M/D S + nanos Multi-field No Yes No Yes No Works with plus/minus plus/minus date/time LocalDate/LocalDateTime Time/time-zone Human-based No Yes No Yes No Machine-based Yes Yes Yes No Yes"},{"location":"it/module-03/formatting/","title":"13. Formattazione e Localizzazione in Java","text":""},{"location":"it/module-03/formatting/#indice","title":"Indice","text":"<ul> <li>13.1 Formattazione delle Stringhe<ul> <li>13.1.1 String.format e formatted<ul> <li>13.1.1.1 Flag per numeri in virgola mobile</li> <li>13.1.1.2 Precisione n</li> <li>13.1.1.3 Larghezza m</li> <li>13.1.1.4 Flag di riempimento con zero 0</li> <li>13.1.1.5 Giustificazione a sinistra Flag -</li> <li>13.1.1.6 Segno esplicito Flag +</li> <li>13.1.1.7 Parentesi per i negativi Flag (</li> <li>13.1.1.8 Combinazione dei flag</li> <li>13.1.1.9 Effetti del Locale</li> <li>13.1.1.10 Errori comuni</li> </ul> </li> <li>13.1.2 Valori di testo personalizzati ed escaping</li> </ul> </li> <li>13.2 Formattazione dei Numeri<ul> <li>13.2.1 NumberFormat</li> <li>13.2.2 Localizzazione dei numeri</li> <li>13.2.3 DecimalFormat e NumberFormat</li> <li>13.2.4 Struttura del pattern DecimalFormat</li> <li>13.2.5 Il simbolo 0 (cifra obbligatoria)</li> <li>13.2.6 Il simbolo # (cifra opzionale)</li> <li>13.2.7 Combinare 0 e #</li> <li>13.2.8 Separatori decimali e di raggruppamento</li> <li>13.2.9 DecimalFormatSymbols: simboli di formattazione specifici del Locale</li> <li>13.2.10 Pattern speciali di DecimalFormat</li> <li>13.2.11 Regole ed errori comuni</li> </ul> </li> <li>13.3 Parsing dei Numeri<ul> <li>13.3.1 Parsing con DecimalFormat</li> <li>13.3.2 CompactNumberFormat</li> </ul> </li> <li>13.4 Formattazione di Data e Ora<ul> <li>13.4.1 DateTimeFormatter</li> <li>13.4.2 Simboli standard di data e ora</li> <li>13.4.3 datetime.format vs formatter.format</li> <li>13.4.4 Localizzazione delle date</li> </ul> </li> <li>13.5 Internazionalizzazione (i18n) e Localizzazione (l10n)<ul> <li>13.5.1 Locales</li> <li>13.5.2 Categorie di Locale</li> <li>13.5.3 Esempio reale</li> </ul> </li> <li>13.6 Properties e Resource Bundles<ul> <li>13.6.1 Regole di risoluzione dei Resource Bundle</li> </ul> </li> <li>13.7 Regole ed errori comuni</li> </ul> <p>Questo capitolo fornisce un trattamento approfondito e pratico della formattazione in Java 21.</p> <p></p>"},{"location":"it/module-03/formatting/#131-formattazione-delle-stringhe","title":"13.1 Formattazione delle Stringhe","text":""},{"location":"it/module-03/formatting/#1311-stringformat-e-formatted","title":"13.1.1 String.format e formatted","text":"<p><code>String.format()</code> crea stringhe formattate utilizzando segnaposto in stile printf.</p> <p>\u00c8 sensibile al locale e restituisce una nuova <code>String</code> immutabile.</p> <pre><code>String result = String.format(\"The User: %s | Score: %d\", \"Bob\", 42);\nSystem.out.println(result);\n\n// Or\n\nSystem.out.println(\"The User: %s | Score: %d\".formatted(\"Bob\", 42));\n</code></pre> <p>Output:</p> <pre><code>The User: Bob | Score: 42\n</code></pre> <p>Caratteristiche chiave:</p> <ul> <li>Utilizza specificatori di formato come <code>%s</code> (qualsiasi tipo, comunemente valori String), <code>%d</code> (valori interi), <code>%f</code> (valori in virgola mobile).</li> <li>Non modifica le stringhe esistenti.</li> <li>Lancia <code>IllegalFormatException</code> se gli argomenti non corrispondono al formato.</li> <li>\u00c8 sensibile al locale quando viene fornito un <code>Locale</code>.</li> </ul> <pre><code>String price = String.format(Locale.GERMANY, \"%.2f\", 1234.5);\n// Output (locale tedesco): 1234,50\n</code></pre> <p></p>"},{"location":"it/module-03/formatting/#13111-flag-per-numeri-in-virgola-mobile","title":"13.1.1.1 Flag per numeri in virgola mobile","text":"<p><code>%f</code> \u00e8 usato per formattare numeri in virgola mobile (<code>float</code>, <code>double</code>, <code>BigDecimal</code>) usando la notazione decimale.</p> <pre><code>System.out.printf(\"%f\", 12.345);\n</code></pre> <pre><code>12.345000\n</code></pre> <ul> <li>Stampa sempre 6 cifre dopo il punto decimale per impostazione predefinita.</li> <li>Utilizza l\u2019arrotondamento (non il troncamento).</li> <li>\u00c8 sensibile al locale per il separatore decimale.</li> </ul> <p></p>"},{"location":"it/module-03/formatting/#13112-precisione-n","title":"13.1.1.2 Precisione (.n)","text":"<p>La precisione definisce il numero di cifre stampate dopo il punto decimale.</p> <pre><code>System.out.printf(\"%.2f\", 12.345);\n</code></pre> <pre><code>12.35\n</code></pre> <ul> <li><code>%.0f</code> non stampa cifre decimali.</li> <li>Viene applicato l\u2019arrotondamento.</li> <li>La precisione \u00e8 applicata prima del riempimento della larghezza.</li> </ul> <p></p>"},{"location":"it/module-03/formatting/#13113-larghezza-m","title":"13.1.1.3 Larghezza (m)","text":"<p>La larghezza definisce il numero minimo totale di caratteri nell\u2019output.</p> <pre><code>System.out.printf(\"%8.2f\", 12.34);\n</code></pre> <pre><code>   12.34\n</code></pre> <ul> <li>Per impostazione predefinita riempie con spazi.</li> <li>Se il valore \u00e8 pi\u00f9 lungo, la larghezza viene ignorata (non viene mai troncato).</li> <li>Il riempimento \u00e8 applicato a sinistra per impostazione predefinita.</li> </ul> <p></p>"},{"location":"it/module-03/formatting/#13114-flag-di-riempimento-con-zero-0","title":"13.1.1.4 Flag di riempimento con zero <code>0</code>","text":"<p>Il flag <code>0</code> sostituisce il riempimento con spazi con zeri.</p> <pre><code>System.out.printf(\"%08.2f\", 12.34);\n</code></pre> <pre><code>00012.34\n</code></pre> <ul> <li>Richiede una larghezza.</li> <li>Gli zeri sono inseriti dopo il segno.</li> <li>Ignorato se \u00e8 presente la giustificazione a sinistra (flag <code>-</code>).</li> </ul> <p></p>"},{"location":"it/module-03/formatting/#13115-giustificazione-a-sinistra-flag-","title":"13.1.1.5 Giustificazione a sinistra Flag <code>-</code>","text":"<p>Il flag <code>-</code> allinea il valore a sinistra all\u2019interno della larghezza.</p> <pre><code>System.out.printf(\"%-8.2f\", 12.34);\n</code></pre> <pre><code>12.34   \n</code></pre> <ul> <li>Il riempimento viene spostato a destra.</li> <li>Sovrascrive il riempimento con zero.</li> </ul> <p></p>"},{"location":"it/module-03/formatting/#13116-segno-esplicito-flag","title":"13.1.1.6 Segno esplicito Flag <code>+</code>","text":"<p>Il flag <code>+</code> forza la visualizzazione del segno per i numeri positivi.</p> <pre><code>System.out.printf(\"%+8.2f\", 12.34);\n</code></pre> <pre><code>   +12.34\n</code></pre> <ul> <li>I numeri negativi mostrano gi\u00e0 <code>-</code>.</li> <li>Sovrascrive il flag spazio (che stampa uno spazio iniziale per i valori positivi).</li> </ul> <p></p>"},{"location":"it/module-03/formatting/#13117-parentesi-per-i-negativi-flag","title":"13.1.1.7 Parentesi per i negativi Flag <code>(</code>","text":"<p>Il flag <code>(</code> formatta i numeri negativi usando le parentesi.</p> <pre><code>System.out.printf(\"%(8.2f\", -12.34);\n</code></pre> <pre><code> (12.34)\n</code></pre> <ul> <li>Influenza solo i valori negativi.</li> <li>Raramente usato nella pratica.</li> </ul> <p></p>"},{"location":"it/module-03/formatting/#13118-combinazione-dei-flag","title":"13.1.1.8 Combinazione dei flag","text":"<pre><code>System.out.printf(\"%+010.2f\", 12.34);\n</code></pre> <pre><code>+000012.34\n</code></pre> <p>Ordine di valutazione (semplificato):</p> <ul> <li>Viene applicata la precisione.</li> <li>Viene gestito il segno.</li> <li>Viene applicata la larghezza.</li> <li>Viene applicato il riempimento (spazi o zeri).</li> </ul> <p></p>"},{"location":"it/module-03/formatting/#13119-effetti-del-locale","title":"13.1.1.9 Effetti del Locale","text":"<pre><code>System.out.printf(Locale.FRANCE, \"%,.2f\", 12345.67);\n</code></pre> <pre><code>12 345,67\n</code></pre> <p>I separatori decimali e di raggruppamento dipendono dal <code>Locale</code> attivo.</p> <p></p>"},{"location":"it/module-03/formatting/#131110-errori-comuni","title":"13.1.1.10 Errori comuni","text":"<ul> <li><code>%f</code> usa 6 cifre decimali per impostazione predefinita se non viene specificata la precisione.</li> <li>La larghezza non tronca mai l\u2019output, ma aggiunge solo riempimento se necessario.</li> <li>Il flag <code>0</code> \u00e8 ignorato quando \u00e8 presente <code>-</code>.</li> <li><code>+</code> sovrascrive il flag spazio.</li> <li>Raggruppamento e separatori dipendono dal Locale.</li> </ul>"},{"location":"it/module-03/formatting/#1312-valori-di-testo-personalizzati-ed-escaping","title":"13.1.2 Valori di testo personalizzati ed escaping","text":"<p>Alcuni caratteri hanno un significato speciale nelle stringhe di formato e devono essere sottoposti a escaping.</p> <ul> <li><code>%%</code> \u2192 segno percentuale letterale.</li> <li><code>\\n</code>, <code>\\t</code> \u2192 escape standard Java.</li> </ul> <pre><code>String msg = String.format(\"Completion: %d%%%nStatus: OK\", 100);\nSystem.out.println(msg);\n</code></pre> <p>Output:</p> <pre><code>Completion: 100%\nStatus: OK\n</code></pre> <p>Note</p> <p>Un singolo % senza uno specificatore valido causa una IllegalFormatException a runtime.</p> <p></p>"},{"location":"it/module-03/formatting/#132-formattazione-dei-numeri","title":"13.2 Formattazione dei Numeri","text":""},{"location":"it/module-03/formatting/#1321-numberformat","title":"13.2.1 NumberFormat","text":"<p><code>NumberFormat</code> \u00e8 una classe astratta utilizzata per formattare e fare il parsing dei numeri in modo sensibile al locale.</p> <pre><code>NumberFormat nf = NumberFormat.getInstance(Locale.FRANCE);\nSystem.out.println(nf.format(1234567.89));\n</code></pre> <p>Important</p> <ul> <li>I metodi factory determinano lo stile di formattazione (generale, intero, valuta, percentuale, compatto, ...).</li> <li>La formattazione dipende dal <code>Locale</code> fornito.</li> <li><code>NumberFormat</code> (e <code>DecimalFormat</code>) non sono thread-safe.</li> </ul> <p></p>"},{"location":"it/module-03/formatting/#1322-localizzazione-dei-numeri","title":"13.2.2 Localizzazione dei numeri","text":"<p>La localizzazione dei numeri influisce sui separatori decimali, sui separatori di raggruppamento e sui simboli di valuta.</p> <pre><code>NumberFormat nfUS = NumberFormat.getInstance(Locale.US);\nNumberFormat nfIT = NumberFormat.getInstance(Locale.ITALY);\n\nSystem.out.println(nfUS.format(1234.56)); // 1,234.56\nSystem.out.println(nfIT.format(1234.56)); // 1.234,56\n</code></pre> <p></p>"},{"location":"it/module-03/formatting/#1323-decimalformat-e-numberformat","title":"13.2.3 DecimalFormat e NumberFormat","text":"<p><code>DecimalFormat</code> \u00e8 una sottoclasse concreta di <code>NumberFormat</code> che fornisce un controllo fine sulla formattazione numerica tramite pattern.</p> <p><code>NumberFormat</code> definisce una formattazione sensibile al locale tramite metodi factory, mentre <code>DecimalFormat</code> consente un controllo esplicito basato su pattern.</p> <pre><code>NumberFormat nf = NumberFormat.getInstance(Locale.US);\nDecimalFormat df = (DecimalFormat) nf;\n</code></pre> <p>Oppure direttamente:</p> <pre><code>DecimalFormat df = new DecimalFormat(\"#,##0.00\");\n</code></pre> <p>Note</p> <ul> <li><code>DecimalFormat</code> \u00e8 mutabile (\u00e8 possibile cambiare pattern, simboli, ecc.).</li> <li><code>DecimalFormat</code> non \u00e8 thread-safe.</li> <li>La formattazione \u00e8 sensibile al locale tramite <code>DecimalFormatSymbols</code>.</li> </ul> <p></p>"},{"location":"it/module-03/formatting/#1324-struttura-del-pattern-decimalformat","title":"13.2.4 Struttura del pattern DecimalFormat","text":"<p>Un pattern pu\u00f2 contenere una sottostruttura positiva e una negativa opzionale, separate da <code>;</code>.</p> <pre><code>#,##0.00;(#,##0.00)\n</code></pre> <p>Note</p> <ul> <li>La prima parte \u2192 numeri positivi.</li> <li>La seconda parte \u2192 numeri negativi.</li> <li>Se la parte negativa \u00e8 omessa, i numeri negativi usano automaticamente un <code>-</code> iniziale.</li> </ul> <p></p>"},{"location":"it/module-03/formatting/#1325-il-simbolo-0-cifra-obbligatoria","title":"13.2.5 Il simbolo <code>0</code> (cifra obbligatoria)","text":"<p>Il simbolo <code>0</code> forza la visualizzazione di una cifra, riempiendo con zeri se necessario.</p> <pre><code>DecimalFormat df = new DecimalFormat(\"0000.00\");\nSystem.out.println(df.format(12.3));\n</code></pre> <pre><code>0012.30\n</code></pre> <ul> <li>Controlla il numero minimo di cifre.</li> <li>Riempie con zeri se il numero ha meno cifre.</li> <li>Utile per output a larghezza fissa o allineato.</li> </ul> <p></p>"},{"location":"it/module-03/formatting/#1326-il-simbolo-cifra-opzionale","title":"13.2.6 Il simbolo <code>#</code> (cifra opzionale)","text":"<p>Il simbolo <code>#</code> visualizza una cifra solo se esiste.</p> <pre><code>DecimalFormat df = new DecimalFormat(\"####.##\");\nSystem.out.println(df.format(12.3));\n</code></pre> <pre><code>12.3\n</code></pre> <ul> <li>Sopprime gli zeri iniziali.</li> <li>Sopprime gli zeri finali non necessari.</li> <li>Adatto a una formattazione \u201cuser-friendly\u201d.</li> </ul> <p></p>"},{"location":"it/module-03/formatting/#1327-combinare-0-e","title":"13.2.7 Combinare <code>0</code> e <code>#</code>","text":"<p>I pattern combinano spesso entrambi i simboli per maggiore flessibilit\u00e0.</p> <pre><code>DecimalFormat df = new DecimalFormat(\"#,##0.##\");\nSystem.out.println(df.format(12));\nSystem.out.println(df.format(12.5));\nSystem.out.println(df.format(12345.678));\n</code></pre> <pre><code>12\n12.5\n12,345.68\n</code></pre> <p>Spiegazione del pattern:</p> <pre><code>#,##0 . ##\n ^  ^    ^\n |  |    |\n |  |    \u2514\u2500 cifre frazionarie opzionali (#)\n |  \u2514\u2500\u2500\u2500\u2500\u2500 cifra intera obbligatoria (0)\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 pattern di raggruppamento (,)\n</code></pre> <ul> <li>\u00c8 garantita almeno una cifra intera (lo <code>0</code>).</li> <li>Le cifre sono raggruppate per migliaia usando il separatore di raggruppamento.</li> <li>Le cifre frazionarie sono opzionali (fino a due).</li> </ul> <p></p>"},{"location":"it/module-03/formatting/#1328-separatori-decimali-e-di-raggruppamento","title":"13.2.8 Separatori decimali e di raggruppamento","text":"<p>Nei pattern:</p> <ul> <li><code>.</code> \u2192 separatore decimale.</li> <li><code>,</code> \u2192 separatore di raggruppamento.</li> </ul> <p>I simboli effettivamente utilizzati a runtime dipendono dal <code>Locale</code> (ad esempio, virgola vs punto).</p> <p></p>"},{"location":"it/module-03/formatting/#1329-decimalformatsymbols-simboli-di-formattazione-specifici-del-locale","title":"13.2.9 DecimalFormatSymbols: simboli di formattazione specifici del Locale","text":"<pre><code>DecimalFormatSymbols symbols =\n        DecimalFormatSymbols.getInstance(Locale.FRANCE);\n\nDecimalFormat df =\n        new DecimalFormat(\"#,##0.00\", symbols);\n\nSystem.out.println(df.format(1234.5));\n</code></pre> <pre><code>1 234,50\n</code></pre> <ul> <li>Controlla i separatori decimali e di raggruppamento.</li> <li>Controlla il segno meno e il simbolo di valuta.</li> <li>Controlla le stringhe NaN e Infinity.</li> </ul>"},{"location":"it/module-03/formatting/#13210-pattern-speciali-di-decimalformat","title":"13.2.10 Pattern speciali di DecimalFormat","text":"<pre><code>0.###E0   notazione scientifica\n###%      percentuale\n\u00a4#,##0.00 valuta (\u00a4 \u00e8 il simbolo di valuta)\n</code></pre>"},{"location":"it/module-03/formatting/#13211-regole-ed-errori-comuni","title":"13.2.11 Regole ed errori comuni","text":"<ul> <li><code>DecimalFormat</code> \u00e8 una sottoclasse di <code>NumberFormat</code>.</li> <li><code>0</code> forza le cifre, <code>#</code> no.</li> <li>I pattern controllano la formattazione, non la modalit\u00e0 di arrotondamento (usare <code>setRoundingMode()</code>).</li> <li>Il raggruppamento funziona solo se il separatore (di solito <code>,</code>) \u00e8 presente nel pattern.</li> <li>Il parsing pu\u00f2 riuscire parzialmente senza errore se sono presenti caratteri finali dopo un numero valido.</li> <li><code>DecimalFormat</code> \u00e8 mutabile e non thread-safe.</li> </ul>"},{"location":"it/module-03/formatting/#133-parsing-dei-numeri","title":"13.3 Parsing dei Numeri","text":"<p>Il parsing converte testo localizzato in valori numerici. Per impostazione predefinita, il parsing \u00e8 permissivo.</p> <pre><code>NumberFormat nf = NumberFormat.getInstance(Locale.FRANCE);\nNumber n = nf.parse(\"12 345,67abc\"); // estrae 12345.67\n</code></pre> <ul> <li>Il parsing si ferma al primo carattere non valido.</li> <li>Il testo finale viene ignorato se non controllato esplicitamente.</li> </ul> <p></p>"},{"location":"it/module-03/formatting/#1331-parsing-con-decimalformat","title":"13.3.1 Parsing con DecimalFormat","text":"<p><code>DecimalFormat</code> pu\u00f2 anche effettuare il parsing dei numeri. Il parsing \u00e8 permissivo per impostazione predefinita.</p> <pre><code>DecimalFormat df = new DecimalFormat(\"#,##0.##\");\nNumber n = df.parse(\"1,234.56abc\");\n</code></pre> <ul> <li>Il parsing si ferma al primo carattere non valido.</li> <li>Il testo finale viene ignorato se presente.</li> </ul> <p>Per forzare un parsing rigoroso:</p> <pre><code>df.setParseStrict(true);\n</code></pre> <p></p>"},{"location":"it/module-03/formatting/#1332-compactnumberformat","title":"13.3.2 CompactNumberFormat","text":"<p>La formattazione compatta abbrevia i numeri grandi per la leggibilit\u00e0 umana.</p> <ul> <li>Supporta stili SHORT e LONG.</li> <li>Usa abbreviazioni dipendenti dal locale (ad esempio K, M, \u201cmillion\u201d).</li> </ul> <pre><code>NumberFormat cnf =\n        NumberFormat.getCompactNumberInstance(\n                Locale.US, NumberFormat.Style.SHORT);\n\nSystem.out.println(cnf.format(1_200));        // 1.2K\nSystem.out.println(cnf.format(5_000_000));    // 5M\n\nNumberFormat cnf1 =\n        NumberFormat.getCompactNumberInstance(\n                Locale.US, NumberFormat.Style.SHORT);\n\nNumberFormat cnf2 =\n        NumberFormat.getCompactNumberInstance(\n                Locale.US, NumberFormat.Style.LONG);\n\nSystem.out.println(cnf1.format(315_000_000));   // 315M\nSystem.out.println(cnf2.format(315_000_000));   // 315 million\n</code></pre> <p></p>"},{"location":"it/module-03/formatting/#134-formattazione-di-data-e-ora","title":"13.4 Formattazione di Data e Ora","text":""},{"location":"it/module-03/formatting/#1341-datetimeformatter","title":"13.4.1 DateTimeFormatter","text":"<p>Java 21 si basa su <code>java.time</code> e <code>DateTimeFormatter</code> per la formattazione moderna di data e ora.</p> <pre><code>DateTimeFormatter f =\n        DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\");\nSystem.out.println(LocalDateTime.now().format(f));\n</code></pre> <p>Propriet\u00e0 principali:</p> <ul> <li>Immutabile.</li> <li>Thread-safe.</li> <li>Sensibile al locale.</li> </ul> <p></p>"},{"location":"it/module-03/formatting/#1342-simboli-standard-di-data-e-ora","title":"13.4.2 Simboli standard di data e ora","text":"<pre><code>y   anno\nM   numero del mese (o nome con pi\u00f9 lettere)\nd   giorno del mese\nE   nome del giorno\nH   ora (0\u201323)\nh   ora (1\u201312)\nm   minuto\ns   secondo\na   indicatore AM/PM\nz   fuso orario\n</code></pre>"},{"location":"it/module-03/formatting/#1343-datetimeformat-vs-formatterformat","title":"13.4.3 datetime.format vs formatter.format","text":"<p>Entrambi i metodi sono funzionalmente identici:</p> <pre><code>date.format(formatter);\nformatter.format(date);\n</code></pre> <ul> <li><code>date.format(formatter)</code> \u2192 preferito per leggibilit\u00e0 (prima il dato, poi la formattazione).</li> <li><code>formatter.format(date)</code> \u2192 utile in codice funzionale o con formatter riutilizzabili.</li> </ul> <p></p>"},{"location":"it/module-03/formatting/#1344-localizzazione-delle-date","title":"13.4.4 Localizzazione delle date","text":"<p>Gli stili localizzati adattano l\u2019output delle date alle norme culturali.</p> <pre><code>DateTimeFormatter fullIt =\n        DateTimeFormatter\n                .ofLocalizedDate(FormatStyle.FULL)\n                .withLocale(Locale.ITALY);\n\nDateTimeFormatter shortIt =\n        DateTimeFormatter\n                .ofLocalizedDate(FormatStyle.SHORT)\n                .withLocale(Locale.ITALY);\n\nLocalDate today = LocalDate.of(2025, 12, 17);\n\nSystem.out.println(today.format(fullIt));\nSystem.out.println(today.format(shortIt));\n</code></pre> <p>Output possibile:</p> <pre><code>mercoled\u00ec 17 dicembre 2025\n17/12/25\n</code></pre> <p></p>"},{"location":"it/module-03/formatting/#135-internazionalizzazione-i18n-e-localizzazione-l10n","title":"13.5 Internazionalizzazione (i18n) e Localizzazione (l10n)","text":""},{"location":"it/module-03/formatting/#1351-locales","title":"13.5.1 Locales","text":"<p>Un <code>Locale</code> definisce lingua, paese e una variante opzionale.</p> <pre><code>Locale l1 = Locale.US;\nLocale l2 = Locale.of(\"fr\", \"FR\");\nLocale l3 = new Locale.Builder()\n        .setLanguage(\"en\")\n        .setRegion(\"US\")\n        .build();\n</code></pre> <p>Formati di Locale:</p> <ul> <li><code>en</code> (it, fr, ecc.): codice lingua minuscolo.</li> <li><code>en_US</code> (fr_CA, it_IT, ecc.): codice lingua minuscolo + underscore + codice paese maiuscolo.</li> </ul> <p></p>"},{"location":"it/module-03/formatting/#1352-categorie-di-locale","title":"13.5.2 Categorie di Locale","text":"<p>Le categorie di Locale separano la formattazione dalla lingua dell\u2019interfaccia utente.</p> <p><code>Locale.Category</code> consente a Java di usare Locale predefiniti diversi per scopi diversi.</p> <p>Esistono due categorie:</p> Category Usata per FORMAT Numeri, date, valuta, altra formattazione DISPLAY Testo leggibile (UI, nomi, messaggi) <p></p>"},{"location":"it/module-03/formatting/#1353-esempio-reale","title":"13.5.3 Esempio reale","text":"<p>Un utente francese che vive in Germania potrebbe volere:</p> <ul> <li>Numeri e date \u2192 formato tedesco.</li> <li>Lingua dell\u2019interfaccia \u2192 francese.</li> </ul> <p>Prima di Java 7, questo non era possibile.</p> <pre><code>Locale.setDefault(Locale.Category.FORMAT, Locale.GERMANY);\nLocale.setDefault(Locale.Category.DISPLAY, Locale.FRANCE);\n</code></pre> <p>Effetti di esempio:</p> Aspetto Risultato (esempio) Numeri 1.234,56 Date 31.12.2025 Valuta \u20ac Testo UI Francese Nomi dei mesi d\u00e9cembre Nomi dei paesi Allemagne <p></p>"},{"location":"it/module-03/formatting/#136-properties-e-resource-bundles","title":"13.6 Properties e Resource Bundles","text":"<p>I resource bundle esternalizzano il testo e consentono la localizzazione senza modifiche al codice.</p> <pre><code>ResourceBundle rb =\n        ResourceBundle.getBundle(\"messages\", Locale.GERMAN);\n\nString msg = rb.getString(\"welcome\");\n</code></pre> <p></p>"},{"location":"it/module-03/formatting/#1361-regole-di-risoluzione-dei-resource-bundle","title":"13.6.1 Regole di risoluzione dei Resource Bundle","text":"<p>Java cerca i bundle seguendo un ordine di fallback rigoroso. Ad esempio, con nome base <code>messages</code> e locale <code>de_DE</code>:</p> <ul> <li>messages_de_DE.properties</li> <li>messages_de.properties</li> <li>messages.properties</li> </ul> <p>Se nessuno viene trovato \u2192 <code>MissingResourceException</code>.</p> <p>Note</p> <p>I file <code>.properties</code> tradizionali sono specificati come ISO-8859-1; i caratteri non ASCII devono essere codificati come escape Unicode (ad esempio <code>\\u00E9</code> per \u00e9), a meno di usare meccanismi di caricamento alternativi.</p> <p></p>"},{"location":"it/module-03/formatting/#137-regole-ed-errori-comuni","title":"13.7 Regole ed errori comuni","text":"<ul> <li><code>DateTimeFormatter</code> \u00e8 immutabile e thread-safe.</li> <li><code>NumberFormat</code> / <code>DecimalFormat</code> sono mutabili e non thread-safe.</li> <li>Cambiare il <code>Locale</code> influisce su come i valori sono formattati e interpretati, non sui valori numerici o temporali sottostanti.</li> <li>Il parsing con <code>NumberFormat</code> o <code>DecimalFormat</code> pu\u00f2 riuscire parzialmente senza eccezioni se dopo un numero valido \u00e8 presente testo aggiuntivo.</li> <li><code>java.time</code> sostituisce la maggior parte degli usi delle vecchie API <code>java.util.Date</code> / <code>Calendar</code> nel codice moderno e nell\u2019esame.</li> </ul>"},{"location":"it/module-03/math/","title":"11. Matematica in Java","text":""},{"location":"it/module-03/math/#indice","title":"Indice","text":"<ul> <li>11.1 API Math<ul> <li>11.1.1 Massimo e minimo tra due valori</li> <li>11.1.2 Math.round</li> <li>11.1.3 Math.ceil (Ceiling)</li> <li>11.1.4 Math.floor (Floor)</li> <li>11.1.5 Math.pow</li> <li>11.1.6 Math.random</li> <li>11.1.7 Math.abs</li> <li>11.1.8 Math.sqrt</li> <li>11.1.9 Tabella riassuntiva</li> </ul> </li> <li>11.2 BigInteger e BigDecimal<ul> <li>11.2.1 Perch\u00e9 double e float non sono sufficienti</li> <li>11.2.2 BigInteger \u2014 Interi a precisione arbitraria</li> <li>11.2.3 Creare BigInteger</li> <li>11.2.4 Operazioni (niente operatori)</li> </ul> </li> </ul>"},{"location":"it/module-03/math/#111-api-math","title":"11.1 API Math","text":"<p>La classe <code>java.lang.Math</code> fornisce un insieme di metodi statici utili per operazioni numeriche.</p> <p>Questi metodi funzionano con i tipi numerici primitivi.</p> <p>Di seguito una sintesi di quelli usati pi\u00f9 frequentemente, insieme alle loro forme sovraccaricate.</p> <p></p>"},{"location":"it/module-03/math/#1111-massimo-e-minimo-tra-due-valori","title":"11.1.1 Massimo e minimo tra due valori","text":"<p><code>Math.max()</code> e <code>Math.min()</code> confrontano i due valori forniti e restituiscono il massimo o il minimo tra di essi.</p> <p>Esistono quattro versioni sovraccaricate per ciascun metodo:</p> <pre><code>public static int min(int x, int y);\npublic static float min(float x, float y);\npublic static long min(long x, long y);\npublic static double min(double x, double y);\n\npublic static int max(int x, int y);\npublic static float max(float x, float y);\npublic static long max(long x, long y);\npublic static double max(double x, double y);\n</code></pre> <ul> <li>Esempio:</li> </ul> <pre><code>System.out.println(Math.max(10.50, 7.5));   // 10.5\nSystem.out.println(Math.min(10, -20));      // -20\n</code></pre> <p></p>"},{"location":"it/module-03/math/#1112-mathround","title":"11.1.2 <code>Math.round()</code>","text":"<p><code>round()</code> restituisce l\u2019intero pi\u00f9 vicino al suo argomento, seguendo le regole standard di arrotondamento: i valori con parte frazionaria 0.5 e superiore vengono arrotondati verso l\u2019alto; sotto 0.5 vengono arrotondati verso il basso (verso l\u2019intero pi\u00f9 vicino).</p> <p>Overload - <code>long round(double value)</code> - <code>int round(float value)</code></p> <ul> <li>Esempi:</li> </ul> <pre><code>Math.round(3.2);    // 3   (returns long)\nMath.round(3.6);    // 4\nMath.round(-3.5f);  // -3  (float version returns int)\n</code></pre> <p>Note</p> <ul> <li>La versione <code>float</code> restituisce un <code>int</code>.</li> <li>La versione <code>double</code> restituisce un <code>long</code>.</li> </ul> <p></p>"},{"location":"it/module-03/math/#1113-mathceil-ceiling","title":"11.1.3 <code>Math.ceil()</code> (Ceiling)","text":"<p><code>ceil()</code> restituisce il pi\u00f9 piccolo valore <code>double</code> che \u00e8 maggiore o uguale all\u2019argomento.</p> <p>Overload - <code>double ceil(double value)</code></p> <ul> <li>Esempi:</li> </ul> <pre><code>Math.ceil(3.1);   // 4.0\nMath.ceil(-3.1);  // -3.0\n</code></pre> <p></p>"},{"location":"it/module-03/math/#1114-mathfloor-floor","title":"11.1.4 <code>Math.floor()</code> (Floor)","text":"<p><code>floor()</code> restituisce il pi\u00f9 grande valore <code>double</code> che \u00e8 minore o uguale all\u2019argomento.</p> <p>Overload - <code>double floor(double value)</code></p> <ul> <li>Esempi:</li> </ul> <pre><code>Math.floor(3.9);   // 3.0\nMath.floor(-3.1);  // -4.0\n</code></pre> <p></p>"},{"location":"it/module-03/math/#1115-mathpow","title":"11.1.5 <code>Math.pow()</code>","text":"<p><code>pow()</code> eleva un valore a una potenza.</p> <p>Overload - <code>double pow(double base, double exponent)</code></p> <ul> <li>Esempi:</li> </ul> <pre><code>Math.pow(2, 3);      // 8.0\nMath.pow(9, 0.5);    // 3.0  (radice quadrata)\nMath.pow(10, -1);    // 0.1\n</code></pre> <p></p>"},{"location":"it/module-03/math/#1116-mathrandom","title":"11.1.6 <code>Math.random()</code>","text":"<p><code>random()</code> restituisce un <code>double</code> randomico nell\u2019intervallo <code>[0.0, 1.0)</code> (0.0 incluso, 1.0 escluso).</p> <p>Overload - <code>double random()</code></p> <ul> <li>Esempi:</li> </ul> <pre><code>double r = Math.random();   // 0.0 &lt;= r &lt; 1.0\n\n// Example: random int 0\u20139\nint x = (int)(Math.random() * 10);\n</code></pre> <p></p>"},{"location":"it/module-03/math/#1117-mathabs","title":"11.1.7 <code>Math.abs()</code>","text":"<p><code>abs()</code> restituisce il valore assoluto (distanza da zero).</p> <p>Overload - <code>int abs(int value)</code> - <code>long abs(long value)</code> - <code>float abs(float value)</code> - <code>double abs(double value)</code></p> <p></p>"},{"location":"it/module-03/math/#1118-mathsqrt","title":"11.1.8 <code>Math.sqrt()</code>","text":"<p><code>sqrt()</code> calcola la radice quadrata e restituisce un <code>double</code>.</p> <pre><code>Math.sqrt(9);    // 3.0\nMath.sqrt(-1);   // NaN (not a number)\n</code></pre> <p></p>"},{"location":"it/module-03/math/#1119-tabella-riassuntiva","title":"11.1.9 Tabella riassuntiva","text":"Metodo Restituisce Overload Note <code>round()</code> int o long float, double Intero pi\u00f9 vicino <code>ceil()</code> double double Valore pi\u00f9 piccolo &gt;= argomento <code>floor()</code> double double Valore pi\u00f9 grande &lt;= argomento <code>pow()</code> double double, double Esponenziazione <code>random()</code> double none 0.0 &lt;= r &lt; 1.0 <code>min()/max()</code> stesso tipo int, long, float, double Confronta due valori <code>abs()</code> stesso tipo int, long, float, double Valore assoluto <code>sqrt()</code> double double Radice quadrata"},{"location":"it/module-03/math/#112-biginteger-e-bigdecimal","title":"11.2 BigInteger e BigDecimal","text":"<p>Le classi <code>BigInteger</code> e <code>BigDecimal</code> (in <code>java.math</code>) forniscono tipi numerici a precisione arbitraria.</p> <p>Si usano quando:</p> <ul> <li>I tipi primitivi (<code>int</code>, <code>long</code>, <code>double</code>, ecc.) non hanno abbastanza range.</li> <li>Gli errori di arrotondamento in virgola mobile di <code>float</code>/<code>double</code> non sono accettabili (ad esempio, nei calcoli finanziari).</li> </ul> <p>Entrambi sono immutabili: ogni operazione restituisce una nuova istanza.</p> <p></p>"},{"location":"it/module-03/math/#1121-perche-double-e-float-non-sono-sufficienti","title":"11.2.1 Perch\u00e9 <code>double</code> e <code>float</code> non sono sufficienti","text":"<p>I tipi in virgola mobile (<code>float</code>, <code>double</code>) usano una rappresentazione binaria. Molte frazioni decimali non possono essere rappresentate esattamente (come 0.1 o 0.2), quindi si ottengono errori di arrotondamento:</p> <pre><code>System.out.println(0.1 + 0.2); // 0.30000000000000004 \n</code></pre> <p>Per attivit\u00e0 come i calcoli finanziari, questo \u00e8 inaccettabile.</p> <p><code>BigDecimal</code> risolve il problema rappresentando i numeri usando un modello decimale con una scala configurabile (numero di cifre dopo il separatore decimale).</p> <p></p>"},{"location":"it/module-03/math/#1122-biginteger-interi-a-precisione-arbitraria","title":"11.2.2 BigInteger \u2014 Interi a precisione arbitraria","text":"<p><code>BigInteger</code> rappresenta valori interi di dimensione praticamente qualsiasi, limitata solo dalla memoria disponibile.</p> <p></p>"},{"location":"it/module-03/math/#1123-creare-biginteger","title":"11.2.3 Creare BigInteger","text":"<p>Modi comuni:</p> <p>Da un long</p> <pre><code>static BigInteger valueOf(long val);\n</code></pre> <p>Da una String</p> <pre><code>BigInteger(String val);        // decimal by default\nBigInteger(String val, int radix);\n</code></pre> <p>Valore randomico</p> <pre><code>BigInteger(int numBits, Random rnd);\n</code></pre> <ul> <li>Esempi:</li> </ul> <pre><code>import java.math.BigInteger;\nimport java.math.BigDecimal;\nimport java.util.Random;\n\nBigInteger a = BigInteger.valueOf(10L);\n\n// Si puo passare un long a entrambi, ma un double solo a BigDecimal\n\nBigInteger g = BigInteger.valueOf(3000L);\nBigDecimal p = BigDecimal.valueOf(3000L);\nBigDecimal q = BigDecimal.valueOf(3000.00);\n\nBigInteger b = new BigInteger(\"12345678901234567890\"); // decimal string\nBigInteger c = new BigInteger(\"FF\", 16);               // 255 in base 16\nBigInteger r = new BigInteger(128, new Random());      // random 128-bit number\n</code></pre> <p></p>"},{"location":"it/module-03/math/#1124-operazioni-niente-operatori","title":"11.2.4 Operazioni (niente operatori!)","text":"<p>Non puoi usare gli operatori aritmetici standard (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>) con <code>BigInteger</code> o <code>BigDecimal</code>.</p> <p>Devi invece chiamare metodi (tutti i quali restituiscono nuove istanze). Ecco alcuni di quelli comuni per <code>BigInteger</code>:</p> <ul> <li><code>add(BigInteger val)</code></li> <li><code>subtract(BigInteger val)</code></li> <li><code>multiply(BigInteger val)</code></li> <li><code>divide(BigInteger val)</code> \u2013 divisione intera</li> <li><code>remainder(BigInteger val)</code></li> <li><code>pow(int exponent)</code></li> <li><code>negate()</code></li> <li><code>abs()</code></li> <li><code>gcd(BigInteger val)</code></li> <li> <p><code>compareTo(BigInteger val)</code> \u2013 ordinamento</p> </li> <li> <p>Esempio:</p> </li> </ul> <pre><code>BigInteger x = new BigInteger(\"100000000000000000000\");\nBigInteger y = new BigInteger(\"3\");\n\nBigInteger sum = x.add(y);        // x + y\nBigInteger prod = x.multiply(y);  // x * y\nBigInteger div = x.divide(y);     // integer division\nBigInteger rem = x.remainder(y);  // modulus\n\nif (x.compareTo(y) &gt; 0) {\n    System.out.println(\"x is larger\");\n}\n</code></pre>"},{"location":"it/module-03/strings/","title":"9. Stringhe in Java","text":""},{"location":"it/module-03/strings/#indice","title":"Indice","text":"<ul> <li>9.1 Stringhe &amp; Text Blocks<ul> <li>9.1.1 Stringhe<ul> <li>9.1.1.1 Inizializzare le stringhe</li> <li>9.1.1.2 Lo String Pool</li> <li>9.1.1.3 Caratteri speciali e sequenze di escape</li> <li>9.1.1.4 Regole per la concatenazione di stringhe</li> <li>9.1.1.5 Regole di concatenazione</li> </ul> </li> <li>9.1.2 Text Blocks (da Java 15)<ul> <li>9.1.2.1 Formattazione: whitespace essenziale vs incidentale</li> <li>9.1.2.2 Conteggio righe, righe vuote e line break</li> <li>9.1.2.3 Text Blocks e caratteri di escape</li> <li>9.1.2.4 Errori comuni con correzioni</li> </ul> </li> </ul> </li> <li>9.2 Metodi principali delle stringhe<ul> <li>9.2.1 Indicizzazione delle stringhe</li> <li>9.2.2 Metodo length</li> <li>9.2.3 Regole dei limiti: indice iniziale vs indice finale</li> <li>9.2.4 Metodi che usano solo l\u2019indice iniziale (inclusivo)</li> <li>9.2.5 Metodi con inizio inclusivo / fine esclusivo</li> <li>9.2.6 Metodi che operano sull\u2019intera stringa</li> <li>9.2.7 Accesso ai caratteri</li> <li>9.2.8 Ricerca</li> <li>9.2.9 Metodi di sostituzione</li> <li>9.2.10 Suddivisione e unione</li> <li>9.2.11 Metodi che restituiscono array</li> <li>9.2.12 Indentazione</li> <li>9.2.13 Esempi aggiuntivi</li> </ul> </li> </ul>"},{"location":"it/module-03/strings/#91-stringhe-text-blocks","title":"9.1 Stringhe &amp; Text Blocks","text":""},{"location":"it/module-03/strings/#911-stringhe","title":"9.1.1 Stringhe","text":""},{"location":"it/module-03/strings/#9111-inizializzare-le-stringhe","title":"9.1.1.1 Inizializzare le stringhe","text":"<p>In Java, una String \u00e8 un oggetto della classe <code>java.lang.String</code>, usato per rappresentare una sequenza di caratteri.</p> <p>Le stringhe sono immutabili: una volta create, il loro contenuto non pu\u00f2 essere cambiato. Qualsiasi operazione che sembra modificare una stringa in realt\u00e0 ne crea una nuova.</p> <p>Puoi creare e inizializzare le stringhe in diversi modi:</p> <pre><code>String s1 = \"Hello\";                    // string literal\nString s2 = new String(\"Hello\");        // using constructor (not recommended)\nString s3 = s1.toUpperCase();           // creates a new String (\"HELLO\")\n</code></pre> <p>Note</p> <ul> <li>I letterali stringa sono memorizzati nello <code>String pool</code>, un\u2019area speciale di memoria usata per evitare di creare oggetti stringa duplicati.</li> <li>L\u2019uso della keyword <code>new</code> crea sempre un nuovo oggetto al di fuori del pool.</li> </ul> <p></p>"},{"location":"it/module-03/strings/#9112-lo-string-pool","title":"9.1.1.2 Lo String Pool","text":"<p>Poich\u00e9 gli oggetti <code>String</code> sono immutabili e ampiamente usati, potrebbero facilmente occupare una grande quantit\u00e0 di memoria in un programma Java.</p> <p>Per ridurre la duplicazione, Java riutilizza tutte le stringhe dichiarate come letterali (vedi l\u2019esempio sopra), memorizzandole in un\u2019area dedicata della JVM nota come String Pool o Intern Pool.</p> <p>Per una spiegazione pi\u00f9 approfondita e esempi, controlla il paragrafo: \"6.4.3 String Pool and Equality\" nel capitolo: Istanziazione dei tipi.</p> <p></p>"},{"location":"it/module-03/strings/#9113-caratteri-speciali-e-sequenze-di-escape","title":"9.1.1.3 Caratteri speciali e sequenze di escape","text":"<p>Le stringhe possono contenere caratteri di escape, che permettono di includere simboli speciali o caratteri di controllo (caratteri con un significato speciale in Java). Una sequenza di escape inizia con un backslash <code>\\</code>.</p> <p>Note</p> <p>Tabella dei caratteri speciali &amp; sequenze di escape nelle stringhe</p> Escape Significato Esempio Java Risultato <code>\\\"</code> doppia virgoletta <code>\"She said \\\"Hi\\\"\"</code> <code>She said \"Hi\"</code> <code>\\\\</code> backslash <code>\"C:\\\\Users\\\\Alex\"</code> <code>C:\\Users\\Alex</code> <code>\\n</code> a capo (LF) <code>\"Hello\\nWorld\"</code> <code>Hello</code> + line break + <code>World</code> <code>\\r</code> ritorno carrello (CR) <code>\"A\\rB\"</code> <code>CR before B</code> <code>\\t</code> tab <code>\"Name\\tAge\"</code> <code>Name    Age</code> <code>\\'</code> virgoletta singola <code>\"It\\'s ok\"</code> <code>It's ok</code> <code>\\b</code> backspace <code>\"AB\\bC\"</code> <code>AC</code> (il <code>B</code> viene rimosso visivamente) <code>\\uXXXX</code> unit\u00e0 di codice Unicode <code>\"\\u00A9\"</code> <code>\u00a9</code> <p></p>"},{"location":"it/module-03/strings/#9114-regole-per-la-concatenazione-di-stringhe","title":"9.1.1.4 Regole per la concatenazione di stringhe","text":"<p>Come introdotto nel capitolo su Operatori Java, il simbolo <code>+</code> normalmente rappresenta l\u2019addizione aritmetica quando viene usato con operandi numerici.</p> <p>Tuttavia, quando applicato alle String, lo stesso operatore esegue la concatenazione di stringhe \u2014 crea una nuova stringa unendo gli operandi tra loro.</p> <p>Poich\u00e9 l\u2019operatore <code>+</code> pu\u00f2 apparire in espressioni in cui sono presenti sia numeri sia stringhe, Java applica un insieme specifico di regole per determinare se <code>+</code> significa addizione numerica o concatenazione di stringhe.</p> <p></p>"},{"location":"it/module-03/strings/#9115-regole-di-concatenazione","title":"9.1.1.5 Regole di concatenazione","text":"<ul> <li>Se entrambi gli operandi sono numerici, <code>+</code> esegue l\u2019addizione numerica.</li> <li>Se almeno un operando \u00e8 una <code>String</code>, l\u2019operatore <code>+</code> esegue la concatenazione di stringhe.</li> <li>La valutazione \u00e8 strettamente da sinistra a destra, perch\u00e9 <code>+</code> \u00e8 associativo a sinistra.  </li> </ul> <p>Questo significa che, una volta che una <code>String</code> appare sul lato sinistro dell\u2019espressione, tutte le successive operazioni <code>+</code> diventano concatenazioni.</p> <p>Tip</p> <p>Poich\u00e9 la valutazione \u00e8 da sinistra a destra, la posizione del primo operando <code>String</code> determina come viene valutato il resto dell\u2019espressione.</p> <ul> <li>Esempi</li> </ul> <pre><code>// *** Pure numeric addition\n\nint a = 10 + 20;        // 30\ndouble b = 1.5 + 2.3;   // 3.8\n\n\n\n// *** String concatenation when at least one operand is a String\n\nString s = \"Hello\" + \" World\";  // \"Hello World\"\nString t = \"Value: \" + 10;      // \"Value: 10\"\n\n\n\n// *** Left-to-right evaluation affects the result\n\nSystem.out.println(1 + 2 + \" apples\"); \n// 3 + \" apples\"  \u2192 \"3 apples\"\n\nSystem.out.println(\"apples: \" + 1 + 2); \n// \"apples: 1\" + 2 \u2192 \"apples: 12\"\n\n\n\n// *** Adding parentheses changes the meaning\n\nSystem.out.println(\"apples: \" + (1 + 2)); \n// parentheses force numeric addition \u2192 \"apples: 3\"\n\n\n\n// *** Mixed types with multiple operands\n\nString result = 10 + 20 + \"\" + 30 + 40;\n// (10 + 20) = 30\n// 30 + \"\"  = \"30\"\n// \"30\" + 30 = \"3030\"\nString out = \"3030\" + 40; // \"303040\"\n\nSystem.out.println(1 + 2 + \"3\" + 4 + 5);\n// Step 1: 1 + 2 = 3\n// Step 2: 3 + \"3\" = \"33\"\nString r = \"33\" + 4;  // \"334\"\n// Step 4: \"334\" + 5 = \"3345\"\n\n\n\n// *** null is represented as a string when concatenated\n\nSystem.out.println(\"AB\" + null);\n// ABnull\n</code></pre> <p></p>"},{"location":"it/module-03/strings/#912-text-blocks-da-java-15","title":"9.1.2 Text Blocks (da Java 15)","text":"<p>Un text block \u00e8 un letterale stringa multi-linea introdotto per semplificare la scrittura di stringhe grandi (come HTML, JSON o codice) senza la necessit\u00e0 di molte sequenze di escape.</p> <p>Un text block inizia e termina con tre doppi apici (<code>\"\"\"</code>).</p> <p>Puoi usare i text block ovunque useresti le stringhe.</p> <pre><code>String html = \"\"\"\n    &lt;html&gt;\n        &lt;body&gt;\n            &lt;p&gt;Hello, world!&lt;/p&gt;\n        &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\";\n</code></pre> <p>Note</p> <ul> <li>I text block includono automaticamente line break e indentazione per la leggibilit\u00e0. I newline sono normalizzati a <code>\\n</code>.</li> <li>Le doppie virgolette all\u2019interno del blocco di solito non richiedono escape.</li> <li>Il compilatore interpreta il contenuto tra le triple virgolette di apertura e chiusura come il valore della stringa.</li> </ul> <p></p>"},{"location":"it/module-03/strings/#9121-formattazione-whitespace-essenziale-vs-incidentale","title":"9.1.2.1 Formattazione: whitespace essenziale vs incidentale","text":"<ul> <li>Whitespace essenziale: spazi e newline che fanno parte del contenuto della stringa.</li> <li>Whitespace incidentale: indentazione nel codice sorgente che non consideri concettualmente parte del testo.</li> </ul> <pre><code>String text = \"\"\"\n        Line 1\n        Line 2\n        Line 3\n        \"\"\";\n</code></pre> <p>Important</p> <ul> <li>Carattere pi\u00f9 a sinistra (baseline): la posizione del primo carattere non-spazio su tutte le righe (o la <code>\"\"\"</code> di chiusura) definisce la baseline di indentazione. Gli spazi a sinistra di questa baseline sono considerati incidentali e vengono rimossi.</li> <li>La riga immediatamente successiva alla <code>\"\"\"</code> di apertura non \u00e8 inclusa nell\u2019output se \u00e8 vuota (formattazione tipica).</li> <li>Il newline prima della <code>\"\"\"</code> di chiusura \u00e8 incluso nel contenuto.   Nell\u2019esempio sopra, la stringa risultante termina con un newline dopo <code>\"Line 3\"</code>: in totale ci sono 4 righe.</li> </ul> <p>Output con numeri di riga (mostrando la riga vuota finale):</p> <pre><code>1: Line 1\n2: Line 2\n3: Line 3\n4:\n</code></pre> <p>Per sopprimere il newline finale:</p> <ul> <li>Usa un backslash di continuazione riga alla fine dell\u2019ultima riga di contenuto.</li> <li>Metti le triple virgolette di chiusura sulla stessa riga dell\u2019ultimo contenuto.</li> </ul> <pre><code>String textNoTrail_1 = \"\"\"\n        Line 1\n        Line 2\n        Line 3\\\n        \"\"\";\n\n// OR\n\nString textNoTrail_2 = \"\"\"\n        Line 1\n        Line 2\n        Line 3\"\"\";\n</code></pre> <p></p>"},{"location":"it/module-03/strings/#9122-conteggio-righe-righe-vuote-e-line-break","title":"9.1.2.2 Conteggio righe, righe vuote e line break","text":"<ul> <li>Ogni line break visibile dentro il blocco diventa <code>\\n</code>.</li> <li>Le righe vuote dentro il blocco vengono preservate.</li> </ul> <pre><code>String textNoTrail_0 = \"\"\"\n        Line 1  \n        Line 2 \\n\n        Line 3 \n\n        Line 4 \n        \"\"\";\n</code></pre> <p>Output:</p> <pre><code>1: Line 1\n2: Line 2\n3:\n4: Line 3\n5:\n6: Line 4\n7:\n</code></pre> <p></p>"},{"location":"it/module-03/strings/#9123-text-blocks-e-caratteri-di-escape","title":"9.1.2.3 Text Blocks e caratteri di escape","text":"<p>Le sequenze di escape funzionano ancora dentro i text block quando necessario (per esempio, per backslash o caratteri di controllo espliciti).</p> <pre><code>String json = \"\"\"\n    {\n      \"name\": \"Alice\",\n      \"path\": \"C:\\\\\\\\Users\\\\\\\\Alice\"\n    }\\\n    \"\"\";\n</code></pre> <p>Puoi anche formattare un text block usando placeholder e <code>formatted()</code>:</p> <pre><code>String card = \"\"\"\n    Name: %s\n    Age:  %d\n    \"\"\".formatted(\"Alice\", 30);\n</code></pre> <p></p>"},{"location":"it/module-03/strings/#9124-errori-comuni-con-correzioni","title":"9.1.2.4 Errori comuni (con correzioni)","text":"<pre><code>// \u274c Mismatched delimiters / missing closing triple quote\nString bad = \"\"\"\n  Hello\nWorld\";      // ERROR \u2014 not a closing text block\n\n// \u2705 Fix\nString ok = \"\"\"\n  Hello\n  World\n  \"\"\";\n</code></pre> <pre><code>// \u274c Text blocks require a line break after the opening \"\"\"\nString invalid = \"\"\"Hello\"\"\";  // ERROR\n\n// \u2705 Fix\nString valid = \"\"\"\n    Hello\n    \"\"\";\n</code></pre> <pre><code>// \u274c Unescaped trailing backslash at end of a line inside the block\nString wrong = \"\"\"\n    C:\\Users\\Alex\\     // ERROR \u2014 backslash escapes the newline\n    Documents\n    \"\"\";\n\n// \u2705 Fix: escape backslashes, or avoid backslash at end of line\nString correct = \"\"\"\n    C:\\\\Users\\\\Alex\\\\\n    Documents\\\n    \"\"\";\n</code></pre>"},{"location":"it/module-03/strings/#92-metodi-principali-delle-stringhe","title":"9.2 Metodi principali delle stringhe","text":""},{"location":"it/module-03/strings/#921-indicizzazione-delle-stringhe","title":"9.2.1 Indicizzazione delle stringhe","text":"<p>Le stringhe in Java usano l\u2019indicizzazione a base zero, il che significa:</p> <ul> <li>Il primo carattere \u00e8 all\u2019indice <code>0</code></li> <li>L\u2019ultimo carattere \u00e8 all\u2019indice <code>length() - 1</code></li> <li> <p>Accedere a qualsiasi indice fuori da questo intervallo causa una <code>StringIndexOutOfBoundsException</code></p> </li> <li> <p>Esempio:</p> </li> </ul> <pre><code>String s = \"Java\";\n// Indexes:  0    1    2    3\n// Chars:    J    a    v    a\n\nchar c = s.charAt(2); // 'v'\n</code></pre> <p></p>"},{"location":"it/module-03/strings/#922-metodo-length","title":"9.2.2 Metodo <code>length()</code>","text":"<p><code>length()</code> restituisce il numero di caratteri nella stringa.</p> <pre><code>String s = \"hello\";\nSystem.out.println(s.length());  // 5\n</code></pre> <p>L\u2019ultimo indice valido \u00e8 sempre <code>length() - 1</code>.</p> <p></p>"},{"location":"it/module-03/strings/#923-regole-dei-limiti-indice-iniziale-vs-indice-finale","title":"9.2.3 Regole dei limiti: indice iniziale vs indice finale","text":"<p>Molti metodi di <code>String</code> usano due indici:</p> <ul> <li>Indice iniziale \u2014 inclusivo</li> <li>Indice finale \u2014 esclusivo</li> </ul> <p>In altre parole, <code>substring(start, end)</code> include i caratteri dall\u2019indice <code>start</code> fino a (ma non includendo) l\u2019indice <code>end</code>.</p> <ul> <li>L\u2019indice iniziale deve essere <code>&gt;= 0</code> e <code>&lt;= length() - 1</code></li> <li>L\u2019indice finale pu\u00f2 essere uguale a <code>length()</code> (la \u201cposizione virtuale\u201d dopo l\u2019ultimo carattere).</li> <li>L\u2019indice finale non deve superare <code>length()</code>.</li> <li> <p>L\u2019indice iniziale non deve mai essere maggiore dell\u2019indice finale.</p> </li> <li> <p>Esempio:</p> </li> </ul> <pre><code>String s = \"abcdef\";\ns.substring(1, 4); // \"bcd\" (indexes 1,2,3)\n</code></pre> <p>Questa regola si applica alla maggior parte dei metodi basati su substring.</p> <p></p>"},{"location":"it/module-03/strings/#924-metodi-che-usano-solo-lindice-iniziale-inclusivo","title":"9.2.4 Metodi che usano solo l\u2019indice iniziale (inclusivo)","text":"Metodo Descrizione Parametri Regola indice Esempio substring(int start) Restituisce la sottostringa da start alla fine start start inclusivo \"abcdef\".substring(2) \u2192 \"cdef\" indexOf(String) Prima occorrenza \u2014 \u2014 \"Java\".indexOf(\"a\") \u2192 1 indexOf(String, start) Inizia la ricerca all\u2019indice start start inclusivo \"banana\".indexOf(\"a\", 2) \u2192 3 lastIndexOf(String) Ultima occorrenza \u2014 \u2014 \"banana\".lastIndexOf(\"a\") \u2192 5 lastIndexOf(String, fromIndex) Cerca all\u2019indietro dall\u2019indice fromIndex fromIndex inclusivo \"banana\".lastIndexOf(\"a\", 3) \u2192 3"},{"location":"it/module-03/strings/#925-metodi-con-inizio-inclusivo-fine-esclusivo","title":"9.2.5 Metodi con inizio inclusivo / fine esclusivo","text":"<p>Questi metodi seguono lo stesso comportamento di slicing: <code>start</code> incluso, <code>end</code> escluso.</p> Metodo Descrizione Firma Esempio substring(start, end) Estrae una parte della stringa (int start, int end) \"abcdef\".substring(1,4) \u2192 \"bcd\" regionMatches Confronta regioni di sottostringhe (toffset, other, ooffset, len) \"Hello\".regionMatches(1, \"ell\", 0, 3) \u2192 true getBytes(int srcBegin, int srcEnd, byte[] dst, int dstBegin) Copia caratteri in un array di byte start inclusivo, end esclusivo Copia i caratteri in [srcBegin, srcEnd) copyValueOf(char[] data, int offset, int count) Crea una nuova stringa offset inclusivo; offset+count esclusivo Stessa regola di substring <p></p>"},{"location":"it/module-03/strings/#926-metodi-che-operano-sullintera-stringa","title":"9.2.6 Metodi che operano sull\u2019intera stringa","text":"Metodo Descrizione Esempio toUpperCase() Versione maiuscola \"java\".toUpperCase() \u2192 \"JAVA\" toLowerCase() Versione minuscola \"JAVA\".toLowerCase() \u2192 \"java\" trim() Rimuove whitespace iniziale/finale \"  hi  \".trim() \u2192 \"hi\" strip() Trim Unicode-aware \"  hi\\u2003\".strip() \u2192 \"hi\" stripLeading() Rimuove whitespace iniziale \"  hi\".stripLeading() \u2192 \"hi\" stripTrailing() Rimuove whitespace finale \"hi  \".stripTrailing() \u2192 \"hi\" isBlank() Vero se vuota o solo whitespace \"  \".isBlank() \u2192 true isEmpty() Vero se length == 0 \"\".isEmpty() \u2192 true"},{"location":"it/module-03/strings/#927-accesso-ai-caratteri","title":"9.2.7 Accesso ai caratteri","text":"Metodo Descrizione Esempio charAt(int index) Restituisce il carattere all\u2019indice \"Java\".charAt(2) \u2192 'v' codePointAt(int index) Restituisce il code point Unicode Utile per emoji o caratteri oltre BMP"},{"location":"it/module-03/strings/#928-ricerca","title":"9.2.8 Ricerca","text":"Metodo Descrizione Esempio contains(CharSequence) Test di sottostringa \"hello\".contains(\"ell\") \u2192 true startsWith(String) Prefisso \"abcdef\".startsWith(\"abc\") \u2192 true startsWith(String, offset) Prefisso all\u2019indice \"abc\".startsWith(\"b\", 1) \u2192 true endsWith(String) Suffisso \"abcdef\".endsWith(\"def\") \u2192 true"},{"location":"it/module-03/strings/#929-metodi-di-sostituzione","title":"9.2.9 Metodi di sostituzione","text":"Metodo Descrizione Esempio replace(char old, char new) Sostituisce caratteri \"banana\".replace('a','o') \u2192 \"bonono\" replace(CharSequence old, CharSequence new) Sostituisce sottostringhe \"ababa\".replace(\"aba\",\"X\") \u2192 \"Xba\" replaceAll(String regex, String replacement) Sostituzione regex globale \"a1a2\".replaceAll(\"\\d\",\"\") \u2192 \"aa\" replaceFirst(String regex, String replacement) Solo prima corrispondenza regex \"a1a2\".replaceFirst(\"\\d\",\"\") \u2192 \"aa2\""},{"location":"it/module-03/strings/#9210-suddivisione-e-unione","title":"9.2.10 Suddivisione e unione","text":"Metodo Descrizione Esempio split(String regex) Suddivide per regex \"a,b,c\".split(\",\") \u2192 [\"a\",\"b\",\"c\"] split(String regex, int limit) Suddivide con limite limit &lt; 0 mantiene tutte le stringhe vuote finali"},{"location":"it/module-03/strings/#9211-metodi-che-restituiscono-array","title":"9.2.11 Metodi che restituiscono array","text":"Metodo Descrizione Esempio toCharArray() Restituisce char[] \"abc\".toCharArray() getBytes() Restituisce byte[] usando encoding di piattaforma/default \"\u00e1\".getBytes()"},{"location":"it/module-03/strings/#9212-indentazione","title":"9.2.12 Indentazione","text":"Metodo Descrizione Esempio indent(int numSpaces) Aggiunge (positivo) o rimuove (negativo) spazi dall\u2019inizio di ogni riga; aggiunge anche un line break alla fine se non gi\u00e0 presente str.indent(-20) stripIndent() Rimuove tutto il whitespace iniziale incidentale da ogni riga; non aggiunge un line break finale str.stripIndent() <ul> <li>Esempio:</li> </ul> <pre><code>var txtBlock = \"\"\"\n\n                    a\n                      b\n                     c\"\"\";\n\nvar conc = \" a\\n\" + \" b\\n\" + \" c\";\n\nSystem.out.println(\"length: \" + txtBlock.length());\nSystem.out.println(txtBlock);\nSystem.out.println(\"\");\nString stripped1 = txtBlock.stripIndent();\nSystem.out.println(stripped1);\nSystem.out.println(\"length: \" + stripped1.length());\n\nSystem.out.println(\"*********************\");\n\nSystem.out.println(\"length: \" + conc.length());\nSystem.out.println(conc);\nSystem.out.println(\"\");\nString stripped2 = conc.stripIndent();\nSystem.out.println(stripped2);\nSystem.out.println(\"length: \" + stripped2.length());\n</code></pre> <p>Output:</p> <pre><code>length: 9\n\na\n  b\n c\n\n\na\n  b\n c\nlength: 9\n*********************\nlength: 8\n a\n b\n c\n\na\nb\nc\nlength: 5\n</code></pre> <p></p>"},{"location":"it/module-03/strings/#9213-esempi-aggiuntivi","title":"9.2.13 Esempi aggiuntivi","text":"<ul> <li>Esempio 1 \u2014 Estrarre <code>[start, end)</code></li> </ul> <pre><code>String s = \"012345\";\nSystem.out.println(s.substring(2, 5));\n// includes 2,3,4 \u2192 prints \"234\"\n</code></pre> <ul> <li>Esempio 2 \u2014 Ricerca da un indice iniziale</li> </ul> <pre><code>String s = \"hellohello\";\nint idx = s.indexOf(\"lo\", 5); // search begins at index 5\n</code></pre> <ul> <li>Esempio 3 \u2014 Errori comuni</li> </ul> <pre><code>String s = \"abcd\";\nSystem.out.println(s.substring(1,1)); // \"\" empty string\nSystem.out.println(s.substring(3, 2)); // \u274c Exception: start index (3) &gt; end index (2)\n\nSystem.out.println(\"abcd\".substring(2, 4)); // \"cd\" \u2014 includes indexes 2 and 3; 4 is excluded but legal here\n\nSystem.out.println(\"abcd\".substring(2, 5)); // \u274c StringIndexOutOfBoundsException (end index 5 is invalid)\n</code></pre>"},{"location":"it/module-04/beyond-classes/","title":"17. Oltre le Classi","text":""},{"location":"it/module-04/beyond-classes/#indice","title":"Indice","text":"<ul> <li>17.1 Interfacce<ul> <li>17.1.1 Cosa Possono Contenere le Interfacce</li> <li>17.1.2 Implementare un\u2019Interfaccia</li> <li>17.1.3 Ereditariet\u00e0 Multipla</li> <li>17.1.4 Ereditariet\u00e0 delle Interfacce e Conflitti</li> <li>17.1.5 Metodi default</li> <li>17.1.6 Metodi static</li> <li>17.1.7 Metodi private nelle interfacce</li> </ul> </li> <li>17.2 Tipi sealed, non-sealed e final<ul> <li>17.2.1 Regole</li> </ul> </li> <li>17.3 Enum<ul> <li>17.3.1 Definizione di Enum Semplice</li> <li>17.3.2 Enum Complesse con Stato e Comportamento</li> <li>17.3.3 Metodi delle Enum</li> <li>17.3.4 Regole</li> </ul> </li> <li>17.4 Record (Java 16+)<ul> <li>17.4.1 Riepilogo delle Regole di Base per i Record</li> <li>17.4.2 Costruttore Lungo</li> <li>17.4.3 Costruttore Compatto</li> <li>17.4.4 Pattern Matching per i Record</li> <li>17.4.5 Nested Record Patterns e Matching dei Record con var e Generics<ul> <li>17.4.5.1 Nested Record Pattern di Base</li> <li>17.4.5.2 Nested Record Patterns con var</li> <li>17.4.5.3 Nested Record Patterns e Generics</li> <li>17.4.5.4 Errori Comuni con i Nested Record Patterns</li> </ul> </li> </ul> </li> <li>17.5 Classi Annidate in Java<ul> <li>17.5.1 Static Nested Classes<ul> <li>17.5.1.1 Sintassi e Regole di Accesso</li> <li>17.5.1.2 Errori Comuni</li> </ul> </li> <li>17.5.2 Inner Classes (Non-Static Nested Classes)<ul> <li>17.5.2.1 Sintassi e Regole di Accesso</li> <li>17.5.2.2 Errori Comuni</li> </ul> </li> <li>17.5.3 Classi Locali<ul> <li>17.5.3.1 Caratteristiche</li> <li>17.5.3.2 Errori Comuni</li> </ul> </li> <li>17.5.4 Classi Anonime<ul> <li>17.5.4.1 Sintassi e Utilizzo</li> <li>17.5.4.2 Classe Anonima che Estende una Classe</li> </ul> </li> <li>17.5.5 Confronto dei Tipi di Classi Annidate</li> </ul> </li> <li>17.6 Nesting delle Interfacce in Java<ul> <li>17.6.1 Dove pu\u00f2 essere dichiarata un\u2019interfaccia</li> <li>17.6.2 Interfacce annidate (Nested Interfaces)<ul> <li>17.6.2.1 Interfaccia annidata in una Classe</li> <li>17.6.2.2 Interfaccia annidata in una un\u2019altra Interfaccia</li> </ul> </li> <li>17.6.3 Regole di Accesso</li> <li>17.6.4 Nested Types nelle Interfacce</li> <li>17.6.5 Riassunto Essenziale</li> </ul> </li> </ul> <p>Questo capitolo presenta diversi meccanismi avanzati di tipo (type) oltre il design della Classe in Java: interfacce, enum, classi sealed / non-sealed, record e classi annidate.</p> <p></p>"},{"location":"it/module-04/beyond-classes/#171-interfacce","title":"17.1 Interfacce","text":"<p>Un\u2019interfaccia in Java \u00e8 un tipo di riferimento che definisce un contratto di metodi che una classe accetta di implementare.</p> <p>Un <code>interface</code> \u00e8 implicitamente <code>abstract</code> e non pu\u00f2 essere marcato come <code>final</code>: come per le classi top-level, un\u2019interfaccia pu\u00f2 dichiarare visibilit\u00e0 come <code>public</code> o <code>default</code> (package-private).</p> <p>Una classe Java pu\u00f2 implementare un numero qualsiasi di interfacce tramite la keyword <code>implements</code>.</p> <p>Un <code>interface</code> pu\u00f2 a sua volta estendere pi\u00f9 interfacce usando la keyword <code>extends</code>.</p> <p>Le interfacce abilitano astrazione, accoppiamento lasco e ereditariet\u00e0 multipla di tipo.</p> <p></p>"},{"location":"it/module-04/beyond-classes/#1711-cosa-possono-contenere-le-interfacce","title":"17.1.1 Cosa Possono Contenere le Interfacce","text":"<ul> <li>Metodi astratti (implicitamente <code>public</code> e <code>abstract</code>)</li> <li>Metodi concreti<ul> <li>Metodi default (includono codice e sono implicitamente <code>public</code>)</li> <li>Metodi static (dichiarati come <code>static</code>, includono codice e sono implicitamente <code>public</code>)</li> <li>Metodi private (Java 9+) per riuso interno</li> </ul> </li> <li>Costanti \u2192 implicitamente <code>public static final</code> e inizializzate alla dichiarazione</li> </ul> <pre><code>interface Calculator {\n\n    int add(int a, int b);                 // abstract\n\n    default int mult(int a, int b) {       // default method\n        return a * b;\n    }\n\n    static double pi() { return 3.14; }    // static method\n}\n</code></pre> <p>Warning</p> <p>Poich\u00e9 i metodi astratti delle interfacce sono implicitamente <code>public</code>, non puoi ridurre il livello di accesso su un metodo di implementazione.</p> <p></p>"},{"location":"it/module-04/beyond-classes/#1712-implementare-uninterfaccia","title":"17.1.2 Implementare un\u2019Interfaccia","text":"<pre><code>class BasicCalc implements Calculator {\n    public int add(int a, int b) { return a + b; }\n}\n</code></pre> <p>Note</p> <p>Ogni metodo astratto deve essere implementato a meno che la classe non sia astratta essa stessa.</p> <p></p>"},{"location":"it/module-04/beyond-classes/#1713-ereditarieta-multipla","title":"17.1.3 Ereditariet\u00e0 Multipla","text":"<p>Una classe pu\u00f2 implementare pi\u00f9 interfacce.</p> <pre><code>interface A { void a(); }\ninterface B { void b(); }\n\nclass C implements A, B {\n    public void a() {}\n    public void b() {}\n}\n</code></pre> <p></p>"},{"location":"it/module-04/beyond-classes/#1714-ereditarieta-delle-interfacce-e-conflitti","title":"17.1.4 Ereditariet\u00e0 delle Interfacce e Conflitti","text":"<p>Se due interfacce forniscono metodi <code>default</code> con la stessa signature, la classe che implementa deve fare override del metodo.</p> <pre><code>interface X { default void run() { } }\ninterface Y { default void run() { } }\n\nclass Z implements X, Y {\n    public void run() { } // mandatory\n}\n</code></pre> <p>Se vuoi comunque accedere a una particolare implementazione del metodo <code>default</code> ereditato, puoi usare la seguente sintassi:</p> <pre><code>interface X { default int run() { return 1; } }\ninterface Y { default int run() { return 2; } }\n\nclass Z implements X, Y {\n\n    public int useARun(){\n        return Y.super.run();\n    }\n\n}\n</code></pre> <p></p>"},{"location":"it/module-04/beyond-classes/#1715-metodi-default","title":"17.1.5 Metodi <code>default</code>","text":"<p>Un metodo <code>default</code> (dichiarato con la keyword <code>default</code>) \u00e8 un metodo che definisce un\u2019implementazione e pu\u00f2 essere sovrascritto da una classe che implementa l\u2019interfaccia.</p> <ul> <li>Un metodo default include codice ed \u00e8 implicitamente <code>public</code>;</li> <li>Un metodo default non pu\u00f2 essere <code>abstract</code>, <code>static</code> o <code>final</code>;</li> <li>Come visto appena sopra, se due interfacce forniscono metodi default con la stessa signature, la classe che implementa deve fare override del metodo;</li> <li>Una classe che implementa pu\u00f2 naturalmente basarsi sull\u2019implementazione fornita del metodo <code>default</code> senza sovrascriverlo;</li> <li>Il metodo <code>default</code> pu\u00f2 essere invocato su un\u2019istanza della classe che implementa e NON come metodo <code>static</code> dell\u2019interfaccia contenitore;</li> </ul> <p></p>"},{"location":"it/module-04/beyond-classes/#1716-metodi-static","title":"17.1.6 Metodi <code>static</code>","text":"<ul> <li>Un\u2019interfaccia pu\u00f2 fornire <code>static methods</code> (tramite la keyword <code>static</code>) che sono implicitamente <code>public</code>;</li> <li>I metodi static devono includere un corpo del metodo e sono accessibili usando il nome dell\u2019interfaccia;</li> <li>I metodi static non possono essere <code>abstract</code> o <code>final</code>;</li> </ul>"},{"location":"it/module-04/beyond-classes/#1717-metodi-private-nelle-interfacce","title":"17.1.7 Metodi <code>private</code> nelle interfacce","text":"<p>Tra tutti i metodi concreti che un\u2019interfaccia pu\u00f2 implementare, abbiamo anche:</p> <ul> <li>Metodi <code>private</code>: visibili solo all\u2019interno dell\u2019interfaccia dichiarante e che possono essere invocati solo da un contesto <code>non-static</code> (metodi <code>default</code> o altri <code>non-static private methods</code>).</li> <li>Metodi <code>private static</code>: visibili solo all\u2019interno dell\u2019interfaccia dichiarante e che possono essere invocati da qualsiasi metodo dell\u2019interfaccia contenitore.</li> </ul> <p></p>"},{"location":"it/module-04/beyond-classes/#172-tipi-sealed-non-sealed-e-final","title":"17.2 Tipi sealed, non-sealed e final","text":"<p>Le classi e le interfacce <code>sealed</code> (Java 17+) restringono quali altre classi (o interfacce) possono estenderle o implementarle.</p> <p>Un <code>sealed type</code> \u00e8 dichiarato mettendo il modificatore <code>sealed</code> subito prima della keyword class (o interface), e aggiungendo, dopo il nome del Tipo, la keyword <code>permits</code> seguita dalla lista dei tipi che possono estenderlo (o implementarlo).</p> <pre><code>public sealed class Shape permits Circle, Rectangle { }\n\nfinal class Circle extends Shape { }\n\nnon-sealed class Rectangle extends Shape { }\n</code></pre> <p></p>"},{"location":"it/module-04/beyond-classes/#1721-regole","title":"17.2.1 Regole","text":"<ul> <li>Un tipo sealed deve dichiarare tutti i sottotipi permessi.</li> <li>Un sottotipo permesso deve essere final, sealed o non-sealed; poich\u00e9 le interfacce non possono essere final, possono essere marcate solo <code>sealed</code> o <code>non-sealed</code> quando estendono un\u2019interfaccia sealed.</li> <li>I tipi sealed devono essere dichiarati nello stesso package (o modulo nominato) dei loro sottotipi diretti.</li> </ul>"},{"location":"it/module-04/beyond-classes/#173-enum","title":"17.3 Enum","text":"<p>Le enum definiscono un insieme fisso di valori costanti.</p> <p>Le <code>enum</code> possono dichiarare <code>attributi</code>, <code>costruttori</code> e <code>metodi</code> come le classi regolari ma non possono essere estese.</p> <p>La lista dei valori dell\u2019enum deve terminare con un punto e virgola <code>(;)</code> nel caso di <code>Enum Complesse</code>, ma questo non \u00e8 obbligatorio per <code>Enum Semplici</code>.</p> <p></p>"},{"location":"it/module-04/beyond-classes/#1731-definizione-di-enum-semplice","title":"17.3.1 Definizione di Enum <code>Semplice</code>","text":"<pre><code>enum Day { MON, TUE, WED, THU, FRI, SAT, SUN } // punto e virgola omesso\n</code></pre>"},{"location":"it/module-04/beyond-classes/#1732-enum-complesse-con-stato-e-comportamento","title":"17.3.2 Enum <code>Complesse</code> con Stato e Comportamento","text":"<pre><code>enum Level {\n    LOW(1), MEDIUM(5), HIGH(10); // punto e virgola obbligatorio\n\n    private int code; \n\n    Level(int code) { this.code = code; }\n\n    public int getCode() { return code; }\n}\n\npublic static void main(String[] args) {\n    Level.MEDIUM.getCode();     // invoking a method\n}\n</code></pre>"},{"location":"it/module-04/beyond-classes/#1733-metodi-delle-enum","title":"17.3.3 Metodi delle Enum","text":"<ul> <li><code>values()</code> \u2013 restituisce un array di tutti i valori costanti che possono essere usati, per esempio, in un ciclo <code>for-each</code></li> <li><code>valueOf(String)</code> \u2013 restituisce la costante per nome</li> <li><code>ordinal()</code> \u2013 indice (int) della costante</li> </ul>"},{"location":"it/module-04/beyond-classes/#1734-regole","title":"17.3.4 Regole","text":"<ul> <li>I costruttori delle enum sono implicitamente <code>private</code>;</li> <li>Le enum possono contenere metodi <code>static</code> e <code>instance</code>;</li> <li>Le enum possono implementare <code>interfaces</code>;</li> </ul>"},{"location":"it/module-04/beyond-classes/#174-record-java-16","title":"17.4 Record (Java 16+)","text":"<p>Un record \u00e8 una classe speciale progettata per modellare dati immutabili: sono infatti implicitamente final.</p> <p>Non puoi estendere un record, ma \u00e8 permesso implementare un\u2019interfaccia regolare o sealed.</p> <p>Fornisce automaticamente:</p> <ul> <li>campi private final per ogni componente</li> <li>costruttore con parametri nello stesso ordine della dichiarazione del record;</li> <li>getters (con nome degli attributi)</li> <li><code>equals()</code>, <code>hashCode()</code>, <code>toString()</code>: \u00e8 inoltre permesso fare override di questi metodi</li> <li>I Record possono includere <code>nested classes</code>, <code>interfaces</code>, <code>records</code>, <code>enums</code> e <code>annotations</code></li> </ul> <pre><code>public record Point(int x, int y) { }\n\nvar element = new Point(11, 22);\n\nSystem.out.println(element.x);\nSystem.out.println(element.y);\n</code></pre> <p>Se ti serve validazione o trasformazione aggiuntiva dei campi forniti, puoi definire un <code>costruttore lungo</code> o un <code>costruttore compatto</code>.</p> <p></p>"},{"location":"it/module-04/beyond-classes/#1741-riepilogo-delle-regole-di-base-per-i-record","title":"17.4.1 Riepilogo delle Regole di Base per i Record","text":"<p>Un record pu\u00f2 essere dichiarato in tre posizioni:</p> <ul> <li>Come record top-level (direttamente in un package)</li> <li>Come record member (come membro, all\u2019interno di una classe o interfaccia)</li> <li>Come record local (all\u2019interno di un metodo)</li> </ul> <p>Tutte le classi record <code>member</code> e <code>local</code> sono implicitamente <code>static</code>.</p> <ul> <li>Un record member pu\u00f2 dichiarare <code>static</code> in modo ridondante.</li> <li>Un record local non deve dichiarare <code>static</code> esplicitamente.</li> </ul> <p>Ogni classe record \u00e8 implicitamente <code>final</code>.</p> <ul> <li>Dichiarare <code>final</code> esplicitamente \u00e8 consentito ma ridondante.</li> <li>Un record non pu\u00f2 essere dichiarato <code>abstract</code>, <code>sealed</code> o <code>non-sealed</code>.</li> </ul> <p>La superclasse diretta di ogni record \u00e8 <code>java.lang.Record</code>.</p> <ul> <li>Un record non pu\u00f2 dichiarare una clausola <code>extends</code>.</li> <li>Un record non pu\u00f2 estendere nessun\u2019altra classe.</li> </ul> <p>La serializzazione dei record \u00e8 diversa rispetto alle classi serializzabili ordinarie.</p> <ul> <li>Durante la deserializzazione viene invocato il costruttore canonico.</li> </ul> <p>Il corpo di un record pu\u00f2 contenere:</p> <ul> <li>Costruttori</li> <li>Metodi</li> <li>Campi statici</li> <li>Blocchi di inizializzazione statici</li> </ul> <p>Il corpo di un record NON deve contenere:</p> <ul> <li>Dichiarazioni di campi di istanza</li> <li>Blocchi di inizializzazione di istanza</li> <li>Metodi <code>abstract</code></li> <li>Metodi <code>native</code></li> </ul> <p></p>"},{"location":"it/module-04/beyond-classes/#1742-costruttore-lungo","title":"17.4.2 Costruttore Lungo","text":"<pre><code>public record Person(String name, int age) {\n\n    public Person (String name, int age){\n        if (age &lt; 0) throw new IllegalArgumentException();\n        this.name = name;\n        this.age = age;\n    }\n}\n</code></pre> <p>Puoi anche definire costruttori in overload, purch\u00e9 alla fine deleghino a quello canonico usando <code>this(...)</code>:</p> <pre><code>public record Point(int x, int y) {\n\n    // Overloaded constructor (NOT canonical)\n    public Point(int value) {\n        this(value, value); // deve invocare, come prima istruzione, un altro costruttore overloaded e, in ultima istanza, il costruttore canonico.\n    }\n}\n</code></pre> <p>Note</p> <ul> <li>Il compilatore non inserir\u00e0 un costruttore se ne fornisci manualmente uno con la stessa lista di parametri nell\u2019ordine definito;</li> <li>In questo caso, devi impostare esplicitamente ogni campo manualmente;</li> </ul> <p></p>"},{"location":"it/module-04/beyond-classes/#1743-costruttore-compatto","title":"17.4.3 Costruttore Compatto","text":"<p>Puoi definire un <code>costruttore compatto</code> che imposta implicitamente tutti i campi, permettendoti di eseguire validazioni e trasformazioni su campi specifici.</p> <p>Java eseguir\u00e0 il costruttore completo, impostando tutti i campi, dopo che il costruttore compatto \u00e8 terminato.</p> <pre><code>public record Person(String name, int age) {\n\n    public Person {\n        if (age &lt; 0) throw new IllegalArgumentException();\n\n        name = name.toUpperCase(); // This transformation is still (at this level of initialization) on the input parameter.\n\n        // this.name = name; // \u274c Does not compile.\n    }   \n}\n</code></pre> <p>Warning</p> <ul> <li>Se provi a modificare un attributo di Record dentro un Costruttore Compatto, il tuo codice non compiler\u00e0</li> </ul> <p></p>"},{"location":"it/module-04/beyond-classes/#1744-pattern-matching-per-i-record","title":"17.4.4 Pattern Matching per i Record","text":"<p>Quando usi pattern matching con <code>instanceof</code> o con <code>switch</code>, un record pattern deve specificare:</p> <ul> <li>Il tipo del record;</li> <li>Un pattern per ogni campo del record (corrispondendo al numero corretto di componenti, e tipi compatibili);</li> </ul> <p>Esempio record:</p> <pre><code>Object obj = new Point(3, 5);\n\nif (obj instanceof Point(int a, int b)) {\n    System.out.println(a + b);   // 8\n}\n</code></pre> <p></p>"},{"location":"it/module-04/beyond-classes/#1745-nested-record-patterns-e-matching-dei-record-con-var-e-generics","title":"17.4.5 Nested Record Patterns e Matching dei Record con <code>var</code> e Generics","text":"<p>I nested record patterns permettono di destrutturare record che contengono altri record o tipi complessi, estraendo valori ricorsivamente direttamente nel pattern stesso.</p> <p>Combinano la potenza della destrutturazione dei <code>record</code> con il pattern matching, dandoti un modo conciso ed espressivo per navigare strutture dati gerarchiche.</p> <p></p>"},{"location":"it/module-04/beyond-classes/#17451-nested-record-pattern-di-base","title":"17.4.5.1 Nested Record Pattern di Base","text":"<p>Se un record contiene un altro record, puoi destrutturare entrambi in una volta:</p> <pre><code>record Address(String city, String country) {}\nrecord Person(String name, Address address) {}\n\nvoid printInfo(Object obj) {\n\n    switch (obj) {\n        case Person(String n, Address(String c, String co)) -&gt; System.out.println(n + \" lives in \" + c + \", \" + co);\n        default -&gt; System.out.println(\"Unknown\");\n    }\n}\n</code></pre> <p>Nell\u2019esempio sopra, il pattern <code>Person</code> include un pattern <code>Address</code> annidato.</p> <p>Entrambi sono matchati strutturalmente.</p> <p></p>"},{"location":"it/module-04/beyond-classes/#17452-nested-record-patterns-con-var","title":"17.4.5.2 Nested Record Patterns con <code>var</code>","text":"<p>Invece di specificare tipi esatti per ogni campo, puoi usare <code>var</code> dentro il pattern per lasciare al compilatore l\u2019inferenza del tipo.</p> <pre><code>    switch (obj) {\n        case Person(var name, Address(var city, var country)) -&gt; System.out.println(name + \" \u2014 \" + city + \", \" + country);\n    }\n</code></pre> <p><code>var</code> nei pattern funziona come <code>var</code> nelle variabili locali: significa \"inferisci il tipo\".</p> <p>Warning</p> <ul> <li>Ti serve ancora il tipo del record contenitore (Person, Address);</li> <li>solo i tipi dei campi possono essere sostituiti con <code>var</code>.</li> </ul> <p></p>"},{"location":"it/module-04/beyond-classes/#17453-nested-record-patterns-e-generics","title":"17.4.5.3 Nested Record Patterns e Generics","text":"<p>I record patterns funzionano anche con record generici.</p> <pre><code>record Box&lt;T&gt;(T value) {}\nrecord Wrapper(Box&lt;String&gt; box) {}\n\nstatic void test(Object o) {\n    switch (o) {\n        case Wrapper(Box&lt;String&gt;(var v)) -&gt; System.out.println(\"Boxed string: \" + v);\n        default -&gt; System.out.println(\"Something else\");\n    }\n}\n</code></pre> <p>In questo esempio:</p> <ul> <li>Il pattern richiede esattamente <code>Box&lt;String&gt;</code>, non <code>Box&lt;Integer&gt;</code>.</li> <li>Dentro il pattern, <code>var v</code> cattura il valore generico unboxed.</li> </ul> <p></p>"},{"location":"it/module-04/beyond-classes/#17454-errori-comuni-con-i-nested-record-patterns","title":"17.4.5.4 Errori Comuni con i Nested Record Patterns","text":"<p>Struttura record non corrispondente</p> <pre><code>// \u274c ERROR: pattern does not match record structure\ncase Person(var n, var city) -&gt; ...\n</code></pre> <p><code>Person</code> ha 2 campi, ma uno di questi \u00e8 un record. Devi destrutturare correttamente.</p> <p>Numero errato di componenti</p> <pre><code>// \u274c ERROR: Address has 2 components, not 1\ncase Person(var n, Address(var onlyCity)) -&gt; ...\n</code></pre> <p>Mismatch generico</p> <pre><code>// \u274c ERROR: expecting Box&lt;String&gt; but found Box&lt;Integer&gt;\ncase Wrapper(Box&lt;Integer&gt;(var v)) -&gt; ...\n</code></pre> <p>Posizionamento illegale di <code>var</code></p> <pre><code>// \u274c var cannot replace the record type itself\ncase var(Person(var n, var a)) -&gt; ...\n</code></pre> <p>Note</p> <ul> <li><code>var</code> non pu\u00f2 sostituire l\u2019intero pattern, solo i singoli componenti.</li> </ul> <p></p>"},{"location":"it/module-04/beyond-classes/#175-classi-annidate-in-java","title":"17.5 Classi Annidate in Java","text":"<p>Java supporta diversi tipi di classi annidate \u2014 classi dichiarate dentro un\u2019altra classe.</p> <p>Sono uno strumento fondamentale per incapsulamento, organizzazione del codice, pattern di event-handling e rappresentazione di gerarchie logiche.</p> <p>Una classe annidata appartiene sempre a una classe contenitore e ha regole speciali di accessibilit\u00e0 e istanziazione a seconda della sua categoria.</p> <p>Java definisce quattro tipi di classi annidate:</p> <ul> <li>Static Nested Classes \u2013 dichiarate con <code>static</code> dentro un\u2019altra classe.</li> <li>Inner Classes (non-static nested classes).</li> <li>Local Classes \u2013 dichiarate dentro un blocco (metodo, costruttore o initializer).</li> <li>Anonymous Classes \u2013 classi senza nome create inline, di solito per fare override di un metodo o implementare un\u2019interfaccia.</li> </ul> <p>Warning</p> <ul> <li><code>static</code> si applica solo alle classi membro nested</li> <li>Le classi <code>Top-level</code> \u2192 non possono essere static</li> <li>Le classi <code>Local</code> (dichiarate nei metodi) \u2192 non possono essere static</li> <li>Le classi <code>Anonymous</code> \u2192 non possono essere static</li> <li>Una classe <code>static nested</code> non pu\u00f2 accedere ai membri di istanza senza un riferimento esplicito a un oggetto esterno.</li> </ul> <p></p>"},{"location":"it/module-04/beyond-classes/#1751-static-nested-classes","title":"17.5.1 Static Nested Classes","text":"<p>Una static nested class si comporta come una classe top-level con namespace dentro la sua classe contenitore. Non pu\u00f2 accedere ai membri d\u2019istanza della classe esterna ma pu\u00f2 accedere ai membri statici. Non mantiene un riferimento a un\u2019istanza della classe contenitore. Una classe annidata <code>static</code> pu\u00f2 contenere variabili membro non statiche.</p> <p></p>"},{"location":"it/module-04/beyond-classes/#17511-sintassi-e-regole-di-accesso","title":"17.5.1.1 Sintassi e Regole di Accesso","text":"<ul> <li>Dichiarata usando <code>static class</code> dentro un\u2019altra classe.</li> <li>Pu\u00f2 accedere solo ai membri static della classe esterna.</li> <li>Non ha un riferimento implicito all\u2019istanza contenitore.</li> <li>Pu\u00f2 essere istanziata senza un\u2019istanza esterna.</li> </ul> <pre><code>class Outer {\n    static int version = 1;\n\n    static class Nested {\n        void print() {\n            System.out.println(\"Version: \" + version); // OK: accessing static member\n        }\n    }\n}\n\nclass Test {\n    public static void main(String[] args) {\n        Outer.Nested n = new Outer.Nested(); // No Outer instance required\n        n.print();\n    }\n}\n</code></pre>"},{"location":"it/module-04/beyond-classes/#17512-errori-comuni","title":"17.5.1.2 Errori Comuni","text":"<ul> <li>Le static nested classes non possono accedere alle variabili d\u2019istanza:</li> </ul> <pre><code>class Outer {\n    int x = 10;\n    static class Nested {\n        void test() {\n            // System.out.println(x); // \u274c Compile error\n        }\n    }\n}\n</code></pre>"},{"location":"it/module-04/beyond-classes/#1752-inner-classes-non-static-nested-classes","title":"17.5.2 Inner Classes (Non-Static Nested Classes)","text":"<p>Una inner class \u00e8 associata a un\u2019istanza della classe esterna e pu\u00f2 accedere a tutti i membri della classe esterna, inclusi quelli private.</p> <p></p>"},{"location":"it/module-04/beyond-classes/#17521-sintassi-e-regole-di-accesso","title":"17.5.2.1 Sintassi e Regole di Accesso","text":"<ul> <li>Dichiarata senza <code>static</code>.</li> <li>Ha un riferimento implicito all\u2019istanza contenitore.</li> <li>Pu\u00f2 accedere sia ai membri statici sia ai membri d\u2019istanza della classe esterna.</li> <li>Poich\u00e9 non \u00e8 statica, deve essere creata tramite un\u2019istanza della classe contenitore.</li> </ul> <pre><code>class Outer {\n    private int value = 100;\n\n    class Inner {\n        void print() {\n            System.out.println(\"Value = \" + value); // OK: accessing private\n        }\n    }\n\n    void make() {\n        Inner i = new Inner(); // OK inside the outer class\n        i.print();\n    }\n}\n\nclass Test {\n    public static void main(String[] args) {\n        Outer o = new Outer();\n        Outer.Inner i = o.new Inner(); // MUST be created from an instance\n        i.print();\n    }\n}\n</code></pre>"},{"location":"it/module-04/beyond-classes/#17522-errori-comuni","title":"17.5.2.2 Errori Comuni","text":"<ul> <li>Le inner classes non possono dichiarare membri statici eccetto static final constants.</li> </ul> <pre><code>class Outer {\n    class Inner {\n        // static int x = 10;     // \u274c Compile error\n        static final int OK = 10; // \u2714 Allowed (constant)\n    }\n}\n</code></pre> <p>Warning</p> <ul> <li>Istanziare una inner class SENZA un\u2019istanza esterna \u00e8 illegale.</li> </ul> <p></p>"},{"location":"it/module-04/beyond-classes/#1753-classi-locali","title":"17.5.3 Classi Locali","text":"<p>Una classe locale \u00e8 una classe annidata definita dentro un blocco \u2014 pi\u00f9 comunemente un metodo.</p> <p>Non ha modificatori di accesso ed \u00e8 visibile solo dentro il blocco in cui \u00e8 dichiarata.</p> <p></p>"},{"location":"it/module-04/beyond-classes/#17531-caratteristiche","title":"17.5.3.1 Caratteristiche","text":"<ul> <li>Dichiarata dentro un metodo, costruttore o initializer.</li> <li>Pu\u00f2 accedere ai membri della classe esterna.</li> <li>Pu\u00f2 accedere a variabili locali se sono effectively final.</li> <li>Non pu\u00f2 dichiarare membri statici (eccetto static final constants).</li> </ul> <pre><code>class Outer {\n    void compute() {\n        int base = 5; // must be effectively final\n\n        class Local {\n            void show() {\n                System.out.println(base); // OK\n            }\n        }\n\n        new Local().show();\n    }\n}\n</code></pre>"},{"location":"it/module-04/beyond-classes/#17532-errori-comuni","title":"17.5.3.2 Errori Comuni","text":"<ul> <li><code>base</code> deve essere effectively final; cambiarla rompe la compilazione.</li> </ul> <pre><code>void compute() {\n    int base = 5;\n    base++; // \u274c Now base is NOT effectively final\n    class Local {}\n}\n</code></pre>"},{"location":"it/module-04/beyond-classes/#1754-classi-anonime","title":"17.5.4 Classi Anonime","text":"<p>Una classe anonima \u00e8 una classe one-off creata inline, di solito per implementare un\u2019interfaccia o fare override di un metodo senza nominare una nuova classe.</p> <p></p>"},{"location":"it/module-04/beyond-classes/#17541-sintassi-e-utilizzo","title":"17.5.4.1 Sintassi e Utilizzo","text":"<ul> <li>Creata usando <code>new</code> + tipo + body.</li> <li>Non pu\u00f2 avere costruttori (nessun nome).</li> <li>Spesso usata per event handling, callbacks, comparators.</li> </ul> <pre><code>Runnable r = new Runnable() {\n    @Override\n    public void run() {\n        System.out.println(\"Anonymous running\");\n    }\n};\n</code></pre>"},{"location":"it/module-04/beyond-classes/#17542-classe-anonima-che-estende-una-classe","title":"17.5.4.2 Classe Anonima che Estende una Classe","text":"<pre><code>Button b = new Button(\"Click\");\nb.onClick(new ClickHandler() {\n    @Override\n    public void handle() {\n        System.out.println(\"Handled!\");\n    }\n});\n</code></pre>"},{"location":"it/module-04/beyond-classes/#1755-confronto-dei-tipi-di-classi-annidate","title":"17.5.5 Confronto dei Tipi di Classi Annidate","text":"<p>Una tabella rapida che riassume tutti i tipi di classi annidate.</p> Tipo Ha un\u2019Istanza Esterna? Pu\u00f2 Accedere ai Membri d\u2019Istanza Esterna? Pu\u00f2 Avere Membri Statici? Uso Tipico Static Nested No No S\u00ec Namespacing, helpers Inner Class S\u00ec S\u00ec No (eccetto costanti) Comportamento legato all\u2019oggetto Local Class S\u00ec S\u00ec No Classi temporanee con scope Anonymous Class S\u00ec S\u00ec No Personalizzazione inline <p></p>"},{"location":"it/module-04/beyond-classes/#176-nesting-delle-interfacce-in-java","title":"17.6 Nesting delle Interfacce in Java","text":"<p>In Java, un\u2019interfaccia pu\u00f2 essere dichiarata in diverse posizioni e seguire regole specifiche riguardo al nesting e ai membri consentiti.</p> <p></p>"},{"location":"it/module-04/beyond-classes/#1761-dove-puo-essere-dichiarata-uninterfaccia","title":"17.6.1 Dove pu\u00f2 essere dichiarata un\u2019interfaccia","text":"<p>Un\u2019interfaccia pu\u00f2 essere:</p> <ul> <li>Top-level (direttamente in un package)</li> <li>Nested member interface (dichiarata all\u2019interno di una classe o di un\u2019altra interfaccia)</li> <li>Local interface \u274c (non consentita)</li> <li>Anonymous interface \u274c (non esiste come dichiarazione, solo implementazioni anonime)</li> </ul> <p>In Java non \u00e8 permesso dichiarare un\u2019interfaccia locale (cio\u00e8 dentro un metodo o blocco). Le interfacce possono essere solo <code>top-level</code> o <code>member</code>.</p> <p></p>"},{"location":"it/module-04/beyond-classes/#1762-interfacce-annidate-nested-interfaces","title":"17.6.2 Interfacce annidate (Nested Interfaces)","text":"<p>Una Nested Interface pu\u00f2 essere dichiarata dentro:</p> <p></p>"},{"location":"it/module-04/beyond-classes/#17621-interfaccia-annidata-in-una-classe","title":"17.6.2.1 Interfaccia annidata in una Classe","text":"<ul> <li>\u00c8 implicitamente <code>static</code></li> <li>Non pu\u00f2 essere dichiarata <code>non-static</code></li> <li> <p>Pu\u00f2 essere dichiarata <code>public</code>, <code>protected</code>, <code>private</code> o<code>package-private</code></p> </li> <li> <p>Esempio:</p> </li> </ul> <pre><code>class Outer {\n    interface InnerInterface {\n        void test();\n    }\n}\n</code></pre> <p>La parola chiave <code>static</code> \u00e8 implicita:</p> <pre><code>class Outer {\n    static interface InnerInterface {   // consentito ma ridondante\n        void test();\n    }\n}\n</code></pre> <p></p>"},{"location":"it/module-04/beyond-classes/#17622-interfaccia-annidata-in-una-unaltra-interfaccia","title":"17.6.2.2 Interfaccia annidata in una un\u2019altra Interfaccia","text":"<ul> <li>\u00c8 implicitamente <code>public</code> e <code>static</code></li> <li>Non pu\u00f2 essere <code>private</code> o <code>protected</code></li> </ul> <pre><code>interface A {\n    interface B {\n        void test();\n    }\n}\n</code></pre>"},{"location":"it/module-04/beyond-classes/#1763-regole-di-accesso","title":"17.6.3 Regole di Accesso","text":"<p>Una <code>nested interface</code>:</p> <ul> <li>Non ha riferimento implicito a un\u2019istanza della classe esterna</li> <li>Non pu\u00f2 accedere direttamente ai membri di istanza della classe esterna</li> <li>Pu\u00f2 accedere solo ai membri <code>static</code> della classe esterna</li> </ul> <p></p>"},{"location":"it/module-04/beyond-classes/#1764-nested-types-nelle-interfacce","title":"17.6.4 Nested Types nelle Interfacce","text":"<p>Un\u2019interfaccia pu\u00f2 contenere:</p> <ul> <li>Classi annidate (implicitamente <code>public static</code>)</li> <li>Record annidati (implicitamente <code>public static</code>)</li> <li>Enum annidati (implicitamente <code>public static</code>)</li> <li>Altre interfacce annidate (implicitamente <code>public static</code>)</li> </ul> <p></p>"},{"location":"it/module-04/beyond-classes/#1765-riassunto-essenziale","title":"17.6.5 Riassunto Essenziale","text":"<ul> <li>Le interfacce nested sono sempre <code>static</code></li> <li>Non esistono interfacce locali</li> <li>I campi sono sempre <code>public static final</code></li> <li>I metodi sono implicitamente <code>public abstract</code> (salvo default/static/private)</li> <li>Possono contenere altri tipi nested</li> </ul>"},{"location":"it/module-04/class-loading/","title":"15. Caricamento delle Classi, Inizializzazione e Costruzione degli Oggetti","text":""},{"location":"it/module-04/class-loading/#indice","title":"Indice","text":"<ul> <li>15.1 Aree di Memoria Java Rilevanti per l\u2019Inizializzazione di Classi e Oggetti</li> <li>15.2 Caricamento delle Classi con Ereditariet\u00e0<ul> <li>15.2.1 Ordine di Caricamento delle Classi</li> <li>15.2.2 Cosa Succede Durante il Caricamento di una Classe</li> </ul> </li> <li>15.3 Creazione degli Oggetti con Ereditariet\u00e0<ul> <li>15.3.1 Ordine Completo di Creazione delle Istanze</li> </ul> </li> <li>15.4 Esempio Completo: Inizializzazione Statica + di Istanza nell\u2019Ereditariet\u00e0</li> <li>15.5 Diagramma di Visualizzazione</li> <li>15.6 Regole Chiave</li> <li>15.7 Tabella Riassuntiva</li> </ul> <p>In Java, comprendere come vengono caricate le classi, come vengono inizializzati i membri statici e di istanza, e come vengono eseguiti i costruttori \u2014 specialmente con l\u2019ereditariet\u00e0 \u2014 \u00e8 fondamentale per padroneggiare il linguaggio.</p> <p>Questo capitolo fornisce una spiegazione unificata e chiara su:</p> <ul> <li>Come una classe viene caricata in memoria  </li> <li>Come vengono eseguite le variabili statiche e i blocchi statici  </li> <li>Come vengono creati gli oggetti passo dopo passo  </li> <li>Come vengono eseguiti i costruttori in una catena ereditaria  </li> <li>Come le diverse aree di memoria (Heap, Stack, Method Area) partecipano al processo  </li> </ul> <p></p>"},{"location":"it/module-04/class-loading/#151-aree-di-memoria-java-rilevanti-per-linizializzazione-di-classi-e-oggetti","title":"15.1 Aree di Memoria Java rilevanti per l\u2019Inizializzazione di Classi e Oggetti","text":"<p>Prima di comprendere l\u2019ordine di inizializzazione, \u00e8 utile ricordare le tre principali aree di memoria coinvolte:</p> <ul> <li>Method Area (nota anche come Class Area) \u2014 memorizza i metadati delle classi, le variabili statiche e i blocchi di inizializzazione statica.  </li> <li>Heap \u2014 memorizza tutti gli oggetti e i campi di istanza.  </li> <li>Stack \u2014 memorizza le chiamate ai metodi, le variabili locali e i riferimenti.  </li> </ul> <p>Note</p> <p>I membri statici appartengono alla classe e vengono creati una sola volta nella Method Area.</p> <p>I membri di istanza appartengono a ogni oggetto e vivono nell\u2019Heap.</p> <p></p>"},{"location":"it/module-04/class-loading/#152-caricamento-delle-classi-con-ereditarieta","title":"15.2 Caricamento delle Classi (con Ereditariet\u00e0)","text":"<p>Quando un programma Java si avvia, la JVM carica le classi su richiesta.</p> <p>Quando una classe viene referenziata per la prima volta (ad esempio tramite <code>new</code> o accedendo a un membro statico), l\u2019intera catena ereditaria deve essere caricata prima in memoria.</p> <p></p>"},{"location":"it/module-04/class-loading/#1521-ordine-di-caricamento-delle-classi","title":"15.2.1 Ordine di Caricamento delle Classi","text":"<p>Data una gerarchia di classi:</p> <pre><code>class A { ... }\nclass B extends A { ... }\nclass C extends B { ... }\n</code></pre> <p>Se il codice esegue:</p> <pre><code>public static void main(String[] args) {\n    new C();\n}\n</code></pre> <p>Allora il caricamento delle classi procede in questo ordine rigoroso:</p> <ul> <li>Carica la classe A  </li> <li>Inizializza le variabili statiche di A (default \u2192 esplicite)  </li> <li>Esegue i blocchi di inizializzazione statica di A (dall\u2019alto verso il basso)  </li> <li>Carica la classe B e ripete la stessa logica  </li> <li>Carica la classe C e ripete la stessa logica  </li> </ul> <p></p>"},{"location":"it/module-04/class-loading/#1522-cosa-succede-durante-il-caricamento-di-una-classe","title":"15.2.2 Cosa Succede Durante il Caricamento di una Classe","text":"<ul> <li>Passo 1: Le variabili statiche vengono allocate (prima con valori di default).  </li> <li>Passo 2: Vengono eseguite le inizializzazioni statiche esplicite.  </li> <li>Passo 3: Vengono eseguiti i blocchi di inizializzazione statica nell\u2019ordine in cui compaiono nel codice.  </li> </ul> <p>Note</p> <p>Dopo questi passaggi, la classe \u00e8 completamente pronta e pu\u00f2 essere utilizzata (istanziata o referenziata).</p> <p></p>"},{"location":"it/module-04/class-loading/#153-creazione-degli-oggetti-con-ereditarieta","title":"15.3 Creazione degli Oggetti (con Ereditariet\u00e0)","text":"<p>Quando viene usata la parola chiave <code>new</code>, la creazione dell\u2019istanza segue una sequenza rigorosa e prevedibile che coinvolge tutte le classi genitrici.</p> <p></p>"},{"location":"it/module-04/class-loading/#1531-ordine-completo-di-creazione-delle-istanze","title":"15.3.1 Ordine Completo di Creazione delle Istanze","text":"<ul> <li>1. Viene allocata memoria sull\u2019Heap per il nuovo oggetto (gli attributi ricevono valori di default).  </li> <li>2. La catena dei costruttori viene eseguita (non ancora i corpi) dal genitore al figlio \u2014 si parte dalla cima della gerarchia e procede verso le subclass.  </li> <li>3. Le variabili di istanza ricevono le inizializzazioni esplicite.  </li> <li>4. Vengono eseguiti i blocchi di inizializzazione di istanza.  </li> <li>5. Viene eseguito il corpo del costruttore: per ogni classe nella catena ereditaria, i passaggi 3\u20135 (inizializzazione dei campi, blocchi di istanza, corpo del costruttore) si applicano dal genitore al figlio.  </li> </ul>"},{"location":"it/module-04/class-loading/#154-esempio-completo-inizializzazione-statica-di-istanza-nellereditarieta","title":"15.4 Esempio Completo: Inizializzazione Statica + di Istanza nell\u2019Ereditariet\u00e0","text":"<p>Consideriamo la seguente gerarchia a tre livelli:</p> <pre><code>class A {\n    static int sa = init(\"A static var\");\n\n    static {\n        System.out.println(\"A static block\");\n    }\n\n    int ia = init(\"A instance var\");\n\n    {\n        System.out.println(\"A instance block\");\n    }\n\n    A() {\n        System.out.println(\"A constructor\");\n    }\n\n    static int init(String msg) {\n        System.out.println(msg);\n        return 0;\n    }\n}\n\nclass B extends A {\n    static int sb = init(\"B static var\");\n\n    static {\n        System.out.println(\"B static block\");\n    }\n\n    int ib = init(\"B instance var\");\n\n    {\n        System.out.println(\"B instance block\");\n    }\n\n    B() {\n        System.out.println(\"B constructor\");\n    }\n}\n\nclass C extends B {\n    static int sc = init(\"C static var\");\n\n    static {\n        System.out.println(\"C static block\");\n    }\n\n    int ic = init(\"C instance var\");\n\n    {\n        System.out.println(\"C instance block\");\n    }\n\n    C() {\n        System.out.println(\"C constructor\");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        new C();\n    }\n}\n</code></pre> <p>Output</p> <pre><code>A static var\nA static block\nB static var\nB static block\nC static var\nC static block\nA instance var\nA instance block\nA constructor\nB instance var\nB instance block\nB constructor\nC instance var\nC instance block\nC constructor\n</code></pre> <p></p>"},{"location":"it/module-04/class-loading/#155-diagramma-di-visualizzazione","title":"15.5 Diagramma di Visualizzazione","text":"<pre><code>            CARICAMENTO DELLE CLASSI (dall\u2019alto verso il basso)\n\n                A  ---&gt;  B  ---&gt;  C\n                |         |         |\n      variabili statiche + blocchi statici eseguiti in ordine\n\n-------------------------------------------------------\n\n            CREAZIONE DELL\u2019OGGETTO (dal genitore al figlio)\n\n new C() \n    |\n    +--&gt; allocazione memoria per C (valori di default)\n    +--&gt; chiamata al costruttore B()\n            |\n            +--&gt; chiamata al costruttore A()\n                    |\n                    +--&gt; inizializza variabili di istanza di A\n                    +--&gt; esegue blocchi di istanza di A\n                    +--&gt; esegue costruttore A\n            +--&gt; inizializza variabili di istanza di B\n            +--&gt; esegue blocchi di istanza di B\n            +--&gt; esegue costruttore B\n    +--&gt; inizializza variabili di istanza di C\n    +--&gt; esegue blocchi di istanza di C\n    +--&gt; esegue costruttore C\n</code></pre>"},{"location":"it/module-04/class-loading/#156-regole-chiave","title":"15.6 Regole Chiave","text":"<ul> <li>L\u2019inizializzazione statica avviene una sola volta per classe.  </li> <li>Gli inizializzatori statici vengono eseguiti in ordine genitore \u2192 figlio.  </li> <li>L\u2019inizializzazione di istanza avviene ogni volta che viene creato un oggetto.  </li> <li>Per ogni classe nella catena ereditaria, i campi di istanza e i blocchi di istanza vengono eseguiti prima del corpo del costruttore di quella classe.  </li> <li>Nel complesso, sia l\u2019inizializzazione dei campi/blocchi di istanza sia i costruttori vengono eseguiti dal genitore al figlio.  </li> <li>I costruttori chiamano sempre il costruttore del genitore (esplicitamente o implicitamente).  </li> </ul>"},{"location":"it/module-04/class-loading/#157-tabella-riassuntiva","title":"15.7 Tabella Riassuntiva","text":"STATIC (Livello Classe) INSTANCE (Livello Oggetto) Una sola volta Avviene a ogni <code>new</code> Eseguito genitore \u2192 figlio Inizializzazione di istanza e costruttori genitore \u2192 figlio variabili statiche (default \u2192 esplicite) variabili di istanza (default \u2192 esplicite) blocchi statici blocchi di istanza + costruttore"},{"location":"it/module-04/exceptions/","title":"19. Eccezioni e Gestione degli Errori","text":""},{"location":"it/module-04/exceptions/#indice","title":"Indice","text":"<ul> <li>19.1 Gerarchia e tipi di eccezioni<ul> <li>19.1.1 Throwable</li> <li>19.1.2 Error (unchecked)</li> <li>19.1.3 Eccezioni Checked (<code>Exception</code>)</li> <li>19.1.4 Eccezioni Unchecked (<code>RuntimeException</code>)</li> </ul> </li> <li>19.2 Dichiarare e lanciare eccezioni<ul> <li>19.2.1 Dichiarare eccezioni con throws</li> <li>19.2.2 Lanciare eccezioni</li> </ul> </li> <li>19.3 Override dei metodi e regole sulle eccezioni</li> <li>19.4 Gestione delle eccezioni: try, catch, finally<ul> <li>19.4.1 Sintassi base try-catch</li> <li>19.4.2 Blocchi catch multipli</li> <li>19.4.3 Multi-catch Java 7</li> <li>19.4.4 Blocco finally</li> </ul> </li> <li>19.5 Gestione automatica delle risorse try-with-resources<ul> <li>19.5.1 Sintassi base</li> <li>19.5.2 Dichiarare risorse multiple</li> <li>19.5.3 Scope delle risorse</li> </ul> </li> <li>19.6 Eccezioni soppresse</li> <li>19.7 Riepilogo sulle eccezioni</li> </ul> <p>Le <code>Exceptions</code> sono il meccanismo strutturato di Java per gestire condizioni anomale a runtime. </p> <p>Permettono ai programmi di separare il flusso di esecuzione normale dalla logica di gestione degli errori, migliorando robustezza, leggibilit\u00e0 e correttezza.</p> <p></p>"},{"location":"it/module-04/exceptions/#191-gerarchia-e-tipi-di-eccezioni","title":"19.1 Gerarchia e tipi di eccezioni","text":"<p>Tutte le eccezioni derivano da <code>Throwable</code>.</p> <p>La gerarchia definisce quali condizioni sono recuperabili, quali devono essere dichiarate e quali rappresentano errori fatali del sistema.</p> <pre><code>java.lang.Object\n\u2514\u2500\u2500 java.lang.Throwable\n    \u251c\u2500\u2500 java.lang.Error\n    \u2514\u2500\u2500 java.lang.Exception\n        \u2514\u2500\u2500 java.lang.RuntimeException\n</code></pre> <p></p>"},{"location":"it/module-04/exceptions/#1911-throwable","title":"19.1.1 Throwable","text":"<ul> <li>Classe base per tutti gli errori e le eccezioni  </li> <li>Supporta messaggio, causa e stack trace  </li> <li>Solo <code>Throwable</code> (e le sue sottoclassi) pu\u00f2 essere lanciato o catturato  </li> </ul>"},{"location":"it/module-04/exceptions/#1912-error-unchecked","title":"19.1.2 Error (unchecked)","text":"<ul> <li>Rappresenta gravi problemi della JVM o del sistema  </li> <li>Non \u00e8 pensato per essere catturato o gestito  </li> <li>Esempi: <code>OutOfMemoryError</code>, <code>StackOverflowError</code> </li> </ul> <p>NOTA Gli Error indicano condizioni dalle quali l\u2019applicazione generalmente non \u00e8 attesa a riprendersi.</p> <p></p>"},{"location":"it/module-04/exceptions/#1913-eccezioni-checked-exception","title":"19.1.3 Eccezioni Checked (<code>Exception</code>)","text":"<ul> <li>Sottoclassi di <code>Exception</code> escludendo <code>RuntimeException</code> </li> <li>Rappresentano condizioni che le applicazioni potrebbero voler gestire  </li> <li>Devono essere catturate oppure dichiarate </li> <li>Esempi: <code>IOException</code>, <code>SQLException</code> </li> </ul>"},{"location":"it/module-04/exceptions/#1914-eccezioni-unchecked-runtimeexception","title":"19.1.4 Eccezioni Unchecked (<code>RuntimeException</code>)","text":"<ul> <li>Sottoclassi di <code>RuntimeException</code> </li> <li>Non \u00e8 richiesto dichiararle o catturarle  </li> <li>Solitamente rappresentano errori di programmazione  </li> <li>Esempi: <code>NullPointerException</code>, <code>IllegalArgumentException</code> </li> </ul>"},{"location":"it/module-04/exceptions/#192-dichiarare-e-lanciare-eccezioni","title":"19.2 Dichiarare e lanciare eccezioni","text":""},{"location":"it/module-04/exceptions/#1921-dichiarare-eccezioni-con-throws","title":"19.2.1 Dichiarare eccezioni con throws","text":"<p>Un metodo dichiara eccezioni checked usando la clausola <code>throws</code>. Questa fa parte del contratto API del metodo.</p> <pre><code>void readFile(Path p) throws IOException {\n    Files.readString(p);\n}\n</code></pre> <p>NOTA Solo le eccezioni checked devono essere dichiarate. Le eccezioni unchecked possono essere dichiarate, ma di solito vengono omesse.</p> <p></p>"},{"location":"it/module-04/exceptions/#1922-lanciare-eccezioni","title":"19.2.2 Lanciare eccezioni","text":"<p>Le eccezioni vengono create con <code>new</code> e lanciate esplicitamente usando <code>throw</code>.</p> <pre><code>if (value &lt; 0) {\n    throw new IllegalArgumentException(\"value must be &gt;= 0\");\n}\n</code></pre> <ul> <li><code>throw</code> lancia esattamente un\u2019istanza di eccezione  </li> <li><code>throws</code> dichiara le possibili eccezioni nella firma del metodo  </li> </ul> <p></p>"},{"location":"it/module-04/exceptions/#193-override-dei-metodi-e-regole-sulle-eccezioni","title":"19.3 Override dei metodi e regole sulle eccezioni","text":"<p>Quando si fa override di un metodo, le regole sulle eccezioni sono applicate in modo rigoroso.</p> <ul> <li>Un metodo in override pu\u00f2 lanciare meno o pi\u00f9 specifiche eccezioni checked  </li> <li>Pu\u00f2 lanciare qualsiasi eccezione unchecked  </li> <li>Non pu\u00f2 lanciare nuove o pi\u00f9 generiche eccezioni checked  </li> </ul> <pre><code>class Parent {\n    void work() throws IOException {}\n}\n\nclass Child extends Parent {\n    @Override\n    void work() throws FileNotFoundException {} // OK (sottoclasse)\n}\n</code></pre> <p>NOTA Cambiare solo le eccezioni unchecked non rompe mai il contratto di override.</p> <p></p>"},{"location":"it/module-04/exceptions/#194-gestione-delle-eccezioni-try-catch-finally","title":"19.4 Gestione delle eccezioni: try, catch, finally","text":""},{"location":"it/module-04/exceptions/#1941-sintassi-base-try-catch","title":"19.4.1 Sintassi base try-catch","text":"<pre><code>try {\n    riskyOperation();\n} catch (IOException e) {\n    handle(e);\n}\n</code></pre> <ul> <li>Un blocco <code>try</code> deve essere seguito da almeno un <code>catch</code> oppure da un <code>finally</code> </li> <li>I catch vengono controllati dall\u2019alto verso il basso  </li> </ul>"},{"location":"it/module-04/exceptions/#1942-blocchi-catch-multipli","title":"19.4.2 Blocchi catch multipli","text":"<p>Blocchi catch multipli permettono gestioni diverse per tipi di eccezione differenti.</p> <pre><code>try {\n    process();\n} catch (FileNotFoundException e) {\n    recover();\n} catch (IOException e) {\n    log();\n}\n</code></pre> <p>NOTA Le eccezioni pi\u00f9 specifiche devono venire prima di quelle pi\u00f9 generali, altrimenti la compilazione fallisce. Se si mette un catch per una superclasse (es. <code>IOException</code>) prima di uno per una sottoclasse (es. <code>FileNotFoundException</code>), il catch della sottoclasse diventa irraggiungibile.</p> <p></p>"},{"location":"it/module-04/exceptions/#1943-multi-catch-java-7","title":"19.4.3 Multi-catch (Java 7+)","text":"<pre><code>try {\n    process();\n} catch (IOException | SQLException e) {\n    log(e);\n}\n</code></pre> <ul> <li>I tipi di eccezione devono essere non correlati (nessuna relazione parent/child)  </li> <li>La variabile catturata \u00e8 implicitamente <code>final</code> </li> </ul>"},{"location":"it/module-04/exceptions/#1944-blocco-finally","title":"19.4.4 Blocco finally","text":"<p>Il blocco <code>finally</code> viene eseguito indipendentemente dal fatto che venga lanciata un\u2019eccezione, tranne in casi estremi di terminazione della JVM.</p> <pre><code>try {\n    open();\n} finally {\n    close();\n}\n</code></pre> <ul> <li>Usato per logica di cleanup  </li> <li>Viene eseguito anche se si usa <code>return</code> nel blocco try e/o catch  </li> </ul> <p>NOTA Un blocco <code>finally</code> pu\u00f2 sovrascrivere un valore di ritorno o \u201cinghiottire\u201d un\u2019eccezione. Questo \u00e8 generalmente sconsigliato perch\u00e9 rende il flusso di controllo pi\u00f9 difficile da comprendere.</p> <p></p>"},{"location":"it/module-04/exceptions/#195-gestione-automatica-delle-risorse-try-with-resources","title":"19.5 Gestione automatica delle risorse (try-with-resources)","text":"<p>Il <code>try-with-resources</code> fornisce la chiusura automatica delle risorse che implementano <code>AutoCloseable</code>.</p> <p>Elimina la necessit\u00e0 di cleanup esplicito con <code>finally</code> nella maggior parte dei casi.</p> <p></p>"},{"location":"it/module-04/exceptions/#1951-sintassi-base","title":"19.5.1 Sintassi base","text":"<pre><code>try (BufferedReader br = Files.newBufferedReader(path)) {\n    return br.readLine();\n}\n</code></pre> <ul> <li>Le risorse vengono chiuse automaticamente  </li> <li>La chiusura avviene anche se viene lanciata un\u2019eccezione</li> <li>Le risorse vengono chiuse prima dell'esecuzione dei blocchi <code>catch</code> o del <code>finally</code></li> </ul> <pre><code>try (Resource a = new Resource()) {\n    a.read();\n} finally {\n    a.close();  // \u274c Compile-time error: a \u00e8 out of scope qui\n}\n</code></pre>"},{"location":"it/module-04/exceptions/#1952-dichiarare-risorse-multiple","title":"19.5.2 Dichiarare risorse multiple","text":"<pre><code>try (InputStream in = Files.newInputStream(p);\n        OutputStream out = Files.newOutputStream(q)) {\n    in.transferTo(out);\n}\n</code></pre> <ul> <li>Le risorse vengono chiuse in ordine inverso rispetto alla dichiarazione  </li> </ul>"},{"location":"it/module-04/exceptions/#1953-scope-delle-risorse","title":"19.5.3 Scope delle risorse","text":"<ul> <li>Le risorse sono visibili solo all\u2019interno del blocco <code>try</code> </li> <li>Sono implicitamente <code>final</code> </li> <li>Da Java 9, si possono dichiarare risorse in anticipo, fuori dal try-with-resources, purch\u00e9 siano dichiarate <code>final</code> o siano effettivamente final.</li> </ul> <pre><code>final var firstWriter = Files.newBufferedWriter(filePath);\n\ntry (firstWriter; var secondWriter = Files.newBufferedWriter(filePath)) {\n    // CODE\n}\n</code></pre> <p>NOTA Tentare di riassegnare una variabile risorsa causa un errore di compilazione.</p> <pre><code>Resource a = new Resource();\ntry(a){ // since Java 9\n  ...\n}finally{\n   a.close(); // questo codice compila ma la risorsa puntata dal reference 'a', \u00e8 stata chiusa.\n}\n</code></pre> <p></p>"},{"location":"it/module-04/exceptions/#196-eccezioni-soppresse","title":"19.6 Eccezioni soppresse","text":"<p>Quando sia il blocco <code>try</code> sia il metodo <code>close()</code> della risorsa lanciano eccezioni, Java conserva l\u2019eccezione principale e sopprime le altre.</p> <pre><code>try (BadResource r = new BadResource()) {\n    throw new RuntimeException(\"main\");\n}\n</code></pre> <p>Se anche <code>close()</code> lancia un\u2019eccezione, questa diventa soppressa.</p> <pre><code>catch (Exception e) {\n    for (Throwable t : e.getSuppressed()) {\n        System.out.println(t);\n    }\n}\n</code></pre> <ul> <li>L\u2019eccezione principale viene lanciata  </li> <li>Le eccezioni secondarie sono accessibili tramite <code>getSuppressed()</code> </li> </ul> <p></p>"},{"location":"it/module-04/exceptions/#197-riepilogo-sulle-eccezioni","title":"19.7 Riepilogo sulle eccezioni","text":"<ul> <li>Le eccezioni checked devono essere catturate o dichiarate  </li> <li>I metodi in override non possono ampliare le eccezioni checked  </li> <li>Usa il multi-catch per logica di gestione condivisa  </li> <li>Preferisci try-with-resources al cleanup con finally  </li> <li>Le risorse si chiudono in ordine inverso  </li> <li>Le eccezioni soppresse preservano il contesto completo del fallimento</li> </ul>"},{"location":"it/module-04/generics/","title":"18. Generics in Java","text":""},{"location":"it/module-04/generics/#indice","title":"Indice","text":"<ul> <li>18.1 Basi dei Tipi Generici</li> <li>18.2 Perch\u00e9 Esistono i Generics</li> <li>18.3 Metodi Generici</li> <li>18.4 Type Erasure<ul> <li>18.4.1 Come Funziona la Type Erasure</li> <li>18.4.2 Erasure dei Parametri di Tipo Senza Bound</li> <li>18.4.3 Erasure dei Parametri di Tipo con Bound</li> <li>18.4.4 Bound Multipli: Il Primo Bound Determina l\u2019Erasure</li> <li>18.4.5 Perch\u00e9 Solo il Primo Bound Diventa il Tipo a Runtime</li> <li>18.4.6 Un Esempio Pi\u00f9 Complesso</li> <li>18.4.7 Override e Generics<ul> <li>18.4.7.1 Come il compilatore valida un override</li> <li>18.4.7.2 Parametri generici e override</li> <li>18.4.7.3 Override valido \u2014 Eliminazione della specificit\u00e0 generica</li> <li>18.4.7.4 Override non valido \u2014 Aggiunta di specificit\u00e0 generica</li> <li>18.4.7.5 Override valido \u2014 Parametrizzazione identica</li> <li>18.4.7.6 Override non valido \u2014 Modifica dell\u2019argomento generico</li> <li>18.4.7.7 Perch\u00e9 esiste questa regola</li> <li>18.4.7.8 Modello mentale</li> <li>18.4.7.9 Regole riassuntive</li> </ul> </li> <li>18.4.8 Overloading di un Metodo Generico \u2014 Perch\u00e9 Alcuni Overload Sono Impossibili</li> <li>18.4.9 Overloading di un Metodo Generico Ereditato da una Classe Parent</li> <li>18.4.10 Restituire Tipi Generici \u2014 Regole e Restrizioni</li> <li>18.4.11 Riepilogo delle Regole di Erasure</li> </ul> </li> <li>18.5 Bound sui Parametri di Tipo<ul> <li>18.5.1 Upper Bounds: extends</li> <li>18.5.2 Bound Multipli</li> <li>18.5.3 Wildcard: ?, ? extends, ? super<ul> <li>18.5.3.1 Wildcard Non Limitata</li> <li>18.5.3.2 Wildcard con Upper Bound extends</li> <li>18.5.3.3 Wildcard con Lower Bound super</li> </ul> </li> </ul> </li> <li>18.6 Generics ed Ereditariet\u00e0</li> <li>18.7 Type Inference (Operatore Diamond)</li> <li>18.8 Raw Types (Compatibilit\u00e0 Legacy)</li> <li>18.9 Array Generici (Non Permessi)</li> <li>18.10 Bounded Type Inference</li> <li>18.11 Wildcard vs Parametri di Tipo</li> <li>18.12 Regola PECS (Producer Extends, Consumer Super)</li> <li>18.13 Errori Comuni</li> <li>18.14 Tabella Riassuntiva delle Wildcard</li> <li>18.15 Riepilogo dei Concetti</li> <li>18.16 Esempio Completo</li> </ul> <p>Java <code>Generics</code> permettono di creare classi, interfacce e metodi che lavorano con tipi specificati dall\u2019utente, garantendo che vengano usati solo oggetti del tipo corretto.</p> <p>Tutti i controlli di tipo vengono eseguiti dal compilatore a compile-time. </p> <p>Durante la compilazione, il compilatore verifica i tipi e poi rimuove le informazioni generiche (processo identificato come type erasure), sostituendole con i tipi reali o con Object quando necessario.</p> <p>Il bytecode risultante non contiene generics: contiene solo i tipi concreti e, se serve, cast inseriti automaticamente dal compilatore.</p> <p>In questo modo, gli errori di tipo vengono intercettati prima dell\u2019esecuzione, rendendo il codice pi\u00f9 sicuro, leggibile e riutilizzabile.</p> <p>I Generics si applicano a: - <code>Classi</code> - <code>Interfacce</code> - <code>Metodi</code> (metodi generici) - <code>Costruttori</code></p> <p></p>"},{"location":"it/module-04/generics/#181-basi-dei-tipi-generici","title":"18.1 Basi dei Tipi Generici","text":"<p>Una classe o interfaccia generica introduce uno o pi\u00f9 parametri di tipo, racchiusi tra parentesi angolari.</p> <pre><code>class Box&lt;T&gt; {\n    private T value;\n    void set(T v) { value = v; }\n    T get()       { return value; }\n}\n\nBox&lt;String&gt; b = new Box&lt;&gt;();\n\nb.set(\"hello\");\n\nString x = b.get(); // nessun cast necessario\n</code></pre> <p>Sono permessi pi\u00f9 parametri di tipo:</p> <pre><code>class Pair&lt;K, V&gt; {\n    K key;\n    V value;\n}\n</code></pre> <p></p>"},{"location":"it/module-04/generics/#182-perche-esistono-i-generics","title":"18.2 Perch\u00e9 Esistono i Generics","text":"<pre><code>List list = new ArrayList();          // pre-generics\nlist.add(\"hi\");\n\nInteger x = (Integer) list.get(0);    // ClassCastException a runtime\n</code></pre> <p>Con i generics:</p> <pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"hi\");\n\nString x = list.get(0);               // type-safe, nessun cast\n</code></pre> <p></p>"},{"location":"it/module-04/generics/#183-metodi-generici","title":"18.3 Metodi Generici","text":"<p>Un metodo generico introduce i propri parametri di tipo, indipendenti dalla classe.</p> <pre><code>class Util {\n\n    static &lt;T&gt; T pick(T a, T b) { return a; }\n\n}\n\nString s = Util.&lt;String&gt;pick(\"A\", \"B\"); // esplicito\nString t = Util.pick(\"A\", \"B\");         // l\u2019inferenza funziona\n</code></pre> <p></p>"},{"location":"it/module-04/generics/#184-type-erasure","title":"18.4 Type Erasure","text":"<p>La <code>Type erasure</code> \u00e8 il processo attraverso cui il compilatore Java rimuove tutte le informazioni sui tipi generici prima di generare il bytecode.</p> <p>Questo garantisce compatibilit\u00e0 con le JVM precedenti a Java 5.</p> <p>A <code>compile time</code>, i generics sono completamente controllati: bound sui tipi, varianza, overloading di metodi generici, ecc. </p> <p>Tuttavia, a runtime, tutte le informazioni generiche scompaiono.</p> <p></p>"},{"location":"it/module-04/generics/#1841-come-funziona-la-type-erasure","title":"18.4.1 Come Funziona la Type Erasure","text":"<ul> <li>Sostituire tutte le variabili di tipo (come <code>T</code>) con il loro tipo erasure.</li> <li>Inserire cast dove necessario.</li> <li>Rimuovere tutti gli argomenti di tipo generico (es. <code>List&lt;String&gt;</code> \u2192 <code>List</code>).</li> </ul>"},{"location":"it/module-04/generics/#1842-erasure-dei-parametri-di-tipo-senza-bound","title":"18.4.2 Erasure dei Parametri di Tipo Senza Bound","text":"<p>Se una variabile di tipo non ha bound:</p> <pre><code>class Box&lt;T&gt; {\n    T value;\n    T get() { return value; }\n}\n</code></pre> <p>L\u2019erasure di <code>T</code> \u00e8 <code>Object</code>.</p> <pre><code>class Box {\n    Object value;\n    Object get() { return value; }\n}\n</code></pre> <p></p>"},{"location":"it/module-04/generics/#1843-erasure-dei-parametri-di-tipo-con-bound","title":"18.4.3 Erasure dei Parametri di Tipo con Bound","text":"<p>Se il parametro di tipo ha bound:</p> <pre><code>class TaskRunner&lt;T extends Runnable&gt; {\n\n    void run(T task) { task.run(); }\n\n}\n</code></pre> <p>Allora l\u2019erasure di <code>T</code> \u00e8 il primo bound trovato dal compilatore: in questo specifico caso <code>Runnable</code>.</p> <pre><code>class TaskRunner {\n    void run(Runnable task) { task.run(); }\n}\n</code></pre> <p></p>"},{"location":"it/module-04/generics/#1844-bound-multipli-il-primo-bound-determina-lerasure","title":"18.4.4 Bound Multipli: Il Primo Bound Determina l\u2019Erasure","text":"<p>Java permette bound multipli:</p> <pre><code>&lt;T extends Runnable &amp; Serializable &amp; Cloneable&gt;\n</code></pre> <p>Important</p> <p>L\u2019erasure di <code>T</code> \u00e8 sempre il primo bound, che deve essere una classe o interfaccia.</p> <p>Poich\u00e9 <code>Runnable</code> \u00e8 il primo bound, il compilatore effettua l\u2019erasure di <code>T</code> a <code>Runnable</code>.</p> <ul> <li>Esempio con Bound Multipli (Completamente Espanso)</li> </ul> <pre><code>public static &lt;T extends Runnable &amp; Serializable &amp; Cloneable&gt;\nvoid runAll(List&lt;T&gt; list) {\n    for (T t : list) {\n        t.run();\n    }\n}\n</code></pre> <p>Versione con Erasure</p> <pre><code>public static void runAll(List list) {\n    for (Object obj : list) {\n        Runnable t = (Runnable) obj;   // cast inserito dal compilatore\n        t.run();\n    }\n}\n</code></pre> <p>Cosa succede agli altri bound (Serializable, Cloneable)?</p> <ul> <li>Sono applicati solo a compile time.</li> <li>NON compaiono nel bytecode.</li> <li>Nessuna interfaccia aggiuntiva viene associata al tipo con erasure.</li> </ul> <p></p>"},{"location":"it/module-04/generics/#1845-perche-solo-il-primo-bound-diventa-il-tipo-a-runtime","title":"18.4.5 Perch\u00e9 Solo il Primo Bound Diventa il Tipo a Runtime?","text":"<p>Perch\u00e9 la JVM deve operare usando un singolo tipo di riferimento concreto per ogni variabile o parametro.</p> <p>Le istruzioni bytecode a runtime come <code>invokevirtual</code> richiedono una singola classe o interfaccia, non un tipo composto come \u201cRunnable &amp; Serializable &amp; Cloneable\u201d.</p> <p>Note</p> <p>Java seleziona il primo bound come tipo a runtime, e usa i bound restanti solo per la validazione a compile-time.</p> <p></p>"},{"location":"it/module-04/generics/#1846-un-esempio-piu-complesso","title":"18.4.6 Un Esempio Pi\u00f9 Complesso","text":"<pre><code>interface A { void a(); }\ninterface B { void b(); }\n\nclass C implements A, B {\n    public void a() {}\n    public void b() {}\n}\n\nclass Demo&lt;T extends A &amp; B&gt; {\n    void test(T value) {\n        value.a();\n        value.b();\n    }\n}\n</code></pre> <p>Versione con Erasure</p> <pre><code>class Demo {\n    void test(A value) {\n        value.a();\n        // value.b();   // \u274c non disponibile dopo l\u2019erasure: il tipo \u00e8 A, non B\n    }\n}\n</code></pre> <p>Note</p> <p>Il compilatore pu\u00f2 inserire cast aggiuntivi o metodi bridge in scenari di ereditariet\u00e0 pi\u00f9 complessi, ma l\u2019erasure usa sempre solo il primo bound (A in questo caso).</p> <p></p>"},{"location":"it/module-04/generics/#1847-override-e-generics","title":"18.4.7 Override e Generics","text":"<p>Quando i generics interagiscono con l\u2019ereditariet\u00e0, \u00e8 fondamentale comprendere chiaramente due regole:</p> <p>Important</p> <p>L\u2019override viene verificato dopo la type erasure. La compatibilit\u00e0 dei tipi viene verificata prima della type erasure.</p> <p>Questi due passaggi spiegano perch\u00e9 alcuni metodi effettuano correttamente l\u2019override mentre altri producono errori di compilazione.</p> <p></p>"},{"location":"it/module-04/generics/#18471-come-il-compilatore-valida-un-override","title":"18.4.7.1 Come il compilatore valida un override","text":"<p>Quando una sottoclasse dichiara un metodo che potrebbe effettuare l\u2019override di un metodo della superclasse, il compilatore esegue due controlli:</p> <ol> <li>Prima della erasure    Il metodo deve essere compatibile a livello di tipo con quello della classe padre:</li> <li>Stesso nome del metodo</li> <li>Stessi tipi dei parametri (inclusi gli argomenti generici)</li> <li> <p>Tipo di ritorno compatibile (covarianza ammessa)</p> </li> <li> <p>Dopo la erasure    Le firme erase devono coincidere esattamente.</p> </li> </ol> <p>Entrambe le condizioni devono essere soddisfatte.</p> <p></p>"},{"location":"it/module-04/generics/#18472-parametri-generici-e-override","title":"18.4.7.2 Parametri generici e override","text":"<p>Gli argomenti di tipo generico fanno parte della firma del metodo a compile-time, ma scompaiono dopo la erasure.</p> <p>Per questo motivo:</p> <ul> <li>\u00c8 consentito eliminare l\u2019informazione generica nel metodo che effettua override</li> <li>Non \u00e8 consentito aggiungere nuova specificit\u00e0 generica</li> <li>Se entrambi i metodi dichiarano tipi parametrizzati, devono coincidere esattamente</li> </ul> <p></p>"},{"location":"it/module-04/generics/#18473-override-valido-eliminazione-della-specificita-generica","title":"18.4.7.3 Override valido \u2014 Eliminazione della specificit\u00e0 generica","text":"<pre><code>class Parent {\n    void process(Set&lt;Integer&gt; data) {}\n}\n\nclass Child extends Parent {\n    @Override\n    void process(Set data) {}   // \u2714 consentito (raw type)\n}\n</code></pre> <p>Spiegazione:</p> <ul> <li>Prima della erasure: <code>Set</code> \u00e8 assignment-compatible con <code>Set&lt;Integer&gt;</code></li> <li>Dopo la erasure: entrambi diventano <code>Set</code></li> </ul> <p>\u2714 Override valido.</p> <p></p>"},{"location":"it/module-04/generics/#18474-override-non-valido-aggiunta-di-specificita-generica","title":"18.4.7.4 Override non valido \u2014 Aggiunta di specificit\u00e0 generica","text":"<pre><code>class Parent {\n    void process(Set data) {}\n}\n\nclass Child extends Parent {\n    void process(Set&lt;Integer&gt; data) {}   // \u274c errore di compilazione\n}\n</code></pre> <p>Spiegazione:</p> <ul> <li>Prima della erasure: <code>Set&lt;Integer&gt;</code> NON \u00e8 assignment-compatible con <code>Set</code></li> <li>Il compilatore lo rifiuta prima ancora di considerare la erasure</li> </ul> <p></p>"},{"location":"it/module-04/generics/#18475-override-valido-parametrizzazione-identica","title":"18.4.7.5 Override valido \u2014 Parametrizzazione identica","text":"<pre><code>class Parent {\n    void process(Set&lt;Integer&gt; data) {}\n}\n\nclass Child extends Parent {\n    @Override\n    void process(Set&lt;Integer&gt; data) {}   // \u2714 corrispondenza esatta\n}\n</code></pre> <p>Entrambi i controlli sono soddisfatti: - Compatibilit\u00e0 prima della erasure - Firma identica dopo la erasure</p> <p></p>"},{"location":"it/module-04/generics/#18476-override-non-valido-modifica-dellargomento-generico","title":"18.4.7.6 Override non valido \u2014 Modifica dell\u2019argomento generico","text":"<pre><code>class Parent {\n    void process(Set&lt;Integer&gt; data) {}\n}\n\nclass Child extends Parent {\n    void process(Set&lt;String&gt; data) {}   // \u274c errore di compilazione\n}\n</code></pre> <p>Spiegazione:</p> <ul> <li>Prima della erasure: <code>Set&lt;String&gt;</code> non \u00e8 compatibile con <code>Set&lt;Integer&gt;</code></li> <li>Dopo la erasure: entrambi diventerebbero <code>Set</code></li> <li>Collisione + incompatibilit\u00e0 \u2192 errore di compilazione</li> </ul> <p></p>"},{"location":"it/module-04/generics/#18477-perche-esiste-questa-regola","title":"18.4.7.7 Perch\u00e9 esiste questa regola","text":"<p>Java deve garantire:</p> <ul> <li>Type safety a compile-time</li> <li>Polimorfismo a runtime dopo la erasure</li> </ul> <p>Poich\u00e9 i generics scompaiono a runtime, la JVM vede solo le firme erase. Il compilatore deve quindi garantire compatibilit\u00e0 prima della erasure e coerenza dopo la erasure.</p> <p></p>"},{"location":"it/module-04/generics/#18478-modello-mentale","title":"18.4.7.8 Modello mentale","text":"<p>Considera l\u2019override con generics come un controllo in due fasi:</p> <pre><code>Fase 1 \u2192 I tipi a livello di sorgente sono compatibili?\nFase 2 \u2192 Le firme erase coincidono?\n</code></pre> <p>Se una delle due fasi fallisce \u2192 errore di compilazione.</p> <p></p>"},{"location":"it/module-04/generics/#18479-regole-riassuntive","title":"18.4.7.9 Regole riassuntive","text":"<ul> <li>L\u2019override \u00e8 validato dopo la erasure</li> <li>La compatibilit\u00e0 \u00e8 validata prima della erasure</li> <li>\u00c8 possibile eliminare informazione generica nella sottoclasse</li> <li>Non \u00e8 possibile aggiungere nuova specificit\u00e0 generica</li> <li>Se entrambi i metodi sono parametrizzati, gli argomenti devono coincidere esattamente</li> <li>Dopo la erasure, le firme devono essere identiche</li> </ul> <p>Questo spiega perch\u00e9 alcuni metodi che sembrano semplici overload vengono rifiutati: dopo la erasure entrano in collisione e, se non costituiscono un override valido, il compilatore li blocca.</p> <p></p>"},{"location":"it/module-04/generics/#1848-overloading-di-un-metodo-generico-perche-alcuni-overload-sono-impossibili","title":"18.4.8 Overloading di un Metodo Generico \u2014 Perch\u00e9 Alcuni Overload Sono Impossibili","text":"<p>Quando Java compila codice generico, applica la type erasure: i parametri di tipo come T vengono rimossi, e il compilatore li sostituisce con il loro tipo erasure (di solito Object o il primo bound).</p> <p>Per questo motivo, due metodi che sembrano diversi a livello di sorgente possono diventare identici dopo l\u2019erasure.</p> <p>Se le <code>signature</code> con erasure sono uguali, Java non pu\u00f2 distinguerli, quindi il codice non compila.</p> <ul> <li>Esempio: Due Metodi che Collassano sulla Stessa <code>Signature</code></li> </ul> <pre><code>public class Demo {\n    public void testInput(List&lt;Object&gt; inputParam) {}\n\n    // public void testInput(List&lt;String&gt; inputParam) {}   // \u274c Errore di compilazione: dopo l\u2019erasure, entrambi diventano testInput(List)\n}\n</code></pre> <p>Spiegazione</p> <pre><code>List&lt;Object&gt; e List&lt;String&gt; vengono entrambi cancellati a List.\n</code></pre> <p>A runtime entrambi i metodi apparirebbero come:</p> <pre><code>void testInput(List inputParam)\n</code></pre> <p>Java non permette due metodi con signature identiche nella stessa classe, quindi l\u2019overload viene rifiutato a compile time.</p> <p></p>"},{"location":"it/module-04/generics/#1849-overloading-di-un-metodo-generico-ereditato-da-una-classe-parent","title":"18.4.9 Overloading di un Metodo Generico Ereditato da una Classe Parent","text":"<p>La stessa regola si applica quando una subclass tenta di introdurre un metodo che, dopo erasure, ha la stessa signature di uno nella superclass.</p> <pre><code>public class SubDemo extends Demo {\n    public void testInput(List&lt;Integer&gt; inputParam) {} \n    // \u274c Errore di compilazione: erasure \u2192 testInput(List), uguale al parent\n}\n</code></pre> <p>Ancora una volta, il compilatore rifiuta l\u2019overload perch\u00e9 le signature con erasure collidono.</p> <p>Quando l\u2019Overloading Funziona</p> <p>L\u2019erasure rimuove solo i parametri generici, non la classe reale usata come parametro del metodo.</p> <p>Quindi, se due parametri differiscono nel tipo raw (non generico), l\u2019overload \u00e8 legale.</p> <pre><code>public class Demo {\n    public void testInput(List&lt;Object&gt; inputParam) {}\n    public void testInput(ArrayList&lt;String&gt; inputParam) {}  // \u2714 Compila\n}\n</code></pre> <p>Perch\u00e9 funziona</p> <p>Anche se <code>ArrayList&lt;String&gt;</code> diventa <code>ArrayList</code>, e <code>List&lt;Object&gt;</code> diventa <code>List</code>, queste sono classi diverse (ArrayList vs List), quindi le signature restano distinte:</p> <pre><code>void testInput(List inputParam)\nvoid testInput(ArrayList inputParam)\n</code></pre> <p>Nessuna collisione \u2192 overloading legale.</p> <p></p>"},{"location":"it/module-04/generics/#18410-restituire-tipi-generici-regole-e-restrizioni","title":"18.4.10 Restituire Tipi Generici \u2014 Regole e Restrizioni","text":"<p>Quando si restituisce un valore da un metodo, Java segue una regola rigida:</p> <p>Il tipo di ritorno di un metodo in overriding deve essere un sottotipo del tipo di ritorno del parent, e qualsiasi argomento generico deve rimanere type-compatible (anche se viene cancellato a runtime).</p> <p>Questo spesso confonde i programmatori, perch\u00e9 i generics nei tipi di ritorno causano conflitti simili a quelli dei parametri.</p> <p>Punti Chiave: - La covarianza del tipo di ritorno si applica solo al tipo raw, non agli argomenti generici. - Gli argomenti generici devono restare compatibili dopo l\u2019erasure (devono coincidere). - Due metodi non possono differire solo per il parametro generico nel tipo di ritorno.</p> <p>Esempio: sostituzione Illegale del Tipo di Ritorno a Causa di Incompatibilit\u00e0 Generica</p> <pre><code>class A {\n    List&lt;String&gt; getData() { return null; }\n}\n\nclass B extends A {\n    // List&lt;Integer&gt; non \u00e8 un tipo di ritorno covariante di List&lt;String&gt;\n    // \u274c Errore di compilazione\n    List&lt;Integer&gt; getData() { return null; }\n}\n</code></pre> <p>Spiegazione:</p> <p>Anche se i generics vengono cancellati, Java impone comunque type safety a livello di sorgente:</p> <pre><code>List&lt;Integer&gt; non \u00e8 un sottotipo di List&lt;String&gt;.\n</code></pre> <p>Entrambi diventano List, ma Java rifiuta l\u2019override che rompe la compatibilit\u00e0 di tipo.</p> <ul> <li>Esempio: Tipo di Ritorno Covariante Legale</li> </ul> <pre><code>class A {\n    Collection&lt;String&gt; getData() { return null; }\n}\n\nclass B extends A {\n    List&lt;String&gt; getData() { return null; }  // \u2714 List \u00e8 sottotipo di Collection\n}\n</code></pre> <p>Questo \u00e8 permesso perch\u00e9: - I tipi raw sono covarianti (List estende Collection). - Gli argomenti generici coincidono (String vs String).</p> <ul> <li></li> <li>Esempio: Overload Illegale Basato Solo sul Tipo di Ritorno</li> </ul> <pre><code>class Demo {\n    List&lt;String&gt; getList() { return null; }\n\n    // List&lt;Integer&gt; getList() { return null; }  \n    // \u274c Errore di compilazione: il tipo di ritorno da solo non distingue i metodi\n}\n</code></pre> <p>Java non usa il tipo di ritorno per distinguere metodi in overload.</p> <p></p>"},{"location":"it/module-04/generics/#18411-riepilogo-delle-regole-di-erasure","title":"18.4.11 Riepilogo delle Regole di Erasure","text":"<ul> <li><code>T senza bound</code> \u2192 erasure a Object.</li> <li><code>T extends X</code> \u2192 erasure a X.</li> <li><code>T extends X &amp; Y &amp; Z</code> \u2192 erasure a X.</li> <li>Tutti i parametri generici vengono cancellati nelle signature dei metodi.</li> <li>Vengono inseriti cast per preservare la tipizzazione a compile-time.</li> <li>Possono essere generati metodi bridge per preservare il polimorfismo.</li> </ul>"},{"location":"it/module-04/generics/#185-bound-sui-parametri-di-tipo","title":"18.5 Bound sui Parametri di Tipo","text":""},{"location":"it/module-04/generics/#1851-upper-bounds-extends","title":"18.5.1 Upper Bounds: extends","text":"<p><code>&lt;T extends Number&gt;</code> significa T deve essere Number o una sottoclasse.</p> <pre><code>class Stats&lt;T extends Number&gt; {\n    T num;\n    Stats(T num) { this.num = num; }\n}\n</code></pre> <p></p>"},{"location":"it/module-04/generics/#1852-bound-multipli","title":"18.5.2 Bound Multipli","text":"<p>Sintassi: <code>T extends Class &amp; Interface1 &amp; Interface2 ...</code> La classe deve comparire per prima.</p> <pre><code>class C&lt;T extends Number &amp; Comparable&lt;T&gt;&gt; { }\n</code></pre> <p></p>"},{"location":"it/module-04/generics/#1853-wildcard-extends-super","title":"18.5.3 Wildcard: <code>?</code>, <code>? extends</code>, <code>? super</code>","text":""},{"location":"it/module-04/generics/#18531-wildcard-non-limitata","title":"18.5.3.1 Wildcard Non Limitata <code>?</code>","text":"<p>Da utilizzare quando si vuole accettare una lista di tipo sconosciuto:</p> <pre><code>void printAll(List&lt;?&gt; list) { ... }\n</code></pre> <p></p>"},{"location":"it/module-04/generics/#18532-wildcard-con-upper-bound-extends","title":"18.5.3.2 Wildcard con Upper Bound <code>? extends</code>","text":"<pre><code>List&lt;? extends Number&gt; nums = List.of(1, 2, 3);\n\nNumber n = nums.get(0);   // OK\n// nums.add(5);           // \u274c non si pu\u00f2 aggiungere: type safety\n</code></pre> <p>Non puoi aggiungere elementi (eccetto null) a <code>? extends</code> perch\u00e9 non conosci il sottotipo esatto.</p> <p></p>"},{"location":"it/module-04/generics/#18533-wildcard-con-lower-bound-super","title":"18.5.3.3 Wildcard con Lower Bound <code>? super</code>","text":"<p><code>&lt;? super Integer&gt;</code> significa il tipo deve essere Integer o una superclasse di Integer.</p> <pre><code>List&lt;? super Integer&gt; list = new ArrayList&lt;Number&gt;();\nlist.add(10);    // OK\n\nObject o = list.get(0); // restituisce Object (supertype comune minimo)\n</code></pre> <p>IMPORTANT</p> <p><code>super</code> accetta inserimento</p> <p><code>extends</code> accetta estrazione.</p> <p></p>"},{"location":"it/module-04/generics/#186-generics-ed-ereditarieta","title":"18.6 Generics ed Ereditariet\u00e0","text":"<p>I generics NON partecipano all\u2019ereditariet\u00e0. Un <code>List&lt;String&gt;</code> non \u00e8 sottotipo di <code>List&lt;Object&gt;</code>; i tipi parametrizzati sono invarianti.</p> <pre><code>List&lt;String&gt; ls = new ArrayList&lt;&gt;();\nList&lt;Object&gt; lo = ls;      // \u274c errore di compilazione\n</code></pre> <p>Invece:</p> <pre><code>List&lt;? extends Object&gt; ok = ls;   // funziona\n</code></pre> <p></p>"},{"location":"it/module-04/generics/#187-type-inference-operatore-diamond","title":"18.7 Type Inference (Operatore Diamond)","text":"<pre><code>Map&lt;String, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();\n</code></pre> <p>Il compilatore deduce gli argomenti generici dall\u2019assegnazione.</p> <p></p>"},{"location":"it/module-04/generics/#188-raw-types-compatibilita-legacy","title":"18.8 Raw Types (Compatibilit\u00e0 Legacy)","text":"<p>Un raw type disabilita i generics, reintroducendo comportamenti non sicuri.</p> <pre><code>List raw = new ArrayList();\nraw.add(\"x\");\nraw.add(10);   // permesso, ma non sicuro\n</code></pre> <p>I raw types dovrebbero essere evitati.</p> <p></p>"},{"location":"it/module-04/generics/#189-array-generici-non-permessi","title":"18.9 Array Generici (Non Permessi)","text":"<p>Non puoi creare array di tipi parametrizzati:</p> <pre><code>List&lt;String&gt;[] arr = new List&lt;String&gt;[10];   // \u274c errore di compilazione\n</code></pre> <p>Perch\u00e9 gli array applicano type safety a runtime mentre i generics si basano solo su controlli a compile-time.</p> <p></p>"},{"location":"it/module-04/generics/#1810-bounded-type-inference","title":"18.10 Bounded Type Inference","text":"<pre><code>static &lt;T extends Number&gt; T identity(T x) { return x; }\n\nint v = identity(10);   // OK\n// String s = identity(\"x\"); // \u274c non \u00e8 un Number\n</code></pre>"},{"location":"it/module-04/generics/#1811-wildcard-vs-parametri-di-tipo","title":"18.11 Wildcard vs Parametri di Tipo","text":"<p>Usa le wildcard quando ti serve flessibilit\u00e0 nei parametri. Usa i parametri di tipo quando il metodo deve restituire o mantenere informazioni di tipo.</p> <ul> <li>Esempio \u2014 wildcard troppo debole:</li> </ul> <pre><code>List&lt;?&gt; copy(List&lt;?&gt; list) {\n   return list;  // perde informazioni di tipo\n}\n</code></pre> <p>Meglio:</p> <pre><code>&lt;T&gt; List&lt;T&gt; copy(List&lt;T&gt; list) {\n    return list;\n}\n</code></pre> <p></p>"},{"location":"it/module-04/generics/#1812-regola-pecs-producer-extends-consumer-super","title":"18.12 Regola PECS (Producer Extends, Consumer Super)","text":"<p>Usa ? extends quando il parametro produce valori. Usa ? super quando il parametro consuma valori.</p> <pre><code>List&lt;? extends Number&gt; listExtends = List.of(1, 2, 3);\nList&lt;? super Integer&gt; listSuper = new ArrayList&lt;Number&gt;();\n\n// ? extends \u2192 lettura sicura\nNumber n = listExtends.get(0);\n\n// ? super \u2192 scrittura sicura\nlistSuper.add(10);\n</code></pre> <p></p>"},{"location":"it/module-04/generics/#1813-errori-comuni","title":"18.13 Errori Comuni","text":"<ul> <li>Ordinare liste con wildcard: <code>List&lt;? extends Number&gt;</code> non pu\u00f2 accettare inserimenti.</li> <li>Fraintendere che <code>List&lt;Object&gt;</code> NON \u00e8 un supertype di <code>List&lt;String&gt;</code>.</li> <li>Dimenticare che gli array generici sono illegali.</li> <li>Pensare che i tipi generici siano preservati a runtime (vengono cancellati).</li> <li>Provare a fare overload di metodi usando solo parametri di tipo diversi.</li> </ul>"},{"location":"it/module-04/generics/#1814-tabella-riassuntiva-delle-wildcard","title":"18.14 Tabella Riassuntiva delle Wildcard","text":"Sintassi Significato <code>?</code> tipo sconosciuto (sola lettura eccetto metodi Object) <code>? extends T</code> leggere T in sicurezza, non si pu\u00f2 aggiungere (eccetto null) <code>? super T</code> si pu\u00f2 aggiungere T, la lettura restituisce Object"},{"location":"it/module-04/generics/#1815-riepilogo-dei-concetti","title":"18.15 Riepilogo dei Concetti","text":"<pre><code>Generics = type safety a compile-time\nBound = limitano i tipi legali\nWildcard = flessibilit\u00e0 nei parametri\nType Inference = il compilatore deduce i tipi\nType Erasure = i generics scompaiono a runtime\nBridge Methods = mantengono il polimorfismo\n</code></pre>"},{"location":"it/module-04/generics/#1816-esempio-completo","title":"18.16 Esempio Completo","text":"<pre><code>class Repository&lt;T extends Number&gt; {\n    private final List&lt;T&gt; store = new ArrayList&lt;&gt;();\n\n    void add(T value) { store.add(value); }\n\n    T first() { return store.isEmpty() ? null : store.get(0); }\n\n    // metodo generico con wildcard\n    static double sum(List&lt;? extends Number&gt; list) {\n        double total = 0;\n        for (Number n : list) total += n.doubleValue();\n        return total;\n    }\n}\n</code></pre>"},{"location":"it/module-04/inheritance/","title":"16. Ereditariet\u00e0 in Java","text":""},{"location":"it/module-04/inheritance/#indice","title":"Indice","text":"<ul> <li>16.1 Definizione Generale di Ereditariet\u00e0</li> <li>16.2 Ereditariet\u00e0 Singola e java.lang.Object</li> <li>16.3 Ereditariet\u00e0 Transitiva</li> <li>16.4 Cosa Viene Ereditato, Breve Promemoria</li> <li>16.5 Modificatori di Classe che Influenzano l\u2019Ereditariet\u00e0</li> <li>16.6 Riferimenti this e super<ul> <li>16.6.1 Il Riferimento this</li> <li>16.6.2 Il Riferimento super</li> </ul> </li> <li>16.7 Dichiarare Costruttori in una catena ereditaria</li> <li>16.8 Costruttore no-arg di Default</li> <li>16.9 Usare this e Constructor Overloading</li> <li>16.10 Chiamare il Costruttore del Parent usando super</li> <li>16.11 Suggerimenti e Trappole sul Costruttore di Default</li> <li>16.12 super si Riferisce Sempre al Parent pi\u00f9 diretto</li> <li>16.13 Ereditare Membri<ul> <li>16.13.1 Method Overriding<ul> <li>16.13.1.1 Definizione e Ruolo nell\u2019Ereditariet\u00e0</li> <li>16.13.1.2 Usare super per chiamare l\u2019Implementazione del Parent</li> <li>16.13.1.3 Regole di Overriding Instance Methods</li> <li>16.13.1.4 Nascondere Static Methods Method Hiding</li> </ul> </li> <li>16.13.2 Abstract Classes<ul> <li>16.13.2.1 Definizione e Scopo</li> <li>16.13.2.2 Regole per le Abstract Classes</li> </ul> </li> <li>16.13.3 Creare Oggetti Immutabili<ul> <li>16.13.3.1 Cos\u2019\u00e8 un Oggetto Immutable</li> <li>16.13.3.2 Linee Guida per Progettare Classi Immutable</li> </ul> </li> </ul> </li> </ul> <p>L'<code>Inheritance</code> (Ereditariet\u00e0) \u00e8 uno dei pilastri fondamentali dell'Object-Oriented Programming.</p> <p>Essa permette a una classe <code>figlia</code> ( child ), la subclass, di acquisire lo stato e il comportamento di un\u2019altra classe <code>genitrice</code> ( parent ), la superclass, creando relazioni gerarchiche che promuovono riuso del codice, specializzazione e polimorfismo.</p> <p></p>"},{"location":"it/module-04/inheritance/#161-definizione-generale-di-ereditarieta","title":"16.1 Definizione Generale di Ereditariet\u00e0","text":"<p>L\u2019ereditariet\u00e0 consente a una classe di estenderne un\u2019altra, ottenendone automaticamente i suoi <code>attributi</code> e i suoi <code>metodi</code> accessibili.</p> <p>La classe che estende pu\u00f2 aggiungere nuove funzionalit\u00e0 o ridefinire (fare <code>override</code>) i comportamenti esistenti, creando versioni pi\u00f9 specializzate della propria classe parent.</p> <p>Note</p> <p>L\u2019Ereditariet\u00e0 esprime una relazione \u201cis-a\u201d (\u00e8-un): un Cane is a (\u00e8-un) Animale.</p> <p></p>"},{"location":"it/module-04/inheritance/#162-ereditarieta-singola-e-javalangobject","title":"16.2 Ereditariet\u00e0 Singola e java.lang.Object","text":"<p>Java supporta la single inheritance, il che significa che ogni classe pu\u00f2 estendere una sola superclasse diretta.</p> <p>Tutte le classi ereditano in ultima analisi da <code>java.lang.Object</code>, che si trova al vertice della gerarchia.</p> <p>Questo garantisce che tutti gli oggetti Java condividano un comportamento minimo comune (ad esempio i metodi <code>toString()</code>, <code>equals()</code>, <code>hashCode()</code>).</p> <pre><code>class Animal { }\nclass Dog extends Animal { }\n\n// All classes implicitly extend Object\nSystem.out.println(new Dog() instanceof Object); // true\n</code></pre> <p></p>"},{"location":"it/module-04/inheritance/#163-ereditarieta-transitiva","title":"16.3 Ereditariet\u00e0 Transitiva","text":"<p>L\u2019<code>Inheritance</code> \u00e8 transitiva.</p> <p>Se la classe <code>C</code> estende <code>B</code> e <code>B</code> estende <code>A</code>, allora <code>C</code> eredita effettivamente i membri accessibili sia da <code>B</code> sia da <code>A</code>.</p> <pre><code>class A { }\nclass B extends A { }\nclass C extends B { } // C inherits from both A and B\n</code></pre> <p></p>"},{"location":"it/module-04/inheritance/#164-cosa-viene-ereditato-breve-promemoria","title":"16.4 Cosa Viene Ereditato, Breve Promemoria","text":"<p>Una subclass eredita tutti i membri accessibili della classe genitrice.</p> <p>Tuttavia, nello specifico, questo dipende dagli <code>access modifiers</code>.</p> <ul> <li>public \u2192 sempre ereditato</li> <li>protected \u2192 ereditato se accessibile tramite regole di package o subclass</li> <li>default (package-private) \u2192 ereditato solo nello stesso package</li> <li>private \u2192 NON ereditato</li> </ul> <p>Note</p> <p>( Fare riferimento al Paragrafo \"Access Modifiers\" nel Capitolo: Mattoni di base del linguaggio Java )</p> <p></p>"},{"location":"it/module-04/inheritance/#165-modificatori-di-classe-che-influenzano-lereditarieta","title":"16.5 Modificatori di Classe che influenzano l\u2019Ereditariet\u00e0","text":"<p>Alcuni modificatori a livello di classe determinano se una classe possa essere estesa.</p> Modifier Meaning Effect on Inheritance <code>final</code> La classe non pu\u00f2 essere estesa Inheritance STOP <code>abstract</code> La classe non pu\u00f2 essere istanziata Deve essere estesa <code>sealed</code> Permette solo un elenco fisso di subclass Restringe l\u2019inheritance <code>non-sealed</code> Subclass di una sealed class che riapre l\u2019inheritance Inheritance permesso <code>static</code> Si applica solo alle nested classes Si comporta come una top-level class all\u2019interno della sua classe contenitore <p>Note</p> <p>Una classe <code>static</code> in Java pu\u00f2 esistere solo come static nested class.</p> <p></p>"},{"location":"it/module-04/inheritance/#166-riferimenti-this-e-super","title":"16.6 Riferimenti <code>this</code> e <code>super</code>","text":""},{"location":"it/module-04/inheritance/#1661-il-riferimento-this","title":"16.6.1 Il Riferimento <code>this</code>","text":"<p>Il riferimento <code>this</code> si riferisce all\u2019istanza corrente dell\u2019oggetto e permette di disambiguare l\u2019accesso ai membri correnti ed ereditati.</p> <p>Java utilizza una regola di granular scope: - Se una variabile di metodo/locale ha lo stesso nome di un <code>instance field</code>, quella locale \u201coscura\u201d l'attributo di istanza. - \u00c8 necessario usare <code>this.fieldName</code> per accedere quindi all\u2019attributo di istanza.</p> <pre><code>public class Person {\n    String name;\n\n    public Person(String name) {\n        this.name = name;\n    }\n}\n</code></pre> <p>Se i nomi differiscono, <code>this</code> \u00e8 opzionale.</p> <pre><code>public class Person {\n    String name;\n\n    public Person(String n) {\n        name = n;\n    }\n}\n</code></pre> <p>Warning</p> <p><code>this</code> NON pu\u00f2 essere usato all\u2019interno di metodi statici perch\u00e9, in quel contesto, non esiste alcuna istanza.</p> <p></p>"},{"location":"it/module-04/inheritance/#1662-il-riferimento-super","title":"16.6.2 Il Riferimento <code>super</code>","text":"<p>Il riferimento <code>super</code> d\u00e0 accesso ai membri della classe genitrice (parent) diretta.</p> <p>Utile quando: - Il parent (genitore) e il child (figlio) definiscono un attributo/metodo con lo stesso nome; vedi sezione: Ereditare Membri - Parent e child definiscono un attributo con lo stesso nome \u2192 <code>variable hiding</code> (due copie) - Parent e child definiscono un metodo con la stessa signature \u2192 <code>method overriding</code> - Si vuole chiamare esplicitamente l\u2019implementazione ereditata</p> <pre><code>class Parent { int value = 10; }\n\nclass Child extends Parent {\n    int value = 20;\n\n    void printBoth() {\n        System.out.println(value);      // child value\n        System.out.println(super.value); // parent value\n    }\n}\n</code></pre> <p>Note</p> <p><code>super</code> NON pu\u00f2 essere usato dentro contesti static.</p> <p></p>"},{"location":"it/module-04/inheritance/#167-dichiarare-costruttori-in-una-catena-ereditaria","title":"16.7 Dichiarare Costruttori in una catena ereditaria","text":"<p>Un <code>costruttore</code> inizializza un oggetto appena creato.</p> <p>I costruttori non vengono mai ereditati, ma ogni costruttore di subclass deve assicurare che la classe parent sia inizializzata.</p> <p>I <code>costruttori</code> sono metodi speciali con un nome che corrisponde al nome della classe e che non dichiarano alcun return type.</p> <p>Una classe pu\u00f2 definire pi\u00f9 costruttori (constructor overloading), ciascuno con una <code>signature</code> unica.</p> <p>Si pu\u00f2 dichiarare esplicitamente un <code>no-arg constructor</code> o un qualsiasi costruttore specifico oppure, se non lo si fa, Java creer\u00e0 implicitamente un <code>default no-arg constructor</code>.</p> <p>Se si dichiara esplicitamente un costruttore, il compilatore Java non includer\u00e0 alcun <code>default no-arg constructor</code>: questa regola si applica indipendentemente a ogni classe nella gerarchia.</p> <p>Una classe parent continua ad avere il proprio costruttore di default a meno che non ne definisca anch\u2019essa uno.</p> <p></p>"},{"location":"it/module-04/inheritance/#168-costruttore-no-arg-di-default","title":"16.8 Costruttore <code>no-arg</code> di Default","text":"<p>Se una classe non dichiara alcun costruttore, Java inserisce automaticamente un default no-argument constructor.</p> <p>Questo costruttore invocher\u00e0 il costruttore <code>super()</code> del genitore diretto, implicitamente: il compilatore Java inserisce implicitamente una chiamata al no-arg constructor <code>super()</code>.</p> <pre><code>class Parent { }\n\nclass Child extends Parent {\n    // Compiler inserts:\n    // Child() { super(); }\n}\n</code></pre> <p></p>"},{"location":"it/module-04/inheritance/#169-usare-this-e-constructor-overloading","title":"16.9 Usare <code>this()</code> e Constructor Overloading","text":"<p>this() invoca un altro costruttore nella stessa classe.</p> <p>Regole: - Deve essere la prima istruzione nel costruttore - Non pu\u00f2 essere combinato con <code>super()</code> - \u00c8 consentita una sola chiamata a <code>this()</code> in un costruttore - Usato per centralizzare l\u2019inizializzazione</p> <pre><code>class Car {\n    int year;\n    String model;\n\n    Car() {\n        this(2020, \"Unknown\");\n    }\n\n    Car(int year, String model) {\n        this.year = year;\n        this.model = model;\n    }\n}\n</code></pre> <p></p>"},{"location":"it/module-04/inheritance/#1610-chiamare-il-costruttore-del-parent-usando-super","title":"16.10 Chiamare il Costruttore del Parent usando <code>super()</code>","text":"<p>Ogni costruttore deve chiamare un costruttore della superclasse, esplicitamente o implicitamente.</p> <p>La chiamata a <code>super()</code> deve apparire come prima istruzione nel costruttore (a meno che non sia sostituito da <code>this()</code>).</p> <pre><code>class Parent {\n    Parent() { System.out.println(\"Parent constructor\"); }\n}\n\nclass Child extends Parent {\n    Child() {\n        super(); // optional, compiler would insert it\n        System.out.println(\"Child constructor\");\n    }\n}\n</code></pre> <p></p>"},{"location":"it/module-04/inheritance/#1611-suggerimenti-e-trappole-sul-costruttore-di-default","title":"16.11 Suggerimenti e Trappole sul Costruttore di Default","text":"<ul> <li>Se la classe genitore non ha un no-arg constructor, la classe figlia DEVE invocare lo specifico <code>super(args)</code> esplicitamente.</li> <li>Se la classe figlia non definisce alcun costruttore, Java non crea automaticamente un costruttore di default per questa.</li> <li>Se ci si dimentica di chiamare esplicitamente un <code>parent constructor</code> esistente, il compilatore inserisce <code>super()</code> \u2014 il quale potrebbe non esistere.</li> </ul> <pre><code>class Parent {\n    Parent(int x) { }\n}\n\nclass Child extends Parent {\n    // ERROR \u2192 compiler inserts super(), but Parent() does not exist\n    Child() { }\n}\n</code></pre>"},{"location":"it/module-04/inheritance/#1612-super-si-riferisce-sempre-al-parent-piu-diretto","title":"16.12 <code>super()</code> si Riferisce Sempre al Parent pi\u00f9 diretto","text":"<p>Anche in lunghe catene ereditarie, <code>super()</code> invoca sempre (e soltanto) il costruttore della classe genitrice immediata.</p> <pre><code>class A { \n    A() { System.out.println(\"A\"); } \n}\nclass B extends A { \n    B() { System.out.println(\"B\"); } \n}\nclass C extends B {\n    C() {\n        super(); // Calls B(), not A()\n        System.out.println(\"C\");\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>A\nB\nC\n</code></pre> <p></p>"},{"location":"it/module-04/inheritance/#1613-ereditare-membri","title":"16.13 Ereditare Membri","text":"<p>In Java, l\u2019accesso ai campi e le chiamate a metodi statici vengono risolti a compile-time, mentre le chiamate ai metodi di istanza vengono risolte a runtime.</p> <p>La distinzione fondamentale \u00e8:</p> <ul> <li>La <code>variabile</code> o il <code>metodo statico</code> utilizzato dipende dal tipo dichiarato del riferimento.</li> <li>Il <code>metodo di istanza</code> eseguito dipende dal tipo reale dell\u2019oggetto a runtime.</li> </ul> <p>Esempio: <code>Accesso ai Campi</code> (Non Polimorfico)</p> <p>I campi vengono risolti in base al tipo dichiarato del riferimento, non al tipo reale dell\u2019oggetto.</p> <pre><code>class Parent {\n    String name = \"Parent\";\n}\n\nclass Child extends Parent {\n    String name = \"Child\";\n}\n\nParent p = new Child();\nSystem.out.println(p.name);   // Output: Parent\n</code></pre> <p>Spiegazione:</p> <ul> <li>Il riferimento <code>p</code> \u00e8 dichiarato di tipo <code>Parent</code>.</li> <li>L\u2019accesso ai campi \u00e8 determinato a compile-time.</li> <li>Pertanto viene utilizzato <code>Parent.name</code>, anche se l\u2019oggetto \u00e8 di tipo <code>Child</code>.</li> </ul> <p>I campi non sono polimorfici.</p> <p>Esempio: <code>Metodi Statici</code> (Non Polimorfici)</p> <p>Anche i metodi statici vengono risolti utilizzando il tipo dichiarato del riferimento.</p> <pre><code>class Parent {\n    static void print() {\n        System.out.println(\"Parent static\");\n    }\n}\n\nclass Child extends Parent {\n    static void print() {\n        System.out.println(\"Child static\");\n    }\n}\n\nParent p = new Child();\np.print();   // Output: Parent static\n</code></pre> <p>Spiegazione:</p> <ul> <li>I metodi statici sono collegati (binding) a compile-time.</li> <li>Il metodo scelto dipende dal tipo del riferimento (<code>Parent</code>), non dal tipo reale dell\u2019oggetto.</li> </ul> <p>Questo meccanismo \u00e8 chiamato method hiding, non overriding.</p> <p>Esempio: <code>Metodi di Istanza</code> (Polimorfici)</p> <p>I metodi di istanza vengono risolti a runtime in base al tipo reale dell\u2019oggetto.</p> <pre><code>class Parent {\n    void print() {\n        System.out.println(\"Parent instance\");\n    }\n}\n\nclass Child extends Parent {\n    @Override\n    void print() {\n        System.out.println(\"Child instance\");\n    }\n}\n\nParent p = new Child();\np.print();   // Output: Child instance\n</code></pre> <p>Spiegazione:</p> <ul> <li>Il tipo del riferimento \u00e8 <code>Parent</code>.</li> <li>L\u2019oggetto reale \u00e8 di tipo <code>Child</code>.</li> <li>Java utilizza il dynamic dispatch.</li> <li>Pertanto viene eseguito <code>Child.print()</code>.</li> </ul> <p>I metodi di istanza sono polimorfici.</p> <p></p>"},{"location":"it/module-04/inheritance/#16131-method-overriding","title":"16.13.1 Method Overriding","text":"<p>Il <code>method overriding</code> \u00e8 un concetto fondamentale dell'ereditariet\u00e0: permette a una classe figlia di fornire una nuova implementazione per un metodo gi\u00e0 definito in una sua classe parent.</p> <p>A runtime, la versione del metodo eseguita dipende dal tipo reale dell\u2019oggetto, non dal particolare <code>reference type</code>.</p> <p>Questo comportamento \u00e8 chiamato dynamic dispatch ed \u00e8 ci\u00f2 che rende possibile il polimorfismo in Java.</p> <p></p>"},{"location":"it/module-04/inheritance/#161311-definizione-e-ruolo-nellereditarieta","title":"16.13.1.1 Definizione e Ruolo nell\u2019Ereditariet\u00e0","text":"<p>Un metodo in una subclass fa override di un metodo di una sua superclass se: - il metodo della superclass \u00e8 <code>metodo d'istanza</code> (non statico); - il metodo della subclass ha lo stesso nome, la stessa lista di parametri e un return type che \u00e8 dello stesso tipo o di un sottotipo del return type nel metodo ereditato; - entrambi i metodi sono accessibili (non privati) e il metodo della subclass non \u00e8 meno visibile di quello della superclass. - Il metodo in overriding non pu\u00f2 dichiarare nuove o pi\u00f9 ampie checked exceptions.</p> <p>L\u2019Overriding \u00e8 usato per specializzare il comportamento: una subclass pu\u00f2 adattare o rifinire il comportamento della classe parent, pur potendo essere usata tramite un reference del tipo genitore.</p> <pre><code>class Animal {\n    void speak() {\n        System.out.println(\"Some generic animal sound\");\n    }\n}\n\nclass Dog extends Animal {\n\n    @Override\n    void speak() {\n        System.out.println(\"Woof!\");\n    }\n}\n\npublic class TestOverride {\n    public static void main(String[] args) {\n        Animal a = new Dog(); // reference type = Animal, object type = Dog\n        a.speak(); // prints \"Woof!\" (Dog implementation)\n    }\n}\n</code></pre> <p></p>"},{"location":"it/module-04/inheritance/#161312-usare-super-per-chiamare-limplementazione-del-parent","title":"16.13.1.2 Usare super per chiamare l\u2019Implementazione del Parent","text":"<p>Quando una subclass fa override di un metodo, pu\u00f2 comunque accedere all\u2019implementazione \"originaria\" della superclass, tramite il riferimento <code>super</code>.</p> <p>Questo \u00e8 utile se si vuole riusare o estendere il comportamento definito nella classe parent.</p> <pre><code>class Person {\n    void introduce() {\n        System.out.println(\"I am a person.\");\n    }\n}\n\nclass Student extends Person {\n    @Override\n    void introduce() {\n        super.introduce(); // calls Person.introduce()\n        System.out.println(\"I am also a student.\");\n    }\n}\n</code></pre> <p>Se sia la classe parent sia la classe child dichiarano un membro (attributo o metodo) con lo stesso nome, il child pu\u00f2 accedere a entrambi: - la versione in overriding (default) - la versione del parent tramite <code>super</code></p> <pre><code>class Base {\n    int value = 10;\n\n    void show() {\n        System.out.println(\"Base value = \" + value);\n    }\n}\n\nclass Derived extends Base {\n    int value = 20; // hides Base.value\n\n    @Override\n    void show() {\n        System.out.println(\"Derived value = \" + value);          // 20\n        System.out.println(\"Base value via super = \" + super.value); // 10\n    }\n}\n</code></pre> <p></p>"},{"location":"it/module-04/inheritance/#161313-regole-di-overriding-instance-methods","title":"16.13.1.3 Regole di Overriding (Instance Methods)","text":"<ul> <li>Stessa firma (signature): stesso nome di metodo, stessi tipi e ordine dei parametri.</li> <li>return type coovariante: il metodo in overriding pu\u00f2 restituire (ritornare) lo stesso tipo del parent, o un subtype del return type del parent.</li> <li>Accessibilit\u00e0: il metodo in overriding non pu\u00f2 essere meno accessibile del metodo originario (ad esempio, non si pu\u00f2 passare da <code>public</code> a <code>protected</code> o <code>private</code>). Pu\u00f2 soltanto mantenere la stessa visibilit\u00e0 o aumentarla.</li> <li>Checked exceptions: il metodo in overriding non pu\u00f2 dichiarare nuove o pi\u00f9 ampie <code>checked exceptions</code> rispetto al <code>parent method</code>; pu\u00f2 dichiararne meno, dichiarare checked exceptions pi\u00f9 specifiche o, eventualmente, rimuoverle completamente.</li> <li>Unchecked exceptions: possono essere aggiunte o rimosse senza restrizioni.</li> <li>final methods: non possono partecipare all'<code>override</code>.</li> </ul> <pre><code>class Parent {\n    Number getValue() throws Exception {\n        return 42;\n    }\n}\n\nclass Child extends Parent {\n@Override\n    // Covariant return type: Integer is a subclass of Number\n    Integer getValue() throws RuntimeException {\n        return 100;\n    }\n}\n</code></pre>"},{"location":"it/module-04/inheritance/#161314-nascondere-static-methods-method-hiding","title":"16.13.1.4 Nascondere Static Methods (Method Hiding)","text":"<p>I metodi statici non partecipano all'<code>overriding</code>; risultano invece, eventualmente, nascosti (hidden).</p> <p>Se una subclass definisce uno static method con la stessa firma di uno static method della classe parent, il metodo statico della subclass nasconde quello della classe genitrice.</p> <p>Se uno dei metodi invece \u00e8 marcato come <code>static</code> e l\u2019altro no, il codice non compiler\u00e0.</p> <p>La selezione del metodo per i metodi statici avviene a compile time ed \u00e8 basata sul <code>reference type</code>: non sull\u2019<code>object type</code>.</p> <pre><code>class A {\n    static void show() {\n        System.out.println(\"A.show()\");\n    }\n}\n\nclass B extends A {\n    static void show() {\n        System.out.println(\"B.show()\");\n    }\n}\n\npublic class TestStatic {\n    public static void main(String[] args) {\n        A a = new B();\n        B b = new B();\n\n        a.show(); // A.show()  (reference type A)\n        b.show(); // B.show()  (reference type B)\n    }\n}\n</code></pre> <p>Important</p> <ul> <li>metodi statici final non possono essere <code>hidden</code> (nascosti); metodi d'istanza dichiarati final non possono essere <code>overriden</code>.</li> <li>Se si prova a ridefinirli in una subclass, il codice non compiler\u00e0.</li> </ul> <p></p>"},{"location":"it/module-04/inheritance/#16132-abstract-classes","title":"16.13.2 Abstract Classes","text":""},{"location":"it/module-04/inheritance/#161321-definizione-e-scopo","title":"16.13.2.1 Definizione e Scopo","text":"<p>Una abstract class \u00e8 una classe che non pu\u00f2 essere istanziata direttamente ed \u00e8 destinata a essere estesa.</p> <p>Pu\u00f2 contenere: - metodi abstract (dichiarati senza body); - metodi concreti (con implementazione); - attributi, costruttori, membri statici, e anche static initializers.</p> <p>Le abstract classes sono usate quando si vuole definire un comportamento comune (e un contratto) di base, ma lasciare alcuni dettagli da implementare alle subclasses concrete.</p> <p></p>"},{"location":"it/module-04/inheritance/#161322-regole-per-le-abstract-classes","title":"16.13.2.2 Regole per le Abstract Classes","text":"<ul> <li>Una classe con almeno un metodo astratto deve essere dichiarata <code>abstract</code>.</li> <li>Una <code>abstract class</code> non pu\u00f2 essere istanziata direttamente.</li> <li>I metodi astratti non hanno body e terminano con un punto e virgola.</li> <li>Gli abstract methods non possono essere <code>final</code>, <code>static</code> o <code>private</code>, perch\u00e9 devono essere ridefinibili <code>overridable</code>.</li> <li>La prima subclass concreta (non-abstract) nella gerarchia, deve implementare tutti gli <code>abstract methods</code> ereditati, altrimenti deve essere dichiarata anch'essa <code>abstract</code>.</li> </ul> <pre><code>abstract class Shape {\n\n    abstract double area(); // must be implemented by concrete subclasses\n\n    void describe() {\n        System.out.println(\"I am a shape.\");\n    }\n\n    Shape() {\n        System.out.println(\"Shape constructor\");\n    }\n}\n\nclass Circle extends Shape {\n    private final double radius;\n\n    Circle(double radius) {\n        this.radius = radius;\n    }\n\n    @Override\n    double area() {\n        return Math.PI * radius * radius;\n    }\n}\n</code></pre> <p>Note</p> <ul> <li>Sebbene una <code>abstract class</code> non possa essere istanziata, i suoi costruttori vengono comunque chiamati quando si creano istanze di classi figlie concrete.</li> <li>Il flusso delle istanziazioni, nella <code>catena ereditaria</code>, parte sempre dal top della gerarchia e si muove verso il basso.</li> </ul> <p></p>"},{"location":"it/module-04/inheritance/#16133-creare-oggetti-immutabili","title":"16.13.3 Creare Oggetti Immutabili","text":""},{"location":"it/module-04/inheritance/#161331-cose-un-oggetto-immutable","title":"16.13.3.1 Cos\u2019\u00e8 un Oggetto <code>Immutable</code>","text":"<p>Un oggetto \u00e8 immutable se, dopo che \u00e8 stato creato, il suo stato non pu\u00f2 cambiare.</p> <p>Tutti gli attributi che ne rappresentano lo stato, rimangono costanti per l'intero ciclo di vita di quell\u2019oggetto.</p> <p>Gli <code>immutable objects</code> sono semplici da comprendere, intrinsecamente <code>thread safe</code> (se progettati correttamente), e ampiamente usati nella Java Standard Library (ad esempio <code>String</code>, wrapper classes come <code>Integer</code>, e molte classi in <code>java.time</code>).</p> <p></p>"},{"location":"it/module-04/inheritance/#161332-linee-guida-per-progettare-classi-immutable","title":"16.13.3.2 Linee Guida per Progettare Classi Immutable","text":"<ul> <li>Dichiarare una classe final cosicch\u00e9 non possa essere estesa (oppure rendere tutti i costruttori privati e fornire factory methods protetti).</li> <li>Rendere tutti gli attributi che ne rappresentano lo stato private e final.</li> <li>Non fornire alcun <code>mutator</code> (setter) methods.</li> <li>Inizializzare tutti gli attributi nei costruttori (o nei factory methods) e non esporli mai in modo <code>mutabile</code>.</li> <li>Se un attributo si riferisce ad un oggetto mutabile, fare defensive copies (copie difensive) in fase di costruzione e quando lo si restituisce tramite <code>getters</code>.</li> </ul> <pre><code>import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic final class Person {\n    private final String name; // String is immutable\n    private final int age;\n    private final List&lt;String&gt; hobbies; // List is mutable, we must protect it\n\n    public Person(String name, int age, List&lt;String&gt; hobbies) {\n        this.name = name;\n        this.age = age;\n        // Defensive copy on input\n        this.hobbies = new ArrayList&lt;&gt;(hobbies);\n    }\n\n    public String getName() {\n        return name; // safe (String is immutable)\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public List&lt;String&gt; getHobbies() {\n        // Defensive copy or unmodifiable view on output\n        return Collections.unmodifiableList(hobbies);\n    }\n}\n</code></pre> <p>In questo esempio: - <code>Person</code> \u00e8 final: non pu\u00f2 essere estesa e il suo comportamento non pu\u00f2 essere alterato tramite <code>inheritance</code>. - Tutti gli attributi sono <code>private</code> e <code>final</code>, definiti una sola volta nel costruttore. - La lista degli <code>hobbies</code> viene copiata difensivamente nella fase di costruzione e wrappata come <code>unmodifiable</code> (non modificabile) nel <code>metodo getter</code>, cosicch\u00e9 alcun codice esterno ne possa modificare lo stato interno.</p> <p>Progettare <code>immutable objects</code> \u00e8 particolarmente importante in contesti multithread e quando si passano oggetti attraverso i diversi layers di una applicazione.</p>"},{"location":"it/module-04/methods-attributes/","title":"14. Metodi, Attributi e Variabili","text":""},{"location":"it/module-04/methods-attributes/#indice","title":"Indice","text":"<ul> <li>14.1 Metodi<ul> <li>14.1.1 Componenti obbligatori di un metodo<ul> <li>14.1.1.1 Modificatori di accesso</li> <li>14.1.1.2 Tipo di ritorno</li> <li>14.1.1.3 Nome del metodo</li> <li>14.1.1.4 Firma del metodo</li> <li>14.1.1.5 Corpo del metodo</li> </ul> </li> <li>14.1.2 Modificatori opzionali</li> <li>14.1.3 Dichiarare i metodi</li> </ul> </li> <li>14.2 Java \u00e8 un linguaggio Pass-by-Value</li> <li>14.3 Overloading dei metodi<ul> <li>14.3.1 Chiamare metodi overloaded<ul> <li>14.3.1.1 Vince la corrispondenza esatta</li> <li>14.3.1.2 Se non esiste una corrispondenza esatta Java sceglie il tipo compatibile pi\u00f9 specifico</li> <li>14.3.1.3 L\u2019allargamento dei primitivi batte il boxing</li> <li>14.3.1.4 Il boxing batte i varargs</li> <li>14.3.1.5 Per i riferimenti Java sceglie il tipo di riferimento pi\u00f9 specifico</li> <li>14.3.1.6 Quando non esiste un pi\u00f9 specifico non ambiguo la chiamata \u00e8 un errore di compilazione</li> <li>14.3.1.7 Overload misti primitivi + wrapper</li> <li>14.3.1.8 Quando i primitivi si mescolano con i tipi di riferimento</li> <li>14.3.1.9 Quando vince Object</li> <li>14.3.1.10 Tabella riassuntiva risoluzione overload</li> </ul> </li> </ul> </li> <li>14.4 Variabili locali e di istanza<ul> <li>14.4.1 Variabili di istanza</li> <li>14.4.2 Variabili locali<ul> <li>14.4.2.1 Variabili locali effettivamente final</li> <li>14.4.2.2 Parametri come effettivamente final</li> </ul> </li> </ul> </li> <li>14.5 Varargs liste di argomenti a lunghezza variabile</li> <li>14.6 Metodi statici variabili statiche e inizializzatori statici<ul> <li>14.6.1 Variabili statiche variabili di classe</li> <li>14.6.2 Metodi statici</li> <li>14.6.3 Blocchi di inizializzazione statica</li> <li>14.6.4 Ordine di inizializzazione statico vs istanza</li> <li>14.6.5 Accesso ai membri statici<ul> <li>14.6.5.1 Utilizzare nome della classe</li> <li>14.6.5.2 Utilizzare riferimento di istanza</li> </ul> </li> <li>14.6.6 Static ed ereditariet\u00e0</li> <li>14.6.7 Errori comuni</li> </ul> </li> </ul> <p>Questo capitolo introduce concetti fondamentali di Programmazione Orientata agli Oggetti (OOP) in Java, iniziando con metodi, passaggio dei parametri, overloading, variabili locali vs. di istanza e varargs.</p> <p></p>"},{"location":"it/module-04/methods-attributes/#141-metodi","title":"14.1 Metodi","text":"<p>I <code>metodi</code> rappresentano le operazioni/comportamenti che possono essere eseguiti da un particolare tipo di dato (una classe).</p> <p>Descrivono cosa pu\u00f2 fare l\u2019oggetto e come interagisce con il suo stato interno e con il mondo esterno.</p> <p>Una <code>dichiarazione di metodo</code> \u00e8 composta da componenti obbligatori e opzionali.</p> <p></p>"},{"location":"it/module-04/methods-attributes/#1411-componenti-obbligatori-di-un-metodo","title":"14.1.1 Componenti obbligatori di un metodo","text":""},{"location":"it/module-04/methods-attributes/#14111-modificatori-di-accesso","title":"14.1.1.1  Modificatori di accesso","text":"<p>I <code>Modificatori di accesso</code> controllano la visibilit\u00e0, non il comportamento.</p> <p>( Fare riferimento al Paragrafo \"Access Modifiers\" nel Capitolo: Mattoni di base del linguaggio Java )</p> <p></p>"},{"location":"it/module-04/methods-attributes/#14112-tipo-di-ritorno","title":"14.1.1.2 Tipo di ritorno","text":"<p>Appare immediatamente prima del nome del metodo.</p> <ul> <li>Se il metodo restituisce un valore \u2192 il tipo di ritorno specifica il tipo del valore.</li> <li>Se il metodo non restituisce un valore \u2192 la keyword <code>void</code> deve essere usata.</li> <li>Un metodo con tipo di ritorno non-void deve contenere almeno una istruzione <code>return valore;</code>.</li> <li>Un metodo <code>void</code> pu\u00f2:</li> <li> <ul> <li>omettere una istruzione return</li> </ul> </li> <li> <ul> <li>includere <code>return;</code> (senza nessun valore)</li> </ul> </li> </ul> <p></p>"},{"location":"it/module-04/methods-attributes/#14113-nome-del-metodo","title":"14.1.1.3 Nome del metodo","text":"<p>Segue le stesse regole degli identificatori ( Fare riferimento al Capitolo: Regole di naming Java ).</p> <p></p>"},{"location":"it/module-04/methods-attributes/#14114-firma-del-metodo","title":"14.1.1.4 Firma del metodo","text":"<p>La firma del metodo in Java include:</p> <ul> <li>il nome del metodo</li> <li>la lista dei tipi dei parametri (tipi + ordine)</li> </ul> <p>Note</p> <p>I nomi dei parametri NON fanno parte della firma, contano solo <code>tipi</code> e <code>ordine</code>.</p> <ul> <li>Esempio di firme distinte:</li> </ul> <pre><code>void process(int x)\nvoid process(int x, int y)\nvoid process(int x, String y)\n</code></pre> <ul> <li>Esempio di stessa firma (overloading illegale):</li> </ul> <pre><code>// \u274c stessa firma: differiscono solo i nomi dei parametri\nvoid m(int a)\nvoid m(int b)\n</code></pre> <p></p>"},{"location":"it/module-04/methods-attributes/#14115-corpo-del-metodo","title":"14.1.1.5 Corpo del metodo","text":"<p>Un blocco <code>{ }</code> contenente zero o pi\u00f9 istruzioni.</p> <p>Se il metodo \u00e8 <code>abstract</code>, il corpo deve essere omesso.</p> <p></p>"},{"location":"it/module-04/methods-attributes/#1412-modificatori-opzionali","title":"14.1.2 Modificatori opzionali","text":"<p>I modificatori opzionali dei metodi includono:</p> <ul> <li><code>static</code></li> <li><code>abstract</code></li> <li><code>final</code></li> <li><code>default</code> (metodi di interfaccia)</li> <li><code>synchronized</code></li> <li><code>native</code></li> <li><code>strictfp</code></li> </ul> <p>Regole:</p> <ul> <li>I modificatori opzionali possono apparire in qualsiasi ordine.</li> <li> <p>Tutti i modificatori devono apparire prima del tipo di ritorno.</p> </li> <li> <p>Esempio:</p> </li> </ul> <pre><code>public static final int compute() {\n    return 10;\n}\n</code></pre> <p></p>"},{"location":"it/module-04/methods-attributes/#1413-dichiarare-i-metodi","title":"14.1.3 Dichiarare i metodi","text":"<pre><code>public final synchronized String formatValue(int x, double y) throws IOException {\n    return \"Result: \" + x + \", \" + y;\n}\n</code></pre> <p>Scomposizione:</p> Part Significato <code>public</code> modificatore di accesso <code>final</code> non pu\u00f2 essere sovrascritto <code>synchronized</code> modificatore di controllo dei thread <code>String</code> tipo di ritorno <code>formatValue</code> nome del metodo <code>(int x, double y)</code> lista dei parametri <code>throws IOException</code> lista delle eccezioni <code>method body</code> implementazione <p></p>"},{"location":"it/module-04/methods-attributes/#142-java-e-un-linguaggio-pass-by-value","title":"14.2 Java \u00e8 un linguaggio \u201cPass-by-Value\u201d","text":"<p>Java usa solo pass-by-value, senza eccezioni.</p> <p>Questo significa:</p> <ul> <li>Per i tipi primitivi \u2192 il metodo riceve una copia del valore.</li> <li>Per i tipi riferimento \u2192 il metodo riceve una copia del riferimento, il che significa:</li> <li> <ul> <li>il riferimento stesso non pu\u00f2 essere cambiato dal metodo</li> </ul> </li> <li> <ul> <li>l\u2019oggetto puntato pu\u00f2 essere modificato tramite quel riferimento</li> </ul> </li> <li> <p>Esempio:</p> </li> </ul> <pre><code>void modify(int a, StringBuilder b) {\n    a = 50;           // modifica la *copia* locale \u2192 nessun effetto all\u2019esterno\n    b.append(\"!\");    // modifica l\u2019*oggetto puntato* \u2192 visibile all\u2019esterno\n}\n</code></pre> <pre><code>public static void main(String[] args) {\n\n    int num1 = 11;\n    methodTryModif(num1);\n    System.out.println(num1);\n\n}\n\npublic static void methodTryModif(int num1){    \n    num1 = 10;  // questa nuova assegnazione influisce solo sul parametro del metodo che, accidentalmente, ha lo stesso nome della variabile esterna.\n}\n</code></pre> <p></p>"},{"location":"it/module-04/methods-attributes/#143-overloading-dei-metodi","title":"14.3 Overloading dei metodi","text":"<p>L\u2019overloading dei metodi significa stesso nome del metodo, firma diversa.</p> <p>Due metodi sono considerati <code>overloaded</code> se differiscono per:</p> <ul> <li>numero di parametri</li> <li>tipi dei parametri</li> <li>ordine dei parametri</li> </ul> <p>L\u2019overloading NON dipende da:</p> <ul> <li>tipo di ritorno</li> <li>modificatore di accesso</li> <li> <p>eccezioni</p> </li> <li> <p>Esempio:</p> </li> </ul> <pre><code>void print(int x)\nvoid print(double x)\nvoid print(int x, int y)\n</code></pre> <p>Metodo overloaded illegale:</p> <pre><code>// \u274c Il tipo di ritorno non conta nell\u2019overloading\nint compute(int x)\ndouble compute(int x)\n</code></pre> <p></p>"},{"location":"it/module-04/methods-attributes/#1431-chiamare-metodi-overloaded","title":"14.3.1 Chiamare metodi overloaded","text":"<p>Quando sono disponibili pi\u00f9 metodi overloaded, Java applica la risoluzione dell\u2019overload per decidere quale metodo chiamare.</p> <p>Il compilatore seleziona il metodo i cui tipi di parametro sono i pi\u00f9 specifici e compatibili con gli argomenti forniti.</p> <p>La risoluzione dell\u2019overload avviene a compile-time (a differenza dell\u2019<code>overriding</code>, che \u00e8 basato sul run-time).</p> <p>Java segue queste regole:</p> <p></p>"},{"location":"it/module-04/methods-attributes/#14311-vince-la-corrispondenza-esatta","title":"14.3.1.1 Vince la corrispondenza esatta","text":"<p>Se un argomento corrisponde esattamente a un parametro del metodo, quel metodo viene scelto.</p> <pre><code>void call(int x)    { System.out.println(\"int\"); }\nvoid call(long x)   { System.out.println(\"long\"); }\n\ncall(5); // stampa: int (corrispondenza esatta per int)\n</code></pre> <p></p>"},{"location":"it/module-04/methods-attributes/#14312-se-non-esiste-una-corrispondenza-esatta-java-sceglie-il-tipo-compatibile-piu-specifico","title":"14.3.1.2 \u2014 Se non esiste una corrispondenza esatta, Java sceglie il tipo compatibile pi\u00f9 specifico","text":"<p>Java preferisce:</p> <ul> <li>widening rispetto all\u2019autoboxing</li> <li>autoboxing rispetto ai varargs</li> <li> <p>riferimento pi\u00f9 ampio solo se un tipo pi\u00f9 specifico non \u00e8 disponibile</p> </li> <li> <p>Esempio con primitivi numerici:</p> </li> </ul> <pre><code>void test(long x)   { System.out.println(\"long\"); }\nvoid test(float x)  { System.out.println(\"float\"); }\n\ntest(5);  // letterale int: pu\u00f2 essere allargato a long o float\n          // ma long \u00e8 pi\u00f9 specifico di float per i tipi interi\n          // Output: long\n</code></pre> <p></p>"},{"location":"it/module-04/methods-attributes/#14313-lallargamento-dei-primitivi-batte-il-boxing","title":"14.3.1.3 \u2014 L\u2019allargamento dei primitivi batte il boxing","text":"<p>Se un argomento primitivo pu\u00f2 essere sia allargato sia autoboxato, Java sceglie l\u2019allargamento.</p> <pre><code>void m(int x)       { System.out.println(\"int\"); }\nvoid m(Integer x)   { System.out.println(\"Integer\"); }\n\nbyte b = 10;\nm(b);               // byte \u2192 int (widening) vince\n                    // Output: int\n</code></pre> <p></p>"},{"location":"it/module-04/methods-attributes/#14314-il-boxing-batte-i-varargs","title":"14.3.1.4 \u2014 Il boxing batte i varargs","text":"<pre><code>void show(Integer x)    { System.out.println(\"Integer\"); }\nvoid show(int... x)     { System.out.println(\"varargs\"); }\n\nshow(5);                // int \u2192 Integer (boxing) preferito\n                        // Output: Integer\n</code></pre>"},{"location":"it/module-04/methods-attributes/#14315-per-i-riferimenti-java-sceglie-il-tipo-di-riferimento-piu-specifico","title":"14.3.1.5 \u2014 Per i riferimenti, Java sceglie il tipo di riferimento pi\u00f9 specifico","text":"<pre><code>void ref(Object o)      { System.out.println(\"Object\"); }\nvoid ref(String s)      { System.out.println(\"String\"); }\n\nref(\"abc\");             // \"abc\" \u00e8 una String \u2192 pi\u00f9 specifica di Object\n                        // Output: String\n</code></pre> <p>Pi\u00f9 specifico significa pi\u00f9 in basso nella gerarchia di ereditariet\u00e0.</p> <p></p>"},{"location":"it/module-04/methods-attributes/#14316-quando-non-esiste-un-piu-specifico-non-ambiguo-la-chiamata-genera-un-errore-di-compilazione","title":"14.3.1.6 \u2014 Quando non esiste un \u201cpi\u00f9 specifico\u201d non ambiguo, la chiamata genera un errore di compilazione","text":"<p>Esempio con classi sorelle:</p> <pre><code>void check(Number n)      { System.out.println(\"Number\"); }\nvoid check(String s)      { System.out.println(\"String\"); }\n\ncheck(null);    // Sia String che Number accettano null\n                // String \u00e8 pi\u00f9 specifica perch\u00e9 \u00e8 una classe concreta\n                // Output: String\n</code></pre> <p>Ma se competono due classi non correlate:</p> <pre><code>void run(String s)   { }\nvoid run(Integer i)  { }\n\nrun(null);  // \u274c Errore a compile-time: chiamata di metodo ambigua\n</code></pre> <p></p>"},{"location":"it/module-04/methods-attributes/#14317-overload-misti-primitivi-wrapper","title":"14.3.1.7 \u2014 Overload misti primitivi + wrapper","text":"<p>Java valuta <code>widening</code>, <code>boxing</code> e <code>varargs</code> in questo ordine:</p> <p><code>widening \u2192 boxing \u2192 varargs</code></p> <ul> <li>Esempio:</li> </ul> <pre><code>void mix(long x)        { System.out.println(\"long\"); }\nvoid mix(Integer x)     { System.out.println(\"Integer\"); }\nvoid mix(int... x)      { System.out.println(\"varargs\"); }\n\nshort s = 5;\nmix(s);   // short \u2192 int \u2192 long  (widening)\n          // boxing e varargs ignorati\n          // Output: long\n</code></pre> <p></p>"},{"location":"it/module-04/methods-attributes/#14318-quando-i-primitivi-si-mescolano-con-i-tipi-reference","title":"14.3.1.8 \u2014 Quando i primitivi si mescolano con i tipi reference","text":"<pre><code>void fun(Object o)     { System.out.println(\"Object\"); }\nvoid fun(int x)        { System.out.println(\"int\"); }\n\nfun(10);                // vince la corrispondenza primitiva esatta\n                        // Output: int\n\nInteger i = 10;\nfun(i);                 // riferimento accettato \u2192 Object\n                        // Output: Object\n</code></pre>"},{"location":"it/module-04/methods-attributes/#14319-quando-vince-object","title":"14.3.1.9 \u2014 Quando vince Object","text":"<pre><code>void fun(List&lt;String&gt; o)    { System.out.println(\"O\"); }\nvoid fun(CharSequence x)    { System.out.println(\"X\"); }\nvoid fun(Object y)          { System.out.println(\"Y\"); }\n\nfun(LocalDate.now());       // Output: Y\n</code></pre>"},{"location":"it/module-04/methods-attributes/#143110-tabella-riassuntiva-risoluzione-delloverload","title":"14.3.1.10 Tabella riassuntiva (Risoluzione dell\u2019overload)","text":"Situation Rule Exact match Sempre scelto Primitive widening vs boxing Vince il widening Boxing vs varargs Vince il boxing Most specific reference type Vince Unrelated reference types Ambiguo \u2192 errore di compilazione Mixed primitive + wrapper Widening \u2192 boxing \u2192 varargs"},{"location":"it/module-04/methods-attributes/#144-variabili-locali-e-di-istanza","title":"14.4 Variabili locali e di istanza","text":""},{"location":"it/module-04/methods-attributes/#1441-variabili-di-istanza","title":"14.4.1 Variabili di istanza","text":"<p>Le variabili di istanza sono:</p> <ul> <li>dichiarate come membri di una classe</li> <li>create quando un oggetto \u00e8 istanziato</li> <li>accessibili da tutti i metodi dell\u2019istanza</li> </ul> <p>Modificatori possibili per le variabili di istanza:</p> <ul> <li>modificatori di accesso (<code>public</code>, <code>protected</code>, <code>private</code>, <code>package-private</code>)</li> <li><code>final</code></li> <li><code>volatile</code></li> <li> <p><code>transient</code></p> </li> <li> <p>Esempio:</p> </li> </ul> <pre><code>public class Person {\n    private String name;         // variabile di istanza\n    protected final int age = 0; // final significa che non pu\u00f2 essere riassegnata\n}\n</code></pre> <p></p>"},{"location":"it/module-04/methods-attributes/#1442-variabili-locali","title":"14.4.2 Variabili locali","text":"<p>Le variabili locali:</p> <ul> <li>sono dichiarate all\u2019interno di un metodo, costruttore o blocco</li> <li>non hanno valori di default \u2192 devono essere inizializzate esplicitamente prima dell\u2019uso</li> <li> <p>unico modificatore consentito: final</p> </li> <li> <p>Esempio:</p> </li> </ul> <pre><code>void calculate() {\n    int x;        // dichiarata\n    x = 10;       // deve essere inizializzata prima dell\u2019uso\n\n    final int y = 5;  // legale\n}\n</code></pre> <p>Due casi speciali:</p> <p></p>"},{"location":"it/module-04/methods-attributes/#14421-variabili-locali-effettivamente-final","title":"14.4.2.1 Variabili locali effettivamente final","text":"<p>Una variabile locale \u00e8 effettivamente final se viene assegnata una sola volta, anche senza <code>final</code>.</p> <p>Le variabili effettivamente final possono essere usate in:</p> <ul> <li>espressioni lambda</li> <li>classi locali/anonime</li> </ul> <p></p>"},{"location":"it/module-04/methods-attributes/#14422-parametri-come-effettivamente-final","title":"14.4.2.2 Parametri come effettivamente final","text":"<p>I parametri di metodo si comportano come variabili locali e seguono le stesse regole.</p> <p></p>"},{"location":"it/module-04/methods-attributes/#145-varargs-liste-di-argomenti-a-lunghezza-variabile","title":"14.5 Varargs (Liste di argomenti a lunghezza variabile)","text":"<p>I varargs permettono a un metodo di accettare zero o pi\u00f9 parametri dello stesso tipo.</p> <p>Sintassi:</p> <pre><code>void printNames(String... names)\n</code></pre> <p>Regole:</p> <ul> <li>Un metodo pu\u00f2 avere un solo parametro varargs.</li> <li>Deve essere l\u2019ultimo parametro nella lista.</li> <li> <p>I varargs sono trattati come un array all\u2019interno del metodo.</p> </li> <li> <p>Esempio:</p> </li> </ul> <pre><code>void show(int x, String... values) {\n    System.out.println(values.length);\n}\n\nshow(10);                     // length = 0\nshow(10, \"A\");                // length = 1\nshow(10, \"A\", \"B\", \"C\");      // length = 3\n</code></pre> <p>Important</p> <p>Varargs e array partecipano all\u2019overloading dei metodi. La risoluzione dell\u2019overload pu\u00f2 diventare ambigua.</p> <p></p>"},{"location":"it/module-04/methods-attributes/#146-metodi-statici-variabili-statiche-e-inizializzatori-statici","title":"14.6 Metodi statici, variabili statiche e inizializzatori statici","text":"<p>In Java, la keyword <code>static</code> marca elementi che appartengono alla classe stessa, non alle singole istanze. Questo significa:</p> <ul> <li>Sono caricati una sola volta in memoria quando la classe \u00e8 caricata per la prima volta dalla JVM.</li> <li>Sono condivisi tra tutte le istanze.</li> <li>Vi si puo accedere senza creare un oggetto della classe.</li> </ul> <p>I membri statici sono memorizzati nella method area della JVM (memoria a livello di classe), mentre i membri di istanza vivono nello heap.</p> <p></p>"},{"location":"it/module-04/methods-attributes/#1461-variabili-statiche-variabili-di-classe","title":"14.6.1 Variabili statiche (Variabili di classe)","text":"<p>Una variabile statica \u00e8 una variabile definita a livello di classe e condivisa da tutte le istanze.</p> <p>Caratteristiche:</p> <ul> <li>Create quando la classe \u00e8 caricata.</li> <li>Esistono anche se nessuna istanza della classe \u00e8 creata.</li> <li>Tutti gli oggetti vedono lo stesso valore.</li> <li> <p>Possono essere marcate <code>final</code>, <code>volatile</code> o <code>transient</code>.</p> </li> <li> <p>Esempio:</p> </li> </ul> <pre><code>public class Counter {\n    static int count = 0;    // condivisa da tutte le istanze\n    int id;                  // variabile di istanza\n\n    public Counter() {\n        count++;\n        id = count;          // ogni istanza ottiene un id unico\n    }\n}\n</code></pre> <p></p>"},{"location":"it/module-04/methods-attributes/#1462-metodi-statici","title":"14.6.2 Metodi statici","text":"<p>Un metodo statico appartiene alla classe, non a una istanza dell\u2019oggetto.</p> <p>Regole:</p> <ul> <li>Possono essere chiamati usando il nome della classe: <code>ClassName.method()</code>.</li> <li>Non possono accedere direttamente a variabili o metodi di istanza, ma solo tramite un\u2019istanza della classe.</li> <li>Non possono usare <code>this</code> o <code>super</code>.</li> <li>Sono comunemente usati per:</li> <li> <ul> <li>metodi di utilit\u00e0 (es. <code>Math.sqrt()</code>)</li> </ul> </li> <li> <ul> <li>factory methods</li> </ul> </li> <li> <ul> <li>comportamenti globali che non dipendono dallo stato di istanza</li> </ul> </li> <li> <p>Esempio:</p> </li> </ul> <pre><code>public class MathUtil {\n\n    static int square(int x) {        // metodo statico\n        return x * x;\n    }\n\n    void instanceMethod() {\n        // System.out.println(count);   // OK: accesso a variabile statica\n        // square(5);                   // OK: metodo statico accessibile\n    }\n}\n</code></pre> <p>Errori comuni:</p> <pre><code>// \u274c Errore di compilazione: metodo di istanza non accessibile direttamente in contesto statico\nstatic void go() {\n    run();        // run() \u00e8 un metodo di istanza!\n}\n\nvoid run() { }\n</code></pre> <p></p>"},{"location":"it/module-04/methods-attributes/#1463-blocchi-di-inizializzazione-statica","title":"14.6.3 Blocchi di inizializzazione statica","text":"<p>I blocchi di inizializzazione statica permettono di eseguire codice una sola volta, quando la classe \u00e8 caricata.</p> <p>Sintassi:</p> <pre><code>static {\n    // logica di inizializzazione\n}\n</code></pre> <p>Utilizzo:</p> <ul> <li>inizializzazione di variabili statiche complesse</li> <li>esecuzione di setup a livello di classe</li> <li> <p>esecuzione di codice che deve essere eseguito esattamente una volta</p> </li> <li> <p>Esempio:</p> </li> </ul> <pre><code>public class Config {\n\n    static final Map&lt;String, String&gt; settings = new HashMap&lt;&gt;();\n\n    static {\n        settings.put(\"mode\", \"production\");\n        settings.put(\"version\", \"1.0\");\n        System.out.println(\"Static initializer executed\");\n    }\n}\n</code></pre> <p>Important</p> <p>I blocchi di inizializzazione statica vengono eseguiti una sola volta, nell\u2019ordine in cui appaiono, prima di <code>main()</code> e prima che qualsiasi metodo statico sia chiamato.</p> <p></p>"},{"location":"it/module-04/methods-attributes/#1464-ordine-di-inizializzazione-statico-vs-istanza","title":"14.6.4 Ordine di inizializzazione (Statico vs. Istanza)","text":"<p>( Fare riferimento al Capitolo: Class Loading, Inizializzazione, e Costruzione degli Oggetti )</p> <p></p>"},{"location":"it/module-04/methods-attributes/#1465-accesso-ai-membri-statici","title":"14.6.5 Accesso ai membri statici","text":""},{"location":"it/module-04/methods-attributes/#14651-utilizzare-nome-della-classe","title":"14.6.5.1 Utilizzare nome della classe","text":"<pre><code>Math.sqrt(16);\nMyClass.staticMethod();\n</code></pre>"},{"location":"it/module-04/methods-attributes/#14652-utilizzare-riferimento-di-istanza","title":"14.6.5.2 Utilizzare riferimento di istanza","text":"<pre><code>MyClass obj = new MyClass();\nobj.staticMethod();\n</code></pre>"},{"location":"it/module-04/methods-attributes/#1466-static-ed-ereditarieta","title":"14.6.6 Static ed ereditariet\u00e0","text":"<p>I metodi statici:</p> <ul> <li>possono essere nascosti, non sovrascritti</li> <li>il binding \u00e8 a compile-time, non a runtime</li> <li> <p>sono accessi in base al tipo del riferimento, non al tipo dell\u2019oggetto</p> </li> <li> <p>Esempio:</p> </li> </ul> <pre><code>class A {\n    static void test() { System.out.println(\"A\"); }\n}\n\nclass B extends A {\n    static void test() { System.out.println(\"B\"); }\n}\n\nA ref = new B();\nref.test();   // stampa \"A\" \u2014 binding statico!\n</code></pre> <p>Note</p> <p>Regola chiave: i metodi statici usano il tipo del riferimento, non il tipo dell\u2019oggetto.</p> <p></p>"},{"location":"it/module-04/methods-attributes/#1467-errori-comuni","title":"14.6.7 Errori comuni","text":"<ul> <li>Tentare di riferirsi a una variabile/metodo di istanza da un contesto statico.</li> <li>Supporre che i metodi statici siano sovrascritti \u2192 sono nascosti.</li> <li>Chiamare un metodo statico da un riferimento di istanza (legale ma confondente).</li> <li>Confondere l\u2019ordine di inizializzazione degli elementi statici rispetto a quelli di istanza.</li> <li>Dimenticare che le variabili statiche sono condivise tra tutti gli oggetti.</li> <li>Non sapere che gli inizializzatori statici vengono eseguiti una sola volta, in ordine di dichiarazione.</li> </ul>"},{"location":"it/module-05/functional/","title":"20. Programmazione Funzionale in Java","text":""},{"location":"it/module-05/functional/#indice","title":"Indice","text":"<ul> <li>20.1 Interfacce Funzionali<ul> <li>20.1.1 Regole per le Interfacce Funzionali</li> <li>20.1.2 Interfacce Funzionali Comuni (java.util.function)</li> <li>20.1.3 Metodi di Comodit\u00e0 nelle Interfacce Funzionali</li> <li>20.1.4 Interfacce Funzionali Primitive</li> <li>20.1.5 Riepilogo</li> </ul> </li> <li>20.2 Espressioni Lambda<ul> <li>20.2.1 Sintassi delle Espressioni Lambda</li> <li>20.2.2 Esempi di Sintassi Lambda</li> <li>20.2.3 Regole per le Espressioni Lambda</li> <li>20.2.4 Inferenza di Tipo</li> <li>20.2.5 Restrizioni nei Corpi delle Lambda</li> <li>20.2.6 Regole sul Tipo di Ritorno</li> <li>20.2.7 Lambda vs Classi Anonime</li> <li>20.2.8 Errori Comuni nelle Lambda Trappole da Certificazione</li> </ul> </li> <li>20.3 Riferimenti a Metodi<ul> <li>20.3.1 Riferimento a un Metodo Statico</li> <li>20.3.2 Riferimento a un Metodo d\u2019Istanza di un Oggetto Specifico</li> <li>20.3.3 Riferimento a un Metodo d\u2019Istanza di un Oggetto Arbitrario di un Dato Tipo</li> <li>20.3.4 Riferimento a un Costruttore</li> <li>20.3.5 Tabella Riassuntiva dei Tipi di Method Reference</li> <li>20.3.6 Errori Comuni</li> </ul> </li> </ul> <p>La <code>programmazione funzionale</code> \u00e8 un paradigma di programmazione che si concentra sul descrivere cosa deve essere fatto, piuttosto che come deve essere fatto.</p> <p>A partire da Java 8, il linguaggio ha aggiunto diverse funzionalit\u00e0 che abilitano uno stile di programmazione \u201cfunzionale\u201d: <code>lambda expressions</code>, <code>functional interfaces</code> e <code>method references</code>.</p> <p>Queste funzionalit\u00e0 permettono agli sviluppatori di scrivere codice pi\u00f9 espressivo, conciso e riutilizzabile, soprattutto quando si lavora con collezioni, API di concorrenza e sistemi event-driven.</p> <p></p>"},{"location":"it/module-05/functional/#201-interfacce-funzionali","title":"20.1 Interfacce Funzionali","text":"<p>In Java, un\u2019interfaccia funzionale \u00e8 un\u2019interfaccia che contiene esattamente un solo metodo astratto.</p> <p>Le interfacce funzionali abilitano Lambda Expressions e Method References, formando il nucleo del modello di programmazione funzionale di Java.</p> <p>Note</p> <p>Java tratta automaticamente come interfaccia funzionale qualsiasi interfaccia con un solo metodo astratto. L\u2019annotazione <code>@FunctionalInterface</code> \u00e8 opzionale ma consigliata.</p> <p></p>"},{"location":"it/module-05/functional/#2011-regole-per-le-interfacce-funzionali","title":"20.1.1 Regole per le Interfacce Funzionali","text":"<ul> <li>Esattamente un metodo astratto (SAM = Single Abstract Method).</li> <li>Le interfacce possono dichiarare un numero qualsiasi di metodi default, static o private.</li> <li>Possono fare override dei metodi di <code>Object</code> (<code>toString()</code>, <code>equals(Object)</code>, <code>hashCode()</code>) senza influenzare il conteggio SAM.</li> <li>Il metodo funzionale pu\u00f2 provenire da una superinterfaccia.</li> </ul> <p>Esempio:</p> <pre><code>@FunctionalInterface\ninterface Adder {\n    int add(int a, int b);   // single abstract method\n    static void info() {}\n    default void log() {}\n}\n</code></pre> <p></p>"},{"location":"it/module-05/functional/#2012-interfacce-funzionali-comuni-javautilfunction","title":"20.1.2 Interfacce Funzionali Comuni (java.util.function)","text":"<p>Di seguito un riepilogo delle interfacce funzionali pi\u00f9 importanti.</p> Functional Interface Returns Method Parameters <code>Supplier&lt;T&gt;</code> T get() 0 <code>Consumer&lt;T&gt;</code> void accept(T) 1 <code>BiConsumer&lt;T,U&gt;</code> void accept(T,U) 2 <code>Function&lt;T,R&gt;</code> R apply(T) 1 <code>BiFunction&lt;T,U,R&gt;</code> R apply(T,U) 2 <code>UnaryOperator&lt;T&gt;</code> T apply(T) 1 (stessi tipi) <code>BinaryOperator&lt;T&gt;</code> T apply(T,T) 2 (stessi tipi) <code>Predicate&lt;T&gt;</code> boolean test(T) 1 <code>BiPredicate&lt;T,U&gt;</code> boolean test(T,U) 2 <ul> <li>Esempi</li> </ul> <pre><code>Supplier&lt;String&gt; sup = () -&gt; \"Hello!\";\n\nConsumer&lt;String&gt; printer = s -&gt; System.out.println(s);\n\nFunction&lt;String, Integer&gt; length = s -&gt; s.length();\n\nUnaryOperator&lt;Integer&gt; square = x -&gt; x * x;\n\nPredicate&lt;Integer&gt; positive = x -&gt; x &gt; 0;\n</code></pre> <p></p>"},{"location":"it/module-05/functional/#2013-metodi-di-comodita-nelle-interfacce-funzionali","title":"20.1.3 Metodi di Comodit\u00e0 nelle Interfacce Funzionali","text":"<p>Molte interfacce funzionali includono metodi di supporto che consentono chaining e composizione.</p> Interface Method Description Function andThen() applica questa funzione, poi un\u2019altra Function compose() applica un\u2019altra funzione, poi questa Function identity() restituisce una funzione x -&gt; x Predicate and() AND logico Predicate or() OR logico Predicate negate() NOT logico Consumer andThen() concatena consumer BinaryOperator minBy() minimo basato su comparator BinaryOperator maxBy() massimo basato su comparator <ul> <li>Esempi</li> </ul> <pre><code>Function&lt;Integer, Integer&gt; times2 = x -&gt; x * 2;\nFunction&lt;Integer, Integer&gt; plus3  = x -&gt; x + 3;\n\nvar result1 = times2.andThen(plus3).apply(5);   // (5*2)+3 = 13\nvar result2 = times2.compose(plus3).apply(5);   // (5+3)*2 = 16\n\nPredicate&lt;String&gt; longString = s -&gt; s.length() &gt; 5;\nPredicate&lt;String&gt; startsWithA = s -&gt; s.startsWith(\"A\");\n\nboolean ok = longString.and(startsWithA).test(\"Amazing\");  // true\n</code></pre> <p></p>"},{"location":"it/module-05/functional/#2014-interfacce-funzionali-primitive","title":"20.1.4 Interfacce Funzionali Primitive","text":"<p>Java fornisce versioni specializzate delle interfacce funzionali per i tipi primitivi, per evitare overhead di boxing/unboxing.</p> Functional Interface Return Type Single Abstract Method # Parameters IntSupplier int getAsInt() 0 LongSupplier long getAsLong() 0 DoubleSupplier double getAsDouble() 0 BooleanSupplier boolean getAsBoolean() 0 IntConsumer void accept(int) 1 (int) LongConsumer void accept(long) 1 (long) DoubleConsumer void accept(double) 1 (double) IntPredicate boolean test(int) 1 (int) LongPredicate boolean test(long) 1 (long) DoublePredicate boolean test(double) 1 (double) IntUnaryOperator int applyAsInt(int) 1 (int) LongUnaryOperator long applyAsLong(long) 1 (long) DoubleUnaryOperator double applyAsDouble(double) 1 (double) IntBinaryOperator int applyAsInt(int, int) 2 (int,int) LongBinaryOperator long applyAsLong(long, long) 2 (long,long) DoubleBinaryOperator double applyAsDouble(double,double) 2 IntFunction R apply(int) 1 (int) LongFunction R apply(long) 1 (long) DoubleFunction R apply(double) 1 (double) ToIntFunction int applyAsInt(T) 1 (T) ToLongFunction long applyAsLong(T) 1 (T) ToDoubleFunction double applyAsDouble(T) 1 (T) ToIntBiFunction int applyAsInt(T,U) 2 (T,U) ToLongBiFunction long applyAsLong(T,U) 2 (T,U) ToDoubleBiFunction double applyAsDouble(T,U) 2 (T,U) ObjIntConsumer void accept(T,int) 2 (T,int) ObjLongConsumer void accept(T,long) 2 (T,long) ObjDoubleConsumer void accept(T,double) 2 (T,double) DoubleToIntFunction int applyAsInt(double) 1 DoubleToLongFunction long applyAsLong(double) 1 IntToDoubleFunction double applyAsDouble(int) 1 IntToLongFunction long applyAsLong(int) 1 LongToDoubleFunction double applyAsDouble(long) 1 LongToIntFunction int applyAsInt(long) 1 <ul> <li>Esempio</li> </ul> <pre><code>IntSupplier dice = () -&gt; (int)(Math.random() * 6) + 1;\n\nIntPredicate even = x -&gt; x % 2 == 0;\n\nIntUnaryOperator doubleIt = x -&gt; x * 2;\n</code></pre> <p></p>"},{"location":"it/module-05/functional/#2015-riepilogo","title":"20.1.5 Riepilogo","text":"<ul> <li>Le interfacce funzionali contengono esattamente un metodo astratto (SAM).</li> <li>Sono alla base di Lambda e Method References.</li> <li>Java offre molte FI built-in in <code>java.util.function</code>.</li> <li>Le varianti primitive migliorano le performance rimuovendo il boxing.</li> </ul>"},{"location":"it/module-05/functional/#202-espressioni-lambda","title":"20.2 Espressioni Lambda","text":"<p>Una lambda expression \u00e8 un modo compatto di scrivere una funzione.</p> <p>Le lambda expressions offrono un modo conciso per definire implementazioni di interfacce funzionali.</p> <p>Una lambda \u00e8 essenzialmente un piccolo blocco di codice che accetta parametri e restituisce un valore, senza richiedere una dichiarazione completa di metodo.</p> <p>Rappresentano il comportamento come dato e sono un elemento chiave del modello di programmazione funzionale in Java.</p> <p></p>"},{"location":"it/module-05/functional/#2021-sintassi-delle-espressioni-lambda","title":"20.2.1 Sintassi delle Espressioni Lambda","text":"<p>La sintassi generale \u00e8:</p> <p><code>(parameters) -&gt; expression</code> oppure <code>(parameters) -&gt; { statements }</code></p> <p></p>"},{"location":"it/module-05/functional/#2022-esempi-di-sintassi-lambda","title":"20.2.2 Esempi di Sintassi Lambda","text":"<p>Zero parametri <pre><code>Runnable r = () -&gt; System.out.println(\"Hello\");\n</code></pre></p> <p>Un parametro (parentesi opzionali) <pre><code>Consumer&lt;String&gt; c = s -&gt; System.out.println(s);\n</code></pre></p> <p>Pi\u00f9 parametri <pre><code>BinaryOperator&lt;Integer&gt; add = (a, b) -&gt; a + b;\n</code></pre></p> <p>Con block body <pre><code>Function&lt;Integer, String&gt; f = (x) -&gt; {\n    int doubled = x * 2;\n    return \"Value: \" + doubled;\n};\n</code></pre></p> <p></p>"},{"location":"it/module-05/functional/#2023-regole-per-le-espressioni-lambda","title":"20.2.3 Regole per le Espressioni Lambda","text":"<ul> <li>I tipi dei parametri possono essere omessi (type inference).</li> <li>Se un parametro ha un tipo, allora tutti i parametri devono specificare il tipo.</li> <li>Un singolo parametro non richiede parentesi.</li> <li>Pi\u00f9 parametri richiedono le parentesi.</li> <li>Se il corpo \u00e8 una singola espressione (senza <code>{ }</code>), <code>return</code> non \u00e8 consentito; l\u2019espressione stessa \u00e8 il valore di ritorno.</li> <li>Se il corpo usa <code>{ }</code> (un blocco), <code>return</code> deve comparire se viene restituito un valore.</li> <li>Le lambda possono essere assegnate solo a interfacce funzionali (tipi SAM).</li> </ul>"},{"location":"it/module-05/functional/#2024-inferenza-di-tipo","title":"20.2.4 Inferenza di Tipo","text":"<p>Il compilatore deduce il tipo della lambda dal contesto dell\u2019interfaccia funzionale target.</p> <pre><code>Predicate&lt;String&gt; p = s -&gt; s.isEmpty();  // s inferito come String\n</code></pre> <p>Se il compilatore non riesce a inferire il tipo, devi specificarlo esplicitamente.</p> <pre><code>BiFunction&lt;Integer, Integer, Integer&gt; f = (Integer a, Integer b) -&gt; a * b;\n</code></pre> <p></p>"},{"location":"it/module-05/functional/#2025-restrizioni-nei-corpi-delle-lambda","title":"20.2.5 Restrizioni nei Corpi delle Lambda","text":"<p>Le lambda possono catturare solo variabili locali che sono final o effectively final (non riassegnate).</p> <pre><code>int x = 10;\nRunnable r = () -&gt; {\n    // x++;   // \u274c errore di compilazione \u2014 x deve essere effectively final\n    System.out.println(x);\n};\n</code></pre> <p>Possono invece modificare lo stato di un oggetto (solo i riferimenti devono essere effectively final).</p> <pre><code>var list = new ArrayList&lt;&gt;();\nRunnable r2 = () -&gt; list.add(\"OK\");  // consentito\n</code></pre> <p></p>"},{"location":"it/module-05/functional/#2026-regole-sul-tipo-di-ritorno","title":"20.2.6 Regole sul Tipo di Ritorno","text":"<p>Se il corpo \u00e8 un\u2019espressione: l\u2019espressione \u00e8 il valore di ritorno.</p> <pre><code>Function&lt;Integer, Integer&gt; f = x -&gt; x * 2;\n</code></pre> <p>Se il corpo \u00e8 un blocco: devi includere <code>return</code>.</p> <pre><code>Function&lt;Integer, Integer&gt; g = x -&gt; {\n    return x * 2;\n};\n</code></pre> <p></p>"},{"location":"it/module-05/functional/#2027-lambda-vs-classi-anonime","title":"20.2.7 Lambda vs Classi Anonime","text":"<ul> <li>Le lambda NON creano un nuovo scope: condividono lo scope contenitore.</li> <li><code>this</code> dentro una lambda si riferisce all\u2019oggetto contenitore, non alla lambda.</li> </ul> <pre><code>class Test {\n    void run() {\n        Runnable r = () -&gt; System.out.println(this.toString());\n    }\n}\n</code></pre> <p>Nelle classi anonime, <code>this</code> si riferisce all\u2019istanza della classe anonima.</p> <p></p>"},{"location":"it/module-05/functional/#2028-errori-comuni-nelle-lambda-trappole-da-certificazione","title":"20.2.8 Errori Comuni nelle Lambda (Trappole da Certificazione)","text":"<p>Tipi di ritorno incoerenti <pre><code>x -&gt; { if (x &gt; 0) return 1; }  // \u274c manca return per il caso negativo\n</code></pre></p> <p>Mescolare parametri tipizzati e non tipizzati <pre><code>(a, int b) -&gt; a + b   // \u274c illegale\n</code></pre></p> <p>Restituire un valore da una lambda con target void <pre><code>Runnable r = () -&gt; 5;  // \u274c Runnable.run() restituisce void\n</code></pre></p> <p>Risoluzione di overload ambigua</p> <pre><code>void m(IntFunction&lt;Integer&gt; f) {}\nvoid m(Function&lt;Integer, Integer&gt; f) {}\n\nm(x -&gt; x + 1);  // \u274c ambiguo\n</code></pre> <p></p>"},{"location":"it/module-05/functional/#203-riferimenti-a-metodi","title":"20.3 Riferimenti a Metodi","text":"<p>I riferimenti a metodi (method references) forniscono una sintassi abbreviata per usare un metodo esistente come implementazione di un\u2019interfaccia funzionale.</p> <p>Sono equivalenti alle lambda expressions, ma pi\u00f9 concisi, leggibili e spesso preferibili quando il metodo target esiste gi\u00e0.</p> <p>Esistono quattro categorie di method references in Java:</p> <ul> <li> <ol> <li>Riferimento a un metodo statico (<code>ClassName::staticMethod</code>)</li> </ol> </li> <li> <ol> <li>Riferimento a un metodo d\u2019istanza di un oggetto specifico (<code>instance::method</code>)</li> </ol> </li> <li> <ol> <li>Riferimento a un metodo d\u2019istanza di un oggetto arbitrario di un dato tipo (<code>ClassName::instanceMethod</code>)</li> </ol> </li> <li> <ol> <li>Riferimento a un costruttore (<code>ClassName::new</code>)</li> </ol> </li> </ul> <p></p>"},{"location":"it/module-05/functional/#2031-riferimento-a-un-metodo-statico","title":"20.3.1 Riferimento a un Metodo Statico","text":"<p>Un method reference statico sostituisce una lambda che invoca un metodo statico.</p> <pre><code>class Utils {\n    static int square(int x) { return x * x; }\n}\n\nFunction&lt;Integer, Integer&gt; f1 = x -&gt; Utils.square(x);\nFunction&lt;Integer, Integer&gt; f2 = Utils::square;  // method reference\n</code></pre> <p>Sia <code>f1</code> che <code>f2</code> si comportano in modo identico.</p> <p></p>"},{"location":"it/module-05/functional/#2032-riferimento-a-un-metodo-distanza-di-un-oggetto-specifico","title":"20.3.2 Riferimento a un Metodo d\u2019Istanza di un Oggetto Specifico","text":"<p>Usato quando hai gi\u00e0 un\u2019istanza di un oggetto e vuoi riferirti a uno dei suoi metodi.</p> <pre><code>String prefix = \"Hello, \";\n\nUnaryOperator&lt;String&gt; op1 = s -&gt; prefix.concat(s);\nUnaryOperator&lt;String&gt; op2 = prefix::concat;   // method reference\n\nSystem.out.println(op2.apply(\"World\"));\n</code></pre> <p>Il riferimento <code>prefix::concat</code> lega <code>concat</code> a quell\u2019oggetto specifico.</p> <p></p>"},{"location":"it/module-05/functional/#2033-riferimento-a-un-metodo-distanza-di-un-oggetto-arbitrario-di-un-dato-tipo","title":"20.3.3 Riferimento a un Metodo d\u2019Istanza di un Oggetto Arbitrario di un Dato Tipo","text":"<p>Questa \u00e8 la forma pi\u00f9 \u201cinsidiosa\u201d.</p> <p>Il primo parametro dell\u2019interfaccia funzionale diventa il receiver del metodo (<code>this</code>).</p> <pre><code>BiPredicate&lt;String, String&gt; p1 = (s1, s2) -&gt; s1.equals(s2);\nBiPredicate&lt;String, String&gt; p2 = String::equals;   // method reference\n\nSystem.out.println(p2.test(\"abc\", \"abc\"));  // true\n</code></pre> <p>Note</p> <p>Questa forma applica il metodo al primo argomento della lambda.</p> <p></p>"},{"location":"it/module-05/functional/#2034-riferimento-a-un-costruttore","title":"20.3.4 Riferimento a un Costruttore","text":"<p>I constructor references sostituiscono lambda che invocano <code>new</code>.</p> <pre><code>Supplier&lt;ArrayList&lt;String&gt;&gt; sup1 = () -&gt; new ArrayList&lt;&gt;();\nSupplier&lt;ArrayList&lt;String&gt;&gt; sup2 = ArrayList::new; // method reference\n\nFunction&lt;Integer, ArrayList&lt;String&gt;&gt; sup3 = ArrayList::new;\n// invoca il costruttore ArrayList(int capacity)\n</code></pre> <p></p>"},{"location":"it/module-05/functional/#2035-tabella-riassuntiva-dei-tipi-di-method-reference","title":"20.3.5 Tabella Riassuntiva dei Tipi di Method Reference","text":"<p>La tabella seguente riassume tutte le categorie di method reference.</p> Type Syntax Example Equivalent Lambda Static method Class::staticMethod x -&gt; Class.staticMethod(x) Instance method of specific object instance::method x -&gt; instance.method(x) Instance method of arbitrary object Class::method (obj, x) -&gt; obj.method(x) Constructor Class::new () -&gt; new Class() <p></p>"},{"location":"it/module-05/functional/#2036-errori-comuni","title":"20.3.6 Errori Comuni","text":"<ul> <li>Un method reference deve combaciare esattamente con la signature dell\u2019interfaccia funzionale.</li> <li>Gli overload possono rendere i method references ambigui.</li> <li>Il riferimento a metodo d\u2019istanza (<code>Class::method</code>) sposta il receiver al parametro 1.</li> <li>Un constructor reference fallisce se non esiste un costruttore compatibile.</li> </ul> <pre><code>// \u274c Ambiguo: quale println()? (println(int), println(String)...)\nConsumer&lt;String&gt; c = System.out::println; // OK solo perch\u00e9 il parametro FI \u00e8 String\n\n// \u274c Costruttore non compatibile: interfaccia funzionale errata\nSupplier&lt;Integer&gt; s = Integer::new;          // \u2714 OK: invoca Integer()\nFunction&lt;String, Long&gt; f = Integer::new;     // \u274c ERRORE: il costruttore restituisce Integer, non Long\n</code></pre> <p>In caso di dubbio, riscrivi il method reference come una lambda: se la lambda funziona ma il method reference no, il problema \u00e8 quasi sempre il matching della signature.</p>"},{"location":"it/module-05/streams/","title":"21. Java Optional e Streams","text":""},{"location":"it/module-05/streams/#indice","title":"Indice","text":"<ul> <li>21.1 Optional (Optional OptionalInt OptionalLong OptionalDouble)<ul> <li>21.1.1 Creare Optional</li> <li>21.1.2 Leggere valori in sicurezza</li> <li>21.1.3 Trasformare Optional</li> <li>21.1.4 Optional e Stream</li> <li>21.1.5 Optional per tipi primitivi</li> <li>21.1.6 Trappole comuni</li> </ul> </li> <li>21.2 Che Cos\u2019\u00e8 uno Stream (E cosa Non \u00e8)</li> <li>21.3 Architettura della Pipeline Stream<ul> <li>21.3.1 Sorgenti di Stream</li> <li>21.3.2 Operazioni Intermedie</li> <li>21.3.2.1 Tabella delle operazioni intermedie comuni</li> <li>21.3.3 Operazioni Terminali<ul> <li>21.3.3.1 Tabella delle operazioni terminali</li> </ul> </li> </ul> </li> <li>21.4 Valutazione Pigra e Short-Circuiting</li> <li>21.5 Operazioni Stateless vs Stateful<ul> <li>21.5.1 Operazioni Stateless</li> <li>21.5.2 Operazioni Stateful</li> </ul> </li> <li>21.6 Ordinamento degli Stream e Determinismo</li> <li>21.7 Stream Paralleli</li> <li>21.8 Operazioni di Riduzione<ul> <li>21.8.1 <code>reduce()</code>: combinare uno stream in un singolo oggetto<ul> <li>21.8.1.1 Modello mentale corretto</li> </ul> </li> <li>21.8.2 <code>collect()</code></li> <li>21.8.3 Perch\u00e9 <code>collect()</code> \u00e8 diverso da <code>reduce()</code></li> </ul> </li> <li>21.9 Trappole Comuni degli Stream</li> <li>21.10 Stream Primitivi<ul> <li>21.10.1 Perch\u00e9 gli stream primitivi sono importanti</li> <li>21.10.2 Metodi comuni di creazione</li> <li>21.10.3 Metodi di mapping specializzati per primitivi</li> <li>21.10.4 Tabella di mapping tra <code>Stream&lt;T&gt;</code> e stream primitivi</li> <li>21.10.5 Operazioni terminali e i loro tipi di risultato</li> <li>21.10.6 Trappole e gotcha comuni</li> </ul> </li> <li>21.11 Collector (collect(), Collector e i Metodi Factory di Collectors)<ul> <li>21.11.1 collect() vs Collector</li> <li>21.11.2 Collector core</li> <li>21.11.3 Collector di raggruppamento</li> <li>21.11.4 partitioningBy</li> <li>21.11.5 toMap e regole di merge</li> <li>21.11.6 collectingAndThen</li> <li>21.11.7 Come i collector si relazionano agli stream paralleli</li> </ul> </li> </ul>"},{"location":"it/module-05/streams/#211-optional-optional-optionalint-optionallong-optionaldouble","title":"21.1 Optional (Optional, OptionalInt, OptionalLong, OptionalDouble)","text":"<p><code>Optional&lt;T&gt;</code> \u00e8 un oggetto contenitore che pu\u00f2 contenere, o meno, un valore non-null. </p> <p>\u00c8 stato pensato per rendere esplicita l\u2019\u201cassenza di un valore\u201d e per ridurre il rischio di <code>NullPointerException</code> forzando i chiamanti a gestire il caso di \"assenza\".</p> <p>Note</p> <ul> <li><code>Optional</code> \u00e8 inteso principalmente per tipi di ritorno.</li> <li>\u00c8 generalmente sconsigliato per attributi, parametri di metodo e contesti di serializzazione (a meno che un contratto API specifico lo richieda).</li> </ul> <p></p>"},{"location":"it/module-05/streams/#2111-creare-optional","title":"21.1.1 Creare Optional","text":"<p>Ci sono tre metodi factory principali per creare Optional. </p> <ul> <li><code>Optional.of(value)</code> \u2192 value deve essere non-null; altrimenti viene lanciata <code>NullPointerException</code></li> <li><code>Optional.ofNullable(value)</code> \u2192 restituisce empty se value \u00e8 null</li> <li><code>Optional.empty()</code> \u2192 un Optional esplicitamente vuoto</li> </ul> <pre><code>Optional&lt;String&gt; a = Optional.of(\"x\");\nOptional&lt;String&gt; b = Optional.ofNullable(null); // Optional.empty\nOptional&lt;String&gt; c = Optional.empty();\n</code></pre> <p></p>"},{"location":"it/module-05/streams/#2112-leggere-valori-in-sicurezza","title":"21.1.2 Leggere valori in sicurezza","text":"<p>Gli Optional forniscono molteplici modi per accedere al valore incapsulato.</p> <ul> <li><code>isPresent()</code> / <code>isEmpty()</code> \u2192 test di presenza</li> <li><code>get()</code> \u2192 restituisce il valore o lancia <code>NoSuchElementException</code> se non presente (sconsigliato)</li> <li><code>orElse(defaultValue)</code> \u2192 restituisce valore o default (default valutato immediatamente)</li> <li><code>orElseGet(supplier)</code> \u2192 restituisce valore o risultato del supplier (supplier valutato lazily)</li> <li><code>orElseThrow()</code> \u2192 restituisce valore o lancia <code>NoSuchElementException</code></li> <li><code>orElseThrow(exceptionSupplier)</code> \u2192 restituisce valore o lancia eccezione personalizzata</li> </ul> <pre><code>Optional&lt;String&gt; opt = Optional.of(\"java\");\n\nString v1 = opt.orElse(\"default\");\nString v2 = opt.orElseGet(() -&gt; \"computed\");\nString v3 = opt.orElseThrow(); // ok perch\u00e9 opt \u00e8 presente\n</code></pre> <p>Note</p> <ul> <li>Una trappola comune: <code>orElse(...)</code> valuta il suo argomento anche se l\u2019Optional \u00e8 presente.</li> <li>Usa <code>orElseGet(...)</code> quando il default \u00e8 laborioso da calcolare.</li> </ul> <p></p>"},{"location":"it/module-05/streams/#2113-trasformare-optional","title":"21.1.3 Trasformare Optional","text":"<p>Gli Optional supportano trasformazioni funzionali simili agli stream, ma con semantica \u201c0 o 1 elemento\u201d.</p> <ul> <li><code>map(fn)</code> \u2192 trasforma il valore se presente</li> <li><code>flatMap(fn)</code> \u2192 trasforma in un Optional \"flattened\", senza annidamento</li> <li><code>filter(predicate)</code> \u2192 mantiene il valore solo se il predicate \u00e8 true</li> </ul> <pre><code>Optional&lt;String&gt; name = Optional.of(\"Alice\");\n\nOptional&lt;Integer&gt; len =\n    name.map(String::length); // Optional[5]\n\nOptional&lt;String&gt; filtered =\n    name.filter(n -&gt; n.startsWith(\"A\")); // Optional[Alice]\n\nSystem.out.println(len.orElse(0));\nSystem.out.println(filtered.orElseGet(() -&gt; \"11\"));\n</code></pre> <p>Output:</p> <pre><code>5\nAlice\n</code></pre> <p>Note</p> <ul> <li><code>map</code> incapsula il risultato in un Optional.</li> <li>Se la tua funzione di mapping restituisce gi\u00e0 un Optional, usa <code>flatMap</code> per evitare l\u2019annidamento <code>Optional&lt;Optional&lt;T&gt;&gt;</code>.</li> </ul> <p></p>"},{"location":"it/module-05/streams/#2114-optional-e-stream","title":"21.1.4 Optional e Stream","text":"<p>Un pattern di pipeline molto comune \u00e8 fare <code>map</code> verso un Optional e poi rimuovere gli \"assenti\". </p> <p>Da Java 9, <code>Optional</code> fornisce <code>stream()</code> per convertire \u201cpresente \u2192 un elemento\u201d e \u201cvuoto \u2192 zero elementi\u201d.</p> <pre><code>        Stream&lt;String&gt; words = Stream.of(\"a\", \"bb\", \"ccc\");\n\n        words.map(w -&gt; w.length() &gt; 1 ? Optional.of(w.length()) : Optional.&lt;Integer&gt;empty()).flatMap(Optional::stream) // rimuove gli elementi vuoti\n                .forEach(System.out::println); \n</code></pre> <p>Output:</p> <pre><code>2\n3\n</code></pre> <p>Note</p> <p>Prima di Java 9, questo pattern richiedeva <code>filter(Optional::isPresent)</code> pi\u00f9 <code>map(Optional::get)</code>.</p> <p></p>"},{"location":"it/module-05/streams/#2115-optional-per-tipi-primitivi","title":"21.1.5 Optional per tipi primitivi","text":"<p>Gli stream primitivi usano optional primitivi per evitare boxing: <code>OptionalInt</code>, <code>OptionalLong</code>, <code>OptionalDouble</code>. </p> <p>Essi rispecchiano la API principale di Optional con <code>getter</code> primitivi come <code>getAsInt()</code>.</p> <ul> <li><code>OptionalInt.getAsInt()</code> / <code>OptionalLong.getAsLong()</code> / <code>OptionalDouble.getAsDouble()</code></li> <li><code>orElse(...)</code> / <code>orElseGet(...)</code> / <code>orElseThrow(...)</code></li> </ul> <pre><code>OptionalInt m = IntStream.of(3, 1, 2).min(); // OptionalInt[1]\nint value = m.orElse(0); // 1\n</code></pre> <p></p>"},{"location":"it/module-05/streams/#2116-trappole-comuni","title":"21.1.6 Trappole comuni","text":"<ul> <li>Non usare <code>get()</code> senza controllare la presenza; si preferisca <code>orElseThrow</code> o trasformazioni</li> <li>Evita di restituire <code>null</code> invece di <code>Optional.empty()</code>; un riferimento Optional in s\u00e9 non dovrebbe essere null</li> <li>Ricorda: <code>average()</code> sugli stream primitivi restituisce sempre <code>OptionalDouble</code> (anche per <code>IntStream</code> e <code>LongStream</code>)</li> <li>Usa <code>orElseGet</code> quando calcolare il default \u00e8 costoso in termini di calcolo (Performances)</li> </ul>"},{"location":"it/module-05/streams/#212-che-cose-uno-stream-e-cosa-non-e","title":"21.2 Che Cos\u2019\u00e8 uno Stream (E cosa non \u00e8)","text":"<p>Uno <code>Stream Java</code> rappresenta una sequenza di elementi (una pipeline) che supporta operazioni in stile funzionale. </p> <p>Gli stream sono progettati per l\u2019elaborazione dei dati, non per l\u2019archiviazione degli stessi.</p> <p>Caratteristiche chiave:</p> <ul> <li>Uno stream non memorizza dati</li> <li>Uno stream \u00e8 Lazy \u2014 non succede nulla su di esso, finch\u00e9 non viene invocata un\u2019operazione terminale</li> <li>Uno stream pu\u00f2 essere consumato soltanto una volta</li> <li>Gli stream incoraggiano operazioni senza effetti collaterali</li> </ul> <p>Note</p> <p>Gli stream sono concettualmente simili a query di database: descrivono cosa calcolare, non come iterare.</p> <p></p>"},{"location":"it/module-05/streams/#213-architettura-della-pipeline-stream","title":"21.3 Architettura della Pipeline Stream","text":"<p>Ogni pipeline di stream consiste di tre fasi distinte:</p> <ul> <li>1\ufe0f Sorgente</li> <li>2\ufe0f Zero o pi\u00f9 Operazioni Intermedie</li> <li>3\ufe0f Esattamente una Operazione Terminale</li> </ul> <p></p>"},{"location":"it/module-05/streams/#2131-sorgenti-di-stream","title":"21.3.1 Sorgenti di Stream","text":"<p>Sorgenti comuni di stream includono:</p> <ul> <li>Collezioni: <code>collection.stream()</code></li> <li>Array: <code>Arrays.stream(array)</code></li> <li>Canali I/O e file</li> <li>Stream infiniti: <code>Stream.iterate</code>, <code>Stream.generate</code></li> </ul> <pre><code>List&lt;String&gt; names = List.of(\"Ana\", \"Bob\", \"Carla\");\n\nStream&lt;String&gt; s = names.stream();  \n</code></pre> <p></p>"},{"location":"it/module-05/streams/#2132-operazioni-intermedie","title":"21.3.2 Operazioni Intermedie","text":"<p>Operazioni intermedie:</p> <ul> <li>Restituiscono un nuovo stream</li> <li>Sono evalualte \"Lazily\"</li> <li>Non innescano l\u2019esecuzione</li> </ul> <p></p>"},{"location":"it/module-05/streams/#21321-tabella-delle-operazioni-intermedie-comuni","title":"21.3.2.1 Tabella delle operazioni intermedie comuni:","text":"Method Common input Params Return value Desctiption <code>filter</code> Predicate <code>Stream&lt;T&gt;</code> filtra lo stream secondo una corrispondenza del predicate <code>map</code> Function <code>Stream&lt;R&gt;</code> trasforma uno stream attraverso un mapping uno a uno input/output <code>flatMap</code> Function <code>Stream&lt;R&gt;</code> appiattisce stream annidati in un singolo stream <code>sorted</code> (none) or Comparator <code>Stream&lt;T&gt;</code> ordina per ordine naturale o per il Comparator fornito <code>distinct</code> (none) <code>Stream&lt;T&gt;</code> rimuove elementi duplicati <code>limit</code> / <code>skip</code> long <code>Stream&lt;T&gt;</code> limita la dimensione o salta elementi <code>peek</code> Consumer <code>Stream&lt;T&gt;</code> esegue un\u2019azione con side-effect per ogni elemento (debugging) <ul> <li>Esempio:</li> </ul> <pre><code>        List&lt;String&gt; names = List.of(\"Ana\", \"Bob\", \"Carla\", \"Mario\");\n\n        names.stream().filter(n -&gt; n.length() &gt; 3).map(String::toUpperCase).forEach(System.out::println);\n</code></pre> <p>Output:</p> <pre><code>CARLA\nMARIO\n</code></pre> <p>Note</p> <p>Le operazioni intermedie descrivono solo il calcolo. Nessun elemento \u00e8 ancora elaborato.</p> <p></p>"},{"location":"it/module-05/streams/#2133-operazioni-terminali","title":"21.3.3 Operazioni Terminali","text":"<p>Operazioni terminali:</p> <ul> <li>Innescano l\u2019esecuzione</li> <li>Consumano lo stream</li> <li>Producono un risultato o un effetto collaterale</li> </ul> <p></p>"},{"location":"it/module-05/streams/#21331-tabella-delle-operazioni-terminali","title":"21.3.3.1 Tabella delle operazioni terminali:","text":"Method Return value behaviour for infinite streams <code>forEach</code> void non termina <code>collect</code> varia non termina <code>reduce</code> varia non termina <code>findFirst</code> / <code>findAny</code> <code>Optional&lt;T&gt;</code> termina <code>anyMatch</code> / <code>allMatch</code> / <code>noneMatch</code> boolean pu\u00f2 terminare presto (short-circuit) <code>min</code> / <code>max</code> <code>Optional&lt;T&gt;</code> non termina <code>count</code> long non termina"},{"location":"it/module-05/streams/#214-valutazione-pigra-e-short-circuiting","title":"21.4 Valutazione Pigra e Short-Circuiting","text":"<pre><code>var newNames = new ArrayList&lt;String&gt;();\n\nnewNames.add(\"Bob\");\nnewNames.add(\"Dan\");\n\n// Gli stream sono valutati pigramente: questo non attraversa ancora i dati,\n// crea solo una descrizione della pipeline legata alla sorgente.\nvar stream = newNames.stream();\n\nnewNames.add(\"Erin\");\n\n// L\u2019operazione terminale innesca la valutazione. Lo stream vede la sorgente aggiornata,\n// quindi il count include \"Erin\".\nstream.count(); // 3\n</code></pre> <p>Nota importante : Uno stream \u00e8 legato alla sua sorgente (<code>newNames</code>), e la pipeline non viene eseguita finch\u00e9 non viene invocata un\u2019operazione terminale. Per questa ragione, se modifichi la collezione prima dell\u2019operazione terminale, l\u2019operazione terminale \u201cvede\u201d i nuovi elementi (qui, <code>Erin</code>). In generale, tuttavia, modificare la sorgente mentre una pipeline stream \u00e8 in uso \u00e8 una cattiva pratica e pu\u00f2 portare a comportamento non deterministico (o <code>ConcurrentModificationException</code> con alcune sorgenti/operazioni).  La regola pratica \u00e8: costruisci la sorgente, poi crea ed esegui lo stream senza mutarla.</p> <p>Gli stream processano elementi uno alla volta, scorrendo \u201cverticalmente\u201d attraverso la pipeline piuttosto che stadio-per-stadio.</p> <p>Sotto modifichiamo l\u2019esempio per usare un\u2019operazione terminale short-circuiting: <code>findFirst()</code>.</p> <pre><code>Stream.of(\"a\", \"bb\", \"ccc\")\n    .filter(s -&gt; {\n        System.out.println(\"filter \" + s);\n        return s.length() &gt; 1;\n    })\n    .map(s -&gt; {\n        System.out.println(\"map \" + s);\n        return s.toUpperCase();\n    })\n    .findFirst()\n    .ifPresent(System.out::println);\n</code></pre> <p>Ordine di esecuzione:</p> <p>Note</p> <p>Viene processato solo il numero minimo di elementi richiesti dall\u2019operazione terminale.</p> <pre><code>filter a\nfilter bb\nmap bb\nBB\n</code></pre> <p><code>findFirst()</code> \u00e8 soddisfatto non appena trova il primo elemento che passa con successo attraverso la pipeline (qui <code>\"bb\"</code>), quindi: - <code>\"ccc\"</code> non viene mai processato (n\u00e9 <code>filter</code> n\u00e9 <code>map</code>); - la valutazione pigra evita lavoro non necessario rispetto a un\u2019operazione terminale che consuma tutti gli elementi (come <code>forEach</code> o <code>count</code>).</p> <p></p>"},{"location":"it/module-05/streams/#215-operazioni-stateless-vs-stateful","title":"21.5 Operazioni Stateless vs Stateful","text":""},{"location":"it/module-05/streams/#2151-operazioni-stateless","title":"21.5.1 Operazioni Stateless","text":"<p>Operazioni come <code>map</code> e <code>filter</code> processano ogni elemento indipendentemente.</p> <p></p>"},{"location":"it/module-05/streams/#2152-operazioni-stateful","title":"21.5.2 Operazioni Stateful","text":"<p>Operazioni come <code>distinct</code>, <code>sorted</code> e <code>limit</code> richiedono il mantenimento di stato interno.</p> <p>Note</p> <p>Le operazioni stateful possono impattare severamente le prestazioni degli stream paralleli.</p> <p></p>"},{"location":"it/module-05/streams/#216-ordinamento-degli-stream-e-determinismo","title":"21.6 Ordinamento degli Stream e Determinismo","text":"<p>Gli stream possono essere:</p> <ul> <li>Ordinati (es. <code>List.stream()</code>)</li> <li>Non ordinati (es. <code>HashSet.stream()</code>)</li> </ul> <p>Alcune operazioni rispettano l\u2019ordine di encounter:</p> <ul> <li><code>forEachOrdered</code></li> <li><code>findFirst</code></li> </ul> <p>Note</p> <p>Negli stream paralleli, <code>forEach</code> non garantisce ordine.</p> <p></p>"},{"location":"it/module-05/streams/#217-stream-paralleli","title":"21.7 Stream Paralleli","text":"<p>Gli stream paralleli dividono il lavoro tra thread usando il ForkJoinPool.commonPool().</p> <pre><code>int sum =\nIntStream.range(1, 1_000_000)\n    .parallel()\n        .sum();\n</code></pre> <p>Regole per stream paralleli sicuri:</p> <ul> <li>Nessun effetto collaterale</li> <li>Nessuno stato condiviso mutabile</li> <li>Solo operazioni associative</li> </ul> <p>Note</p> <p>Gli stream paralleli possono essere pi\u00f9 lenti per carichi di lavoro leggeri.</p> <p></p>"},{"location":"it/module-05/streams/#218-operazioni-di-riduzione","title":"21.8 Operazioni di Riduzione","text":""},{"location":"it/module-05/streams/#2181-reduce-combinare-uno-stream-in-un-singolo-oggetto","title":"21.8.1 <code>reduce()</code>: combinare uno stream in un singolo oggetto","text":"<p>Ci sono tre firme di metodo per questa operazione:</p> <ul> <li>public <code>Optional&lt;T&gt;</code> reduce(<code>BinaryOperator&lt;T&gt; accumulator</code>);</li> <li>public <code>T</code> reduce(<code>T identity</code>, <code>BinaryOperator&lt;T&gt; accumulator</code>);</li> <li>public <code>&lt;U&gt; U</code> reduce(<code>U identity</code>, <code>BiFunction&lt;U, ? super T, U&gt; accumulator</code>, <code>BinaryOperator&lt;U&gt; combiner</code>)</li> </ul> <pre><code>int sum = Stream.of(1, 2, 3)\n    .reduce(0, Integer::sum);\n</code></pre> <p>La riduzione richiede:</p> <ul> <li>Identity: valore iniziale per ogni riduzione parziale; deve essere un elemento neutro; Esempio: 0 per la somma, 1 per la moltiplicazione, collezione vuota per la raccolta;</li> <li>Accumulator: incorpora un elemento dello stream in un risultato parziale;</li> <li>(Opzionale) Combiner: unisce due risultati parziali; Usato solo quando lo stream \u00e8 parallelo; Ignorato per stream sequenziali</li> </ul> <p>Note</p> <p>L\u2019accumulator deve essere associativo e stateless.</p> <p></p>"},{"location":"it/module-05/streams/#21811-modello-mentale-corretto","title":"21.8.1.1 Modello mentale corretto","text":"<ul> <li>Accumulator: risultato + elemento</li> <li>Combiner: risultato + risultato</li> </ul> <p>Esempio 1: Uso corretto (somma delle lunghezze)</p> <pre><code>int totalLength =\n    Stream.of(\"a\", \"bb\", \"ccc\")\n          .parallel()\n          .reduce(\n              0,                       // identity\n              (sum, s) -&gt; sum + s.length(), // accumulator\n              (left, right) -&gt; left + right // combiner\n          );\n</code></pre> <p>Cosa succede in parallelo</p> <p>Supponi che lo stream sia diviso:</p> <ul> <li>Thread 1: \"a\", \"bb\" \u2192 0 + 1 + 2 = 3</li> <li>Thread 2: \"ccc\" \u2192 0 + 3 = 3</li> </ul> <p>in seguito il combiner unisce i risultati parziali:</p> <pre><code>3 + 3 = 6\n</code></pre> <p>Esempio 2: Combiner ignorato negli stream sequenziali</p> <pre><code>int result =\n    Stream.of(\"a\", \"bb\", \"ccc\")\n          .reduce(\n              0,\n              (sum, s) -&gt; sum + s.length(),\n              (x, y) -&gt; {\n                  throw new RuntimeException(\"Never called\");\n              }\n          );\n</code></pre> <p>Esempio 3: Combiner scorretto</p> <pre><code>int result =\n    Stream.of(1, 2, 3, 4)\n          .parallel()\n          .reduce(\n              0,\n              (a, b) -&gt; a - b,   // accumulator\n              (x, y) -&gt; x - y    // combiner\n          );\n</code></pre> <p>Perch\u00e9 questo \u00e8 sbagliato</p> <p>La sottrazione non \u00e8 associativa.</p> <p>Possibile esecuzione:</p> <ul> <li>Thread 1: 0 - 1 - 2 = -3</li> <li>Thread 2: 0 - 3 - 4 = -7</li> </ul> <p>Combiner:</p> <pre><code>-3 - (-7) = 4\n</code></pre> <p>Il risultato sequenziale sarebbe:</p> <pre><code>(((0 - 1) - 2) - 3) - 4 = -10\n</code></pre> <p>Warning</p> <p>\u274c I risultati paralleli e sequenziali differiscono \u2192 riduzione illegale</p> <p></p>"},{"location":"it/module-05/streams/#2182-collect","title":"21.8.2 <code>collect()</code>","text":"<p><code>collect</code> \u00e8 una riduzione mutabile ottimizzata per raggruppamento e aggregazione. </p> <p>\u00c8 lo strumento standard della Stream API per la \u201criduzione mutabile\u201d: accumuli elementi in un contenitore mutabile (come una List, Set, Map, StringBuilder, oggetto risultato custom),  e poi, opzionalmente, si uniscono i contenitori parziali quando si esegue in parallelo.</p> <p>La forma generale \u00e8:</p> <ul> <li><code>public &lt;R&gt; R **collect**(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? super T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner)</code>;</li> </ul> <p>E una versione comune usata \u00e8:</p> <ul> <li><code>public &lt;R, A&gt; R **collect**(Collector&lt;? super T, A, R&gt; collector)</code></li> </ul> <p>dove Collectors.* fornisce collector pre-costruiti (grouping, mapping, joining, counting, ecc.).</p> <p>Significato:</p> <ul> <li>supplier: crea un nuovo contenitore risultato vuoto (es. <code>new ArrayList&lt;&gt;()</code>)</li> <li>accumulator: aggiunge un elemento in quel contenitore (es. <code>list::add</code>)</li> <li>combiner: unisce due contenitori (es. <code>list1.addAll(list2)</code>)</li> </ul> <p></p>"},{"location":"it/module-05/streams/#2183-perche-collect-e-diverso-da-reduce","title":"21.8.3 Perch\u00e9 <code>collect()</code> \u00e8 diverso da <code>reduce()</code>","text":"<ul> <li>Intento: mutazione vs immutabilit\u00e0<ul> <li><code>reduce()</code> \u00e8 progettato per riduzione in stile immutabile: combinare valori in un nuovo valore (es. somma, min, max).</li> <li><code>collect()</code> \u00e8 progettato per contenitori mutabili: costruire una List, Map, StringBuilder, ecc.</li> </ul> </li> <li>Correttezza in parallelo<ul> <li><code>reduce()</code> richiede che l\u2019operazione sia:<ul> <li>associativa</li> <li>stateless</li> <li>compatibile con regole di identity/combiner</li> </ul> </li> <li><code>collect()</code> \u00e8 costruito per supportare il parallelismo in sicurezza mediante:<ul> <li>creazione di un contenitore per thread (supplier)</li> <li>accumulo locale (accumulator)</li> <li>merge alla fine (combiner)</li> </ul> </li> </ul> </li> <li> <p>Prestazioni</p> <ul> <li><code>collect()</code> pu\u00f2 essere ottimizzato perch\u00e9 il runtime dello stream sa che stai costruendo contenitori:<ul> <li>pu\u00f2 evitare copie non necessarie</li> <li>pu\u00f2 pre-dimensionare o usare implementazioni specializzate (a seconda del collector)</li> <li>\u00e8 l\u2019approccio idiomatico e atteso</li> <li>usare reduce() per costruire una collezione spesso crea oggetti extra o forza mutazione non sicura.</li> </ul> </li> </ul> </li> <li> <p>Esempio: \u201ccollect in una List\u201d nel modo corretto</p> </li> </ul> <pre><code>List&lt;String&gt; longNames =\n    names.stream()\n         .filter(s -&gt; s.length() &gt; 3)\n            .collect(Collectors.toList());\n</code></pre> <ul> <li>Esempio: groupingBy con spiegazione</li> </ul> <pre><code>Map&lt;Integer, List&lt;String&gt;&gt; byLength =\n    names.stream()\n         .collect(Collectors.groupingBy(String::length));\n</code></pre> <p>Cosa succede concettualmente:</p> <ul> <li>Il collector crea una <code>Map&lt;Integer, List&lt;String&gt;&gt;</code> vuota</li> <li>Per ogni name:<ul> <li>calcola la chiave (String::length)</li> <li>lo mette nella lista bucket corretta</li> </ul> </li> <li>In parallelo:<ul> <li>ogni thread costruisce le proprie mappe parziali</li> <li>il combiner unisce le mappe unendo le liste per chiave</li> </ul> </li> </ul> <p></p>"},{"location":"it/module-05/streams/#219-trappole-comuni-degli-stream","title":"21.9 Trappole comuni degli Stream","text":"<ul> <li>Riutilizzare uno stream consumato \u2192 <code>IllegalStateException</code></li> <li>Modificare variabili esterne dentro le lambda</li> <li>Assumere ordine di esecuzione negli stream paralleli</li> <li>Usare <code>peek</code> per logica invece che per debugging</li> </ul>"},{"location":"it/module-05/streams/#2110-stream-primitivi","title":"21.10 Stream Primitivi","text":"<p>Java fornisce tre tipi di stream specializzati per evitare overhead di boxing e per abilitare operazioni focalizzate sui numeri:</p> <ul> <li><code>IntStream</code> per <code>int</code></li> <li><code>LongStream</code> per <code>long</code></li> <li><code>DoubleStream</code> per <code>double</code></li> </ul> <p>Gli stream primitivi sono comunque stream (pipeline lazy, operazioni intermedie + terminali, single-use), ma non sono generici e usano interfacce funzionali specializzate per primitivi (es. <code>IntPredicate</code>, <code>LongUnaryOperator</code>, <code>DoubleConsumer</code>).</p> <p>Note</p> <p>Usa stream primitivi quando i dati sono naturalmente numerici o quando le prestazioni contano: evitano overhead di boxing/unboxing e forniscono operazioni terminali numeriche aggiuntive.</p> <p></p>"},{"location":"it/module-05/streams/#21101-perche-gli-stream-primitivi-sono-importanti","title":"21.10.1 Perch\u00e9 gli stream primitivi sono importanti","text":"<ul> <li>Prestazioni: evitare l\u2019allocazione di oggetti wrapper e boxing/unboxing ripetuti in pipeline grandi</li> <li>Convenienza: riduzioni numeriche integrate come <code>sum()</code>, <code>average()</code>, <code>summaryStatistics()</code></li> <li>Trappole comuni: capire quando i risultati sono primitivi vs <code>OptionalInt</code>/<code>OptionalLong</code>/<code>OptionalDouble</code></li> </ul>"},{"location":"it/module-05/streams/#21102-metodi-comuni-di-creazione","title":"21.10.2 Metodi comuni di creazione","text":"<p>I seguenti sono i modi usati pi\u00f9 frequentemente per creare stream primitivi. Molte domande di certificazione iniziano identificando il tipo di stream creato da un metodo factory.</p> Sources IntStream.of(int...) IntStream.range(int startInclusive, int endExclusive) IntStream.rangeClosed(int startInclusive, int endInclusive) IntStream.iterate(int seed, IntUnaryOperator f) // infinito a meno che limitato IntStream.iterate(int seed, IntPredicate hasNext, IntUnaryOperator f) IntStream.generate(IntSupplier s) // infinito a meno che limitato LongStream.of(long...) LongStream.range(long startInclusive, long endExclusive) LongStream.rangeClosed(long startInclusive, long endInclusive) LongStream.iterate(long seed, LongUnaryOperator f) LongStream.iterate(long seed, LongPredicate hasNext, LongUnaryOperator f) LongStream.generate(LongSupplier s) DoubleStream.of(double...) DoubleStream.iterate(double seed, DoubleUnaryOperator f) DoubleStream.iterate(double seed, DoublePredicate hasNext, DoubleUnaryOperator f) DoubleStream.generate(DoubleSupplier s) <p>Important</p> <ul> <li>Solo <code>IntStream</code> e <code>LongStream</code> forniscono <code>range()</code> e <code>rangeClosed()</code>.</li> <li>Non esiste <code>DoubleStream.range</code> perch\u00e9 contare con double ha problemi di arrotondamento.</li> </ul> <p></p>"},{"location":"it/module-05/streams/#21103-metodi-di-mapping-specializzati-per-primitivi","title":"21.10.3 Metodi di mapping specializzati per primitivi","text":"<p>Gli stream primitivi forniscono operazioni di mapping solo per primitivi che evitano boxing:</p> <ul> <li><code>IntStream.map(IntUnaryOperator)</code> \u2192 <code>IntStream</code></li> <li><code>IntStream.mapToLong(IntToLongFunction)</code> \u2192 <code>LongStream</code></li> <li> <p><code>IntStream.mapToDouble(IntToDoubleFunction)</code> \u2192 <code>DoubleStream</code></p> </li> <li> <p><code>LongStream.map(LongUnaryOperator)</code> \u2192 <code>LongStream</code></p> </li> <li><code>LongStream.mapToInt(LongToIntFunction)</code> \u2192 <code>IntStream</code></li> <li> <p><code>LongStream.mapToDouble(LongToDoubleFunction)</code> \u2192 <code>DoubleStream</code></p> </li> <li> <p><code>DoubleStream.map(DoubleUnaryOperator)</code> \u2192 <code>DoubleStream</code></p> </li> <li><code>DoubleStream.mapToInt(DoubleToIntFunction)</code> \u2192 <code>IntStream</code></li> <li><code>DoubleStream.mapToLong(DoubleToLongFunction)</code> \u2192 <code>LongStream</code></li> </ul> <p></p>"},{"location":"it/module-05/streams/#21104-tabella-di-mapping-tra-streamt-e-stream-primitivi","title":"21.10.4 Tabella di mapping tra <code>Stream&lt;T&gt;</code> e stream primitivi","text":"<p>Questa tabella riassume le principali conversioni tra stream di oggetti e stream primitivi. </p> <p>La colonna \u201cFrom\u201d ti dice quali metodi sono disponibili e il tipo di stream target risultante.</p> From (source) To (target) Primary method(s) <code>Stream&lt;T&gt;</code> <code>Stream&lt;R&gt;</code> <code>map(Function&lt;? super T, ? extends R&gt;)</code> <code>Stream&lt;T&gt;</code> <code>Stream&lt;R&gt; (flatten)</code> <code>flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt;)</code> <code>Stream&lt;T&gt;</code> <code>IntStream</code> <code>mapToInt(ToIntFunction&lt;? super T&gt;)</code> <code>Stream&lt;T&gt;</code> <code>LongStream</code> <code>mapToLong(ToLongFunction&lt;? super T&gt;)</code> <code>Stream&lt;T&gt;</code> <code>DoubleStream</code> <code>mapToDouble(ToDoubleFunction&lt;? super T&gt;)</code> <code>Stream&lt;T&gt;</code> <code>IntStream (flatten)</code> <code>flatMapToInt(Function&lt;? super T, ? extends IntStream&gt;)</code> <code>Stream&lt;T&gt;</code> <code>LongStream (flatten)</code> <code>flatMapToLong(Function&lt;? super T, ? extends LongStream&gt;)</code> <code>Stream&lt;T&gt;</code> <code>DoubleStream (flatten)</code> <code>flatMapToDouble(Function&lt;? super T, ? extends DoubleStream&gt;)</code> <code>IntStream</code> <code>Stream&lt;Integer&gt;</code> <code>boxed()</code> <code>LongStream</code> <code>Stream&lt;Long&gt;</code> <code>boxed()</code> <code>DoubleStream</code> <code>Stream&lt;Double&gt;</code> <code>boxed()</code> <code>IntStream</code> <code>Stream&lt;U&gt;</code> <code>mapToObj(IntFunction&lt;? extends U&gt;)</code> <code>LongStream</code> <code>Stream&lt;U&gt;</code> <code>mapToObj(LongFunction&lt;? extends U&gt;)</code> <code>DoubleStream</code> <code>Stream&lt;U&gt;</code> <code>mapToObj(DoubleFunction&lt;? extends U&gt;)</code> <code>IntStream</code> <code>LongStream</code> <code>asLongStream()</code> <code>IntStream</code> <code>DoubleStream</code> <code>asDoubleStream()</code> <code>LongStream</code> <code>DoubleStream</code> <code>asDoubleStream()</code> <p>Important</p> <ul> <li>Non esiste un\u2019operazione <code>unboxed()</code>.</li> <li>Per passare da wrapper a primitivi devi partire da <code>Stream&lt;T&gt;</code> e usare <code>mapToInt</code> / <code>mapToLong</code> / <code>mapToDouble</code>.</li> </ul> <p></p>"},{"location":"it/module-05/streams/#21105-operazioni-terminali-e-i-loro-tipi-di-risultato","title":"21.10.5 Operazioni terminali e i loro tipi di risultato","text":"<p>Gli stream primitivi hanno diverse operazioni terminali che sono uniche o hanno tipi di ritorno specifici per primitivi.</p> Terminal operation IntStream returns LongStream returns DoubleStream returns <code>count()</code> long long long <code>sum()</code> int long double <code>min()</code> / max() OptionalInt OptionalLong OptionalDouble <code>average()</code> OptionalDouble OptionalDouble OptionalDouble <code>findFirst()</code> / findAny() OptionalInt OptionalLong OptionalDouble <code>reduce(op)</code> OptionalInt OptionalLong OptionalDouble <code>reduce(identity, op)</code> int long double <code>summaryStatistics()</code> IntSummaryStatistics LongSummaryStatistics DoubleSummaryStatistics <p>Warning</p> <ul> <li>Anche per <code>IntStream</code> e <code>LongStream</code>, <code>average()</code> restituisce <code>OptionalDouble</code> (non <code>OptionalInt</code> o <code>OptionalLong</code>).</li> </ul> <ul> <li>Esempio 1: <code>Stream&lt;String&gt;</code> \u2192 <code>IntStream</code> \u2192 operazioni terminali primitive.</li> </ul> <pre><code>List&lt;String&gt; words = List.of(\"a\", \"bb\", \"ccc\");\n\nint totalLength = words.stream()\n    .mapToInt(String::length) // IntStream\n        .sum(); // int\n\n// totalLength = 1 + 2 + 3 = 6\n</code></pre> <ul> <li>Esempio 2: <code>IntStream</code> \u2192 boxed <code>Stream&lt;Integer&gt;</code> (boxing introdotto).</li> </ul> <pre><code>Stream&lt;Integer&gt; boxed = IntStream.rangeClosed(1, 3) // 1,2,3\n    .boxed(); // Stream&lt;Integer&gt;\n</code></pre> <ul> <li>Esempio 3: stream primitivo \u2192 stream di oggetti via <code>mapToObj</code>.</li> </ul> <pre><code>Stream&lt;String&gt; labels = IntStream.range(1, 4) // 1,2,3\n    .mapToObj(i -&gt; \"N=\" + i); // Stream&lt;String&gt;\n</code></pre> <p></p>"},{"location":"it/module-05/streams/#21106-trappole-e-gotcha-comuni","title":"21.10.6 Trappole e gotcha comuni","text":"<ul> <li>Non confondere <code>Stream&lt;Integer&gt;</code> con <code>IntStream</code>: i loro metodi di mapping e interfacce funzionali differiscono</li> <li><code>IntStream.sum()</code> restituisce <code>int</code> ma <code>IntStream.count()</code> restituisce <code>long</code></li> <li><code>average()</code> restituisce sempre <code>OptionalDouble</code> per tutti i tipi di stream primitivi</li> <li>Usare <code>boxed()</code> reintroduce boxing; fallo solo se l\u2019API downstream richiede oggetti (es. raccogliere in <code>List&lt;Integer&gt;</code>)</li> <li>Fai attenzione alle conversioni di narrowing: <code>LongStream.mapToInt</code> e <code>DoubleStream.mapToInt</code> possono troncare i valori</li> </ul>"},{"location":"it/module-05/streams/#2111-collector-collect-collector-e-i-metodi-factory-di-collectors","title":"21.11 Collector (collect(), Collector e i Metodi Factory di Collectors)","text":"<p>Un <code>Collector</code> descrive come accumulare elementi di stream in un risultato finale. </p> <p>L\u2019operazione terminale <code>collect(...)</code> esegue questa ricetta. </p> <p>La classe utility <code>Collectors</code> fornisce collector pronti per compiti comuni di aggregazione.</p> <p></p>"},{"location":"it/module-05/streams/#21111-collect-vs-collector","title":"21.11.1 collect() vs Collector","text":"<p>Ci sono due modi principali per raccogliere:</p> <ul> <li><code>collect(Collector)</code> \u2192 la forma comune usando <code>Collectors.*</code></li> <li><code>collect(supplier, accumulator, combiner)</code> \u2192 riduzione mutabile esplicita (pi\u00f9 low-level)</li> </ul> <pre><code>List&lt;String&gt; list =\nStream.of(\"a\", \"b\")\n    .collect(Collectors.toList());\n\nStringBuilder sb =\nStream.of(\"a\", \"b\")\n    .collect(StringBuilder::new, StringBuilder::append, StringBuilder::append);\n</code></pre> <p>Note</p> <p>Usa <code>collect(supplier, accumulator, combiner)</code> quando ti serve un contenitore mutabile custom e non vuoi implementare un <code>Collector</code> completo.</p> <p></p>"},{"location":"it/module-05/streams/#21112-collector-core","title":"21.11.2 Collector core","text":"<p>Questi sono i collector usati pi\u00f9 frequentemente e quelli pi\u00f9 probabilmente presenti in domande d\u2019esame.</p> <ul> <li><code>toList()</code> \u2192 <code>List&lt;T&gt;</code> (nessuna garanzia su mutabilit\u00e0/implementazione)</li> <li><code>toSet()</code> \u2192 <code>Set&lt;T&gt;</code></li> <li><code>toCollection(supplier)</code> \u2192 tipo di collezione specifico (es. <code>TreeSet</code>)</li> <li><code>joining(delim, prefix, suffix)</code> \u2192 <code>String</code> da elementi <code>CharSequence</code></li> <li><code>counting()</code> \u2192 conteggio <code>Long</code></li> <li><code>summingInt</code> / <code>summingLong</code> / <code>summingDouble</code> \u2192 somme numeriche</li> <li><code>averagingInt</code> / <code>averagingLong</code> / <code>averagingDouble</code> \u2192 medie numeriche</li> <li><code>minBy(comparator)</code> / <code>maxBy(comparator)</code> \u2192 <code>Optional&lt;T&gt;</code></li> <li><code>mapping(mapper, downstream)</code> \u2192 trasforma poi raccoglie con downstream</li> <li><code>filtering(predicate, downstream)</code> \u2192 filtra dentro il collector (Java 9+)</li> </ul> <p></p>"},{"location":"it/module-05/streams/#21113-collector-di-raggruppamento","title":"21.11.3 Collector di raggruppamento","text":"<p><code>groupingBy</code> classifica elementi in bucket con chiave data da una funzione classifier. </p> <p>Produce una <code>Map&lt;K, V&gt;</code> dove <code>V</code> dipende dal collector downstream.</p> <pre><code>Map&lt;Integer, List&lt;String&gt;&gt; byLen =\nStream.of(\"a\", \"bb\", \"ccc\", \"dd\")\n    .collect(Collectors.groupingBy(String::length));\nSystem.out.println(\"byLen: \" + byLen.toString());\n</code></pre> <p>Output:</p> <pre><code>byLen: {1=[a], 2=[bb, dd], 3=[ccc]}\n</code></pre> <p>Con un collector downstream controlli cosa contiene ogni bucket:</p> <pre><code>Map&lt;Integer, Long&gt; countByLen =\nStream.of(\"a\", \"bb\", \"ccc\", \"dd\")\n    .collect(Collectors.groupingBy(String::length, Collectors.counting()));\nSystem.out.println(\"countByLen: \" + countByLen.toString());\n\nMap&lt;Integer, Set&lt;String&gt;&gt; setByLen =\nStream.of(\"a\", \"bb\", \"ccc\", \"dd\")\n    .collect(Collectors.groupingBy(String::length, Collectors.toSet()));\nSystem.out.println(\"setByLen: \" + setByLen.toString());\n</code></pre> <p>Output:</p> <pre><code>countByLen: {1=1, 2=2, 3=1}\nsetByLen: {1=[a], 2=[bb, dd], 3=[ccc]}\n</code></pre> <p>Warning</p> <p>Fai attenzione al tipo del valore della mappa risultante. Esempio: <code>groupingBy(..., counting())</code> produce <code>Map&lt;K, Long&gt;</code> (non <code>int</code>).</p> <p></p>"},{"location":"it/module-05/streams/#21114-partitioningby","title":"21.11.4 partitioningBy","text":"<p><code>partitioningBy</code> divide lo stream in esattamente due gruppi usando un <code>Predicate</code> booleano. Restituisce sempre una mappa con chiavi <code>true</code> e <code>false</code>.</p> <pre><code>Map&lt;Boolean, List&lt;String&gt;&gt; parts =\nStream.of(\"a\", \"bb\", \"ccc\")\n    .collect(Collectors.partitioningBy(s -&gt; s.length() &gt; 1));\nSystem.out.println(\"parts: \" + parts.toString());\n</code></pre> <p>Output:</p> <pre><code>parts: {false=[a], true=[bb, ccc]}\n</code></pre> <p>Note</p> <p><code>partitioningBy</code> crea sempre due bucket, mentre <code>groupingBy</code> pu\u00f2 crearne molti. Entrambi supportano collector downstream.</p> <p></p>"},{"location":"it/module-05/streams/#21115-tomap-e-regole-di-merge","title":"21.11.5 toMap e regole di merge","text":"<p><code>toMap</code> lancia un\u2019eccezione su chiavi duplicate a meno che tu non fornisca una funzione di merge.</p> <pre><code>Map&lt;Integer, String&gt; m1 =\nStream.of(\"aa\", \"bb\")\n    .collect(Collectors.toMap(String::length, s -&gt; s)); // \u274c Exception in thread \"main\" java.lang.IllegalStateException: Duplicate key 2 (attempted merging values aa and bb)\n\nMap&lt;Integer, String&gt; m2 =\nStream.of(\"aa\", \"bb\", \"cc\")\n    .collect(Collectors.toMap(String::length, s -&gt; s, (oldV, newV) -&gt; oldV + \",\" + newV)); // key=2 merges values\n</code></pre> <p>Output:</p> <pre><code>m2: {2=aa,bb,cc}\n</code></pre> <p></p>"},{"location":"it/module-05/streams/#21116-collectingandthen","title":"21.11.6 collectingAndThen","text":"<p><code>collectingAndThen(downstream, finisher)</code> ti permette di applicare una trasformazione finale dopo la raccolta (es. rendere la lista non modificabile).</p> <pre><code>List&lt;String&gt; unmodifiable =\nStream.of(\"a\", \"b\", \"c\")\n    .collect(Collectors.collectingAndThen(Collectors.toList(), List::copyOf));\n</code></pre> <p></p>"},{"location":"it/module-05/streams/#21117-come-i-collector-si-relazionano-agli-stream-paralleli","title":"21.11.7 Come i collector si relazionano agli stream paralleli","text":"<p>I collector sono progettati per funzionare con stream paralleli usando supplier/accumulator/combiner internamente. In parallelo, ogni worker costruisce un contenitore di risultato parziale e poi unisce i contenitori.</p> <ul> <li>L\u2019accumulator muta un contenitore per-thread (nessuno stato condiviso mutabile)</li> <li>Il combiner unisce i contenitori (richiesto per esecuzione parallela)</li> <li>Alcuni collector sono \u201cconcurrent\u201d o hanno caratteristiche che influenzano prestazioni e ordinamento</li> </ul> <p>Note</p> <p>preferisci <code>collect(Collectors.toList())</code> rispetto a usare <code>reduce</code> per costruire collezioni. <code>reduce</code> \u00e8 per riduzioni in stile immutabile; <code>collect</code> \u00e8 per contenitori mutabili.</p>"},{"location":"it/module-06/collections/","title":"22. Introduzione al Framework delle Collezioni","text":""},{"location":"it/module-06/collections/#indice","title":"Indice","text":"<ul> <li>22.1 Che cos\u2019\u00e8 il Framework delle Collezioni</li> <li>22.2 Le Interfacce Principali<ul> <li>22.2.1 Principali interfacce di Collection</li> <li>22.2.2 Gerarchia di Map</li> </ul> </li> <li>22.3 Collezioni Sequenced Java-21</li> <li>22.4 Perch\u00e9 esiste il Framework delle Collezioni</li> <li>22.5 I due lati del Framework Collections-vs-Maps</li> <li>22.6 Tipi generici nel Framework delle Collezioni</li> <li>22.7 Mutabilit\u00e0 vs Immutabilit\u00e0</li> <li>22.8 Aspettative di Prestazioni Big-O</li> <li>22.9 Riepilogo</li> </ul> <p>Il <code>Java Collections Framework (JCF)</code> \u00e8 un insieme di interfacce, classi e algoritmi progettato per memorizzare, manipolare ed elaborare gruppi di dati in modo efficiente.</p> <p>Fornisce un\u2019architettura unificata per gestire collezioni, consentendo agli sviluppatori di scrivere codice riutilizzabile e interoperabile con comportamenti prevedibili e caratteristiche di prestazioni.</p> <p>Questo capitolo introduce i concetti fondamentali necessari prima di studiare List, Set, Queue, Map e Sequenced Collections, esplorati in dettaglio nei capitoli successivi.</p> <p></p>"},{"location":"it/module-06/collections/#221-che-cose-il-framework-delle-collezioni","title":"22.1 Che cos\u2019\u00e8 il Framework delle Collezioni?","text":"<p>Il Framework delle Collezioni fornisce:</p> <ul> <li>Un insieme di interfacce (Collection, List, Set, Queue, Deque, Map\u2026)</li> <li>Un insieme di implementazioni (ArrayList, HashSet, TreeSet, LinkedList\u2026)</li> <li>Un insieme di algoritmi di utilit\u00e0 (ordinamento, ricerca, copia, inversione\u2026) in java.util.Collections e java.util.Arrays.</li> <li>Un linguaggio comune per le aspettative di prestazioni (complessit\u00e0 Big-O).</li> </ul> <p>Tutte le principali strutture di collezione condividono un design coerente cos\u00ec che il codice che funziona con un\u2019implementazione pu\u00f2 spesso essere riutilizzato con un\u2019altra.</p> <p></p>"},{"location":"it/module-06/collections/#222-le-interfacce-principali","title":"22.2 Le Interfacce Principali","text":"<p>Al cuore del Java Collections Framework c\u2019\u00e8 un piccolo insieme di interfacce radice che definiscono comportamenti generici di gestione dei dati.</p> <ul> <li>List: una collezione <code>ordinata</code> di elementi che consente <code>duplicati</code>;</li> <li>Set: una collezione che non consente <code>duplicati</code>;</li> <li>Queue: una collezione progettata per contenere elementi in corso di elaborazione, tipicamente FIFO (first-in-first-out), con varianti come priority queue e deque.</li> <li>Map: una struttura che mappa chiavi a valori, dove non sono consentite chiavi duplicate; ogni chiave pu\u00f2 mappare al massimo un valore.</li> </ul> <p></p>"},{"location":"it/module-06/collections/#2221-principali-interfacce-di-collection","title":"22.2.1 Principali interfacce di Collection","text":"<p>Sotto \u00e8 riportata la gerarchia concettuale.</p> <pre><code>java.util\n\u251c\u2500 Collection&lt;E&gt;\n\u2502 \u251c\u2500 SequencedCollection&lt;E&gt; (Java 21+)\n\u2502 \u2502 \u251c\u2500 List&lt;E&gt;\n\u2502 \u2502 \u2502   \u251c\u2500 ArrayList&lt;E&gt;\n\u2502 \u2502 \u2502   \u2514\u2500 LinkedList&lt;E&gt; (also implements Deque&lt;E&gt;)\n\u2502 \u2502 \u2514\u2500 Deque&lt;E&gt; (also extends Queue&lt;E&gt;)\n\u2502 \u2502     \u251c\u2500 ArrayDeque&lt;E&gt;\n\u2502 \u2502     \u2514\u2500 LinkedList&lt;E&gt;\n\u2502 \u251c\u2500 Set&lt;E&gt;\n\u2502 \u2502     \u251c\u2500 SequencedSet&lt;E&gt; (Java 21+)\n\u2502 \u2502     \u2502       \u2514\u2500 LinkedHashSet&lt;E&gt;\n\u2502 \u2502     \u251c\u2500 SortedSet&lt;E&gt;\n\u2502 \u2502     \u2502       \u2514\u2500 NavigableSet&lt;E&gt;\n\u2502 \u2502     \u2502           \u2514\u2500 TreeSet&lt;E&gt;\n\u2502 \u2502     \u251c\u2500 HashSet&lt;E&gt;\n\u2502 \u2502     \u2514\u2500 (other Set implementations)\n\u2502 \u251c\u2500 Queue&lt;E&gt;\n\u2502 \u2502     \u251c\u2500 Deque&lt;E&gt; (already under SequencedCollection&lt;E&gt;)\n\u2502 \u2502     \u251c\u2500 PriorityQueue&lt;E&gt;\n\u2502 \u2502     \u2514\u2500 (other Queue implementations)\n\u2502 \u2514\u2500 (other Collection implementations)\n\u2502\n\u2514\u2500 Map&lt;K,V&gt; (not a Collection)\n    \u251c\u2500 SequencedMap&lt;K,V&gt; (Java 21+)\n    \u2502   \u2514\u2500 LinkedHashMap&lt;K,V&gt;\n    \u251c\u2500 SortedMap&lt;K,V&gt;\n    \u2502   \u2514\u2500 NavigableMap&lt;K,V&gt;\n    \u2502   \u2514\u2500 TreeMap&lt;K,V&gt;\n    \u251c\u2500 HashMap&lt;K,V&gt;\n    \u251c\u2500 Hashtable&lt;K,V&gt;\n    \u2514\u2500 (other Map/ConcurrentMap implementations)\n</code></pre> <p>L\u2019interfaccia Map non estende Collection perch\u00e9 una map memorizza coppie chiave/valore piuttosto che singoli valori.</p> <p></p>"},{"location":"it/module-06/collections/#2222-gerarchia-di-map","title":"22.2.2 Gerarchia di Map","text":"<pre><code>java.util\n\u2514\u2500 Map&lt;K,V&gt;\n    \u251c\u2500 SequencedMap&lt;K,V&gt; (Java 21+)\n    \u2502   \u2514\u2500 LinkedHashMap&lt;K,V&gt;\n    \u251c\u2500 SortedMap&lt;K,V&gt;\n    \u2502   \u2514\u2500 NavigableMap&lt;K,V&gt;\n    \u2502       \u2514\u2500 TreeMap&lt;K,V&gt;\n    \u251c\u2500 HashMap&lt;K,V&gt;\n    \u251c\u2500 Hashtable&lt;K,V&gt;\n    \u2514\u2500 ConcurrentMap&lt;K,V&gt; (java.util.concurrent)\n        \u2514\u2500 ConcurrentHashMap&lt;K,V&gt;\n</code></pre>"},{"location":"it/module-06/collections/#223-collezioni-sequenced-java-21","title":"22.3 Collezioni Sequenced (Java 21+)","text":"<p>Java 21 introduce la nuova interfaccia <code>SequencedCollection</code>, che formalizza l\u2019idea che una collezione mantenga un ordine di encounter definito. Questo era gi\u00e0 vero per List, LinkedHashSet, LinkedHashMap, Deque, ecc., ma ora il comportamento \u00e8 standardizzato.</p> <ul> <li><code>SequencedCollection</code> definisce metodi come <code>getFirst()</code>, <code>getLast()</code>, <code>addFirst()</code>, <code>addLast()</code>, <code>removeFirst()</code>, <code>removeLast()</code>, e <code>reversed()</code>.</li> <li>SequencedSet, SequencedMap estendono l\u2019idea per set e map.</li> </ul> <p>Questo semplifica drasticamente la specifica dei comportamenti di ordinamento e sar\u00e0 usato in tutti i capitoli seguenti.</p> <p></p>"},{"location":"it/module-06/collections/#224-perche-esiste-il-framework-delle-collezioni","title":"22.4 Perch\u00e9 esiste il Framework delle Collezioni","text":"<ul> <li>Evitare di reinventare le strutture dati</li> <li>Fornire algoritmi ben testati e ad alte prestazioni</li> <li>Migliorare l\u2019interoperabilit\u00e0 tramite interfacce condivise</li> <li>Supportare tipi generici per collezioni type-safe</li> </ul> <p>Prima di Java 1.2, le strutture dati erano ad-hoc, incoerenti e non tipizzate.</p> <p>Il Collections Framework ha unificato tutto questo in una API coerente.</p> <p></p>"},{"location":"it/module-06/collections/#225-i-due-lati-del-framework-collections-vs-maps","title":"22.5 I due lati del Framework: Collections vs. Maps","text":"<p>\u201cMap estende Collection?\u201d No. Una Map memorizza coppie, mentre una Collection memorizza singoli elementi.</p> <ul> <li>Collection = List, Set, Queue, Deque, SequencedCollection</li> <li>Map = archivio chiave/valore in stile dizionario</li> </ul> <p></p>"},{"location":"it/module-06/collections/#226-tipi-generici-nel-framework-delle-collezioni","title":"22.6 Tipi generici nel Framework delle Collezioni","text":"<p>Le collezioni sono quasi sempre usate con i generics. L\u2019uso di raw types \u00e8 sconsigliato.</p> <pre><code>List&lt;String&gt; names = new ArrayList&lt;&gt;();\nMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();\n</code></pre> <p>Note</p> <p>I generics nelle collezioni funzionano tramite <code>type erasure</code>: fai riferimento al Paragrafo \"18.4 Type Erasure\" nel Capitolo: Generics in Java.</p> <p></p>"},{"location":"it/module-06/collections/#227-mutabilita-vs-immutabilita","title":"22.7 Mutabilit\u00e0 vs. Immutabilit\u00e0","text":"<p>Molti metodi nella Collections API restituiscono collezioni unmodifiable:</p> <pre><code>List&lt;String&gt; immutable = List.of(\"a\", \"b\");\nimmutable.add(\"c\"); // \u274c UnsupportedOperationException\n</code></pre> <p>Java fornisce diversi modi per creare collezioni immutabili:</p> <ul> <li><code>List.of()</code>, <code>Set.of()</code>, <code>Map.of()</code></li> <li><code>List.copyOf(collection)</code></li> <li>wrapper <code>Collections.unmodifiableList(...)</code></li> <li><code>Records</code> usati come contenitori di valori immutabili</li> </ul> <p>Note</p> <p>Il metodo <code>Arrays.asList(varargs)</code>, che \u00e8 costruito su un array, si comporta diversamente: vedi esempi sotto.</p> <pre><code>String[] vargs = new String[] {\"u\", \"v\", \"z\"};\nList&lt;String&gt; fromAsList = Arrays.asList(vargs);\n\nList&lt;String&gt; immutable1 = List.of(vargs);\nimmutable1.add(\"c\"); // \u274c UnsupportedOperationException\n\nList&lt;String&gt; immutable2 = List.copyOf(fromAsList);\nimmutable2.set(0, \"k\"); // \u274c UnsupportedOperationException\n\n\n// Non possiamo fare  ADD o REMOVE di elementi da \"fromAsList\" ma possiamo sostituirli;\n// o modificando l\u2019array sottostante \"vargs\" o mutando la lista stessa:\n\n\nfromAsList.set(0, \"k\");  // l\u2019aggiornamento sar\u00e0 riflesso anche sull\u2019array sottostante.\n</code></pre> <p>Note</p> <p><code>Arrays.asList(...)</code> restituisce una vista List a dimensione fissa, ma mutabile, supportata dall\u2019array originale. Non puoi aggiungere/rimuovere elementi, ma puoi sostituire quelli esistenti.</p> <p></p>"},{"location":"it/module-06/collections/#228-aspettative-di-prestazioni-big-o","title":"22.8 Aspettative di Prestazioni Big-O","text":"<p>Capire la complessit\u00e0 dei tipi \"Collectio\" \u00e8 essenziale. Ecco alcuni esempi comuni:</p> Type Methods Complexity ArrayList <code>get()</code>, <code>add()</code>, <code>remove()</code> <code>O(1)</code>, <code>O(1) ammortizzato</code>, <code>O(n)</code> LinkedList <code>get()</code>, <code>add/remove first/last</code> <code>O(n)</code>,  <code>O(1)</code> HashSet <code>add()</code>, <code>contains()</code>, <code>remove()</code> ~ <code>O(1)</code> TreeSet <code>add()</code>, <code>contains()</code>, <code>remove()</code> <code>O(log n)</code> HashMap <code>get()/put()</code> ~ <code>O(1) in media</code> TreeMap <code>get()/put()</code> <code>O(log n)</code> Deque <code>add/remove first/last</code> <code>O(1)</code> <p>Note</p> <p>Questi valori sono medie; il caso peggiore pu\u00f2 essere diverso (specialmente per strutture basate su hash).</p> <p></p>"},{"location":"it/module-06/collections/#229-riepilogo","title":"22.9 Riepilogo","text":"<ul> <li>Il Collection Framework \u00e8 costruito su un piccolo insieme di interfacce principali.</li> <li>Java 21 aggiunge Sequenced Collections per unificare il comportamento di ordinamento.</li> <li>Le Map non sono Collection \u2014 formano una gerarchia parallela.</li> <li>Le collezioni fanno massiccio uso dei generics.</li> <li>La mutabilit\u00e0 conta \u2014 i metodi factory spesso restituiscono collezioni immutabili.</li> <li>Le caratteristiche prestazionali sono prevedibili.</li> </ul>"},{"location":"it/module-06/comparing/","title":"24. Comparable, Comparator &amp; Ordinamento in Java","text":""},{"location":"it/module-06/comparing/#indice","title":"Indice","text":"<ul> <li>24.1 Comparable \u2014 Ordinamento Naturale<ul> <li>24.1.1 Contratto del Metodo di Comparable</li> <li>24.1.2 Classe di Esempio che Implementa Comparable</li> <li>24.1.3 Errori Comuni di Comparable</li> </ul> </li> <li>24.2 Comparator \u2014 Ordinamento Personalizzato<ul> <li>24.2.1 Metodi Principali di Comparator<ul> <li>24.2.1.1 Metodi di Supporto Statici di Comparator</li> <li>24.2.1.2 Metodi di Istanza su Comparator</li> </ul> </li> <li>24.2.2 Esempio di Comparator</li> </ul> </li> <li>24.3 Comparable vs Comparator</li> <li>24.4 Ordinamento di Array e Collezioni<ul> <li>24.4.1 Arrays sort</li> <li>24.4.2 Collections sort</li> </ul> </li> <li>24.5 Ordinamento Multi-Livello thenComparing</li> <li>24.6 Confrontare Primitivi in Modo Efficiente</li> <li>24.7 Trappole Comuni</li> <li>24.8 Esempio Completo</li> <li>24.9 Riepilogo</li> </ul> <p>Java fornisce due strategie principali per l\u2019ordinamento e il confronto: <code>Comparable</code> (ordinamento naturale) e <code>Comparator</code> (ordinamento personalizzato).</p> <p>Comprendere le loro regole, i vincoli e le interazioni con i <code>generics</code> \u00e8 essenziale.</p> <ul> <li>Per i tipi numerici, l\u2019ordinamento segue l\u2019ordine numerico naturale, il che significa che i valori pi\u00f9 piccoli vengono prima di quelli pi\u00f9 grandi.</li> <li>L\u2019ordinamento delle stringhe segue l\u2019ordine lessicografico (<code>code point</code> Unicode): confronto carattere per carattere; le cifre vengono prima delle maiuscole, le maiuscole prima delle minuscole.</li> </ul> <p>Questo ordinamento si basa sul <code>code point Unicode</code> di ogni carattere, non sull\u2019intuizione alfabetica.</p> <p>Un Unicode code point \u00e8 un valore numerico unico assegnato ai caratteri nell'Unicode standard.</p> <p>Pi\u00f9 precisamente: un <code>Unicode code point</code> \u00e8 un integer (scritto in esadecimale come U+XXXX) che rappresenta uno specifico carattere, simbolo, o  carattere speciale indipendentemente da font, lingua, o piattaforma.</p> <ul> <li>Esempi:<ul> <li>U+0041 \u2192 A</li> <li>U+0061 \u2192 a</li> <li>U+0030 \u2192 0</li> <li>U+1F600 \u2192 \ud83d\ude00</li> </ul> </li> </ul> <p>Un code point non \u00e8 una sequenza di byte; \u00e8 un numero astratto.</p> <p>Come il code point sia poi stoccato nella memoria fisica dipende dall'encoding (UTF-8, UTF-16, UTF-32).</p> <p>Unicode definisce code point da U+0000 a U+10FFFF.</p> <p>In breve: Unicode code points definisce quale sia il carattere; l'encodings definisce come questo sia rappresentato in bytes.</p> <ul> <li>Esempi di natural ordering</li> </ul> <pre><code>List&lt;String&gt; items = List.of(\"10\", \"2\", \"A\", \"Z\", \"a\", \"b\");\n\nList&lt;String&gt; sorted = new ArrayList&lt;&gt;(items);\nCollections.sort(sorted);\n\nSystem.out.println(sorted);\n</code></pre> <p>Output:</p> <pre><code>[10, 2, A, Z, a, b]\n</code></pre> <p>Note</p> <p>L\u2019ordinamento naturale \u00e8 definito solo per i tipi che implementano <code>Comparable</code>.</p> <p></p>"},{"location":"it/module-06/comparing/#241-comparable-ordinamento-naturale","title":"24.1 Comparable \u2014 Ordinamento Naturale","text":"<p>L\u2019interfaccia <code>Comparable&lt;T&gt;</code> definisce l\u2019ordine naturale di un tipo.</p> <p>Una classe la implementa quando vuole definire la propria regola di ordinamento predefinita.</p> <p></p>"},{"location":"it/module-06/comparing/#2411-contratto-del-metodo-di-comparable","title":"24.1.1 Contratto del Metodo di Comparable","text":"<pre><code>public interface Comparable&lt;T&gt; {\n    int compareTo(T other);\n}\n</code></pre> <p>Regole e restituzione:</p> <ul> <li>Restituisce negativo \u2192 <code>this</code> &lt; <code>other</code></li> <li>Restituisce zero \u2192 <code>this</code> == <code>other</code></li> <li>Restituisce positivo \u2192 <code>this</code> &gt; <code>other</code></li> </ul> <p>Important</p> <ul> <li>L\u2019ordinamento naturale deve essere consistente con <code>equals()</code>, a meno che non sia esplicitamente documentato diversamente:</li> <li><code>compareTo()</code> \u00e8 consistente con <code>equals()</code> se, e solo se, <code>a.compareTo(b) == 0</code> e <code>a.equals(b) \u00e8 true</code>.</li> </ul> <p>Warning</p> <p>compareTo pu\u00f2 lanciare ClassCastException se riceve un tipo non confrontabile \u2014 ma questo di solito succede solo con tipi raw.</p> <p></p>"},{"location":"it/module-06/comparing/#2412-esempio-classe-che-implementa-comparable","title":"24.1.2 Esempio: Classe che Implementa Comparable","text":"<pre><code>public class Person implements Comparable&lt;Person&gt; {\n\n    private String name;\n    private int age;\n\n    public Person(String n, int a) {\n        this.name = n;\n        this.age = a;\n    }\n\n    @Override\n    public int compareTo(Person other) {\n        return Integer.compare(this.age, other.age);\n    }\n\n\n}\n\nvar list = List.of(new Person(\"Bob\", 40), new Person(\"Alice\", 30));\n\nlist.stream().sorted().forEach(p -&gt; System.out.println(p.getAge()));\n</code></pre> <p>La lista viene ordinata per et\u00e0, perch\u00e9 quello \u00e8 l\u2019ordine numerico naturale.</p> <p></p>"},{"location":"it/module-06/comparing/#2413-errori-comuni-di-comparable","title":"24.1.3 Errori Comuni di Comparable","text":"<ul> <li>Confrontare tutti i campi rilevanti \u2192 risultati inconsistenti se non lo si fa</li> <li>Violare la transitivit\u00e0 \u2192 porta a comportamento indefinito</li> <li>Lanciare eccezioni dentro compareTo() rompe l\u2019ordinamento</li> <li>Non implementare la stessa logica di equals() \u2192 trappola comune</li> </ul>"},{"location":"it/module-06/comparing/#242-comparator-ordinamento-personalizzato","title":"24.2 Comparator \u2014 Ordinamento Personalizzato","text":"<p>L\u2019interfaccia <code>Comparator&lt;T&gt;</code> consente di definire pi\u00f9 strategie di ordinamento senza modificare la classe stessa.</p> <p></p>"},{"location":"it/module-06/comparing/#2421-metodi-principali-di-comparator","title":"24.2.1 Metodi Principali di Comparator","text":"<pre><code>int compare(T a, T b);\n</code></pre> <p>Metodi di supporto aggiuntivi:</p> <p></p>"},{"location":"it/module-06/comparing/#24211-metodi-di-supporto-statici-di-comparator","title":"24.2.1.1 Metodi di Supporto Statici di Comparator","text":"Metodo Statico / Istanza Tipo di Ritorno Parametri Descrizione <code>Comparator.comparing(keyExtractor)</code> statico Comparator Function&lt;? super T, ? extends U&gt; Costruisce un comparator che confronta le chiavi estratte usando l\u2019ordinamento naturale. <code>Comparator.comparing(keyExtractor, keyComparator)</code> statico Comparator Function, Comparator Costruisce un comparator che confronta le chiavi estratte usando un comparator personalizzato. <code>Comparator.comparingInt(keyExtractor)</code> statico Comparator ToIntFunction Comparator ottimizzato per chiavi int (evita il boxing). <code>Comparator.comparingLong(keyExtractor)</code> statico Comparator ToLongFunction Comparator ottimizzato per chiavi long. <code>Comparator.comparingDouble(keyExtractor)</code> statico Comparator ToDoubleFunction Comparator ottimizzato per chiavi double. <code>Comparator.naturalOrder()</code> statico Comparator none Comparator che usa l\u2019ordinamento naturale (Comparable). <code>Comparator.reverseOrder()</code> statico Comparator none Ordinamento naturale inverso. <code>Comparator.nullsFirst(comparator)</code> statico Comparator Comparator Incapsula un comparator in modo che i null vengano confrontati prima dei non-null. <code>Comparator.nullsLast(comparator)</code> statico Comparator Comparator Incapsula un comparator in modo che i null vengano confrontati dopo i non-null."},{"location":"it/module-06/comparing/#24212-metodi-di-istanza-su-comparator","title":"24.2.1.2 Metodi di Istanza su Comparator","text":"Metodo Statico / Istanza Tipo di Ritorno Parametri Descrizione <code>thenComparing(otherComparator)</code> istanza Comparator Comparator Aggiunge un comparator secondario quando il primario confronta come uguali. <code>thenComparing(keyExtractor)</code> istanza Comparator Function Confronto secondario usando l\u2019ordinamento naturale della chiave estratta. <code>thenComparing(keyExtractor, keyComparator)</code> istanza Comparator Function, Comparator Confronto secondario con comparator personalizzato. <code>thenComparingInt(keyExtractor)</code> istanza Comparator ToIntFunction Confronto numerico secondario (ottimizzato). <code>thenComparingLong(keyExtractor)</code> istanza Comparator ToLongFunction Confronto numerico secondario. <code>thenComparingDouble(keyExtractor)</code> istanza Comparator ToDoubleFunction Confronto numerico secondario. <code>reversed()</code> istanza Comparator none Restituisce un comparator invertito per la stessa logica di confronto."},{"location":"it/module-06/comparing/#2422-esempio-di-comparator","title":"24.2.2 Esempio di Comparator","text":"<pre><code>var people = List.of(new Person(\"Bob\",40), new Person(\"Ann\",30));\n\nComparator&lt;Person&gt; byName = Comparator.comparing(Person::getName);\n\nComparator&lt;Person&gt; byAgeDesc = Comparator.comparingInt(Person::getAge).reversed();\n\nvar sorted = people.stream().sorted(byName.thenComparing(byAgeDesc)).toList();\n</code></pre>"},{"location":"it/module-06/comparing/#243-comparable-vs-comparator","title":"24.3 Comparable vs Comparator","text":"Caratteristica Comparable Comparator Package java.lang java.util Metodo compareTo(T) compare(T,T) Tipo di Ordinamento Naturale (predefinito) Personalizzato (strategie multiple) Modifica la Classe Sorgente SI NO Utile Per Ordinamento predefinito Ordinamento esterno o alternativo Consente Ordini Multipli NO SI Usato da Collections.sort SI SI Usato da Arrays.sort SI SI"},{"location":"it/module-06/comparing/#244-ordinamento-di-array-e-collezioni","title":"24.4 Ordinamento di Array e Collezioni","text":""},{"location":"it/module-06/comparing/#2441-arrays-sort","title":"24.4.1 Arrays sort()","text":"<pre><code>int[] nums = {3,1,2};\nArrays.sort(nums); // ordine naturale\n\nPerson[] arr = {...};\nArrays.sort(arr); // Person deve implementare Comparable\nArrays.sort(arr, byName); // usando Comparator\n</code></pre>"},{"location":"it/module-06/comparing/#2442-collections-sort","title":"24.4.2 Collections sort()","text":"<pre><code>Collections.sort(list); // ordine naturale\nCollections.sort(list, byName); // comparator\n</code></pre> <p>Note</p> <p>Collections.sort(list) delega a list.sort(comparator) da Java 8.</p> <p></p>"},{"location":"it/module-06/comparing/#245-ordinamento-multi-livello-thencomparing","title":"24.5 Ordinamento Multi-Livello (thenComparing)","text":"<pre><code>var cmp = Comparator\n    .comparing(Person::getLastName)\n        .thenComparing(Person::getFirstName)\n            .thenComparingInt(Person::getAge);\n</code></pre>"},{"location":"it/module-06/comparing/#246-confrontare-primitivi-in-modo-efficiente","title":"24.6 Confrontare Primitivi in Modo Efficiente","text":"<pre><code>Comparator.comparingInt(Person::getAge)\nComparator.comparingLong(...)\nComparator.comparingDouble(...)\n</code></pre> <p>Note</p> <p>Questi evitano il boxing e sono preferiti nel codice sensibile alle prestazioni.</p> <p></p>"},{"location":"it/module-06/comparing/#247-trappole-comuni","title":"24.7 Trappole Comuni","text":"<ul> <li>Ordinare una lista di Object senza Comparable \u2192 ClassCastException a runtime</li> <li>compareTo inconsistente con equals \u2192 comportamento imprevedibile</li> <li>Comparator che rompe la transitivit\u00e0 \u2192 l\u2019ordinamento diventa indefinito</li> <li>Elementi null \u2192 a meno che il Comparator li gestisca, l\u2019ordinamento lancia NPE</li> <li>Comparator che confronta campi di tipi misti \u2192 ClassCastException</li> <li>Usare la sottrazione per confrontare int pu\u00f2 causare overflow \u2192 usare sempre <code>Integer.compare()</code></li> <li>Ordinare una lista con elementi null e ordine naturale \u2192 NPE</li> <li>compareTo non deve mai restituire negativo/zero/positivo inconsistenti sugli stessi due oggetti (niente casualit\u00e0)</li> </ul>"},{"location":"it/module-06/comparing/#248-esempio-completo","title":"24.8 Esempio Completo","text":"<pre><code>record Book(String title, double price, int year) {}\n\nvar books = List.of(\nnew Book(\"Java 17\", 40.0, 2021),\nnew Book(\"Algorithms\", 55.0, 2019),\nnew Book(\"Java 21\", 42.0, 2023)\n);\n\nComparator&lt;Book&gt; cmp =\nComparator\n    .comparingDouble(Book::price)\n        .thenComparing(Book::year)\n            .reversed();\n\nbooks.stream().sorted(cmp)\n    .forEach(System.out::println);\n</code></pre> <p>Note</p> <p><code>reversed()</code> si applica all\u2019intero comparator composto, non solo alla prima chiave di confronto.</p> <p></p>"},{"location":"it/module-06/comparing/#249-riepilogo","title":"24.9 Riepilogo","text":"<ul> <li>Usare <code>Comparable</code> per l\u2019ordinamento naturale (1 ordine predefinito).</li> <li>Usare <code>Comparator</code> per strategie di ordinamento flessibili o multiple.</li> <li>I comparator possono essere composti (reversed, thenComparing).</li> <li>L\u2019ordinamento richiede una logica di confronto consistente.</li> <li>Arrays.sort e Collections.sort usano sia Comparable che Comparator. </li> </ul>"},{"location":"it/module-06/list-api/","title":"25. La API List","text":""},{"location":"it/module-06/list-api/#indice","title":"Indice","text":"<ul> <li>25.1 Caratteristiche delle List</li> <li>25.2 Creare List (Costruttori)<ul> <li>25.2.1 Costruttori di ArrayList</li> <li>25.2.2 Costruttori di LinkedList</li> </ul> </li> <li>25.3 Metodi Factory<ul> <li>25.3.1 List of immutable</li> <li>25.3.2 List copyOf immutable-copy</li> <li>25.3.3 Arrays asList fixed-size-list</li> </ul> </li> <li>25.4 Operazioni Fondamentali di List<ul> <li>25.4.1 Aggiungere Elementi</li> <li>25.4.2 Accedere agli Elementi</li> <li>25.4.3 Rimuovere Elementi</li> <li>25.4.4 Comportamenti e Caratteristiche Importanti</li> </ul> </li> <li>25.5 contains, equals e hashCode<ul> <li>25.5.1 contains</li> <li>25.5.2 Uguaglianza delle List</li> <li>25.5.3 hashCode</li> </ul> </li> <li>25.6 Iterare una List<ul> <li>25.6.1 Ciclo For Classico</li> <li>25.6.2 Ciclo For Migliorato</li> <li>25.6.3 Iterator--ListIterator</li> </ul> </li> <li>25.7 Il Metodo subList<ul> <li>25.7.1 Sintassi</li> <li>25.7.2 Regole</li> <li>25.7.3 Esempi</li> <li>25.7.4 Modificare la lista padre invalida la vista</li> <li>25.7.5 Modificare la subList modifica il padre</li> <li>25.7.6 Svuotare la subList svuota parte della lista padre</li> <li>25.7.7 Trappole Comuni</li> </ul> </li> <li>25.8 Tabella Riassuntiva delle Operazioni Importanti</li> </ul> <p>Nel <code>Collections Framework</code>, una List rappresenta una collezione ordinata, basata su indice, che consente duplicati.</p> <p>L\u2019interfaccia List estende <code>Collection</code> ed \u00e8 implementata da:</p> <pre><code>List\n\u251c\u2500\u2500 ArrayList (Array ridimensionabile \u2014 accesso casuale veloce, inserimenti/rimozioni pi\u00f9 lenti nel mezzo)\n\u251c\u2500\u2500 LinkedList (Lista doppiamente collegata \u2014 inserimenti/rimozioni veloci, accesso casuale pi\u00f9 lento)\n\u2514\u2500\u2500 Vector (Lista sincronizzata legacy \u2014 raramente usata oggi)\n</code></pre> <p>Note</p> <p>Vector \u00e8 legacy e sincronizzato \u2014 evitarlo a meno che non sia esplicitamente richiesto.</p> <p></p>"},{"location":"it/module-06/list-api/#251-caratteristiche-delle-list","title":"25.1 Caratteristiche delle List","text":"<ul> <li>Ordinate \u2014 gli elementi preservano l\u2019ordine di inserimento.</li> <li>Indicizzate \u2014 accessibili tramite <code>get(int)</code> e <code>set(int,E)</code>.</li> <li>Consentono duplicati \u2014 <code>List</code> non impone unicit\u00e0.</li> <li>Possono contenere <code>null</code> \u2014 a meno di usare implementazioni speciali.</li> </ul>"},{"location":"it/module-06/list-api/#252-creare-list-costruttori","title":"25.2 Creare List (Costruttori)","text":""},{"location":"it/module-06/list-api/#2521-costruttori-di-arraylist","title":"25.2.1 Costruttori di ArrayList","text":"<pre><code>List&lt;String&gt; a1 = new ArrayList&lt;&gt;();\nList&lt;String&gt; a2 = new ArrayList&lt;&gt;(50); // capacit\u00e0 iniziale\nList&lt;String&gt; a3 = new ArrayList&lt;&gt;(List.of(\"A\", \"B\"));\n</code></pre> <p>Note</p> <p>La capacit\u00e0 iniziale non \u00e8 una dimensione. Decide solo quanti elementi l\u2019array interno pu\u00f2 contenere prima di ridimensionarsi.</p> <p></p>"},{"location":"it/module-06/list-api/#2522-costruttori-di-linkedlist","title":"25.2.2 Costruttori di LinkedList","text":"<pre><code>List&lt;String&gt; l1 = new LinkedList&lt;&gt;();\nList&lt;String&gt; l2 = new LinkedList&lt;&gt;(List.of(\"A\", \"B\"));\n</code></pre> <p>Note</p> <p><code>LinkedList</code> implementa anche <code>Deque</code>.</p> <p></p>"},{"location":"it/module-06/list-api/#253-metodi-factory","title":"25.3 Metodi Factory","text":""},{"location":"it/module-06/list-api/#2531-listof-immutabile","title":"25.3.1 <code>List.of()</code> (immutabile)","text":"<pre><code>List&lt;String&gt; list1 = List.of(\"A\", \"B\", \"C\");\nlist1.add(\"X\"); // \u274c UnsupportedOperationException\nlist1.set(0, \"Z\"); // \u274c UnsupportedOperationException\n</code></pre> <p>Note</p> <p>Tutte le liste <code>List.of()</code>: - non accettano i <code>null</code> - sono immutabili - lanciano <code>UOE</code> su modifiche strutturali</p> <p></p>"},{"location":"it/module-06/list-api/#2532-listcopyof-copia-immutabile","title":"25.3.2 <code>List.copyOf()</code> (copia immutabile)","text":"<pre><code>List&lt;String&gt; src = new ArrayList&lt;&gt;();\nsrc.add(\"Hello\");\n\nList&lt;String&gt; copy = List.copyOf(src); // snapshot immutabile\n</code></pre>"},{"location":"it/module-06/list-api/#2533-arraysaslist-lista-a-dimensione-fissa","title":"25.3.3 Arrays.asList() (lista a dimensione fissa)","text":"<pre><code>String[] arr = {\"A\", \"B\"};\nList&lt;String&gt; list = Arrays.asList(arr);\n\nlist.set(0, \"Z\"); // OK\nlist.add(\"X\"); // \u274c UOE \u2014 la dimensione \u00e8 fissa\n</code></pre> <p>Note</p> <p>La lista \u00e8 supportata dall\u2019array: modificare uno modifica anche l\u2019altro.</p> <p></p>"},{"location":"it/module-06/list-api/#254-operazioni-fondamentali-di-list","title":"25.4 Operazioni Fondamentali di List","text":""},{"location":"it/module-06/list-api/#2541-aggiungere-elementi","title":"25.4.1 Aggiungere Elementi","text":"<pre><code>list.add(\"A\");\nlist.add(1, \"B\"); // inserisce all\u2019indice\nlist.addAll(otherList);\nlist.addAll(2, otherList);\n</code></pre>"},{"location":"it/module-06/list-api/#2542-accedere-agli-elementi","title":"25.4.2 Accedere agli Elementi","text":"<pre><code>String x = list.get(0);\nlist.set(1, \"NewValue\");\n</code></pre> <p>Note</p> <p><code>get()</code> lancia <code>IndexOutOfBoundsException</code> per indici non validi.</p> <p>Se si tenta di <code>aggiornare</code> un elemento in una List vuota, anche all\u2019indice 0, si ottiene una <code>IndexOutOfBoundsException</code></p> <pre><code>List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\nlist.add(3);\nlist.add(5);\nSystem.out.println(list.toString());\nlist.clear();\nlist.set(0, 2);\n</code></pre> <p>Output</p> <pre><code>[3, 5]\nException in thread \"main\" java.lang.IndexOutOfBoundsException: Index 0 out of bounds for length 0\n</code></pre> <p>Warning</p> <p>Chiamare get/set con un indice non valido lancia IndexOutOfBoundsException</p> <p></p>"},{"location":"it/module-06/list-api/#2543-rimuovere-elementi","title":"25.4.3 Rimuovere Elementi","text":"<pre><code>list.remove(0); // remove(int index) \u2014 rimuove per indice; remove(Object) \u2014 rimuove il primo elemento uguale\nlist.remove(\"A\"); // rimuove la prima occorrenza\nlist.removeIf(s -&gt; s.startsWith(\"X\"));\nlist.clear();\n</code></pre>"},{"location":"it/module-06/list-api/#2544-comportamenti-e-caratteristiche-importanti","title":"25.4.4 Comportamenti e Caratteristiche Importanti","text":"Operazione Comportamento Eccezione(i) <code>add(E)</code> aggiunge sempre in coda \u2014 <code>add(int,E)</code> sposta gli elementi a destra IndexOutOfBoundsException <code>get(int)</code> tempo costante per ArrayList, lineare per LinkedList IndexOutOfBoundsException <code>set(int,E)</code> sostituisce l\u2019elemento IndexOutOfBoundsException <code>remove(int)</code> sposta gli elementi a sinistra IndexOutOfBoundsException <code>remove(Object)</code> rimuove il primo elemento uguale \u2014"},{"location":"it/module-06/list-api/#255-contains-equals-e-hashcode","title":"25.5 <code>contains()</code>, <code>equals()</code> e <code>hashCode()</code>","text":""},{"location":"it/module-06/list-api/#2551-contains","title":"25.5.1 <code>contains()</code>","text":"<p>Il metodo <code>contains()</code> usa <code>.equals()</code> sugli elementi.</p> <p></p>"},{"location":"it/module-06/list-api/#2552-uguaglianza-delle-list","title":"25.5.2 Uguaglianza delle List","text":"<p><code>List.equals()</code> esegue un confronto elemento per elemento, in ordine.</p> <pre><code>List&lt;String&gt; a = List.of(\"A\", \"B\");\nList&lt;String&gt; b = List.of(\"A\", \"B\");\n\nSystem.out.println(a.equals(b)); // true\n</code></pre> <p>Note</p> <ul> <li>L\u2019ordine conta.</li> <li>Il tipo di lista NON conta.</li> </ul> <p></p>"},{"location":"it/module-06/list-api/#2553-hashcode","title":"25.5.3 <code>hashCode()</code>","text":"<p>Calcolato in base al contenuto.</p> <p></p>"},{"location":"it/module-06/list-api/#256-iterare-una-list","title":"25.6 Iterare una List","text":""},{"location":"it/module-06/list-api/#2561-ciclo-for-classico","title":"25.6.1 Ciclo For Classico","text":"<pre><code>for (int i = 0; i &lt; list.size(); i++) {\n    System.out.println(list.get(i));\n}\n</code></pre>"},{"location":"it/module-06/list-api/#2562-ciclo-for-migliorato","title":"25.6.2 Ciclo For Migliorato","text":"<pre><code>for (String s : list) {\n    System.out.println(s);\n}\n</code></pre>"},{"location":"it/module-06/list-api/#2563-iterator-listiterator","title":"25.6.3 Iterator &amp; ListIterator","text":"<pre><code>Iterator&lt;String&gt; it = list.iterator();\nwhile (it.hasNext()) { System.out.println(it.next()); }\n\nListIterator&lt;String&gt; lit = list.listIterator();\nwhile (lit.hasNext()) {\n    if (lit.next().equals(\"A\")) lit.set(\"Z\");\n}\n</code></pre> <p>Warning</p> <p>Tutti gli iteratori standard di List sono fail-fast: una modifica strutturale fuori dall\u2019iteratore causa ConcurrentModificationException.</p> <p>Note</p> <p>Solo <code>ListIterator</code> supporta l\u2019iterazione bidirezionale e la modifica.</p> <p></p>"},{"location":"it/module-06/list-api/#257-il-metodo-sublist","title":"25.7 Il Metodo <code>subList()</code>","text":"<p><code>subList()</code> crea una vista di una porzione della lista, non una copia. Modificare una delle due pu\u00f2 modificare l\u2019altra.</p> <p></p>"},{"location":"it/module-06/list-api/#2571-sintassi","title":"25.7.1 Sintassi","text":"<pre><code>List&lt;E&gt; subList(int fromIndex, int toIndex);\n</code></pre>"},{"location":"it/module-06/list-api/#2572-regole","title":"25.7.2 Regole","text":"Regola Spiegazione fromIndex inclusivo l\u2019elemento a fromIndex \u00e8 incluso toIndex esclusivo l\u2019elemento a toIndex NON \u00e8 incluso La vista \u00e8 supportata dalla lista originale modificare una modifica l\u2019altra Modifica strutturale del padre invalida la subList \u2192 ConcurrentModificationException"},{"location":"it/module-06/list-api/#2573-esempi","title":"25.7.3 Esempi","text":"<pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;(List.of(\"A\", \"B\", \"C\", \"D\"));\nList&lt;String&gt; view = list.subList(1, 3);\n// view = [\"B\", \"C\"]\n\nview.set(0, \"X\");\n// list = [\"A\", \"X\", \"C\", \"D\"]\n// view = [\"X\", \"C\"]\n</code></pre>"},{"location":"it/module-06/list-api/#2574-modificare-la-lista-padre-invalida-la-vista","title":"25.7.4 Modificare la lista padre invalida la vista","text":"<pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;(List.of(\"A\",\"B\",\"C\",\"D\"));\nList&lt;String&gt; view = list.subList(1, 3);\n\nlist.add(\"E\"); // modifica strutturale della lista padre\n\nview.get(0); // \u274c ConcurrentModificationException\n</code></pre>"},{"location":"it/module-06/list-api/#2575-modificare-la-sublist-modifica-il-padre","title":"25.7.5 Modificare la subList modifica il padre","text":"<pre><code>view.remove(1);\n// rimuove \"C\" sia dalla view che dalla lista padre\n</code></pre>"},{"location":"it/module-06/list-api/#2576-svuotare-la-sublist-svuota-parte-della-lista-padre","title":"25.7.6 Svuotare la subList svuota parte della lista padre","text":"<pre><code>view.clear();\n// rimuove gli indici 1 e 2 dalla lista padre\n</code></pre>"},{"location":"it/module-06/list-api/#2577-trappole-comuni","title":"25.7.7 Trappole Comuni","text":"<ul> <li>Supporre che subList sia indipendente: \u00e8 una vista, non una copia</li> <li>Supporre che subList consenta il ridimensionamento: funziona solo su liste padre modificabili</li> <li>Dimenticare che le modifiche al padre invalidano la vista causando ConcurrentModificationException</li> <li>Aspettative errate sugli indici: l\u2019indice finale \u00e8 esclusivo</li> </ul>"},{"location":"it/module-06/list-api/#258-tabella-riassuntiva-delle-operazioni-importanti","title":"25.8 Tabella Riassuntiva delle Operazioni Importanti","text":"Operazione ArrayList LinkedList List Immutabili <code>add(E)</code> veloce veloce \u274c non supportato <code>add(index,E)</code> lento (shift) veloce \u274c <code>get(index)</code> veloce lento veloce <code>remove(index)</code> lento lento (a meno che si rimuova primo/ultimo) \u274c <code>remove(Object)</code> pi\u00f9 lento pi\u00f9 lento \u274c <code>set(index,E)</code> veloce lento \u274c <code>iterator()</code> veloce veloce veloce <code>listIterator()</code> veloce veloce veloce <code>contains(Object)</code> O(n) O(n) O(n) ```"},{"location":"it/module-06/map-api/","title":"28. Map API","text":""},{"location":"it/module-06/map-api/#indice","title":"Indice","text":"<ul> <li>28.1 Caratteristiche Fondamentali di Map</li> <li>28.2 Principali Implementazioni di Map</li> <li>28.3 Creare Map</li> <li>28.4 Operazioni di Base sulle Map</li> <li>28.5 Iterare su una Map</li> <li>28.6 Determinare l\u2019Uguaglianza nelle Map</li> <li>28.7 Comportamento Speciale di TreeMap</li> <li>28.8 Gestione dei Null</li> <li>28.9 Trappole Comuni</li> <li>28.10 Riepilogo</li> </ul> <p>L\u2019interfaccia <code>Map</code> rappresenta una collezione di coppie chiave\u2013valore, dove ogni chiave \u00e8 associata ad un unico valore.</p> <p>A differenza degli altri tipi di collezione, <code>Map</code> non estende <code>Collection</code> e quindi possiede una propria gerarchia e regole specifiche.</p> <p></p>"},{"location":"it/module-06/map-api/#281-caratteristiche-fondamentali-di-map","title":"28.1 Caratteristiche Fondamentali di Map","text":"<ul> <li>Ogni chiave \u00e8 unica; chiavi duplicate sovrascrivono il valore precedente</li> <li>I valori possono essere duplicati</li> <li>Le Map non supportano accesso posizionale (basato su indice)</li> <li>L\u2019iterazione avviene tramite <code>keySet()</code>, <code>values()</code> o <code>entrySet()</code></li> </ul> <p>Note</p> <p>Una <code>Map</code> non \u00e8 una <code>Collection</code>, ma le sue viste (keySet, values, entrySet) sono collezioni.</p> <p></p>"},{"location":"it/module-06/map-api/#282-principali-implementazioni-di-map","title":"28.2 Principali Implementazioni di Map","text":"Implementazione Ordinamento Chiavi Null Valori Null Thread-Safe Note <code>HashMap</code> Nessun ordine 1 Molti No Veloce, la pi\u00f9 comune <code>LinkedHashMap</code> Ordine di inserimento 1 Molti No Iterazione prevedibile <code>TreeMap</code> Ordinata per chiave No Molti No Le chiavi devono essere confrontabili <code>Hashtable</code> Nessun ordine No No S\u00ec Legacy <code>ConcurrentHashMap</code> Nessun ordine No No S\u00ec Adatta alla concorrenza <p>Note</p> <p>L\u2019ordinamento di <code>TreeMap</code> \u00e8 determinato da <code>Comparable</code> o da un <code>Comparator</code> fornito al momento della creazione.</p> <p></p>"},{"location":"it/module-06/map-api/#283-creare-map","title":"28.3 Creare Map","text":"<p>Le <code>Map</code> possono essere create usando costruttori o metodi factory.</p> <pre><code>Map&lt;String, Integer&gt; map1 = new HashMap&lt;&gt;();\nMap&lt;String, Integer&gt; map2 = new LinkedHashMap&lt;&gt;();\nMap&lt;String, Integer&gt; map3 = new TreeMap&lt;&gt;();\n\nMap&lt;String, Integer&gt; map4 = Map.of(\"A\", 1, \"B\", 2);\nMap&lt;String, Integer&gt; map5 = Map.ofEntries(\n    Map.entry(\"X\", 10),\n    Map.entry(\"Y\", 20)\n);\n</code></pre> <p>Note</p> <p>Le Map create con <code>Map.of(...)</code> e <code>Map.ofEntries(...)</code> sono immutabili. Qualsiasi tentativo di modifica lancia <code>UnsupportedOperationException</code>.</p> <p></p>"},{"location":"it/module-06/map-api/#284-operazioni-di-base-sulle-map","title":"28.4 Operazioni di Base sulle Map","text":"Metodo Descrizione Valore di Ritorno <code>put(k, v)</code> Aggiunge o sostituisce una associazione Valore precedente o null <code>putIfAbsent(k,v)</code> Aggiunge solo se la chiave non \u00e8 presente Valore esistente o null <code>get(k)</code> Restituisce il valore o null Valore specifico o null <code>getOrDefault(k, default)</code> Restituisce valore o default Valore specifico o default <code>remove(k)</code> Rimuove l\u2019associazione Valore rimosso o null <code>containsKey(k)</code> Verifica presenza chiave boolean <code>containsValue(v)</code> Verifica presenza valore boolean <code>size()</code> Numero di entry int <code>isEmpty()</code> Verifica se vuota boolean <code>clear()</code> Rimuove tutte le entry void <code>V merge(k, v, BiFunction(V, V, V))</code> merge(k, v, remappingFunction) se la chiave \u00e8 assente \u2192 imposta il valore; se presente \u2192 function(oldValue, newValue); se la funzione restituisce null \u2192 mapping rimosso <pre><code>Map&lt;String, String&gt; map = new HashMap&lt;&gt;();\nmap.put(\"A\", \"Apple\");\nmap.put(\"B\", \"Banana\");\n\nmap.put(\"A\", \"Avocado\"); // sovrascrive il valore\n\nString v = map.get(\"B\"); // Banana\n</code></pre>"},{"location":"it/module-06/map-api/#285-iterare-su-una-map","title":"28.5 Iterare su una Map","text":"<p>Le Map vengono iterate tramite le viste:</p> <ul> <li><code>keySet()</code> \u2192 Set di chiavi</li> <li><code>values()</code> \u2192 Collection di valori</li> <li><code>entrySet()</code> \u2192 Set di Map.Entry</li> </ul> <pre><code>for (String key : map.keySet()) {\n    System.out.println(key);\n}\n\nfor (String value : map.values()) {\n    System.out.println(value);\n}\n\nfor (Map.Entry&lt;String, String&gt; e : map.entrySet()) {\n    System.out.println(e.getKey() + \" = \" + e.getValue());\n}\n</code></pre> <p>Note</p> <p>Modificare la map durante l\u2019iterazione su queste viste pu\u00f2 lanciare <code>ConcurrentModificationException</code> (eccetto per le map concorrenti).</p> <p></p>"},{"location":"it/module-06/map-api/#286-determinare-luguaglianza-nelle-map","title":"28.6 Determinare l\u2019Uguaglianza nelle Map","text":"<p>L\u2019uguaglianza tra map \u00e8 definita come segue:</p> <ul> <li>Due map sono uguali se contengono le stesse associazioni chiave\u2013valore</li> <li>Il confronto delle chiavi usa <code>equals()</code></li> <li>Il confronto dei valori usa <code>equals()</code></li> </ul> <pre><code>Map&lt;String, Integer&gt; m1 = Map.of(\"A\", 1, \"B\", 2);\nMap&lt;String, Integer&gt; m2 = Map.of(\"B\", 2, \"A\", 1);\n\nSystem.out.println(m1.equals(m2)); // true\n</code></pre> <p>Note</p> <p>L\u2019ordine di iterazione non influisce sull\u2019uguaglianza delle map.</p> <p></p>"},{"location":"it/module-06/map-api/#287-comportamento-speciale-di-treemap","title":"28.7 Comportamento Speciale di TreeMap","text":"<p>TreeMap mantiene le entry in ordinate in base alle chiavi.</p> <pre><code>Map&lt;Integer, String&gt; tm = new TreeMap&lt;&gt;();\ntm.put(3, \"C\");\ntm.put(1, \"A\");\ntm.put(2, \"B\");\n\nSystem.out.println(tm); // {1=A, 2=B, 3=C}\n</code></pre> <p>Warning</p> <p>Tutte le chiavi in una <code>TreeMap</code> devono essere mutuamente confrontabili. Mescolare tipi incompatibili causa <code>ClassCastException</code> a runtime.</p> <p></p>"},{"location":"it/module-06/map-api/#288-gestione-dei-null","title":"28.8 Gestione dei Null","text":"Implementazione Chiave Null Valore Null HashMap S\u00ec (1) S\u00ec LinkedHashMap S\u00ec (1) S\u00ec TreeMap No S\u00ec Hashtable No No ConcurrentHashMap No No <p>Note</p> <p><code>TreeMap</code> accetta valori <code>null</code> solo quando non partecipano al confronto delle chiavi. In pratica questo \u00e8 raro, perch\u00e9 le chiavi null sono vietate e i comparator possono rifiutare i null.</p> <p><code>HashMap</code> e <code>LinkedHashMap</code> consentono <code>una sola chiave null</code> \u2014 inserirne un\u2019altra sostituisce quella esistente.</p> <p></p>"},{"location":"it/module-06/map-api/#289-trappole-comuni","title":"28.9 Trappole Comuni","text":"<ul> <li>Supporre che Map sia una Collection</li> <li>Dimenticare che chiavi duplicate sovrascrivono i valori</li> <li>Usare chiavi null in TreeMap o ConcurrentHashMap</li> <li>Confondere l\u2019ordine di iterazione con l\u2019uguaglianza</li> <li>Tentare di modificare map immutabili create con Map.of</li> </ul>"},{"location":"it/module-06/map-api/#2810-riepilogo","title":"28.10 Riepilogo","text":"<ul> <li>Le Map memorizzano chiavi uniche associate a valori</li> <li>L\u2019ordinamento dipende dall\u2019implementazione</li> <li>L\u2019uguaglianza \u00e8 basata sulle coppie chiave\u2013valore</li> <li>TreeMap richiede chiavi confrontabili</li> <li>Le map immutabili lanciano eccezioni in caso di modifica</li> </ul>"},{"location":"it/module-06/queue-api/","title":"27. API Queue &amp; Deque","text":""},{"location":"it/module-06/queue-api/#indice","title":"Indice","text":"<ul> <li>27.1 Queue \u2014 Panoramica<ul> <li>27.1.1 Metodi Principali di Queue</li> <li>27.1.2 Implementazioni di Queue</li> </ul> </li> <li>27.2 Deque \u2014 Panoramica<ul> <li>27.2.1 Metodi Principali di Deque</li> <li>27.2.2 Implementazioni di Deque</li> </ul> </li> <li>27.3 Usare una Queue</li> <li>27.4 Usare una Deque come Queue e come Stack<ul> <li>27.4.1 Esempio FIFO (Comportamento Queue)</li> <li>27.4.2 Esempio LIFO (Comportamento Stack)</li> </ul> </li> <li>27.5 PriorityQueue \u2014 Queue Speciale</li> <li>27.6 Blocking Queue (Basi)</li> <li>27.7 Trappole Comuni</li> <li>27.8 Tabella Riassuntiva</li> </ul> <p>Le interfacce <code>Queue</code> e <code>Deque</code> di Java modellano collezioni ordinate progettate per elaborare elementi in una sequenza specifica.</p> <p>Una Queue modella tipicamente una struttura FIFO (First-In, First-Out). Una Deque (<code>double-ended queue</code>) consente inserimento e rimozione da entrambe le estremit\u00e0, permettendo comportamenti FIFO e LIFO in una singola API.</p> <p></p>"},{"location":"it/module-06/queue-api/#271-queue-panoramica","title":"27.1 Queue \u2014 Panoramica","text":"<p>L\u2019interfaccia <code>Queue</code> estende <code>Collection</code> ed \u00e8 comunemente utilizzata nella programmazione asincrona, nella distribuzione del carico, negli algoritmi e nel buffering.</p> <p>Esistono due famiglie di metodi: quelli che lanciano eccezioni e quelli che restituiscono valori speciali (di solito <code>null</code>).</p> <p></p>"},{"location":"it/module-06/queue-api/#2711-metodi-principali-di-queue","title":"27.1.1 Metodi Principali di Queue","text":"Operazione Lancia Eccezione Restituisce Valore Speciale Descrizione Inserimento <code>add(e)</code> <code>offer(e)</code> Aggiunge un elemento; <code>offer</code> \u00e8 preferibile per queue con capacit\u00e0 limitata Rimozione <code>E remove()</code> <code>E poll()</code> Rimuove e restituisce la testa. <code>remove()</code> lancia NoSuchElementException se la queue \u00e8 vuota, <code>poll()</code> restituisce null Lettura <code>E element()</code> <code>E peek()</code> Restituisce la testa senza rimuoverla. <code>element()</code> lancia NoSuchElementException se la queue \u00e8 vuota, <code>peek()</code> restituisce null"},{"location":"it/module-06/queue-api/#2712-implementazioni-di-queue","title":"27.1.2 Implementazioni di Queue","text":"<p>Classi comuni che implementano <code>Queue</code>:</p> <ul> <li><code>LinkedList</code> \u2014 non limitata, implementa anche <code>Deque</code> e <code>List</code>.</li> <li><code>ArrayDeque</code> \u2014 queue veloce basata su array ridimensionabile; non pu\u00f2 contenere <code>null</code>.</li> <li><code>PriorityQueue</code> \u2014 ordina gli elementi per ordine naturale o comparator; non \u00e8 FIFO.</li> <li><code>ConcurrentLinkedQueue</code> \u2014 thread-safe, lock-free.</li> </ul> <p>Note</p> <p><code>PriorityQueue</code> non garantisce che l\u2019ordine di iterazione corrisponda all\u2019ordinamento per priorit\u00e0.</p> <p>Warning</p> <p>La maggior parte delle implementazioni di Queue rifiuta <code>null</code> perch\u00e9 <code>null</code> \u00e8 usato come valore di ritorno per \u201cvuoto\u201d.</p> <p></p>"},{"location":"it/module-06/queue-api/#272-deque-panoramica","title":"27.2 Deque \u2014 Panoramica","text":"<p><code>Deque</code> (double-ended queue) supporta inserimento, rimozione e ispezione sia dalla testa sia dalla coda.</p> <p>\u00c8 pi\u00f9 versatile di una Queue: - FIFO (simile a una queue) - LIFO (simile a uno stack) - Algoritmi bidirezionali</p> <p></p>"},{"location":"it/module-06/queue-api/#2721-metodi-principali-di-deque","title":"27.2.1 Metodi Principali di Deque","text":"Operazione Fronte Fondo Inserimento addFirst(e), offerFirst(e) addLast(e), offerLast(e) Rimozione removeFirst(), pollFirst() removeLast(), pollLast() Ispezione getFirst(), peekFirst() getLast(), peekLast()"},{"location":"it/module-06/queue-api/#2722-implementazioni-di-deque","title":"27.2.2 Implementazioni di Deque","text":"<ul> <li><code>ArrayDeque</code> \u2014 implementazione consigliata per uso generale (veloce, senza limite di capacit\u00e0).</li> <li><code>LinkedList</code> \u2014 completa ma pi\u00f9 lenta a causa della struttura a nodi.</li> <li><code>ConcurrentLinkedDeque</code> \u2014 deque concorrente non bloccante.</li> </ul> <p>Note</p> <p><code>Stack</code> \u00e8 legacy; usare <code>Deque</code> per il comportamento di stack (push/pop). Le operazioni di queue di ArrayDeque e LinkedList (add/remove/peek) sono O(1) ammortizzato.</p> <p></p>"},{"location":"it/module-06/queue-api/#273-usare-una-queue","title":"27.3 Usare una Queue","text":"<pre><code>Queue&lt;String&gt; q = new LinkedList&lt;&gt;();\n\nq.offer(\"A\");\nq.offer(\"B\");\nq.offer(\"C\");\n\nSystem.out.println(q.peek());   // A\nSystem.out.println(q.poll());   // A\nSystem.out.println(q.poll());   // B\nSystem.out.println(q.poll());   // C\nSystem.out.println(q.poll());   // null (queue vuota)\n</code></pre>"},{"location":"it/module-06/queue-api/#274-usare-una-deque-come-queue-e-come-stack","title":"27.4 Usare una Deque (come Queue e come Stack)","text":""},{"location":"it/module-06/queue-api/#2741-esempio-fifo-comportamento-queue","title":"27.4.1 Esempio FIFO (Comportamento Queue)","text":"<pre><code>Deque&lt;String&gt; dq = new ArrayDeque&lt;&gt;();\n\ndq.offerLast(\"A\"); // enqueue\ndq.offerLast(\"B\");\ndq.offerLast(\"C\");\n\nSystem.out.println(dq.pollFirst()); // A\nSystem.out.println(dq.pollFirst()); // B\nSystem.out.println(dq.pollFirst()); // C\n</code></pre>"},{"location":"it/module-06/queue-api/#2742-esempio-lifo-comportamento-stack","title":"27.4.2 Esempio LIFO (Comportamento Stack)","text":"<pre><code>Deque&lt;String&gt; stack = new ArrayDeque&lt;&gt;();\n\nstack.push(\"A\");\nstack.push(\"B\");\nstack.push(\"C\");\n\nSystem.out.println(stack.pop()); // C\nSystem.out.println(stack.pop()); // B\nSystem.out.println(stack.pop()); // A\n</code></pre>"},{"location":"it/module-06/queue-api/#275-priorityqueue-queue-speciale","title":"27.5 PriorityQueue \u2014 Queue Speciale","text":"<p><code>PriorityQueue</code> ordina gli elementi per ordine naturale o tramite un <code>Comparator</code> fornito.</p> <p>Caratteristiche importanti:</p> <ul> <li>Non FIFO \u2014 la testa \u00e8 l\u2019elemento \u201cpi\u00f9 piccolo\u201d.</li> <li>L\u2019ordine \u00e8 garantito solo durante la rimozione, non durante l\u2019iterazione.</li> <li>Gli elementi <code>null</code> non sono consentiti.</li> </ul> <pre><code>PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;();\n\npq.offer(50);\npq.offer(10);\npq.offer(30);\n\nSystem.out.println(pq.poll()); // 10\nSystem.out.println(pq.poll()); // 30\nSystem.out.println(pq.poll()); // 50\n</code></pre> <p></p>"},{"location":"it/module-06/queue-api/#276-blocking-queue-basi","title":"27.6 Blocking Queue (Basi)","text":"<p>Negli ambienti concorrenti, il package <code>java.util.concurrent</code> fornisce tipi di queue bloccanti.</p> <ul> <li><code>ArrayBlockingQueue</code> \u2014 array sottostante a dimensione fissa.</li> <li><code>LinkedBlockingQueue</code> \u2014 opzionalmente limitata.</li> <li><code>PriorityBlockingQueue</code> \u2014 priority queue thread-safe.</li> <li><code>DelayQueue</code> \u2014 elementi rilasciati dopo un ritardo.</li> </ul> <p>Note</p> <p>BlockingQueue non consente mai <code>null</code>. put(e) \u2014 blocca finch\u00e9 c\u2019\u00e8 spazio disponibile take() \u2014 blocca finch\u00e9 un elemento \u00e8 disponibile BlockingQueue supporta anche operazioni temporizzate: offer(e, timeout), poll(timeout)</p> <p></p>"},{"location":"it/module-06/queue-api/#277-trappole-comuni","title":"27.7 Trappole Comuni","text":"<ul> <li>I metodi di <code>Queue</code> e <code>Deque</code> esistono in varianti \u201ccon eccezione\u201d e \u201ccon valore speciale\u201d \u2014 memorizzare quali sono quali.</li> <li><code>ArrayDeque</code> non pu\u00f2 contenere <code>null</code> \u2014 <code>null</code> \u00e8 usato internamente.</li> <li>L\u2019ordine di iterazione di <code>PriorityQueue</code> NON \u00e8 ordinato.</li> <li>L\u2019uso di <code>Stack</code> \u00e8 sconsigliato; usare invece <code>Deque</code>.</li> <li>Deque consente sia FIFO sia LIFO e ha l\u2019API pi\u00f9 completa.</li> </ul>"},{"location":"it/module-06/queue-api/#278-tabella-riassuntiva","title":"27.8 Tabella Riassuntiva","text":"Interfaccia Comportamento Tipico Null Consentito? Implementazioni Comuni Note Queue FIFO Dipende LinkedList, ArrayDeque, PriorityQueue PriorityQueue non FIFO Deque FIFO + LIFO No (ArrayDeque) ArrayDeque, LinkedList Operazioni complete a doppia estremit\u00e0 PriorityQueue Ordinata per priorit\u00e0 No PriorityQueue Rimuove prima l\u2019elemento pi\u00f9 piccolo BlockingQueue FIFO thread-safe No ArrayBlockingQueue, LinkedBlockingQueue differenze tra add/offer e put ConcurrentLinkedQueue FIFO lock-free No ConcurrentLinkedQueue Molto veloce per il multi-threading"},{"location":"it/module-06/sequenced/","title":"29. Collezioni Sequenziate &amp; Map Sequenziate","text":""},{"location":"it/module-06/sequenced/#indice","title":"Indice","text":"<ul> <li>29.1 Motivazione e Contesto</li> <li>29.2 Interfaccia SequencedCollection<ul> <li>29.2.1 Metodi Principali di SequencedCollection</li> <li>29.2.2 Implementazioni di SequencedCollection</li> <li>29.2.3 Viste Invertite</li> </ul> </li> <li>29.3 Interfaccia SequencedMap<ul> <li>29.3.1 Metodi Principali di SequencedMap</li> <li>29.3.2 Implementazioni di SequencedMap</li> <li>29.3.3 Map Invertite</li> </ul> </li> <li>29.4 Relazione con le API Esistenti<ul> <li>29.4.1 Quali Tipi Built-in Sono Sequenziati</li> </ul> </li> <li>29.5 Trappole Comuni</li> <li>29.6 Riepilogo</li> </ul> <p>Java 21 introduce le <code>Collezioni Sequenziate</code> e le <code>Map Sequenziate</code> per unificare e formalizzare l\u2019accesso agli elementi in base al loro ordine di incontro.</p> <p>Questa aggiunta risolve incoerenze di lunga data tra liste, set, queue, deque e map, fornendo un\u2019API comune per lavorare con il primo e l\u2019ultimo elemento, oltre che con viste invertite.</p> <p></p>"},{"location":"it/module-06/sequenced/#291-motivazione-e-contesto","title":"29.1 Motivazione e Contesto","text":"<p>Prima di Java 21, le collezioni ordinate (come List, LinkedHashSet, Deque o LinkedHashMap) esponevano operazioni basate sull\u2019ordine tramite metodi diversi o, in alcuni casi, non le esponevano affatto.</p> <p>Gli sviluppatori dovevano fare affidamento su API specifiche dell\u2019implementazione o su soluzioni indirette.</p> <p>Le interfacce sequenziate introducono un contratto coerente per tutte le collezioni e map ordinate, rendendo le operazioni basate sull\u2019ordine esplicite, sicure e uniformi.</p> <p></p>"},{"location":"it/module-06/sequenced/#292-interfaccia-sequencedcollection","title":"29.2 Interfaccia SequencedCollection","text":"<p><code>SequencedCollection&lt;E&gt;</code> \u00e8 una nuova interfaccia che estende <code>Collection&lt;E&gt;</code> e rappresenta collezioni con un ordine di incontro ben definito.</p> <p>\u00c8 implementata da <code>List</code>, <code>Deque</code> e <code>LinkedHashSet</code> (<code>TreeSet</code> \u00e8 ordinato ma non implementa direttamente SequencedCollection).</p> <p></p>"},{"location":"it/module-06/sequenced/#2921-metodi-principali-di-sequencedcollection","title":"29.2.1 Metodi Principali di SequencedCollection","text":"<p>L\u2019interfaccia definisce metodi per accedere e manipolare gli elementi a entrambe le estremit\u00e0 della collezione.</p> Metodo Descrizione <code>E getFirst()</code> Restituisce il primo elemento <code>E getLast()</code> Restituisce l\u2019ultimo elemento <code>void addFirst(E e)</code> Inserisce un elemento all\u2019inizio <code>void addLast(E e)</code> Inserisce un elemento alla fine <code>E removeFirst()</code> Rimuove e restituisce il primo elemento <code>E removeLast()</code> Rimuove e restituisce l\u2019ultimo elemento <code>SequencedCollection&lt;E&gt; reversed()</code> Restituisce una vista invertita <p></p>"},{"location":"it/module-06/sequenced/#2922-implementazioni-di-sequencedcollection","title":"29.2.2 Implementazioni di SequencedCollection","text":"<p>I seguenti tipi standard implementano SequencedCollection:</p> Tipo Note List Ordinata per indice Deque Coda a doppia estremit\u00e0 LinkedHashSet Mantiene l\u2019ordine di inserimento <p></p>"},{"location":"it/module-06/sequenced/#2923-viste-invertite","title":"29.2.3 Viste Invertite","text":"<p>La chiamata a <code>reversed()</code> non crea una copia.</p> <p>Restituisce una vista live della stessa collezione con ordine invertito.</p> <pre><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;(List.of(1, 2, 3));\nSequencedCollection&lt;Integer&gt; rev = list.reversed();\n\nrev.removeFirst(); // rimuove 3\nSystem.out.println(list); // [1, 2]\n</code></pre> <p>Note</p> <p>Le viste invertite condividono la stessa collezione sottostante. Le modifiche strutturali in una delle due viste influenzano anche l\u2019altra: modificare sia la collezione originale sia la vista invertita ha effetto su entrambe.</p> <p></p>"},{"location":"it/module-06/sequenced/#293-interfaccia-sequencedmap","title":"29.3 Interfaccia SequencedMap","text":"<p><code>SequencedMap&lt;K,V&gt;</code> estende <code>Map&lt;K,V&gt;</code> e rappresenta map con un ordine di incontro delle entry ben definito.</p> <p>Standardizza operazioni che in precedenza esistevano solo in implementazioni specifiche come <code>LinkedHashMap</code>.</p> <p></p>"},{"location":"it/module-06/sequenced/#2931-metodi-principali-di-sequencedmap","title":"29.3.1 Metodi Principali di SequencedMap","text":"Metodo Descrizione <code>Entry&lt;K,V&gt; firstEntry()</code> Prima entry della map <code>Entry&lt;K,V&gt; lastEntry()</code> Ultima entry della map <code>Entry&lt;K,V&gt; pollFirstEntry()</code> Rimuove e restituisce la prima entry, oppure null se vuota <code>Entry&lt;K,V&gt; pollLastEntry()</code> Rimuove e restituisce l\u2019ultima entry, oppure null se vuota <code>SequencedMap&lt;K,V&gt; reversed()</code> Vista invertita della map"},{"location":"it/module-06/sequenced/#2932-implementazioni-di-sequencedmap","title":"29.3.2 Implementazioni di SequencedMap","text":"<p>Attualmente, la principale implementazione standard \u00e8:</p> Tipo Ordinamento <code>LinkedHashMap</code> Ordine di inserimento (o ordine di accesso se configurato) <p>Note</p> <p>LinkedHashMap pu\u00f2 riordinare le entry in lettura se costruita con <code>accessOrder=true</code>.</p> <p>In tal caso, \u201cprima\u201d e \u201cultima\u201d riflettono l\u2019ordine di accesso pi\u00f9 recente.</p> <p></p>"},{"location":"it/module-06/sequenced/#2933-map-invertite","title":"29.3.3 Map Invertite","text":"<p>Come per le collezioni, <code>reversed()</code> su una map sequenziata restituisce una vista, non una copia.</p> <pre><code>SequencedMap&lt;String, Integer&gt; map =\nnew LinkedHashMap&lt;&gt;(Map.of(\"A\", 1, \"B\", 2, \"C\", 3));\n\nSequencedMap&lt;String, Integer&gt; rev = map.reversed();\n\nrev.pollFirstEntry(); // rimuove C=3\nSystem.out.println(map); // {A=1, B=2}\n</code></pre> <p>Note</p> <p>Come per SequencedCollection, <code>reversed()</code> restituisce una vista live \u2014 le mutazioni si applicano a entrambe le map.</p> <p></p>"},{"location":"it/module-06/sequenced/#294-relazione-con-le-api-esistenti","title":"29.4 Relazione con le API Esistenti","text":"<p>Le interfacce sequenziate non sostituiscono i tipi di collezione esistenti.</p> <p>Si collocano sopra di essi nella gerarchia e unificano i comportamenti comuni.</p> <p>Tutte le collezioni ordinate esistenti beneficiano automaticamente di queste API senza rompere la retrocompatibilit\u00e0.</p> <p></p>"},{"location":"it/module-06/sequenced/#2941-quali-tipi-built-in-sono-sequenziati","title":"29.4.1 Quali Tipi Built-in Sono Sequenziati?","text":"<p>La tabella seguente riassume se i tipi standard di collezione sono ordinati e se implementano le nuove interfacce Sequenced.</p> Tipo Ordinato? SequencedCollection? SequencedMap? <code>List</code> \u2714 S\u00ec \u2714 S\u00ec \u2718 No <code>Deque</code> \u2714 S\u00ec \u2714 S\u00ec \u2718 No <code>LinkedHashSet</code> \u2714 S\u00ec \u2714 S\u00ec \u2718 No <code>TreeSet</code> \u2714 S\u00ec (ordinato) \u2718 No* \u2718 No <code>HashSet</code> \u2718 No \u2718 No \u2718 No <code>LinkedHashMap</code> \u2714 S\u00ec \u2718 No \u2714 S\u00ec <code>HashMap</code> \u2718 No \u2718 No \u2718 No <code>TreeMap</code> \u2714 S\u00ec (ordinato) \u2718 No \u2718 No <p>Note</p> <p><code>TreeSet</code> \u00e8 ordinato, ma implementa <code>SortedSet</code>/<code>NavigableSet</code>, non <code>SequencedCollection</code>.</p> <p></p>"},{"location":"it/module-06/sequenced/#295-trappole-comuni","title":"29.5 Trappole Comuni","text":"<ul> <li>Le interfacce sequenziate definiscono viste, non copie</li> <li><code>reversed()</code> riflette le modifiche in modo bidirezionale</li> <li>Non tutte le implementazioni di Set o Map sono sequenziate</li> <li>HashSet e HashMap non implementano interfacce sequenziate</li> <li>L\u2019ordine \u00e8 garantito solo quando esplicitamente definito</li> <li>La rimozione di elementi tramite iterator sulla vista invertita impatta immediatamente l\u2019ordine originale</li> </ul>"},{"location":"it/module-06/sequenced/#296-riepilogo","title":"29.6 Riepilogo","text":"<ul> <li>Le interfacce sequenziate formalizzano l\u2019ordine di incontro</li> <li>Forniscono accesso first/last e inversione</li> <li>Funzionano tramite viste live, non copie</li> <li>Unificano le API tra liste, deque, set e map</li> </ul>"},{"location":"it/module-06/set-api/","title":"26. Set API","text":""},{"location":"it/module-06/set-api/#indice","title":"Indice","text":"<ul> <li>26.1 Gerarchia dei Set Java-Collections-Framework</li> <li>26.2 Caratteristiche di Ogni Implementazione di Set<ul> <li>26.2.1 HashSet</li> <li>26.2.2 LinkedHashSet</li> <li>26.2.3 TreeSet</li> </ul> </li> <li>26.3 Regole di Uguaglianza nei Set<ul> <li>26.3.1 HashSet--LinkedHashSet</li> <li>26.3.2 TreeSet</li> </ul> </li> <li>26.4 Creare Istanze di Set<ul> <li>26.4.1 Usando i Costruttori</li> <li>26.4.2 Costruttori di Copia</li> <li>26.4.3 Metodi Factory</li> </ul> </li> <li>26.5 Operazioni Principali sui Set<ul> <li>26.5.1 Aggiungere Elementi</li> <li>26.5.2 Verificare l\u2019Appartenenza</li> <li>26.5.3 Rimuovere Elementi</li> <li>26.5.4 Operazioni Bulk</li> </ul> </li> <li>26.6 Trappole Comuni</li> <li>26.7 Tabella Riassuntiva</li> </ul> <p>Un Set in Java rappresenta una collezione che non contiene elementi duplicati.  </p> <p>Modella il concetto matematico di <code>insieme</code>: non ordinato (a meno di usare un\u2019implementazione ordinata) e composto da valori unici.</p> <p>Tutte le implementazioni di Set si basano su semantiche di uguaglianza (tramite <code>equals()</code> oppure logica di <code>Comparator</code>).</p> <p></p>"},{"location":"it/module-06/set-api/#261-gerarchia-dei-set-java-collections-framework","title":"26.1 Gerarchia dei Set (Java Collections Framework)","text":"<pre><code>Set&lt;E&gt;\n \u251c\u2500\u2500 SequencedSet&lt;E&gt; (Java 21+)\n \u2502    \u2514\u2500\u2500 LinkedHashSet&lt;E&gt;   (ordinato)\n \u251c\u2500\u2500 HashSet&lt;E&gt;              (non ordinato)\n \u2514\u2500\u2500 SortedSet&lt;E&gt;\n      \u2514\u2500\u2500 NavigableSet&lt;E&gt;\n           \u2514\u2500\u2500 TreeSet&lt;E&gt;    (ordinato)\n</code></pre> <p>Tutte le implementazioni di <code>Set</code> richiedono: - unicit\u00e0 degli elementi - uguaglianza e hashing prevedibili (a seconda dell\u2019implementazione)</p> <p>Note</p> <p><code>LinkedHashSet</code> \u00e8 ora formalmente un <code>SequencedSet</code> a partire da Java 21.</p> <p></p>"},{"location":"it/module-06/set-api/#262-caratteristiche-di-ogni-implementazione-di-set","title":"26.2 Caratteristiche di Ogni Implementazione di Set","text":""},{"location":"it/module-06/set-api/#2621-hashset","title":"26.2.1 HashSet","text":"<ul> <li>Set generico pi\u00f9 veloce  </li> <li>Non ordinato (nessuna garanzia sull\u2019ordine di iterazione)  </li> <li>Usa <code>hashCode()</code> ed <code>equals()</code> </li> <li>Consente un solo elemento <code>null</code> </li> </ul> <pre><code>Set&lt;String&gt; set = new HashSet&lt;&gt;();\nset.add(\"A\");\nset.add(\"B\");\nset.add(\"A\");   // duplicato ignorato\nSystem.out.println(set); // ordine non garantito\n</code></pre>"},{"location":"it/module-06/set-api/#2622-linkedhashset","title":"26.2.2 LinkedHashSet","text":"<ul> <li>Mantiene l\u2019ordine di inserimento </li> <li>Leggermente pi\u00f9 lento di HashSet  </li> <li>Utile quando \u00e8 richiesto un ordine di iterazione prevedibile</li> </ul> <pre><code>Set&lt;String&gt; set = new LinkedHashSet&lt;&gt;();\nset.add(\"A\");\nset.add(\"C\");\nset.add(\"B\");\nSystem.out.println(set);  // [A, C, B]\n</code></pre>"},{"location":"it/module-06/set-api/#2623-treeset","title":"26.2.3 TreeSet","text":"<p>Un Set ordinato il cui ordine \u00e8 determinato da: 1. Ordinamento naturale (<code>Comparable</code>) 2. Un <code>Comparator</code> fornito  </p> <p>TreeSet: - Non consente elementi <code>null</code> (NullPointerException a runtime) - Garantisce iterazione ordinata - Supporta viste di intervallo: <code>headSet()</code>, <code>tailSet()</code>, <code>subSet()</code> </p> <pre><code>TreeSet&lt;Integer&gt; tree = new TreeSet&lt;&gt;();\ntree.add(10);\ntree.add(1);\ntree.add(5);\n\nSystem.out.println(tree); // [1, 5, 10]\n</code></pre> <p>Note</p> <p><code>TreeSet</code> richiede che tutti gli elementi siano mutuamente confrontabili \u2014 mescolare tipi non confrontabili produce <code>ClassCastException</code>. Le operazioni (add, remove, contains) sono O(log n).</p> <p></p>"},{"location":"it/module-06/set-api/#263-regole-di-uguaglianza-nei-set","title":"26.3 Regole di Uguaglianza nei Set","text":"<p>Le regole differiscono in base all\u2019implementazione.</p> <p></p>"},{"location":"it/module-06/set-api/#2631-hashset-linkedhashset","title":"26.3.1 HashSet &amp; LinkedHashSet","text":"<p>L\u2019<code>unicit\u00e0</code> \u00e8 determinata da due metodi: - <code>hashCode()</code> - <code>equals()</code> </p> <p>Due oggetti sono considerati lo stesso elemento se:</p> <ol> <li>I loro hash code coincidono  </li> <li>Il loro metodo <code>equals()</code> restituisce <code>true</code> </li> </ol> <p>Warning</p> <p>Se si muta un oggetto dopo averlo aggiunto a un HashSet o LinkedHashSet, il suo hashCode pu\u00f2 cambiare e il set pu\u00f2 perdere il riferimento a quell\u2019elemento.</p> <p></p>"},{"location":"it/module-06/set-api/#2632-treeset","title":"26.3.2 TreeSet","text":"<p>L\u2019unicit\u00e0 \u00e8 basata su <code>compareTo()</code> o sul <code>Comparator</code> fornito.  </p> <p>Se <code>compare(a, b) == 0</code> allora gli oggetti sono considerati duplicati, anche se <code>equals()</code> restituisce false.</p> <pre><code>Comparator&lt;String&gt; comp = (a, b) -&gt; a.length() - b.length();\nSet&lt;String&gt; set = new TreeSet&lt;&gt;(comp);\n\nset.add(\"Hi\");\nset.add(\"Yo\"); // stessa lunghezza \u2192 trattato come duplicato\n\nSystem.out.println(set);  // [\"Hi\"]\n</code></pre> <p></p>"},{"location":"it/module-06/set-api/#264-creare-istanze-di-set","title":"26.4 Creare Istanze di Set","text":""},{"location":"it/module-06/set-api/#2641-usando-i-costruttori","title":"26.4.1 Usando i Costruttori","text":"<pre><code>Set&lt;String&gt; s1 = new HashSet&lt;&gt;();\nSet&lt;String&gt; s2 = new LinkedHashSet&lt;&gt;();\nSet&lt;String&gt; s3 = new TreeSet&lt;&gt;();\n</code></pre>"},{"location":"it/module-06/set-api/#2642-costruttori-di-copia","title":"26.4.2 Costruttori di Copia","text":"<pre><code>List&lt;String&gt; list = List.of(\"A\", \"B\", \"C\");\n\nSet&lt;String&gt; copy = new HashSet&lt;&gt;(list); // ordine perso\nSystem.out.println(copy);\n\nSet&lt;String&gt; ordered = new LinkedHashSet&lt;&gt;(list); // mantiene l\u2019ordine della lista\nSystem.out.println(ordered);\n</code></pre>"},{"location":"it/module-06/set-api/#2643-metodi-factory","title":"26.4.3 Metodi Factory","text":"<pre><code>Set&lt;String&gt; s1 = Set.of(\"A\", \"B\", \"C\");   // immutabile\nSet&lt;String&gt; empty = Set.of();             // set immutabile vuoto\n</code></pre> <p>Note</p> <p>I set creati tramite factory sono immutabili: aggiungere o rimuovere elementi lancia <code>UnsupportedOperationException</code>. <code>Set.of(...)</code> rifiuta duplicati in fase di creazione \u2192 IllegalArgumentException e rifiuta null \u2192 NullPointerException</p> <p></p>"},{"location":"it/module-06/set-api/#265-operazioni-principali-sui-set","title":"26.5 Operazioni Principali sui Set","text":""},{"location":"it/module-06/set-api/#2651-aggiungere-elementi","title":"26.5.1 Aggiungere Elementi","text":"<pre><code>set.add(\"A\");          // restituisce true se aggiunto\nset.add(\"A\");          // restituisce false se duplicato\n</code></pre>"},{"location":"it/module-06/set-api/#2652-verificare-lappartenenza","title":"26.5.2 Verificare l\u2019Appartenenza","text":"<pre><code>set.contains(\"A\");\n</code></pre>"},{"location":"it/module-06/set-api/#2653-rimuovere-elementi","title":"26.5.3 Rimuovere Elementi","text":"<pre><code>set.remove(\"A\");\nset.clear();\n</code></pre>"},{"location":"it/module-06/set-api/#2654-operazioni-bulk","title":"26.5.4 Operazioni Bulk","text":"<pre><code>set.addAll(otherSet);\nset.removeAll(otherSet);\nset.retainAll(otherSet); // intersezione\n</code></pre>"},{"location":"it/module-06/set-api/#266-trappole-comuni","title":"26.6 Trappole Comuni","text":"<ul> <li>Usare TreeSet con oggetti non confrontabili \u2192 <code>ClassCastException</code></li> <li>TreeSet non usa affatto <code>equals()</code>: solo comparator/compareTo determina l\u2019unicit\u00e0</li> <li>Usare oggetti mutabili come chiavi di Set \u2192 rompe le regole di hashing</li> <li>I Set creati con Set.of() sono immutabili \u2014 la modifica fallisce</li> <li>HashSet non garantisce l\u2019ordine di iterazione</li> <li>TreeSet tratta oggetti con compare()==0 come duplicati anche se non uguali</li> </ul>"},{"location":"it/module-06/set-api/#267-tabella-riassuntiva","title":"26.7 Tabella Riassuntiva","text":"Implementazione Mantiene l\u2019Ordine? Consente Null? Ordinato? Logica Sottostante HashSet No S\u00ec (1 null) No hashCode + equals LinkedHashSet S\u00ec (ordine di inserimento) S\u00ec (1 null) No tabella hash + lista collegata TreeSet S\u00ec (ordinato) No S\u00ec (naturale/comparator) compareTo / Comparator"},{"location":"it/module-06/shared-operations/","title":"23. Operazioni Condivise delle Collezioni &amp; Uguaglianza","text":""},{"location":"it/module-06/shared-operations/#indice","title":"Indice","text":"<ul> <li>23.1 Metodi Fondamentali delle Collezioni Disponibili per la Maggior Parte delle Collezioni<ul> <li>23.1.1 Operazioni di Mutazione</li> <li>23.1.2 Operazioni di Query</li> </ul> </li> <li>23.2 Uguaglianza</li> <li>23.3 Comportamento Fail-Fast</li> <li>23.4 Operazioni Bulk</li> <li>23.5 Tipi di Ritorno ed Eccezioni Comuni</li> <li>23.6 Tabella di Riepilogo \u2014 Operazioni Condivise</li> </ul> <p>Questo capitolo copre le operazioni fondamentali condivise in tutta la Java Collections API, incluso il modo in cui viene determinata l\u2019uguaglianza all\u2019interno delle collezioni stesse.</p> <p>Questi concetti si applicano a tutte le principali famiglie di collezioni basate su Collection (List, Set, Queue, Deque e le loro varianti Sequenced). <p>Map condivide diversi comportamenti concettuali (iterazione, uguaglianza) ma non eredita da Collection.</p> <p>Padroneggiare queste operazioni \u00e8 essenziale, poich\u00e9 spiegano come le collezioni si comportano quando si aggiungono, cercano, rimuovono, confrontano, iterano e ordinano elementi.</p> <p></p>"},{"location":"it/module-06/shared-operations/#231-metodi-fondamentali-delle-collezioni-disponibili-per-la-maggior-parte-delle-collezioni","title":"23.1 Metodi Fondamentali delle Collezioni (Disponibili per la Maggior Parte delle Collezioni)","text":"<p>I seguenti metodi provengono dall\u2019interfaccia <code>Collection&lt;E&gt;</code> e sono ereditati da tutte le principali collezioni eccetto <code>Map</code> (che ha una propria famiglia di operazioni).</p> <p>Note</p> <p><code>Map</code> non implementa <code>Collection</code>, ma le sue viste <code>keySet()</code>, <code>values()</code> ed <code>entrySet()</code> s\u00ec, e quindi espongono queste operazioni condivise.</p> <p></p>"},{"location":"it/module-06/shared-operations/#2311-operazioni-di-mutazione","title":"23.1.1 Operazioni di Mutazione","text":"<ul> <li><code>boolean add(E e)</code> \u2014 Aggiunge un elemento (le liste consentono duplicati).</li> <li><code>boolean remove(Object o)</code> \u2014 Rimuove il primo elemento corrispondente.</li> <li><code>void clear()</code> \u2014 Rimuove tutti gli elementi.</li> <li><code>boolean addAll(Collection&lt;? extends E&gt; c)</code> \u2014 Inserimento bulk.</li> <li><code>boolean removeAll(Collection&lt;?&gt; c)</code> \u2014 Rimuove tutti gli elementi contenuti nella collezione fornita.</li> <li><code>boolean retainAll(Collection&lt;?&gt; c)</code> \u2014 Mantiene solo gli elementi corrispondenti.</li> </ul>"},{"location":"it/module-06/shared-operations/#2312-operazioni-di-query","title":"23.1.2 Operazioni di Query","text":"<ul> <li><code>int size()</code> \u2014 Numero di elementi.</li> <li><code>boolean isEmpty()</code> \u2014 Indica se la collezione contiene zero elementi.</li> <li><code>boolean contains(Object o)</code> \u2014 Si basa sulle regole di uguaglianza degli elementi.</li> <li><code>Iterator&lt;E&gt; iterator()</code> \u2014 Restituisce un iteratore (fail-fast).</li> <li><code>Object[] toArray()</code> e <code>&lt;T&gt; T[] toArray(T[] a)</code> \u2014 Copia in un array.</li> </ul>"},{"location":"it/module-06/shared-operations/#232-uguaglianza","title":"23.2 Uguaglianza","text":"<p>Un\u2019implementazione personalizzata del metodo <code>equals()</code> consente di confrontare il tipo e il contenuto di due collezioni.</p> <p>L\u2019implementazione differir\u00e0 a seconda che si tratti di <code>List</code> o di <code>Set</code>.</p> <ul> <li>Esempio</li> </ul> <pre><code>List&lt;Integer&gt; firstList = List.of(10, 11, 22);\nList&lt;Integer&gt; secondList = List.of(10, 11, 22);\nList&lt;Integer&gt; thirdList = List.of(22, 11, 10);\n\nSystem.out.println(\"firstList.equals(secondList): \" + firstList.equals(secondList));\nSystem.out.println(\"secondList.equals(thirdList): \" + secondList.equals(thirdList));\n\nSet&lt;Integer&gt; firstSet = Set.of(10, 11, 22);\nSet&lt;Integer&gt; secondSet = Set.of(10, 11, 22);\nSet&lt;Integer&gt; thirdSet = Set.of(22, 11, 10);\n\nSystem.out.println(\"firstSet.equals(secondSet): \" + firstSet.equals(secondSet));\nSystem.out.println(\"secondSet.equals(thirdSet): \" + secondSet.equals(thirdSet));\n</code></pre> <p>Output</p> <pre><code>firstList.equals(secondList): true\nsecondList.equals(thirdList): false\nfirstSet.equals(secondSet): true\nsecondSet.equals(thirdSet): true\n</code></pre> <p>Note</p> <ul> <li>Le List confrontano dimensione, ordine ed uguaglianza degli elementi uno per uno.</li> <li>I Set confrontano solo dimensione e appartenenza \u2014 l\u2019ordine di encounter \u00e8 irrilevante.</li> <li>Due set con gli stessi elementi logici sono uguali anche se mantengono internamente ordini di iterazione diversi.</li> </ul> <p></p>"},{"location":"it/module-06/shared-operations/#233-comportamento-fail-fast","title":"23.3 Comportamento Fail-Fast","text":"<p>La maggior parte degli iteratori delle collezioni (eccetto le collezioni concorrenti) sono <code>fail-fast</code>: modificare strutturalmente una collezione durante l\u2019iterazione provoca una <code>ConcurrentModificationException</code>.</p> <pre><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;(List.of(1,2,3));\nfor (Integer i : list) {\n    list.add(99); // \u274c ConcurrentModificationException\n}\n</code></pre> <p>Note</p> <p>Usa <code>Iterator.remove()</code> quando devi rimuovere elementi durante l\u2019iterazione. Il comportamento fail-fast non \u00e8 garantito \u2014 l\u2019eccezione viene lanciata secondo il principio del best-effort. Non devi fare affidamento sulla sua intercettazione per la correttezza del programma.</p> <p></p>"},{"location":"it/module-06/shared-operations/#234-operazioni-bulk","title":"23.4 Operazioni Bulk","text":"<ul> <li><code>removeIf(Predicate&lt;? super E&gt; filter)</code> \u2014 Rimuove tutti gli elementi corrispondenti.</li> <li><code>replaceAll(UnaryOperator&lt;E&gt; op)</code> \u2014 Sostituisce ogni elemento.</li> <li><code>forEach(Consumer&lt;? super E&gt; action)</code> \u2014 Applica un\u2019azione a ciascun elemento.</li> <li><code>stream()</code> \u2014 Restituisce uno stream per operazioni di pipeline.</li> </ul>"},{"location":"it/module-06/shared-operations/#235-tipi-di-ritorno-ed-eccezioni-comuni","title":"23.5 Tipi di Ritorno ed Eccezioni Comuni","text":"<ul> <li><code>add(E)</code> restituisce boolean \u2014 sempre <code>true</code> per <code>ArrayList</code>, pu\u00f2 essere <code>false</code> per i <code>Set</code> se non avviene alcuna modifica.</li> <li><code>remove(Object)</code> restituisce boolean (non l\u2019elemento rimosso).</li> <li><code>get(int)</code> lancia <code>IndexOutOfBoundsException</code>.</li> <li><code>iterator().remove()</code> lancia <code>IllegalStateException</code> se chiamato due volte senza <code>next()</code>.</li> <li><code>toArray()</code> restituisce sempre un <code>Object[]</code> \u2014 non un <code>T[]</code>.</li> </ul>"},{"location":"it/module-06/shared-operations/#236-tabella-di-riepilogo-operazioni-condivise","title":"23.6 Tabella di Riepilogo \u2014 Operazioni Condivise","text":"Operazione Si applica a Note <code>add(e)</code> Tutte le collezioni eccetto Map Le List consentono duplicati <code>remove(o)</code> Tutte le collezioni eccetto Map Rimuove la prima occorrenza <code>contains(o)</code> Tutte le collezioni eccetto Map Usa equals() <code>size(), isEmpty()</code> Tutte le collezioni Tempo costante per la maggior parte <code>iterator()</code> Tutte le collezioni Fail-fast <code>clear()</code> Tutte le collezioni Rimuove tutti gli elementi <code>stream()</code> Tutte le collezioni Restituisce stream sequenziale <code>removeIf(), replaceAll()</code> Solo List (la maggior parte dei Set non supporta replaceAll) Operazioni bulk <code>toArray()</code> Tutte le collezioni Restituisce Object[]"},{"location":"it/module-07/concurrency/","title":"31. Java Concurrency APIs","text":""},{"location":"it/module-07/concurrency/#indice","title":"Indice","text":"<ul> <li>31.1 Obiettivi e Ambito della Concurrency API</li> <li>31.2 Problemi Fondamentali del Threading<ul> <li>31.2.1 Race Conditions</li> <li>31.2.2 Deadlock</li> <li>31.2.3 Starvation</li> <li>31.2.4 Livelock</li> </ul> </li> <li>31.3 Dai Thread ai Task</li> <li>31.4 Executor Framework<ul> <li>31.4.1 Submitting Task e Futures</li> <li>31.4.2 Callable vs Runnable</li> </ul> </li> <li>31.5 Thread Pools e Scheduling</li> <li>31.6 Lifecycle e Terminazione dell'Executor</li> <li>31.7 Strategie di Thread Safety<ul> <li>31.7.1 Sincronizzazione</li> <li>31.7.2 Variabili Atomiche<ul> <li>31.7.2.1 Atomic classes</li> <li>31.7.2.2 Metodi Atomici</li> </ul> </li> <li>31.7.3 Lock Framework<ul> <li>31.7.3.1 Lock implementations</li> <li>31.7.3.2 Common Lock methods</li> </ul> </li> <li>31.7.4 Coordination Utilities</li> </ul> </li> <li>31.8 Concurrent Collections</li> <li>31.9 Parallel Streams</li> <li>31.10 Relazione con Virtual Threads</li> <li>31.11 Sommario</li> </ul> <p>Questo capitolo introduce la Java Concurrency API, che fornisce astrazioni di alto livello per gestire la concorrenza in modo sicuro, efficiente e scalabile.</p> <p>A differenza della manipolazione di basso livello dei thread presentata nel capitolo precedente, la Concurrency API si concentra su task, executor e meccanismi di coordination, permettendo ai programmatori di ragionare su cosa debba essere fatto piuttosto che su come i thread vengano schedulati.</p> <p></p>"},{"location":"it/module-07/concurrency/#311-obiettivi-e-ambito-della-concurrency-api","title":"31.1 Obiettivi e Ambito della Concurrency API","text":"<p>La <code>Java Concurrency API</code>, principalmente collocata nel package <code>java.util.concurrent</code>, \u00e8 stata introdotta per affrontare problemi fondamentali inerenti alla gestione manuale dei thread.</p> <ul> <li>Separare la sottomissione dei task dalla gestione dei thread.</li> <li>Ridurre la <code>synchronization</code> di basso livello soggetta a errori.</li> <li>Migliorare scalabilit\u00e0 e performance su sistemi multi-core.</li> <li>Fornire meccanismi strutturati per <code>coordination</code>, <code>cancellation</code> e <code>shutdown</code>.</li> </ul> <p>L'API non elimina i problemi di concorrenza ma fornisce strumenti per gestirli in modo sicuro e prevedibile.</p> <p>Invece di creare e controllare esplicitamente i thread, i programmatori eseguono task e lasciano che il framework gestisca thread allocation, riuso, e synchronization.</p> <pre><code>ExecutorService executor = Executors.newSingleThreadExecutor();\nexecutor.execute(() -&gt; System.out.println(\"Task executed\"));\nexecutor.shutdown();\n</code></pre> <p></p>"},{"location":"it/module-07/concurrency/#312-problemi-fondamentali-del-threading","title":"31.2 Problemi Fondamentali del Threading","text":"<p>Prima di comprendere la <code>Concurrency API</code>, \u00e8 essenziale comprendere le problematiche di concorrenza che essa vuole mitigare.</p> <p>Questi problemi sorgono da <code>shared mutable state</code>, <code>scheduling unpredictability</code> e <code>improper coordination</code>.</p> <p></p>"},{"location":"it/module-07/concurrency/#3121-race-conditions","title":"31.2.1 Race Conditions","text":"<p>Una race condition si verifica quando pi\u00f9 thread accedono a <code>shared mutable state</code> (uno stato mutabile e condiviso) e la correttezza del programma dipende dal timing o dall\u2019intercalare della loro esecuzione.</p> <ul> <li>Causata da accesso non sincronizzato a dati condivisi.</li> <li>Porta a stato del programma inconsistente o incorretto.</li> </ul> <pre><code>class Counter {\n    int count = 0;\n    void increment() {\n       count++;\n    }\n}\n</code></pre> <p>Se pi\u00f9 thread invocano <code>increment()</code> in modo concorrente, alcuni incrementi possono andare persi perch\u00e9 l\u2019operazione non \u00e8 atomica.</p> <p></p>"},{"location":"it/module-07/concurrency/#3122-deadlock","title":"31.2.2 Deadlock","text":"<p>Un deadlock si verifica quando due o pi\u00f9 thread sono bloccati in modo permanente, ciascuno in attesa di una risorsa detenuta da un altro thread.</p> <ul> <li>Tipicamente causato da dipendenze circolari tra lock.</li> <li>Nessun thread coinvolto pu\u00f2 fare progressi.</li> </ul> <pre><code>synchronized (lockA) {\n    synchronized (lockB) {\n    }\n}\n</code></pre> <p>Se un altro thread acquisisce prima <code>lockB</code> e poi attende <code>lockA</code>, pu\u00f2 verificarsi un deadlock.</p> <p>Note</p> <p>I deadlock nel mondo reale coinvolgono tipicamente lock multipli e inversioni d\u2019ordine.</p> <p></p>"},{"location":"it/module-07/concurrency/#3123-starvation","title":"31.2.3 Starvation","text":"<p>La starvation si verifica quando a un thread viene negato indefinitamente l\u2019accesso alle risorse, anche se tali risorse sono disponibili.</p> <ul> <li>Spesso causata da <code>unfair locking</code> o policy di scheduling.</li> <li>Il thread rimane <code>runnable</code> ma non viene mai eseguito.</li> </ul> <pre><code>ReentrantLock lock = new ReentrantLock(false); // unfair lock\n</code></pre> <p>Alcuni thread possono acquisire ripetutamente il lock mentre altri attendono indefinitamente.</p> <p></p>"},{"location":"it/module-07/concurrency/#3124-livelock","title":"31.2.4 Livelock","text":"<p>In un livelock, i thread non sono bloccati ma reagiscono continuamente l\u2019uno all\u2019altro in un modo che ne impedisce il progresso.</p> <ul> <li>I thread rimangono attivi ma inefficaci.</li> <li>Spesso causato da logica di retry o avoidance aggressiva.</li> </ul> <pre><code>while (!tryLock()) {\n    Thread.sleep(10);\n}\n</code></pre> <p>Entrambi i thread possono ripetere continuamente il retry, impedendo il forward progress.</p> <p></p>"},{"location":"it/module-07/concurrency/#313-dai-thread-ai-task","title":"31.3 Dai Thread ai Task","text":"<p>La Concurrency API sposta il modello di programmazione dalla gestione diretta dei thread alla sottomissione di task.</p> <p>Un task rappresenta un\u2019unit\u00e0 logica di lavoro indipendente dal thread che lo esegue.</p> <ul> <li>Runnable: Rappresenta un task che non restituisce un risultato.</li> <li>Callable: Rappresenta un task che restituisce un risultato e pu\u00f2 lanciare checked exceptions.</li> </ul> <pre><code>Runnable task = () -&gt; System.out.println(\"Runnable task\");\nCallable&lt;Integer&gt; callable = () -&gt; 42;\n</code></pre> <p>Questa astrazione permette ai task di essere riusati, schedulati in modo flessibile ed eseguiti tramite strategie di esecuzione differenti.</p> <p></p>"},{"location":"it/module-07/concurrency/#314-executor-framework","title":"31.4 Executor Framework","text":"<p>L\u2019Executor Framework \u00e8 il cuore della Concurrency API.</p> <p>Gestisce la creazione dei thread, il riuso ed l'esecuzione dei task attraverso una interfaccia semplice.</p> <ul> <li>Executor: Interfaccia di base per eseguire task.</li> <li>ExecutorService: Estende Executor con controllo del lifecycle e gestione dei risultati.</li> <li>ScheduledExecutorService: Supporta esecuzione di task delayed e periodici.</li> </ul> <pre><code>ExecutorService executor = Executors.newFixedThreadPool(2);\nexecutor.execute(() -&gt; System.out.println(\"Task 1\"));\nexecutor.execute(() -&gt; System.out.println(\"Task 2\"));\nexecutor.shutdown();\n</code></pre> <p></p>"},{"location":"it/module-07/concurrency/#3141-submitting-task-e-futures","title":"31.4.1 Submitting Task e Futures","text":"<p>I task sottomessi tramite <code>execute()</code> restituiscono <code>void</code>: \u00e8 un metodo \"fire-and-forget\" che non restituisce alcuna informazione sul risultato del task.</p> <p>I task sottomessi usando <code>submit()</code> restituiscono un Future, che rappresenta il risultato di una computazione asincrona.</p> <p>Entrambi i metodi sono usati per sottomettere lavoro per esecuzione asincrona.</p> <pre><code>Future&lt;Integer&gt; future = executor.submit(() -&gt; 10 + 20);\nInteger result = future.get();\n</code></pre> Method Description void execute(Runnable task) Esegue un task in modo asincrono senza valore di ritorno e senza <code>Future</code>. Future&lt;?&gt; submit(Runnable task) Esegue un task in modo asincrono; non viene prodotto alcun risultato (<code>Future.get()</code> restituisce <code>null</code>).  Future submit(Callable task) Esegue un task in modo asincrono e restituisce un risultato di tipo <code>T</code>.  List&gt; invokeAll(Collection&lt;? extends Callable&gt; tasks) Esegue tutti i task e restituisce un <code>Future</code> per ciascuno, dopo che tutti completano.  T invokeAny(Collection&lt;? extends Callable&gt; tasks) Esegue i task e restituisce il risultato di uno che completa con successo; gli altri vengono cancellati. Method Description boolean isDone() Restituisce <code>true</code> se il task \u00e8 completato (normalmente, eccezionalmente, o via cancellazione). boolean isCancelled() Restituisce <code>true</code> se il task \u00e8 stato cancellato prima del completamento normale. boolean cancel(boolean mayInterruptIfRunning) Tenta di cancellare l\u2019esecuzione. Se <code>true</code>, interrompe il thread in esecuzione se possibile. T get() Blocca fino al completamento e restituisce il risultato, o lancia un\u2019eccezione se fallito o cancellato. T get(long timeout, TimeUnit unit) Blocca fino al timeout dato e restituisce il risultato, o lancia <code>TimeoutException</code> se non completato. <p>Warning</p> <p><code>execute()</code> scarter\u00e0 le eccezioni silenziosamente a meno che non vengano gestite all\u2019interno del task.</p> <p></p>"},{"location":"it/module-07/concurrency/#3142-callable-vs-runnable","title":"31.4.2 Callable vs Runnable","text":"<p>Entrambe le interfacce rappresentano task, ma con capacit\u00e0 differenti.</p> <ul> <li><code>Runnable</code>: Nessun valore di ritorno, non pu\u00f2 lanciare checked exceptions.</li> <li><code>Callable</code>: Restituisce un valore e supporta checked exceptions.</li> </ul> <pre><code>Callable&lt;String&gt; c = () -&gt; \"done\";\nRunnable r = () -&gt; System.out.println(\"done\");\n</code></pre> <p>Per computazione asincrona orientata al risultato, <code>Callable</code> \u00e8 generalmente preferito.</p> <p></p>"},{"location":"it/module-07/concurrency/#315-thread-pools-e-scheduling","title":"31.5 Thread Pools e Scheduling","text":"<p>Gli executor gestiscono thread pools che riutilizzano un numero fisso o dinamico di thread per eseguire i task in modo efficiente.</p> <ul> <li>Fixed thread pool: Limita la concorrenza a un numero fisso di thread.</li> <li>Cached thread pool: Cresce e si riduce dinamicamente in base alla domanda: crea nuovi thread quando necessario ma riusa thread disponibili.</li> <li>Single-thread executor: Garantisce esecuzione sequenziale dei task.</li> <li>Scheduled executor: Supporta task delayed e periodici.</li> </ul> Metodo Factory Tipo di Ritorno Descrizione <code>Executors.newFixedThreadPool(int nThreads)</code> ExecutorService Crea un thread pool con un numero fisso di thread. <code>Executors.newFixedThreadPool(int nThreads, ThreadFactory threadFactory)</code> ExecutorService Come newFixedThreadPool ma con un ThreadFactory personalizzato. <code>Executors.newSingleThreadExecutor()</code> ExecutorService Crea un thread pool a singolo thread che esegue i task in modo sequenziale. <code>Executors.newSingleThreadExecutor(ThreadFactory threadFactory)</code> ExecutorService Executor a singolo thread con un ThreadFactory personalizzato. <code>Executors.newCachedThreadPool()</code> ExecutorService Crea un thread pool che crea nuovi thread quando necessario e riutilizza quelli inattivi. <code>Executors.newCachedThreadPool(ThreadFactory threadFactory)</code> ExecutorService Thread pool cached con un ThreadFactory personalizzato. <code>Executors.newSingleThreadScheduledExecutor()</code> ScheduledExecutorService Crea un scheduled executor a singolo thread. <code>Executors.newSingleThreadScheduledExecutor(ThreadFactory threadFactory)</code> ScheduledExecutorService Scheduled executor a singolo thread con ThreadFactory personalizzato. <code>Executors.newScheduledThreadPool(int corePoolSize)</code> ScheduledExecutorService Crea un scheduled thread pool con la dimensione core specificata. <code>Executors.newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory)</code> ScheduledExecutorService Scheduled thread pool con ThreadFactory personalizzato. <code>Executors.newWorkStealingPool()</code> ExecutorService Crea un work-stealing pool usando il numero di processori disponibili come livello di parallelismo. <code>Executors.newWorkStealingPool(int parallelism)</code> ExecutorService Crea un work-stealing pool con il livello di parallelismo specificato. <code>Executors.newThreadPerTaskExecutor(ThreadFactory threadFactory)</code> ExecutorService Crea un executor che avvia un nuovo thread per ogni task. <code>Executors.newVirtualThreadPerTaskExecutor()</code> ExecutorService Crea un executor che avvia un nuovo virtual thread per ogni task. <p><code>Task scheduling</code>: i task sottomessi a un executor vengono messi in coda e prelevati dai thread del pool; l\u2019ordine di esecuzione dipende dall\u2019implementazione dell\u2019executor, dalla politica della coda e dalla disponibilit\u00e0 dei thread.  Nei scheduled executor, i task sono ordinati in base al delay di attivazione; i task periodici vengono reinseriti in coda dopo ogni esecuzione.</p> <pre><code>ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\n\nscheduler.schedule(\n    () -&gt; System.out.println(\"Delayed\"),\n    2, TimeUnit.SECONDS);\n</code></pre> Metodo Descrizione ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit) Pianifica un\u2019azione one-shot che diventa eseguibile dopo il delay specificato.  ScheduledFuture schedule(Callable callable, long delay, TimeUnit unit) Pianifica un task one-shot che restituisce un valore dopo il delay specificato. ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) Pianifica un\u2019esecuzione periodica a fixed rate: ogni esecuzione \u00e8 pianificata rispetto al tempo iniziale; se un\u2019esecuzione \u00e8 in ritardo, le successive possono tentare di \u201crecuperare\u201d. ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) Pianifica un\u2019esecuzione periodica con fixed delay: ogni esecuzione \u00e8 pianificata rispetto al completamento della precedente; non esiste comportamento di recupero. <p>Important</p> <p>Non creare mai thread manualmente in un loop: usa invece pools o virtual threads.</p> <p></p>"},{"location":"it/module-07/concurrency/#316-lifecycle-e-terminazione-dellexecutor","title":"31.6 Lifecycle e Terminazione dell'Executor","text":"<p>Gli executor devono essere chiusi esplicitamente per rilasciare risorse e permettere la terminazione della JVM.</p> <ul> <li>shutdown(): Inizia shutdown ordinato: completa i task in attesa ma non accetta ulteriori task.</li> <li>close(): (Java 19+) chiama shutdown() e attende che i task finiscano, comportandosi come supporto try-with-resources per ExecutorService.</li> <li>shutdownNow(): Tenta shutdown immediato e interrompe i task in esecuzione.</li> <li>awaitTermination(): Attende completamento o timeout.</li> </ul> <pre><code>executor.shutdown();\nexecutor.awaitTermination(5, TimeUnit.SECONDS);\n</code></pre> <p></p>"},{"location":"it/module-07/concurrency/#317-strategie-di-thread-safety","title":"31.7 Strategie di Thread Safety","text":"<p>La Concurrency API fornisce molteplici strategie complementari per ottenere thread safety.</p> <p></p>"},{"location":"it/module-07/concurrency/#3171-sincronizzazione","title":"31.7.1 Sincronizzazione","text":"<p>La sincronizzazione impone <code>mutual exclusion</code> e <code>memory visibility</code> usando un lock intrinseco (monitor) associato a un oggetto o a una classe.</p> <pre><code>synchronized void increment() {\n    count++;\n}\n</code></pre> <p>Quando un thread entra in un metodo synchronized:</p> <ul> <li>Acquisisce l\u2019intrinsic lock dell\u2019oggetto target (<code>this</code> per i metodi di istanza).</li> <li>Solo un thread alla volta pu\u00f2 detenere lo stesso lock, prevenendo esecuzione concorrente.</li> <li>Quando il metodo termina, il lock viene rilasciato automaticamente.</li> </ul> <p>La synchronization stabilisce una happens-before relationship nel Java Memory Model:</p> <ul> <li>Tutte le scritture fatte dentro la regione synchronized vengono flushate nella memoria principale quando il lock viene rilasciato.</li> <li>Un thread che acquisisce lo stesso lock in seguito \u00e8 garantito vedere quegli update.</li> </ul> <p>La keyword synchronized pu\u00f2 essere applicata a:</p> <ul> <li>Metodi di istanza (lock su <code>this</code>)</li> <li>Metodi statici (lock sull\u2019oggetto <code>Class</code>)</li> <li>Blocchi (lock su un oggetto specifico, permettendo controllo pi\u00f9 fine)</li> </ul> <p>Important</p> <p>La sincronizzazione \u00e8 semplice ma pu\u00f2 ridurre la scalabilit\u00e0 sotto contention.</p> <p></p>"},{"location":"it/module-07/concurrency/#3172-variabili-atomiche","title":"31.7.2 Variabili Atomiche","text":"<p>Le <code>atomic classes</code> forniscono operazioni lock-free, thread-safe implementate usando primitive CPU di basso livello come Compare-And-Swap (CAS).</p> <pre><code>AtomicInteger count = new AtomicInteger();\ncount.incrementAndGet();\n</code></pre> <p></p>"},{"location":"it/module-07/concurrency/#31721-atomic-classes","title":"31.7.2.1 Atomic classes","text":"Atomic Class Description AtomicBoolean Aggiorna e legge atomicamente un valore <code>boolean</code>. AtomicInteger Aggiorna e legge atomicamente un valore <code>int</code>. AtomicLong Aggiorna e legge atomicamente un valore <code>long</code>. AtomicReference Aggiorna e legge atomicamente un reference a oggetto. AtomicIntegerArray Fornisce operazioni atomiche sugli elementi di un array <code>int</code>. AtomicLongArray Fornisce operazioni atomiche sugli elementi di un array <code>long</code>. AtomicReferenceArray Fornisce operazioni atomiche sugli elementi di un array di reference. AtomicStampedReference Aggiorna atomicamente un reference con un integer stamp per evitare problemi ABA. AtomicMarkableReference Aggiorna atomicamente un reference con un boolean mark."},{"location":"it/module-07/concurrency/#31722-metodi-atomici","title":"31.7.2.2 Metodi Atomici","text":"Method Description get() Restituisce il valore corrente con semantica volatile-read. set(value) Imposta il valore con semantica volatile-write. lazySet(value) Imposta eventualmente il valore con garanzie di ordering pi\u00f9 deboli. compareAndSet(expect, update) Imposta atomicamente il valore se il valore corrente \u00e8 uguale al valore atteso. getAndSet(value) Imposta atomicamente il valore e restituisce il valore precedente. incrementAndGet() Incrementa atomicamente il valore e restituisce il risultato aggiornato. getAndIncrement() Incrementa atomicamente il valore e restituisce il risultato precedente. decrementAndGet() Decrementa atomicamente il valore e restituisce il risultato aggiornato. getAndDecrement() Decrementa atomicamente il valore e restituisce il risultato precedente. addAndGet(delta) Aggiunge atomicamente il delta dato e restituisce il risultato aggiornato. getAndAdd(delta) Aggiunge atomicamente il delta dato e restituisce il risultato precedente. <p>Variabili Atomiche:</p> <ul> <li>Eseguono singole operazioni atomicamente</li> <li>Forniscono memory visibility guarantees simili a <code>volatile</code></li> <li>Evitano thread blocking, rendendole altamente scalabili sotto contention</li> </ul> <p>Tuttavia, le atomic variables garantiscono atomicit\u00e0 solo per operazioni individuali.</p> <p>Comporre pi\u00f9 operazioni richiede comunque synchronization esterna.</p> <p>Le variabili atomiche sono tipicamente usate per:</p> <ul> <li>Counter e sequence generator</li> <li>Flag e state indicator</li> <li>Update ad alto throughput e bassa latenza</li> </ul> <p></p>"},{"location":"it/module-07/concurrency/#3173-lock-framework","title":"31.7.3 Lock Framework","text":"<p>Il package <code>java.util.concurrent.locks</code> fornisce meccanismi di locking espliciti che offrono maggiore flessibilit\u00e0 e controllo rispetto a synchronized.</p> <pre><code>ReentrantLock lock = new ReentrantLock();\nlock.lock();\ntry {\n    // critical section\n} finally {\n    lock.unlock();\n}\n</code></pre> <p>Caratteristiche chiave del Lock framework:</p> <ul> <li>I lock devono essere acquisiti e rilasciati esplicitamente</li> <li>L\u2019acquisizione del lock pu\u00f2 essere interruptible o time-bounded</li> <li>I lock possono essere configurati con fairness policy (parametro) quando l\u2019ordering \u00e8 richiesto (quando devi controllare l\u2019ordine in cui i thread girano)</li> <li>Pi\u00f9 oggetti Condition possono essere associati a un singolo lock</li> </ul> <p></p>"},{"location":"it/module-07/concurrency/#31731-lock-implementations","title":"31.7.3.1 Lock implementations","text":"Lock Implementation Description Lock Interfaccia core che definisce operazioni di lock esplicite. ReentrantLock Lock reentrant di mutual exclusion con fairness policy opzionale. ReadWriteLock Interfaccia che definisce lock separati di read e write. ReentrantReadWriteLock Fornisce lock separati reentrant di read e write per migliorare la scalabilit\u00e0 in lettura. StampedLock Lock che supporta modalit\u00e0 optimistic, read e write locking (non-reentrant). <p>Warning</p> <p>A differenza di altri lock, StampedLock non \u00e8 reentrant \u2014 riacquisirlo dallo stesso thread causa deadlock.</p> <p></p>"},{"location":"it/module-07/concurrency/#31732-common-lock-methods","title":"31.7.3.2 Common Lock methods","text":"Method Description lock() Acquisisce il lock, bloccando indefinitamente finch\u00e9 disponibile. unlock() Rilascia il lock; deve essere chiamato dal thread proprietario. tryLock() Tenta di acquisire il lock immediatamente senza bloccare: restituisce boolean che indica se il lock \u00e8 stato acquisito con successo tryLock(long, TimeUnit) Tenta di acquisire il lock entro il timeout dato. lockInterruptibly() Acquisisce il lock a meno che il thread sia interrotto. newCondition() Crea un\u2019istanza <code>Condition</code> per coordination fine-grained tra thread. <p>A differenza di synchronized, i lock non vengono rilasciati automaticamente, rendendo essenziale l\u2019uso corretto di try/finally per evitare deadlock.</p> <p></p>"},{"location":"it/module-07/concurrency/#3174-coordination-utilities","title":"31.7.4 Coordination Utilities","text":"<p>Le coordination utilities permettono ai thread di coordinare fasi di esecuzione senza proteggere dati condivisi tramite mutual exclusion.</p> <p>Altre coordination primitives includono: - <code>CountDownLatch</code> - <code>Semaphore</code> - <code>Phaser</code></p> <pre><code>import java.util.concurrent.CyclicBarrier;\n\npublic class BarrierExample {\n\n    private static final int THREAD_COUNT = 3;\n\n    public static void main(String[] args) {\n\n        CyclicBarrier barrier = new CyclicBarrier(\n            THREAD_COUNT,\n            () -&gt; System.out.println(\"All threads reached the barrier. Proceeding...\")\n        );\n\n        Runnable task = () -&gt; {\n            String name = Thread.currentThread().getName();\n            try {\n                System.out.println(name + \" performing initial work\");\n                Thread.sleep((long) (Math.random() * 2000));\n\n                // Wait for other threads\n                System.out.println(name + \" waiting at barrier\");\n                barrier.await();\n\n                // Executed only after all threads reach the barrier\n                System.out.println(name + \" performing next phase\");\n\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        };\n\n        for (int i = 1; i &lt;= THREAD_COUNT; i++) {\n            new Thread(task, \"Worker-\" + i).start();\n        }\n    }\n}\n</code></pre> <p>Sample Output:</p> <pre><code>Worker-1 performing initial work\nWorker-2 performing initial work\nWorker-3 performing initial work\nWorker-3 waiting at barrier\nWorker-1 waiting at barrier\nWorker-2 waiting at barrier\nAll threads reached the barrier. Proceeding...\nWorker-3 performing next phase\nWorker-1 performing next phase\nWorker-2 performing next phase\n</code></pre> <p>Un <code>CyclicBarrier</code>:</p> <ul> <li>Blocca i thread finch\u00e9 un numero predefinito di thread raggiunge la barrier</li> <li>Rilascia simultaneamente tutti i thread in attesa una volta che la barrier viene tripped</li> <li>Pu\u00f2 essere riusato per pi\u00f9 cicli di coordination</li> </ul> <p>Queste utilities si concentrano su execution ordering e synchronization, non su data protection.</p> <p></p>"},{"location":"it/module-07/concurrency/#318-concurrent-collections","title":"31.8 Concurrent Collections","text":"<p>Le concurrent collections sono thread-safe data structures progettate per supportare alti livelli di concorrenza senza richiedere sincronizzazione esterna.</p> <p>A differenza dei synchronized wrappers (es. <code>Collections.synchronizedMap</code>), le concurrent collections: - Usano fine-grained locking o lock-free techniques - Permettono a pi\u00f9 thread di accedere e modificare la collection simultaneamente - Scalano meglio sotto contention</p> <p>Esempi comuni includono:</p> <ul> <li>ConcurrentHashMap</li> <li> <p>Una concurrent map ad alte performance che permette letture e update concorrenti partizionando lo stato interno e minimizzando lock contention.</p> </li> <li> <p>CopyOnWriteArrayList</p> </li> <li> <p>Una thread-safe list ottimizzata per scenari con molte letture e poche scritture. Le operazioni di write creano un nuovo array interno, permettendo alle letture di procedere senza locking.</p> </li> <li> <p>BlockingQueue</p> </li> <li>Una queue progettata per producer-consumer patterns, dove i thread possono bloccare mentre attendono elementi o capacit\u00e0 disponibile.</li> </ul> <pre><code>BlockingQueue&lt;String&gt; queue = new LinkedBlockingQueue&lt;&gt;();\nqueue.put(\"item\");   // blocks if the queue is full\nqueue.take();        // blocks if the queue is empty\n</code></pre> <p>Le blocking queue gestiscono la synchronization internamente, semplificando la coordination tra thread producer e consumer.</p> <p>Caution</p> <p>Le CopyOnWrite collections sono memory-expensive; evitarle in workload write-heavy.</p> <p></p>"},{"location":"it/module-07/concurrency/#319-parallel-streams","title":"31.9 Parallel Streams","text":"<p>I <code>parallel streams</code> forniscono declarative data parallelism, permettendo che le operazioni dello stream vengano eseguite in modo concorrente su pi\u00f9 thread con cambiamenti minimi di codice.</p> <p>Caratteristiche chiave: - Attivati tramite <code>parallelStream()</code> o <code>stream().parallel()</code> - Eseguiti internamente usando il common ForkJoinPool - Dividono automaticamente i dati in chunk processati in parallelo</p> <p>I parallel streams funzionano meglio quando: - Le operazioni sono CPU-bound - Le funzioni sono stateless e non-blocking - La sorgente dati \u00e8 abbastanza grande da ammortizzare l\u2019overhead della parallelizzazione</p> <pre><code>list.parallelStream()\n    .map(x -&gt; x * x)\n    .forEach(System.out::println);\n</code></pre> <p>Poich\u00e9 l\u2019ordine di esecuzione non \u00e8 garantito, i parallel streams dovrebbero evitare: - Shared mutable state - Blocking I/O - Order-dependent side effects</p> <p>Note</p> <p>Usa <code>forEachOrdered()</code> se \u00e8 richiesto output deterministico.</p> <p></p>"},{"location":"it/module-07/concurrency/#3110-relazione-con-virtual-threads","title":"31.10 Relazione con Virtual Threads","text":"<p>In Java 21, l\u2019<code>Executor framework</code> integra in modo seamless con virtual threads, abilitando massive concurrency con uso minimo di risorse.</p> <pre><code>ExecutorService executor =\nExecutors.newVirtualThreadPerTaskExecutor();\n\nexecutor.submit(() -&gt; blockingIO());\nexecutor.close();\n</code></pre> <p>Questo permette al codice blocking di scalare efficientemente senza ridisegnare le API.</p> <p></p>"},{"location":"it/module-07/concurrency/#3111-summary","title":"31.11 Summary","text":"<ul> <li>La <code>Java Concurrency API</code> fornisce un\u2019alternativa robusta, scalabile e pi\u00f9 sicura alla gestione manuale dei thread.</li> <li>Astrarre l\u2019esecuzione, coordinare i task e offrire utilities thread-safe permette agli sviluppatori di costruire sistemi concorrenti sia performanti sia manutenibili.</li> <li>Scegli lo strumento giusto: synchronized \u2192 locks \u2192 atomics \u2192 executors \u2192 virtual threads.</li> </ul>"},{"location":"it/module-07/threads/","title":"30. Thread Java \u2013 Fondamenti e Modello di Esecuzione","text":""},{"location":"it/module-07/threads/#indice","title":"Indice","text":"<ul> <li>30.1 Thread, Processi e il Sistema Operativo</li> <li>30.2 Modello di Memoria Stack e Heap</li> <li>30.3 Contesto e Context Switching</li> <li>30.4 Concorrenza vs Parallelismo</li> <li>30.5 Thread in Java Modello Concettuale</li> <li>30.6 Categorie di Thread in Java 21</li> <li>30.7 Creare Thread in Java</li> <li>30.8 Ciclo di Vita ed Esecuzione di un Thread</li> <li>30.9 Avviare vs Eseguire un Thread Sincrono-o-Asincrono</li> <li>30.10 Priorit\u00e0 dei Thread e Scheduling</li> <li>30.11 Differimento e Yield dei Thread</li> <li>30.12 Interruzione dei Thread e Cancellazione Cooperativa<ul> <li>30.12.1 Cosa Significa Interrompere un Thread</li> <li>30.12.2 Interrompere Operazioni Bloccanti</li> <li>30.12.3 Controllare lo Stato di Interruzione</li> <li>30.12.4 Esempio Interrompere un Thread in Sleep</li> <li>30.12.5 Osservazioni Chiave</li> </ul> </li> <li>30.13 Thread e il Thread Principale</li> <li>30.14 Concorrenza dei Thread e Stato Condiviso</li> <li>30.15 Sommario</li> </ul> <p>Questo capitolo introduce i thread a partire dai principi di base e spiega come sono modellati e utilizzati in Java 21.</p> <p>Questo testo stabilisce inoltre le fondamenta concettuali necessarie per comprendere <code>concurrency</code>, <code>synchronization</code> e la <code>Java Concurrency API</code> trattata nel prossimo capitolo.</p> <p></p>"},{"location":"it/module-07/threads/#301-thread-processi-e-il-sistema-operativo","title":"30.1 Thread, Processi e il Sistema Operativo","text":"<p>Per comprendere i thread, dobbiamo partire dal modello di esecuzione del sistema operativo. </p> <p>I moderni sistemi operativi eseguono programmi utilizzando processi e thread.</p> <ul> <li>Processo: Un\u2019istanza di programma in esecuzione gestita dal sistema operativo. Un processo possiede il proprio spazio di memoria virtuale, risorse di sistema (file, socket) e almeno un thread.</li> <li>Thread: Un\u2019unit\u00e0 di esecuzione leggera all\u2019interno di un processo. I thread condividono memoria e risorse del processo ma eseguono in modo indipendente.</li> <li>Task: Un\u2019unit\u00e0 logica di lavoro da eseguire. Un task pu\u00f2 essere eseguito da un thread ma non \u00e8 esso stesso un thread.</li> <li>Core CPU: Un\u2019unit\u00e0 di esecuzione fisica o logica capace di eseguire un thread alla volta. Pi\u00f9 core permettono vera esecuzione parallela.</li> </ul> <p>Un singolo processo pu\u00f2 contenere molti thread, tutti operanti nello stesso ambiente condiviso. Questo ambiente condiviso \u00e8 sia fonte delle potenzialit\u00e0 della Concurrency sia dei suoi rischi.</p> <p></p>"},{"location":"it/module-07/threads/#302-modello-di-memoria-stack-e-heap","title":"30.2 Modello di Memoria: Stack e Heap","text":"<p>I thread interagiscono con la memoria in due modi fondamentalmente diversi.</p> <ul> <li>Stack del Thread: Area di memoria privata per ogni thread. Memorizza frame delle chiamate di metodo, variabili locali e stato di esecuzione. Ogni thread ha esattamente uno stack.</li> <li>Heap: Area di memoria condivisa usata per oggetti e istanze di classe. Tutti i thread nello stesso processo possono accedere all\u2019heap.</li> </ul> <p>Poich\u00e9 gli <code>stack sono isolati</code> e l\u2019<code>heap \u00e8 condiviso</code>, i problemi di concorrenza sorgono quando pi\u00f9 thread accedono agli stessi oggetti nell\u2019heap senza adeguata coordinazione.</p> <p></p>"},{"location":"it/module-07/threads/#303-contesto-e-context-switching","title":"30.3 Contesto e Context Switching","text":"<p>Il sistema operativo pianifica l'esecuzione dei thread sui core della CPU.</p> <p>Poich\u00e9 il numero di thread eseguibili spesso supera il numero di core disponibili, il sistema operativo esegue il context switching.</p> <ul> <li>Contesto: Lo stato completo di esecuzione di un thread, inclusi registri, contatore di programma e puntatore allo stack.</li> <li>Context Switch: L\u2019atto di sospendere un thread e riprenderne un altro salvando e ripristinando i rispettivi contesti.</li> </ul> <p>Il <code>context switching</code> abilita la concorrenza ma ha un costo: cicli CPU vengono consumati senza eseguire logica applicativa.</p> <p>I programmatori Java devono progettare sistemi che bilancino concorrenza ed efficienza.</p> <p></p>"},{"location":"it/module-07/threads/#304-concorrenza-vs-parallelismo","title":"30.4 Concorrenza vs Parallelismo","text":"<p>Questi due termini sono spesso confusi ma descrivono concetti differenti.</p> <ul> <li>Concorrenza: Pi\u00f9 thread sono in esecuzione nello stesso intervallo di tempo, possibilmente interlacciati su un singolo core CPU.</li> <li>Parallelismo: Pi\u00f9 thread vengono eseguiti simultaneamente su core CPU differenti.</li> </ul> <p>Java supporta la concorrenza indipendentemente dal parallelismo hardware.</p> <p>Anche su un sistema single-core, i thread Java possono essere concorrenti tramite time slicing.</p> <p></p>"},{"location":"it/module-07/threads/#305-thread-in-java-modello-concettuale","title":"30.5 Thread in Java: Modello Concettuale","text":"<p>In Java, un thread rappresenta un percorso indipendente di esecuzione all\u2019interno di un singolo processo JVM. Tutti i thread Java operano nello stesso heap e nello stesso contesto di <code>class loading</code>, a meno che non siano esplicitamente isolati tramite meccanismi avanzati.</p> <ul> <li>Thread Java: Un oggetto di tipo <code>java.lang.Thread</code> che mappa a un\u2019unit\u00e0 di esecuzione sottostante.</li> <li>Runnable: Un\u2019interfaccia funzionale che rappresenta un <code>task</code> il cui metodo <code>run()</code> contiene la logica eseguibile.</li> </ul> <p>Un thread esegue codice invocando il proprio metodo <code>run()</code>, direttamente o indirettamente tramite lo scheduler dei thread della JVM: vedere Avviare vs Eseguire un Thread</p> <p></p>"},{"location":"it/module-07/threads/#306-categorie-di-thread-in-java-21","title":"30.6 Categorie di Thread in Java 21","text":"<p>Java 21 definisce diversi tipi di thread, che differiscono per ciclo di vita, scheduling e uso previsto.</p> <ul> <li>Platform Thread: Un thread Java tradizionale mappato uno-a-uno con un thread del sistema operativo.</li> <li>Virtual Thread: Un thread leggero gestito dalla JVM e schedulato su thread carrier. Introdotto per abilitare massiva concorrenza con overhead minimo.</li> <li>Carrier Thread: Un Platform Thread usato internamente dalla JVM per eseguire thread virtuali.</li> <li>Daemon Thread: Un thread in background che non impedisce la terminazione della JVM. Quando restano in esecuzione solo thread daemon, la JVM termina.</li> <li>Thread Utente: Qualsiasi thread non-daemon. La JVM attende che tutti i thread utente completino prima di terminare.</li> <li>Thread di Sistema: Thread creati internamente dalla JVM per garbage collection, compilazione JIT e altri servizi runtime.</li> </ul> <p>Note</p> <p>I <code>thread virtuali</code> sono thread utente leggeri; non sono daemon per default.</p> <p></p>"},{"location":"it/module-07/threads/#307-creare-thread-in-java","title":"30.7 Creare Thread in Java","text":"<p>I thread possono essere creati in diversi modi, tutti concettualmente centrati nel fornire logica eseguibile.</p> <ul> <li>Estendendo <code>Thread</code> e sovrascrivendo <code>run()</code>.</li> <li>Passando un <code>Runnable</code> al costruttore di <code>Thread</code>.</li> <li>Usando factory di thread ed executor (trattati nella sezione Concurrency API).</li> </ul> <pre><code>Runnable runnable = ...\n\n  // Crea un thread di piattaforma tramite costruttore\n  Thread thread = new Thread(runnable);\n  thread.start();\n\n  // Avvia un thread daemon per eseguire un task\n  Thread thread = Thread.ofPlatform().daemon().start(runnable);\n\n  // Crea un thread non avviato con nome \"duke\", il suo metodo start()\n  // deve essere invocato per pianificarne l'esecuzione.\n  Thread thread = Thread.ofPlatform().name(\"duke\").unstarted(runnable);\n\n  // Una ThreadFactory che crea thread daemon chiamati \"worker-0\", \"worker-1\", ...\n  ThreadFactory factory = Thread.ofPlatform().daemon().name(\"worker-\", 0).factory();\n\n  // Avvia un thread virtuale per eseguire un task\n  Thread thread = Thread.ofVirtual().start(runnable);\n\n  // Una ThreadFactory che crea thread virtuali\n  ThreadFactory factory = Thread.ofVirtual().factory();\n</code></pre> <p>Warning</p> <ul> <li>La sola creazione di un thread non ne avvia l\u2019esecuzione.</li> <li>L\u2019esecuzione inizia solo quando lo scheduler della JVM \u00e8 coinvolto.</li> </ul> <p></p>"},{"location":"it/module-07/threads/#308-ciclo-di-vita-ed-esecuzione-di-un-thread","title":"30.8 Ciclo di Vita ed Esecuzione di un Thread","text":"<p>Un thread Java attraversa stati ben definiti durante il suo ciclo di vita.</p> <ul> <li>New: Oggetto thread creato ma non ancora avviato.</li> <li>Runnable: Idoneo all\u2019esecuzione da parte dello scheduler.</li> <li>Running: In esecuzione attiva su un core CPU.</li> <li>Blocked / Waiting: Temporaneamente incapace di proseguire a causa di sincronizzazione o coordinazione.</li> <li>Terminated: Esecuzione completata o interrotta.</li> </ul> <p>La JVM e il sistema operativo cooperano per muovere i thread tra questi stati.</p> <p>I thread in stato <code>BLOCKED</code>, <code>WAITING</code> o <code>TIMED_WAITING</code> non stanno utilizzando risorse CPU</p> <p></p>"},{"location":"it/module-07/threads/#309-avviare-vs-eseguire-un-thread-sincrono-o-asincrono","title":"30.9 Avviare vs Eseguire un Thread: Sincrono o Asincrono","text":"<p>Esiste una distinzione concettuale critica tra invocare <code>run()</code> e invocare <code>start()</code>.</p> <ul> <li>Chiamare direttamente <code>run()</code> esegue il metodo in modo sincrono nel thread corrente, come una normale chiamata di metodo.</li> <li>Chiamare <code>start()</code> richiede alla JVM di creare un nuovo stack di chiamata ed eseguire <code>run()</code> in modo asincrono in un thread separato.</li> </ul> <p>Pertanto, codice come <code>new Thread(r).run();</code> NON crea concorrenza. L\u2019esecuzione rimane sincrona e blocca il thread chiamante fino al completamento.</p> <p>Note</p> <p><code>Esecuzione asincrona</code> significa che il chiamante continua immediatamente mentre il nuovo thread prosegue in modo indipendente, soggetto allo scheduling.</p> <p><code>Esecuzione sincrona</code> significa che il chiamante attende che l\u2019operazione sia completata.</p> <p>Important</p> <p>La concorrenza inizia solo quando viene invocato <code>start()</code>.</p> <p></p>"},{"location":"it/module-07/threads/#3010-priorita-dei-thread-e-scheduling","title":"30.10 Priorit\u00e0 dei Thread e Scheduling","text":"<p>I thread Java hanno una priorit\u00e0 associata che influenza lo scheduling.</p> <ul> <li><code>Priorit\u00e0 del Thread</code>: Un valore intero che ne indica l\u2019importanza relativa, che va da minimo a massimo.</li> <li><code>Scheduling</code>: La JVM delega le decisioni di scheduling al sistema operativo, che pu\u00f2 o meno rispettare rigorosamente le priorit\u00e0.</li> </ul> <p>La priorit\u00e0 del thread influenza la probabilit\u00e0 di scheduling ma non garantisce mai l\u2019ordine di esecuzione. Il codice Java portabile non deve mai fare affidamento sulle priorit\u00e0 per la correttezza.</p> <p>\u00c8 possibile impostare la priorit\u00e0 sui <code>thread di piattaforma</code>; per i <code>thread virtuali</code> la priorit\u00e0 \u00e8 sempre impostata a 5 (<code>Thread.NORM_PRIORITY</code>) e tentare di modificarla non ha effetto.</p> <p></p>"},{"location":"it/module-07/threads/#3011-differimento-e-yield-dei-thread","title":"30.11 Differimento e Yield dei Thread","text":"<p>I thread possono influenzare volontariamente il comportamento di scheduling.</p> <p>Chiamare <code>Thread.yield()</code> segnala la disponibilit\u00e0 a sospendere l\u2019esecuzione.</p> <ul> <li><code>Yielding</code>: Un thread suggerisce di essere disposto a sospendere l\u2019esecuzione per permettere ad altri thread eseguibili di proseguire.</li> <li><code>Sleeping</code>: Un thread sospende l\u2019esecuzione per una durata fissa, entrando in uno stato di attesa temporizzata.</li> </ul> <p>Questi meccanismi non garantiscono l\u2019esecuzione immediata di altri thread; forniscono solo suggerimenti di scheduling.</p> <p></p>"},{"location":"it/module-07/threads/#3012-interruzione-dei-thread-e-cancellazione-cooperativa","title":"30.12 Interruzione dei Thread e Cancellazione Cooperativa","text":"<p>I thread Java non possono essere fermati forzatamente dall\u2019esterno.</p> <p>Invece, Java fornisce un meccanismo cooperativo chiamato interruzione del thread, che permette a un thread di richiedere che un altro thread interrompa ci\u00f2 che sta facendo.</p> <p>Il thread di destinazione decide come e quando rispondere.</p> <p></p>"},{"location":"it/module-07/threads/#30121-cosa-significa-interrompere-un-thread","title":"30.12.1 Cosa Significa Interrompere un Thread","text":"<p>Interrompere un thread non lo termina. Chiamare <code>interrupt()</code> imposta un flag di interruzione interno sul thread di destinazione. \u00c8 responsabilit\u00e0 del thread in esecuzione osservare questo flag e reagire in modo appropriato.</p> <ul> <li><code>Richiesta di Interruzione</code>: Un segnale inviato a un thread che indica che dovrebbe fermarsi o cambiare la propria attivit\u00e0 corrente.</li> <li><code>Flag di Interruzione</code>: Uno stato booleano associato a ciascun thread, impostato quando viene invocato <code>interrupt()</code>.</li> <li><code>Cancellazione Cooperativa</code>: Un design pattern in cui i thread controllano periodicamente eventuali interruzioni e terminano in modo pulito.</li> </ul> <p></p>"},{"location":"it/module-07/threads/#30122-interrompere-operazioni-bloccanti","title":"30.12.2 Interrompere Operazioni Bloccanti","text":"<p>Alcuni metodi bloccanti in Java rispondono immediatamente all\u2019interruzione lanciando <code>InterruptedException</code> e azzerando il flag di interruzione. Questi metodi includono <code>sleep()</code>, <code>wait()</code> e <code>join()</code>.</p> <p>Quando un thread \u00e8 bloccato in uno di questi metodi e un altro thread lo interrompe, il thread bloccato viene risvegliato e viene lanciata un\u2019eccezione. Questo fornisce un punto di uscita sicuro dalle operazioni bloccanti.</p> <p></p>"},{"location":"it/module-07/threads/#30123-controllare-lo-stato-di-interruzione","title":"30.12.3 Controllare lo Stato di Interruzione","text":"<p>I thread che non sono bloccati devono controllare esplicitamente se sono stati interrotti. Java fornisce due modi per farlo.</p> <ul> <li><code>Thread.currentThread().isInterrupted()</code>: Restituisce lo stato di interruzione senza azzerarlo.</li> <li><code>Thread.interrupted()</code>: Restituisce lo stato di interruzione e lo azzera. Questo \u00e8 sottile: la chiamata successiva restituir\u00e0 false.</li> </ul> <p>Non controllare lo stato di interruzione pu\u00f2 far s\u00ec che i thread ignorino richieste di cancellazione e continuino a eseguire indefinitamente.</p> <p></p>"},{"location":"it/module-07/threads/#30124-esempio-interrompere-un-thread-in-sleep","title":"30.12.4 Esempio: Interrompere un Thread in Sleep","text":"<p>Il seguente esempio dimostra la cancellazione cooperativa tramite interruzione.</p> <p>Un thread worker dorme mentre esegue del lavoro. Il thread main lo interrompe, causando uno shutdown pulito.</p> <pre><code>class Main {\n\n    static class Task implements Runnable {\n        public void run() {\n            try {\n                while (true) {\n                    System.out.println(\"Working...\");\n                    Thread.sleep(1000);\n                }\n            } catch (InterruptedException e) {\n                System.out.println(\"Task interrupted, shutting down\");\n            }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread worker = new Thread(new Task());\n        worker.start();\n        System.out.println(\"main before sleep...\");\n        Thread.sleep(3000);\n        System.out.println(\"main after sleep...\");\n        worker.interrupt();\n        System.out.println(\"main reached END\");\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>main before sleep...\nWorking...\nWorking...\nWorking...\nmain after sleep...\nmain reached END\nTask interrupted, shutting down\n</code></pre> <p>Note</p> <p>L\u2019ordine dell\u2019output pu\u00f2 variare leggermente a causa dello scheduling.</p> <p></p>"},{"location":"it/module-07/threads/#30125-osservazioni-chiave","title":"30.12.5 Osservazioni Chiave","text":"<ul> <li>Chiamare <code>interrupt()</code> non ferma direttamente il thread.</li> <li>L\u2019interruzione viene rilevata e <code>sleep()</code> lancia una <code>InterruptedException</code>.</li> <li>Il thread worker termina da solo in modo controllato.</li> <li>Una corretta gestione dell\u2019interruzione permette ai thread di rilasciare risorse e mantenere la coerenza del programma.</li> </ul> <p>Note</p> <p>Ignorare <code>InterruptedException</code> senza terminare o ripristinare lo stato di interruzione \u00e8 considerata cattiva pratica e pu\u00f2 portare a thread non reattivi.</p> <p></p>"},{"location":"it/module-07/threads/#3013-thread-e-il-thread-principale","title":"30.13 Thread e il Thread Principale","text":"<p>Ogni applicazione Java inizia con un thread principale. Questo thread esegue il metodo <code>main(String[])</code>.</p> <ul> <li>Il thread principale \u00e8 un thread utente.</li> <li>La JVM rimane attiva finch\u00e9 almeno un thread utente \u00e8 in esecuzione.</li> <li>Se il thread principale termina ma esistono altri thread utente, la JVM continua l\u2019esecuzione aspettando che i thread utente terminino.</li> <li>I thread daemon non mantengono viva la JVM.</li> </ul> <p>Comprendere il ruolo del thread principale \u00e8 essenziale per ragionare sulla terminazione del programma e sull\u2019elaborazione in background.</p> <p></p>"},{"location":"it/module-07/threads/#3014-concorrenza-dei-thread-e-stato-condiviso","title":"30.14 Concorrenza dei Thread e Stato Condiviso","text":"<p>La <code>Concorrenza</code> nasce quando pi\u00f9 thread accedono a stato mutabile condiviso.</p> <ul> <li><code>Stato Condiviso</code>: Qualsiasi dato locato nello heap accessibile da pi\u00f9 di un thread.</li> <li><code>Race Condition</code>: Un errore di correttezza causato da accesso non sincronizzato a stato condiviso.</li> <li><code>Problema di Visibilit\u00e0</code>: Un thread opera su dati obsoleti a causa della mancanza di corretta sincronizzazione della memoria.</li> </ul> <p>Java risolve questi problemi con sincronizzazione, volatile, lock, atomiche e framework di alto livello (Executors, futures).</p> <p>La sincronizzazione, le variabili volatile e le utility di concorrenza di alto livello saranno studiate nelle sezioni successive.</p> <p></p>"},{"location":"it/module-07/threads/#3015-sommario","title":"30.15 Sommario","text":"<ul> <li>I <code>Thread</code> sono il mattone fondamentale dell\u2019esecuzione concorrente in Java.</li> <li>Esistono all\u2019interno dei processi, condividono memoria e sono schedulati dalla JVM in cooperazione con il sistema operativo.</li> <li>Una corretta gestione dei thread evita perdite, deadlock e spreco di CPU.</li> </ul>"},{"location":"it/module-08/files-path-api/","title":"33. API di Files e Path","text":""},{"location":"it/module-08/files-path-api/#indice","title":"Indice","text":"<ul> <li>33.1 Creazione-e-Conversione di File legacy e Path NIO<ul> <li>33.1.1 Creare un File Legacy</li> <li>33.1.2 Creare un Path NIO-v2</li> <li>33.1.3 Assoluto vs Relativo Cosa Significa Relativo</li> <li>33.1.4 Unire--Costruire-Path<ul> <li>33.1.4.1 resolve</li> <li>33.1.4.2 relativize</li> </ul> </li> <li>33.1.5 Convertire tra File e Path</li> <li>33.1.6 Conversione URI Quando-Serve</li> <li>33.1.7 Canonico vs Assoluto vs Normalizzato Differenze-Fondamentali<ul> <li>33.1.7.1 normalize</li> </ul> </li> <li>33.1.8 Tabella di Confronto Rapida Creazione--Conversione</li> </ul> </li> <li>33.2 Gestire File e Directory: Creare-Copiare-Spostare-Sostituire-Confrontare-Cancellare<ul> <li>33.2.1 Modello Mentale Path-Locator-vs-Operazioni</li> <li>33.2.2 Creare File e Directory<ul> <li>33.2.2.1 Creare un File</li> <li>33.2.2.2 Creare Directory</li> </ul> </li> <li>33.2.3 Copiare File e Directory<ul> <li>33.2.3.1 Copiare un File NIO</li> <li>33.2.3.2 Copia Manuale Legacy-Basata-su-Stream</li> </ul> </li> <li>33.2.4 Spostare--Rinominare-e-Sostituire<ul> <li>33.2.4.1 Rinomina Legacy Trappola-Comune</li> <li>33.2.4.2 NIO Move Preferito</li> </ul> </li> <li>33.2.5 Confrontare Path e File<ul> <li>33.2.5.1 Uguaglianza-vs-Stesso-File</li> </ul> </li> <li>33.2.6 Cancellare File e Directory<ul> <li>33.2.6.1 Delete Legacy</li> <li>33.2.6.2 NIO Delete e Delete-If-Exists</li> </ul> </li> <li>33.2.7 Copiare--Cancellare-Ricorsivamente-Alberi-di-Directory Pattern-NIO</li> <li>33.2.8 Checklist di Riepilogo</li> </ul> </li> </ul> <p>Questa sezione si concentra su come creare localizzatori su filesystem usando la API legacy <code>java.io.File</code> e la moderna API <code>java.nio.file.Path</code>: come convertire tra di loro e comprendere overload, default e trappole comuni.</p> <p></p>"},{"location":"it/module-08/files-path-api/#331-file-legacy-e-path-nio-creazione-e-conversione","title":"33.1 <code>File</code> legacy e <code>Path</code> NIO: Creazione e Conversione","text":""},{"location":"it/module-08/files-path-api/#3311-creare-un-file-legacy","title":"33.1.1 Creare un <code>File</code> (Legacy)","text":"<p>Una istanza <code>File</code> rappresenta un pathname del filesystem (assoluto o relativo).</p> <p>Crearne una non accede al filesystem e non lancia <code>IOException</code>.</p> <p>Costruttori core (pi\u00f9 comuni):</p> <ul> <li><code>new File(String pathname)</code> </li> <li><code>new File(String parent, String child)</code> </li> <li><code>new File(File parent, String child)</code> </li> <li><code>new File(URI uri)</code> (tipicamente <code>file:...</code>)</li> </ul> <pre><code>import java.io.File;\nimport java.net.URI;\n\nFile f1 = new File(\"data.txt\"); // relativo\nFile f2 = new File(\"/tmp\", \"data.txt\"); // parent + child\nFile f3 = new File(new File(\"/tmp\"), \"data.txt\");\n\nFile f4 = new File(URI.create(\"file:///tmp/data.txt\"));\n</code></pre> <p>Note</p> <ul> <li><code>new File(...)</code> non apre mai il file.</li> <li>Esistenza/permessi vengono controllati solo quando invocati metodi come <code>exists()</code>, <code>length()</code>, o quando si apre uno stream/channel.</li> </ul> <p></p>"},{"location":"it/module-08/files-path-api/#3312-creare-un-path-nio-v2","title":"33.1.2 Creare un <code>Path</code> (NIO v.2)","text":"<p>Un <code>Path</code> \u00e8 solo un locator.</p> <p>Come <code>File</code>, creare un <code>Path</code> non accede al filesystem.</p> <p>Factory core:</p> <ul> <li><code>Path.of(String first, String... more)</code> (Java 11+)</li> <li><code>Paths.get(String first, String... more)</code> (stile pi\u00f9 vecchio; ancora valido)</li> <li><code>Path.of(URI uri)</code> (es. <code>file:///...</code>)</li> </ul> <pre><code>import java.net.URI;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\nPath p1 = Path.of(\"data.txt\"); // relativo\nPath p2 = Path.of(\"/tmp\", \"data.txt\"); // parent + child\n\nPath p3 = Paths.get(\"data.txt\"); // stile factory legacy\nPath p4 = Path.of(URI.create(\"file:///tmp/data.txt\"));\n</code></pre> <p>Note</p> <ul> <li><code>Path.of(...)</code> e <code>Paths.get(...)</code> sono equivalenti per il filesystem di default.</li> <li>Preferisci <code>Path.of</code> nel codice moderno.</li> </ul> <p></p>"},{"location":"it/module-08/files-path-api/#3313-assoluto-vs-relativo-cosa-significa-relativo","title":"33.1.3 Assoluto vs Relativo: Cosa Significa \u201cRelativo\u201d","text":"<p>Sia <code>File</code> sia <code>Path</code> possono essere creati come path relativi.</p> <p>I path relativi vengono risolti rispetto alla working directory del processo (tipicamente <code>System.getProperty(\"user.dir\")</code>).</p> <pre><code>import java.io.File;\nimport java.nio.file.Path;\n\nFile rf = new File(\"data.txt\");\nPath rp = Path.of(\"data.txt\");\n\nSystem.out.println(rf.isAbsolute()); // false\nSystem.out.println(rp.isAbsolute()); // false\n\nSystem.out.println(rf.getAbsolutePath());\nSystem.out.println(rp.toAbsolutePath());\n</code></pre> <p>Note</p> <p>I path relativi sono una fonte comune di bug \u201cfunziona sulla mia macchina\u201d perch\u00e9 <code>user.dir</code> dipende da come/dove la JVM \u00e8 stata lanciata.</p> <p></p>"},{"location":"it/module-08/files-path-api/#3314-unire-costruire-path","title":"33.1.4 Unire / Costruire Path","text":"<ul> <li>Il <code>File</code> legacy usa i costruttori (parent + child).</li> <li>NIO usa <code>resolve</code> e metodi correlati.</li> </ul> Task Legacy (File) NIO (Path) Unire parent + child <code>new File(parent, child)</code> <code>parent.resolve(child)</code> Unire molti segmenti Costruttori ripetuti <code>Path.of(a, b, c)</code> o <code>resolve()</code> concatenati <pre><code>import java.io.File;\nimport java.nio.file.Path;\n\nFile f = new File(\"/tmp\", \"a.txt\");\n\nPath base = Path.of(\"/tmp\");\nPath p = base.resolve(\"a.txt\"); // /tmp/a.txt\nPath p2 = base.resolve(\"dir\").resolve(\"a.txt\"); // /tmp/dir/a.txt\n</code></pre>"},{"location":"it/module-08/files-path-api/#33141-resolve","title":"33.1.4.1 <code>resolve()</code>","text":"<p>Combina path in modo filesystem-aware.</p> <ul> <li>I path relativi vengono appesi</li> <li>Un argomento assoluto sostituisce il base path</li> </ul> <p>Note</p> <p><code>Path.resolve(...)</code> ha una regola: se l\u2019argomento \u00e8 assoluto, restituisce l\u2019argomento e scarta la base (non puoi combinare due path assoluti usando <code>resolve</code>).</p> <p></p>"},{"location":"it/module-08/files-path-api/#33142-relativize","title":"33.1.4.2 <code>relativize()</code>","text":"<p><code>Path.relativize</code> calcola un path relativo da un path a un altro. Il path risultante, quando <code>resolved</code> rispetto al path sorgente, produce il path target.</p> <p>In altre parole:</p> <ul> <li>Risponde alla domanda: \u201cCome vado dal path A al path B?\u201d</li> <li>Il risultato \u00e8 sempre un path relativo</li> <li>Non avviene alcun accesso al filesystem</li> </ul> <p>Regole Fondamentali</p> <p><code>relativize</code> ha precondizioni strette. Violandole si lancia una eccezione.</p> Regola Spiegazione Entrambi i path devono essere assoluti o entrambi relativi Entrambi i path devono appartenere allo stesso filesystem stesso provider I componenti di root devono combaciare stessa root (su Windows, stesso drive) Il risultato non \u00e8 mai assoluto sempre relativo <p>Note</p> <p>Se un path \u00e8 assoluto e l\u2019altro relativo, viene lanciata <code>IllegalArgumentException</code>.</p> <p>Esempio Relativo Semplice:</p> <p>Entrambi i path sono relativi, quindi la relativizzazione \u00e8 consentita.</p> <pre><code>Path p1 = Path.of(\"docs/manual\");\nPath p2 = Path.of(\"docs/images/logo.png\");\n\nPath relative = p1.relativize(p2);\nSystem.out.println(relative);\n</code></pre> <pre><code>../images/logo.png\n</code></pre> <p>Interpretazione: da <code>docs/manual</code>, sali di un livello, poi entra in <code>images/logo.png</code>.</p> <p>Esempio di Path Assoluti:</p> <p>I path assoluti funzionano esattamente allo stesso modo.</p> <pre><code>Path base = Path.of(\"/home/user/projects\");\nPath target = Path.of(\"/home/user/docs/readme.txt\");\n\nPath relative = base.relativize(target);\nSystem.out.println(relative);\n</code></pre> <pre><code>../docs/readme.txt\n</code></pre> <p>Usare <code>resolve</code> per Verificare il Risultato</p> <p>Una propriet\u00e0 chiave di <code>relativize</code> \u00e8 questa identit\u00e0:</p> <pre><code>base.resolve(base.relativize(target)).equals(target)\n</code></pre> <pre><code>Path base = Path.of(\"/a/b/c\");\nPath target = Path.of(\"/a/d/e\");\n\nPath r = base.relativize(target);\nSystem.out.println(r); // ../../d/e\nSystem.out.println(base.resolve(r)); // /a/d/e\n</code></pre> <p>Esempio: Mescolare Path Assoluti e Relativi (CASO ERRORE)</p> <p>Questo \u00e8 uno degli errori pi\u00f9 comuni.</p> <pre><code>Path abs = Path.of(\"/a/b\");\nPath rel = Path.of(\"c/d\");\n\nabs.relativize(rel); // lancia eccezione\n</code></pre> <pre><code>Exception in thread \"main\" java.lang.IllegalArgumentException\n</code></pre> <p>Note</p> <p><code>relativize</code> NON tenta di convertire automaticamente i path in assoluti.</p> <p>Esempio: Root Diverse (Trappola Specifica Windows)</p> <p>Su Windows, path con lettere di drive diverse non possono essere relativizzati.</p> <pre><code>Path p1 = Path.of(\"C:\\\\data\\\\a\");\nPath p2 = Path.of(\"D:\\\\data\\\\b\");\n\np1.relativize(p2); // IllegalArgumentException\n</code></pre> <p>Note</p> <p>Su sistemi Unix-like, la root \u00e8 sempre <code>/</code>, quindi questo problema non si verifica.</p> <p></p>"},{"location":"it/module-08/files-path-api/#3315-convertire-tra-file-e-path","title":"33.1.5 Convertire tra <code>File</code> e <code>Path</code>","text":"<p>La conversione \u00e8 diretta e lossless per normali path del filesystem locale.</p> Conversione Come File \u2192 Path <code>file.toPath()</code> Path \u2192 File <code>path.toFile()</code> <pre><code>import java.io.File;\nimport java.nio.file.Path;\n\nFile f = new File(\"data.txt\");\nPath p = f.toPath();\n\nFile back = p.toFile();\n</code></pre> <p>Note</p> <p>La conversione non valida l\u2019esistenza. Converte solo rappresentazioni.</p> <p></p>"},{"location":"it/module-08/files-path-api/#3316-conversione-uri-quando-serve","title":"33.1.6 Conversione URI (Quando Serve)","text":"<p>Gli <code>URI</code> sono utili quando i path devono essere rappresentati in forma standard e assoluta (es. interoperare con risorse in rete o configurazione).</p> <p>Entrambe le API supportano la conversione URI.</p> Direzione Legacy (File) NIO (Path) Da URI <code>new File(uri)</code> <code>Path.of(uri)</code> A URI <code>file.toURI()</code> <code>path.toUri()</code> <pre><code>import java.io.File;\nimport java.net.URI;\nimport java.nio.file.Path;\n\nFile f = new File(\"/tmp/data.txt\");\nURI u1 = f.toURI();\n\nPath p = Path.of(\"/tmp/data.txt\");\nURI u2 = p.toUri();\n\nPath pFromUri = Path.of(u2);\nFile fFromUri = new File(u1);\n</code></pre> <p>Note</p> <p><code>new File(URI)</code> richiede un URI <code>file:</code> e lancia <code>IllegalArgumentException</code> se l\u2019URI non \u00e8 gerarchico o non \u00e8 un file URI.</p> <p></p>"},{"location":"it/module-08/files-path-api/#3317-canonico-vs-assoluto-vs-normalizzato-differenze-fondamentali","title":"33.1.7 Canonico vs Assoluto vs Normalizzato (Differenze Fondamentali)","text":"<p>Questi termini vengono spesso confusi. Non sono la stessa cosa.</p> Concetto Legacy (File) NIO (Path) Tocca filesystem Assoluto <code>getAbsoluteFile()</code> <code>toAbsolutePath()</code> No Normalizzato (nessun normalize puro, usa canonical)* <code>normalize()</code> <code>normalize()</code>: No Canonico / Reale <code>getCanonicalFile()</code> <code>toRealPath()</code> S\u00ec <p>Note</p> <p><code>File.getCanonicalFile()</code> e <code>Path.toRealPath()</code> possono risolvere symlink e richiedere che il path esista, quindi possono lanciare <code>IOException</code>.</p> <p>File non fornisce un metodo per una normalizzazione puramente sintattica: storicamente molti sviluppatori usavano getCanonicalFile(), ma questo accede al filesystem e pu\u00f2 fallire.</p> <pre><code>import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Path;\n\nFile f = new File(\"a/../data.txt\");\nSystem.out.println(f.getAbsolutePath()); // assoluto, pu\u00f2 ancora contenere \"..\"\n\ntry {\n    System.out.println(f.getCanonicalPath()); // risolve \"..\", pu\u00f2 toccare filesystem\n} catch (IOException e) {\n    System.out.println(\"Canonical failed: \" + e.getMessage());\n}\n\nPath p = Path.of(\"a/../data.txt\");\nSystem.out.println(p.toAbsolutePath()); // assoluto, pu\u00f2 ancora contenere \"..\"\nSystem.out.println(p.normalize()); // puramente sintattico\n\ntry {\n    System.out.println(p.toRealPath()); // risolve symlink, richiede esistenza\n} catch (IOException e) {\n    System.out.println(\"RealPath failed: \" + e.getMessage());\n}\n</code></pre> <p></p>"},{"location":"it/module-08/files-path-api/#33171-normalize","title":"33.1.7.1 <code>normalize()</code>","text":"<p>Rimuove elementi di nome ridondanti come <code>.</code> e <code>..</code>.</p> <ul> <li>Puramente sintattico</li> <li>Non controlla se il path esiste</li> </ul> <p>Note</p> <p><code>normalize()</code> \u00e8 puramente sintattico, non controlla l\u2019esistenza, e pu\u00f2 produrre path invalidi se usato male.</p> <p></p>"},{"location":"it/module-08/files-path-api/#3318-tabella-di-confronto-rapida-creazione-conversione","title":"33.1.8 Tabella di Confronto Rapida (Creazione + Conversione)","text":"Esigenza Legacy (File) NIO (Path) Preferito oggi Creare da stringa <code>new File(\"x\")</code> <code>Path.of(\"x\")</code> Path Parent + child <code>new File(p, c)</code> <code>Path.of(p, c)</code> o <code>resolve()</code> Path Convertire tra API <code>toPath()</code> <code>toFile()</code> Path-centric Normalizzare <code>getCanonicalFile()</code> (basato su filesystem) <code>normalize()</code> (solo sintattico) Path Risolvere symlink Canonical <code>toRealPath()</code> Path"},{"location":"it/module-08/files-path-api/#332-gestire-file-e-directory-creare-copiare-spostare-sostituire-confrontare-cancellare-legacy-vs-nio","title":"33.2 Gestire File e Directory: Creare, Copiare, Spostare, Sostituire, Confrontare, Cancellare (Legacy vs NIO)","text":"<p>Questa sezione copre le operazioni che esegui sulle entry del filesystem (file/directory): creazione, copia, spostamento/rinominazione, sostituzione, confronto e cancellazione.</p> <p>Confronta il legacy <code>java.io.File</code> (e helper legacy correlati) con il moderno <code>java.nio.file</code> (NIO.2).</p> <p></p>"},{"location":"it/module-08/files-path-api/#3321-modello-mentale-pathlocator-vs-operazioni","title":"33.2.1 Modello Mentale: \u201cPath/Locator\u201d vs \u201cOperazioni\u201d","text":"<p>Entrambe le API usano oggetti che rappresentano un path, ma le operazioni differiscono:</p> <ul> <li>Legacy: <code>File</code> \u00e8 sia un wrapper di path sia una API di operazioni (responsabilit\u00e0 mescolata)</li> <li>NIO: <code>Path</code> \u00e8 il path; <code>Files</code> esegue le operazioni (separazione delle responsabilit\u00e0)</li> </ul> Responsabilit\u00e0 Legacy NIO Rappresentazione Path <code>File</code> <code>Path</code> Operazioni su filesystem <code>File</code> <code>Files</code> Reporting degli errori Debole (boolean) Forte (eccezioni) <p>Note</p> <p>I metodi legacy spesso restituiscono <code>boolean</code> (fallimento silenzioso), mentre NIO lancia <code>IOException</code> con causa.</p> <p></p>"},{"location":"it/module-08/files-path-api/#3322-creare-file-e-directory","title":"33.2.2 Creare File e Directory","text":"<p>La creazione \u00e8 dove la vecchia API \u00e8 pi\u00f9 scomoda e la API NIO \u00e8 pi\u00f9 espressiva.</p> Task Approccio legacy Approccio NIO Note Creare file vuoto apri+chiudi stream <code>Files.createFile</code> NIO fallisce se esiste Creare una directory <code>mkdir</code> <code>Files.createDirectory</code> Il parent deve esistere Creare directory ricorsivamente <code>mkdirs</code> <code>Files.createDirectories</code> Crea i parent <p></p>"},{"location":"it/module-08/files-path-api/#33221-creare-un-file","title":"33.2.2.1 Creare un File","text":"<p>Il legacy non ha un metodo \u201ccrea file vuoto\u201d, quindi tipicamente crei un file aprendo uno stream di output (side effect).</p> <pre><code>import java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\nFile f = new File(\"created-legacy.txt\");\ntry (FileOutputStream out = new FileOutputStream(f)) {\n    // il file \u00e8 creato (o troncato) come side effect\n}\n</code></pre> <p>NIO fornisce un metodo esplicito di creazione.</p> <pre><code>import java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.io.IOException;\n\nPath p = Path.of(\"created-nio.txt\");\nFiles.createFile(p);\n</code></pre> <p>Note</p> <p><code>Files.createFile</code> lancia <code>FileAlreadyExistsException</code> se la entry esiste.</p> <p></p>"},{"location":"it/module-08/files-path-api/#33222-creare-directory","title":"33.2.2.2 Creare Directory","text":"<pre><code>import java.io.File;\n\nFile dir1 = new File(\"a/b\");\nboolean ok1 = dir1.mkdir(); // fallisce se il parent \"a\" non esiste\nboolean ok2 = dir1.mkdirs(); // crea i parent\n</code></pre> <pre><code>import java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.io.IOException;\n\nPath d = Path.of(\"a/b\");\nFiles.createDirectory(d); // il parent deve esistere\nFiles.createDirectories(d); // crea i parent, ok se gi\u00e0 esiste\n</code></pre> <p>Note</p> <p>I legacy <code>mkdir()/mkdirs()</code> restituiscono <code>false</code> in caso di fallimento senza dire perch\u00e9. NIO lancia <code>IOException</code>.</p> <p></p>"},{"location":"it/module-08/files-path-api/#3323-copiare-file-e-directory","title":"33.2.3 Copiare File e Directory","text":"<p>La copia legacy \u00e8 di solito una copia manuale via stream (o librerie esterne). NIO ha una singola operazione esplicita.</p> Capacit\u00e0 Legacy NIO Copiare contenuti file Stream manuali <code>Files.copy</code> Copiare in target esistente Manuale Opzione <code>REPLACE_EXISTING</code> Copiare albero directory Ricorsione manuale Ricorsione manuale (ma strumenti migliori: <code>Files.walk</code> + <code>Files.copy</code>) <p></p>"},{"location":"it/module-08/files-path-api/#33231-copiare-un-file-nio","title":"33.2.3.1 Copiare un File (NIO)","text":"<pre><code>import java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\nimport java.io.IOException;\n\nPath src = Path.of(\"src.txt\");\nPath dst = Path.of(\"dst.txt\");\n\nFiles.copy(src, dst); // fallisce se dst esiste\nFiles.copy(src, dst, StandardCopyOption.REPLACE_EXISTING);\n</code></pre> <p>Note</p> <p><code>Files.copy</code> lancia <code>FileAlreadyExistsException</code> se il target esiste e non hai usato <code>REPLACE_EXISTING</code>.</p> <p></p>"},{"location":"it/module-08/files-path-api/#33232-copia-manuale-legacy-basata-su-stream","title":"33.2.3.2 Copia Manuale (Legacy, Basata su Stream)","text":"<pre><code>import java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\ntry (FileInputStream in = new FileInputStream(\"src.bin\");\nFileOutputStream out = new FileOutputStream(\"dst.bin\")) {\n\n    byte[] buf = new byte[8192];\n    int n;\n    while ((n = in.read(buf)) != -1) {\n        out.write(buf, 0, n);\n    }\n}\n</code></pre> <p>Note</p> <p>Ricorda <code>read(byte[])</code> restituisce il numero di byte letti; devi scrivere solo quel conteggio, non l\u2019intero buffer.</p> <p></p>"},{"location":"it/module-08/files-path-api/#3324-spostare-rinominare-e-sostituire","title":"33.2.4 Spostare / Rinominare e Sostituire","text":"<p>In entrambe le API, rinomina/sposta \u00e8 \u201ca livello metadata\u201d quando possibile, ma pu\u00f2 comportarsi come copy+delete tra filesystem. NIO lo rende esplicito tramite opzioni.</p> Operazione Legacy NIO Rinominare/spostare <code>File.renameTo</code> <code>Files.move</code> Sostituire esistente Inaffidabile <code>REPLACE_EXISTING</code> Spostamento atomico Non supportato <code>ATOMIC_MOVE</code> (se supportato) <p></p>"},{"location":"it/module-08/files-path-api/#33241-rinomina-legacy-trappola-comune","title":"33.2.4.1 Rinomina Legacy (Trappola Comune)","text":"<pre><code>import java.io.File;\n\nFile from = new File(\"old.txt\");\nFile to = new File(\"new.txt\");\n\nboolean ok = from.renameTo(to); // pu\u00f2 fallire silenziosamente\nSystem.out.println(ok);\n</code></pre> <p>Note</p> <ul> <li><code>renameTo</code> \u00e8 notoriamente platform-dependent e restituisce solo <code>boolean</code>.</li> <li>Pu\u00f2 fallire perch\u00e9 il target esiste, il file \u00e8 aperto, permessi, o spostamento cross-filesystem.</li> </ul> <p></p>"},{"location":"it/module-08/files-path-api/#33242-nio-move-preferito","title":"33.2.4.2 NIO Move (Preferito)","text":"<pre><code>import java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\nimport java.io.IOException;\n\nPath from = Path.of(\"old.txt\");\nPath to = Path.of(\"new.txt\");\n\nFiles.move(from, to); // fallisce se il target esiste\nFiles.move(from, to, StandardCopyOption.REPLACE_EXISTING);\n</code></pre> <p>Note</p> <p><code>Files.move</code> lancia <code>FileAlreadyExistsException</code> quando il target esiste e <code>REPLACE_EXISTING</code> non \u00e8 specificato.</p> <p></p>"},{"location":"it/module-08/files-path-api/#3325-confrontare-path-e-file","title":"33.2.5 Confrontare Path e File","text":"<p>Confrontare locator pu\u00f2 significare: uguaglianza string/path, uguaglianza normalizzata/canonica, o \u201cstesso file su disco\u201d.</p> <p>Le API differiscono significativamente qui.</p> Obiettivo confronto Legacy NIO Stesso testo di path <code>File.equals</code> <code>Path.equals</code> Normalizzare path <code>getCanonicalFile</code> <code>normalize</code> Stesso file/risorsa su disco debole (euristica canonica) <code>Files.isSameFile</code> <p></p>"},{"location":"it/module-08/files-path-api/#33251-uguaglianza-vs-stesso-file","title":"33.2.5.1 Uguaglianza vs Stesso File","text":"<p>Due stringhe di path diverse possono riferirsi allo stesso file.</p> <pre><code>import java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.io.IOException;\n\nPath p1 = Path.of(\"a/../data.txt\");\nPath p2 = Path.of(\"data.txt\");\n\nSystem.out.println(p1.equals(p2)); // false (testo path diverso)\nSystem.out.println(p1.normalize().equals(p2.normalize())); // pu\u00f2 ancora essere false se relativo\n\ntry {\n    System.out.println(Files.isSameFile(p1, p2)); // pu\u00f2 essere true, pu\u00f2 lanciare se non accessibile\n} catch (IOException e) {\n    System.out.println(\"isSameFile failed: \" + e.getMessage());\n}\n</code></pre> <p>Note</p> <p><code>Files.isSameFile</code> pu\u00f2 accedere al filesystem e pu\u00f2 lanciare <code>IOException</code> (problemi di permessi, file mancanti, ecc.).</p> <p></p>"},{"location":"it/module-08/files-path-api/#3326-cancellare-file-e-directory","title":"33.2.6 Cancellare File e Directory","text":"<p>La cancellazione \u00e8 semplice in concetto ma ha casi limite importanti: directory non vuote, target mancanti e differenze nel reporting degli errori.</p> Task Legacy NIO Comportamento se mancante Cancellare file/dir <code>File.delete</code> <code>Files.delete</code> Legacy false, NIO eccezione Cancellare se esiste Nessun diretto (check+delete) <code>Files.deleteIfExists</code> restituisce boolean Cancellare dir non vuota Ricorsione manuale Ricorsione manuale (walk) Entrambe richiedono ricorsione <p></p>"},{"location":"it/module-08/files-path-api/#33261-delete-legacy","title":"33.2.6.1 Delete Legacy","text":"<pre><code>import java.io.File;\n\nFile f = new File(\"x.txt\");\nboolean ok = f.delete(); // false se non cancellato\nSystem.out.println(ok);\n</code></pre> <p>Note</p> <p>Legacy <code>delete()</code> fallisce (restituisce false) per una directory non vuota e spesso non fornisce motivo.</p> <p></p>"},{"location":"it/module-08/files-path-api/#33262-nio-delete-e-delete-if-exists","title":"33.2.6.2 NIO Delete e Delete-If-Exists","text":"<pre><code>import java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.NoSuchFileException;\nimport java.nio.file.DirectoryNotEmptyException;\nimport java.io.IOException;\n\nPath p = Path.of(\"x.txt\");\n\ntry {\n    Files.delete(p);\n} catch (NoSuchFileException e) {\n    System.out.println(\"Missing: \" + e.getFile());\n} catch (DirectoryNotEmptyException e) {\n    System.out.println(\"Directory not empty: \" + e.getFile());\n} catch (IOException e) {\n    System.out.println(\"Delete failed: \" + e.getMessage());\n}\n\nboolean deleted = Files.deleteIfExists(p);\nSystem.out.println(deleted);\n</code></pre> <p>Note</p> <p>Certification tip: <code>Files.delete</code> lancia <code>NoSuchFileException</code> se mancante, mentre <code>deleteIfExists</code> restituisce <code>false</code>.</p> <p></p>"},{"location":"it/module-08/files-path-api/#3327-copiare-cancellare-ricorsivamente-alberi-di-directory-pattern-nio","title":"33.2.7 Copiare / Cancellare Ricorsivamente Alberi di Directory (Pattern NIO)","text":"<p>NIO non fornisce un singolo metodo \u201ccopyTree/deleteTree\u201d, ma l\u2019approccio standard usa <code>Files.walk</code> o <code>Files.walkFileTree</code>.</p> <pre><code>import java.io.IOException;\nimport java.nio.file.*;\nimport java.nio.file.attribute.BasicFileAttributes;\n\nPath root = Path.of(\"dirToDelete\");\n\nFiles.walkFileTree(root, new SimpleFileVisitor&lt;Path&gt;() {\n    @Override\n    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n        Files.delete(file);\n        return FileVisitResult.CONTINUE;\n    }\n\n    @Override\n    public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n        if (exc != null) throw exc;\n        Files.delete(dir);\n        return FileVisitResult.CONTINUE;\n    }\n});\n</code></pre> <p>Note</p> <p>Cancellare un albero di directory richiede cancellare prima i file, poi le directory (post-order). Questa \u00e8 una domanda di ragionamento comune.</p> <p></p>"},{"location":"it/module-08/files-path-api/#3328-checklist-di-riepilogo","title":"33.2.8 Checklist di Riepilogo","text":"<ul> <li>Preferisci <code>Files.createFile/createDirectory/createDirectories</code> rispetto a workaround legacy</li> <li><code>File.renameTo</code> \u00e8 inaffidabile; preferisci <code>Files.move</code> con opzioni</li> <li><code>Files.copy/move</code> lanciano <code>FileAlreadyExistsException</code> a meno che non venga usato <code>REPLACE_EXISTING</code></li> <li><code>Files.delete</code> lancia; <code>Files.deleteIfExists</code> restituisce boolean</li> <li><code>Files.isSameFile</code> pu\u00f2 lanciare <code>IOException</code> e pu\u00f2 toccare il filesystem</li> <li>La cancellazione di directory non vuote richiede ricorsione (entrambe le API)</li> </ul>"},{"location":"it/module-08/files-path/","title":"32. Fondamenti di File e Path","text":""},{"location":"it/module-08/files-path/#indice","title":"Indice","text":"<ul> <li>32.1 Modello Concettuale: Filesystem, File, Directory, Link e Target-di-I/O</li> <li>32.2 Filesystem \u2013 L\u2019Astrazione Globale</li> <li>32.3 Path \u2013 Localizzare una Entry in un Filesystem</li> <li>32.4 File \u2013 Contenitori Persistenti di Dati</li> <li>32.5 Directory \u2013 Contenitori Strutturali</li> <li>32.6 Link \u2013 Meccanismi di Indirezione<ul> <li>32.6.1 Hard Link</li> <li>32.6.2 Link Simbolici Soft</li> </ul> </li> <li>32.7 Altri Tipi di Entry del Filesystem</li> <li>32.8 Come Java IO Interagisce con Questi Concetti</li> <li>32.9 Trappole Concettuali Fondamentali</li> <li>32.10 Perch\u00e9 Esistono Path e Files (Contesto-IO)</li> <li>32.11 File \u00c8 (API legacy) sia un path sia una api-di-operazioni-su-file<ul> <li>32.11.1 Cosa \u00c8 Davvero File</li> <li>32.11.2 Responsabilit\u00e0 tipo-Path</li> <li>32.11.3 Responsabilit\u00e0 di Operazioni sul Filesystem</li> <li>32.11.4 Cosa NON \u00c8 File</li> <li>32.11.5 Il vecchio doppio ruolo</li> <li>32.11.6 Come NIO Ha Risolto Questo</li> <li>32.11.7 Riepilogo</li> </ul> </li> <li>32.12 Path \u00c8 una Descrizione, Non una Risorsa</li> <li>32.13 Path Assoluti vs Relativi<ul> <li>32.13.1 Path Assoluti</li> <li>32.13.2 Path Relativi</li> </ul> </li> <li>32.14 Consapevolezza del Filesystem e Separatori<ul> <li>32.14.1 FileSystem</li> <li>32.14.2 Separatori di Path</li> </ul> </li> <li>32.15 Cosa Fa Davvero Files e Cosa Non Fa<ul> <li>32.15.1 Files FA</li> <li>32.15.2 Files NON FA</li> </ul> </li> <li>32.16 Filosofia di Gestione degli Errori: Old-vs-NIO</li> <li>32.17 Falsi Miti Comuni</li> </ul> <p>Questa sezione si concentra su <code>Path</code>, <code>File</code>, <code>Files</code> e classi correlate, spiegando perch\u00e9 esistono, quali problemi risolvono e quali sono le differenze tra le API legacy <code>java.io</code> e <code>NIO v.2</code> (nuove API di I/O), con particolare attenzione alla semantica del filesystem, alla risoluzione dei path e ai falsi miti comuni.</p> <p></p>"},{"location":"it/module-08/files-path/#321-modello-concettuale-filesystem-file-directory-link-e-target-di-io","title":"32.1 Modello Concettuale: Filesystem, File, Directory, Link e Target-di-I/O","text":"<p>Prima di comprendere le API di Java I/O, \u00e8 essenziale capire con cosa esse interagiscono.</p> <p>Java I/O non opera nel vuoto: interagisce con astrazioni di filesystem fornite dal sistema operativo.</p> <p>Questa sezione definisce questi concetti indipendentemente da Java, poi spiega come Java I/O li mappa e quali problemi vengono risolti.</p> <p></p>"},{"location":"it/module-08/files-path/#322-filesystem-lastrazione-globale","title":"32.2 Filesystem \u2013 L\u2019Astrazione Globale","text":"<p>Un <code>filesystem</code> \u00e8 un meccanismo strutturato fornito da un sistema operativo per organizzare, memorizzare, recuperare e gestire dati su dispositivi di storage persistente.</p> <p>A livello concettuale, un filesystem risolve diversi problemi fondamentali:</p> <ul> <li>Storage persistente oltre l\u2019esecuzione del programma</li> <li>Organizzazione gerarchica dei dati</li> <li>Nominare e localizzare i dati</li> <li>Controllo degli accessi e permessi</li> <li>Garanzie di concorrenza e consistenza</li> </ul> <p>In Java NIO, un filesystem \u00e8 rappresentato dall\u2019astrazione <code>FileSystem</code>, tipicamente ottenuta tramite <code>FileSystems.getDefault()</code> per il filesystem del sistema operativo.</p> Aspetto Significato Persistenza I dati sopravvivono alla terminazione della JVM Ambito Gestito dal SO, non gestito dalla JVM Molteplicit\u00e0 Possono esistere pi\u00f9 filesystem Esempi Disk FS, ZIP FS, in-memory FS <p>Note</p> <p>Java non implementa filesystem; si adatta a implementazioni di filesystem fornite dal SO o da providers custom.</p> <p></p>"},{"location":"it/module-08/files-path/#323-path-localizzare-una-entry-in-un-filesystem","title":"32.3 Path \u2013 Localizzare una Entry in un Filesystem","text":"<p>Un <code>path</code> \u00e8 un localizzatore logico, non una risorsa.</p> <p>Descrive dove qualcosa sarebbe in un filesystem, non cos\u2019\u00e8 o se esiste.</p> <p>Un <code>path</code> risolve il problema dell\u2019<code>addressing</code>:</p> <ul> <li>Identifica una posizione</li> <li>\u00c8 interpretato all\u2019interno di un filesystem specifico</li> <li>Pu\u00f2 o non pu\u00f2 corrispondere a una entry esistente</li> </ul> Propriet\u00e0 Path Consapevole dell\u2019esistenza No Consapevole del tipo No Immutabile S\u00ec Risorsa del SO No <p>Note</p> <p>In Java, <code>Path</code> rappresenta entry potenziali del filesystem, non entry reali.</p> <p></p>"},{"location":"it/module-08/files-path/#324-file-contenitori-persistenti-di-dati","title":"32.4 File \u2013 Contenitori Persistenti di Dati","text":"<p>Un <code>file</code> \u00e8 una entry del filesystem il cui ruolo primario \u00e8 memorizzare dati.</p> <p>Il filesystem tratta i file come sequenze di byte opache.</p> <p>Problemi risolti dai file:</p> <ul> <li>Storage duraturo di informazioni</li> <li>Accesso sequenziale e random ai dati</li> <li>Condivisione dei dati tra processi</li> </ul> <p>Dal punto di vista del filesystem, un file ha:</p> <ul> <li>Contenuto (byte)</li> <li>Metadati (dimensione, timestamp, permessi)</li> <li>Una posizione (path)</li> </ul> Aspetto Descrizione Contenuto Orientato ai byte Interpretazione Definita dall\u2019applicazione Durata Indipendente dai processi Accesso Java Stream, channel, metodi di Files <p>Note</p> <p><code>Testo</code> vs <code>binario</code> non \u00e8 un concetto del filesystem; \u00e8 un\u2019interpretazione a livello applicazione.</p> <p></p>"},{"location":"it/module-08/files-path/#325-directory-contenitori-strutturali","title":"32.5 Directory \u2013 Contenitori Strutturali","text":"<p>Una <code>directory (o folder)</code> \u00e8 una entry del filesystem il cui scopo \u00e8 organizzare altre entry.</p> <p>Le <code>directory</code> risolvono il problema della scalabilit\u00e0 e dell\u2019organizzazione:</p> <ul> <li>Raggruppare entry correlate</li> <li>Abilitare naming gerarchico</li> <li>Supportare lookup efficiente</li> </ul> Aspetto Directory Memorizza dati No (memorizza riferimenti) Contiene File, directory, link Lettura/scrittura Strutturale, non basata sul contenuto Accesso Java Files.list, Files.walk <p>Note</p> <p>Una directory non \u00e8 un file con contenuto, anche se entrambi condividono metadati comuni.</p> <p></p>"},{"location":"it/module-08/files-path/#326-link-meccanismi-di-indirezione","title":"32.6 Link \u2013 Meccanismi di Indirezione","text":"<p>Un <code>link</code> \u00e8 una entry del filesystem che riferisce un\u2019altra entry.</p> <p>I link risolvono il problema dell\u2019indirezione e del riuso.</p> <p></p>"},{"location":"it/module-08/files-path/#3261-hard-link","title":"32.6.1 Hard Link","text":"<p>Un <code>hard link</code> \u00e8 un nome aggiuntivo per gli stessi dati sottostanti.</p> <ul> <li>Pi\u00f9 path puntano agli stessi dati del file</li> <li>La cancellazione avviene solo quando tutti i link vengono rimossi</li> </ul> <p></p>"},{"location":"it/module-08/files-path/#3262-link-simbolici-soft","title":"32.6.2 Link Simbolici (Soft)","text":"<p>Un <code>link simbolico</code> \u00e8 un file speciale che contiene un path verso un\u2019altra entry:</p> <ul> <li>Pu\u00f2 puntare a target non esistenti</li> <li>Risolto al momento dell\u2019accesso</li> </ul> Tipo di Link Riferisce Pu\u00f2 essere dangling Gestione Java Hard Dati No Trasparente Simbolico Path S\u00ec Controllo esplicito <p>Note</p> <p>Java NIO espone il comportamento dei link in modo esplicito tramite <code>LinkOption</code>.</p> <p>In molti filesystem comuni, il codice Java non pu\u00f2 creare hard link in modo pienamente portabile, mentre i link simbolici sono supportati direttamente tramite <code>Files.createSymbolicLink(...)</code> (dove permesso dal SO / permessi).</p> <p></p>"},{"location":"it/module-08/files-path/#327-altri-tipi-di-entry-del-filesystem","title":"32.7 Altri Tipi di Entry del Filesystem","text":"<p>Alcune entry del filesystem non sono contenitori di dati ma endpoint di interazione.</p> Tipo Scopo Device file Interfaccia verso hardware FIFO / Pipe Comunicazione tra processi Socket file Comunicazione di rete <p>Note</p> <p>Java I/O pu\u00f2 interagire con queste entry, ma il comportamento dipende dalla piattaforma.</p> <p></p>"},{"location":"it/module-08/files-path/#328-come-java-io-interagisce-con-questi-concetti","title":"32.8 Come Java IO Interagisce con Questi Concetti","text":"<p>Le API Java I/O operano a diversi livelli di astrazione:</p> <ul> <li><code>Path</code> (NIO) / <code>File</code> (API legacy) \u2192 descrive una entry del filesystem</li> <li><code>File</code> (API legacy) / <code>Files</code> \u2192 interroga o modifica lo stato del filesystem</li> <li><code>Streams</code> / <code>Channels</code> \u2192 muovono byte o caratteri</li> </ul> API Java Ruolo <code>Path</code> Addressing <code>File</code> (API legacy) Addressing / operazioni su filesystem <code>Files</code> Operazioni su filesystem <code>InputStream</code> / <code>Reader</code> Lettura dati <code>OutputStream</code> / <code>Writer</code> Scrittura dati <code>Channel</code> / <code>SeekableByteChannel</code> Avanzato / accesso random <p>Note</p> <p>Nessuna API Java \u201c\u00e8\u201d un file; le API mediano l\u2019accesso a risorse gestite dal filesystem.</p> <p></p>"},{"location":"it/module-08/files-path/#329-trappole-concettuali-fondamentali","title":"32.9 Trappole Concettuali Fondamentali","text":"<ul> <li>Confondere i path con i file</li> <li>Assumere che i path implichino esistenza</li> <li>Assumere che le directory memorizzino i dati dei file</li> <li>Assumere che i link siano sempre risolti automaticamente</li> </ul> <p>Note</p> <p>Separare sempre posizione, struttura e flusso dati quando si ragiona su I/O.</p> <p></p>"},{"location":"it/module-08/files-path/#3210-perche-esistono-path-e-files-contesto-io","title":"32.10 Perch\u00e9 Esistono Path e Files (Contesto-IO)","text":"<p>Il classico <code>java.io</code> mescolava tre compiti diversi in un API poco specifica:</p> <ul> <li>Rappresentazione del path (dove si trova la risorsa?)</li> <li>Interazione con il filesystem (esiste? che tipo?)</li> <li>Accesso ai dati (lettura/scrittura di byte o caratteri)</li> </ul> <p>Il design di NIO.2 (Java 7+) separa deliberatamente queste responsabilit\u00e0:</p> <ul> <li><code>Path</code> \u2192 descrive una posizione</li> <li><code>Files</code> \u2192 esegue operazioni sul filesystem</li> <li><code>Streams / Channels</code> \u2192 spostano dati</li> </ul> <p>Note</p> <p>Un <code>Path</code> non apre mai un file e non tocca mai il disco da solo.</p> <p></p>"},{"location":"it/module-08/files-path/#3211-file-e-api-legacy-sia-un-path-sia-una-api-di-operazioni-su-file","title":"32.11 File \u00c8 (API legacy) sia un path sia una api-di-operazioni-su-file?","text":"<p>S\u00ec \u2014 nella vecchia API di I/O, <code>java.io.File</code> gioca in modo confuso due ruoli allo stesso tempo, e questo design \u00e8 esattamente una delle ragioni per cui \u00e8 stato introdotto <code>java.nio.file</code>.</p> <p>Risposta Breve</p> <ul> <li><code>File</code> rappresenta un path del filesystem</li> <li><code>File</code> espone anche operazioni sul filesystem</li> <li>Non rappresenta n\u00e9 un file aperto, n\u00e9 i contenuti del file</li> </ul> <p>Note</p> <p>Questo mix di responsabilit\u00e0 \u00e8 considerato un difetto di design.</p> <p></p>"},{"location":"it/module-08/files-path/#32111-cosa-e-davvero-file","title":"32.11.1 Cosa \u00c8 Davvero File","text":"<p>Concettualmente, <code>File</code> \u00e8 pi\u00f9 vicino a ci\u00f2 che oggi chiamiamo <code>Path</code>, ma con metodi operativi aggiunti.</p> Aspetto java.io.File Rappresenta una posizione S\u00ec Apre un file No Legge / scrive dati No Interroga il filesystem S\u00ec Modifica il filesystem S\u00ec Contiene handle del SO No <p>Note</p> <p>Un oggetto <code>File</code> pu\u00f2 esistere anche se il file non esiste.</p> <p></p>"},{"location":"it/module-08/files-path/#32112-responsabilita-tipo-path","title":"32.11.2 Responsabilit\u00e0 tipo-Path","text":"<p><code>File</code> si comporta come un\u2019astrazione di path perch\u00e9:</p> <ul> <li>Incapsula un pathname del filesystem (assoluto o relativo)</li> <li>Pu\u00f2 essere risolto rispetto alla working directory</li> <li>Pu\u00f2 essere convertito in forma assoluta o canonica</li> </ul> <p>Esempi:</p> <pre><code>File f = new File(\"data.txt\"); // path relativo\nFile abs = f.getAbsoluteFile(); // path assoluto\nFile canon = f.getCanonicalFile(); // normalizzato + risolto\n</code></pre> <p></p>"},{"location":"it/module-08/files-path/#32113-responsabilita-di-operazioni-sul-filesystem","title":"32.11.3 Responsabilit\u00e0 di Operazioni sul Filesystem","text":"<p>Allo stesso tempo, <code>File</code> espone metodi che toccano il filesystem:</p> <ul> <li>exists()</li> <li>isFile(), isDirectory()</li> <li>length()</li> <li>delete()</li> <li>mkdir(), mkdirs()</li> <li>list(), listFiles()</li> </ul> <p>Note</p> <p>La maggior parte di questi metodi restituisce <code>boolean</code> invece di lanciare <code>IOException</code>, il che nasconde le cause degli eventuali problemi.</p> <p></p>"},{"location":"it/module-08/files-path/#32114-cosa-non-e-file","title":"32.11.4 Cosa NON \u00c8 File","text":"<ul> <li>Non \u00e8 un file descriptor aperto</li> <li>Non \u00e8 uno stream</li> <li>Non \u00e8 un channel</li> <li>Non \u00e8 un contenitore di dati del file</li> </ul> <p>Si devono comunque usare stream o reader/writer per accedere ai contenuti.</p> <p></p>"},{"location":"it/module-08/files-path/#32115-il-vecchio-doppio-ruolo","title":"32.11.5 Il vecchio doppio ruolo","text":"<p>Il doppio ruolo di <code>File</code> ha causato diversi problemi:</p> <ul> <li>Ruolo misto (path + operazioni)</li> <li>Gestione errori insufficiente (boolean invece di eccezioni)</li> <li>Supporto debole per link e filesystem multipli</li> <li>Comportamento dipendente dalla piattaforma</li> </ul> <p></p>"},{"location":"it/module-08/files-path/#32116-come-nio-ha-risolto-questo","title":"32.11.6 Come NIO ha Risolto Questo","text":"<p>NIO.2 separa esplicitamente le responsabilit\u00e0:</p> Responsabilit\u00e0 Vecchia API API NIO <code>Rappresentazione Path</code> <code>File</code> <code>Path</code> <code>Operazioni su filesystem</code> <code>File</code> <code>Files</code> <code>Accesso ai dati</code> Stream Stream / Channel <p>Note</p> <p>Questa separazione \u00e8 uno dei miglioramenti concettuali pi\u00f9 importanti in Java I/O.</p> <p></p>"},{"location":"it/module-08/files-path/#32117-riepilogo","title":"32.11.7 Riepilogo","text":"<ul> <li><code>File</code> rappresenta un path E svolge operazioni sul filesystem</li> <li>Non legge n\u00e9 scrive mai i contenuti del file</li> <li>Non apre mai un file</li> <li><code>Path</code> + <code>Files</code> \u00e8 il sostituto moderno</li> </ul>"},{"location":"it/module-08/files-path/#3212-path-e-una-descrizione-non-una-risorsa","title":"32.12 Path \u00c8 una Descrizione, Non una Risorsa","text":"<p>Un <code>Path</code> \u00e8 un\u2019astrazione pura che rappresenta una sequenza di elementi nominati in un filesystem.</p> <ul> <li>Non implica esistenza</li> <li>Non implica accessibilit\u00e0</li> <li>Non contiene un file descriptor</li> </ul> <p>Questo \u00e8 fondamentalmente diverso da stream o channel.</p> Concetto Path Stream / Channel <code>Apre risorsa</code> No S\u00ec <code>Tocca disco</code> No S\u00ec <code>Contiene handle SO</code> No S\u00ec <code>Immutabile</code> S\u00ec No <p>Note</p> <p>Creare un Path non pu\u00f2 lanciare <code>IOException</code> perch\u00e9 non avviene alcun I/O.</p> <p></p>"},{"location":"it/module-08/files-path/#3213-path-assoluti-vs-relativi","title":"32.13 Path Assoluti vs Relativi","text":"<p>Comprendere la risoluzione dei path \u00e8 essenziale.</p> <p></p>"},{"location":"it/module-08/files-path/#32131-path-assoluti","title":"32.13.1 Path Assoluti","text":"<p>Un path assoluto identifica interamente una posizione dalla root del filesystem.</p> <ul> <li>Root dipendente dalla piattaforma</li> <li>Indipendente dalla JVM working directory</li> </ul> Piattaforma Esempio di Path Assoluto Unix <code>/home/user/file.txt</code> Windows <code>C:\\Users\\User\\file.txt</code> <p>Important</p> <ul> <li>Un path che inizia con una slash <code>(/)</code> (tipo Unix) o con una lettera di drive come <code>C:</code> (Windows) \u00e8 tipicamente considerato un path assoluto.</li> <li>Il simbolo <code>.</code> \u00e8 un riferimento alla directory corrente mentre <code>..</code> \u00e8 un riferimento alla directory padre. Su Windows, un path come <code>\\dir\\file.txt</code> (senza lettera di drive) \u00e8 rooted sul drive corrente, non pienamente qualificato con drive + path.</li> </ul> <p>Esempio:</p> <pre><code>/dirA/dirB/../dirC/./content.txt\n\nis equivalent to:\n\n/dirA/dirC/content.txt\n\n// in this example the symbols were redundant and unnecessary\n</code></pre> <p></p>"},{"location":"it/module-08/files-path/#32132-path-relativi","title":"32.13.2 Path Relativi","text":"<p>Un path relativo viene risolto rispetto alla directory di lavoro corrente della JVM.</p> <ul> <li>Dipende da dove \u00e8 stata avviata la JVM</li> <li>Fonte comune di bug</li> </ul> <p>Note</p> <p>La working directory \u00e8 tipicamente disponibile tramite <code>System.getProperty(\"user.dir\")</code>.</p> <p>Esempio:</p> <pre><code>dirB/dirC/content.txt\n</code></pre> <p></p>"},{"location":"it/module-08/files-path/#3214-consapevolezza-del-filesystem-e-separatori","title":"32.14 Consapevolezza del Filesystem e Separatori","text":"<p>NIO introduce l\u2019astrazione del filesystem, che era in gran parte assente in java.io.</p> <p></p>"},{"location":"it/module-08/files-path/#32141-filesystem","title":"32.14.1 FileSystem","text":"<p>Un <code>FileSystem</code> rappresenta una specifica implementazione concreta di filesystem.</p> <ul> <li>Il filesystem di default corrisponde al filesystem del SO</li> <li>Possibili altri filesystem (ZIP, memoria, rete)</li> </ul> <p>Note</p> <p>I path sono sempre associati a esattamente UN FileSystem.</p> <p></p>"},{"location":"it/module-08/files-path/#32142-separatori-di-path","title":"32.14.2 Separatori di Path","text":"<p>I separatori differiscono tra piattaforme, ma <code>Path</code> li astrae.</p> Aspetto java.io.File java.nio.file.Path Separatore Basato su stringhe Consapevole del filesystem Portabilit\u00e0 Gestione manuale Automatica Comparazione Soggetta a errori Pi\u00f9 sicura <p>Note</p> <p>Hardcodare <code>\"/\"</code> o <code>\"\\\\\"</code> \u00e8 sconsigliato; <code>Path</code> lo gestisce automaticamente.</p> <p></p>"},{"location":"it/module-08/files-path/#3215-cosa-fa-davvero-files-e-cosa-non-fa","title":"32.15 Cosa Fa Davvero Files e Cosa Non Fa","text":"<p>La classe <code>Files</code> esegue vere operazioni di I/O.</p> <p></p>"},{"location":"it/module-08/files-path/#32151-files-fa","title":"32.15.1 Files FA","text":"<ul> <li>Apre file indirettamente (tramite stream / channel restituiti dai suoi metodi)</li> <li>Crea e cancella entry del filesystem</li> <li>Lancia eccezioni checked in caso di fallimento</li> <li>Rispetta i permessi del filesystem</li> </ul>"},{"location":"it/module-08/files-path/#32152-files-non-fa","title":"32.15.2 Files NON FA","text":"<ul> <li>Mantenere risorse aperte dopo il ritorno del metodo (eccetto gli stream)</li> <li>Memorizzare contenuti del file internamente</li> <li>Garantire atomicit\u00e0 se non specificato</li> <li>Mantenere un handle persistente a file aperti (sono stream/channel a possedere l\u2019handle)</li> </ul> <p>Note</p> <p>I metodi che restituiscono stream (es. <code>Files.lines()</code>) tengono il file aperto finch\u00e9 lo stream non viene chiuso.</p> <p></p>"},{"location":"it/module-08/files-path/#3216-filosofia-di-gestione-degli-errori-old-vs-nio","title":"32.16 Filosofia di Gestione degli Errori: Old vs NIO","text":"<p>Una grande differenza concettuale risiede nel reporting degli errori.</p> Aspetto <code>java.io.File</code> <code>java.nio.file.Files</code> Segnalazione errori boolean / <code>null</code> <code>IOException</code> Diagnostica Scarsa Ricca Consapevolezza race Debole Migliorata Preferenza Sconsigliato Preferito <p></p>"},{"location":"it/module-08/files-path/#3217-falsi-miti-comuni","title":"32.17 Falsi Miti Comuni","text":"<ul> <li>\u201cPath rappresenta un file\u201d \u2192 falso</li> <li>\u201cnormalize controlla l\u2019esistenza\u201d \u2192 falso</li> <li>\u201cFiles.readAllLines streamma i dati\u201d \u2192 falso</li> <li>\u201cI path relativi sono portabili\u201d \u2192 falso</li> <li>\u201cCreare un Path pu\u00f2 fallire per permessi\u201d \u2192 falso</li> </ul> <p>Note</p> <p>Molti metodi NIO che suonano \u201csicuri\u201d sono puramente sintattici (come <code>normalize</code> o <code>resolve</code>): non toccano il filesystem e non possono rilevare file mancanti.</p>"},{"location":"it/module-08/io-streams-api/","title":"35. API di I/O Java (Legacy e NIO)","text":""},{"location":"it/module-08/io-streams-api/#indice","title":"Indice","text":"<ul> <li>35.1 Legacy java.io \u2014 Design, comportamento e sottigliezze<ul> <li>35.1.1 L\u2019astrazione di stream</li> <li>35.1.2 Chaining degli stream e pattern Decorator</li> <li>35.1.3 I/O bloccante: cosa significa</li> <li>35.1.4 Gestione risorse: close(), flush() e perch\u00e9 esistono</li> <li>35.1.5 finalize(): perch\u00e9 esiste e perch\u00e9 fallisce</li> <li>35.1.6 available(): scopo e abuso</li> <li>35.1.7 mark() e reset(): backtracking controllato</li> <li>35.1.8 Reader, Writer e codifica dei caratteri</li> <li>35.1.9 File vs FileDescriptor</li> </ul> </li> <li>35.2 java.nio \u2014 Buffer, Channel e I/O non bloccante<ul> <li>35.2.1 Dagli stream ai buffer: un cambio concettuale</li> <li>35.2.2 Buffer: scopo e struttura</li> <li>35.2.3 Ciclo di vita del buffer: Write \u2192 Flip \u2192 Read</li> <li>35.2.4 clear() vs compact()</li> <li>35.2.5 Heap buffers vs Direct buffers</li> <li>35.2.6 Channel: cosa sono</li> <li>35.2.7 Channel bloccanti vs non bloccanti</li> <li>35.2.8 Scatter/Gather I/O</li> <li>35.2.9 Selector: multiplexing dell\u2019I/O non bloccante</li> <li>35.2.10 Quando usare java.nio</li> </ul> </li> <li>35.3 java.nio.file (NIO.2) \u2014 Operazioni su file e directory (Legacy vs Modern)<ul> <li>35.3.1 Verifiche di esistenza e accessibilit\u00e0</li> <li>35.3.2 Creazione di file e directory</li> <li>35.3.3 Eliminazione di file e directory</li> <li>35.3.4 Copia di file e directory</li> <li>35.3.5 Spostamento e rinomina</li> <li>35.3.6 Lettura e scrittura di testo e byte (miglioramenti di Files)</li> <li>35.3.7 newInputStream/newOutputStream e newBufferedReader/newBufferedWriter</li> <li>35.3.8 Listing directory e attraversamento di alberi</li> <li>35.3.9 Ricerca e filtro</li> <li>35.3.10 Attributi: lettura, scrittura e view</li> <li>35.3.11 Link simbolici e follow dei link</li> <li>35.3.12 Sintesi: perch\u00e9 Files \u00e8 un miglioramento</li> </ul> </li> <li>35.4 Serializzazione \u2014 Object stream, compatibilit\u00e0 e trappole<ul> <li>35.4.1 Cosa fa la serializzazione (e cosa non fa)</li> <li>35.4.2 Le due principali marker interface</li> <li>35.4.3 Esempio base: scrivere e leggere un oggetto</li> <li>35.4.4 Grafi di oggetti, riferimenti e identit\u00e0</li> <li>35.4.5 serialVersionUID: la chiave di versioning</li> <li>35.4.6 Campi transient e static</li> <li>35.4.7 Campi non serializzabili e NotSerializableException</li> <li>35.4.8 Costruttori e serializzazione</li> <li>35.4.9 Hook di serializzazione custom: writeObject e readObject</li> <li>35.4.10 Esempio d\u2019uso: ripristinare un campo derivato transient</li> <li>35.4.11 Externalizable: controllo totale (e responsabilit\u00e0 totale)</li> <li>35.4.12 Considerazioni di sicurezza su readObject()</li> <li>35.4.13 Trappole comuni e consigli pratici</li> <li>35.4.14 Quando usare (o evitare) la serializzazione Java</li> </ul> </li> </ul>"},{"location":"it/module-08/io-streams-api/#351-legacy-javaio-design-comportamento-e-sottigliezze","title":"35.1 Legacy java.io \u2014 Design, comportamento e sottigliezze","text":"<p>L\u2019API legacy <code>java.io</code> \u00e8 l\u2019astrazione I/O originale introdotta in Java 1.0.</p> <p>Essa \u00e8 orientata agli stream, bloccante, e mappata strettamente sui concetti I/O del sistema operativo.</p> <p>Anche se esistono API pi\u00f9 recenti, <code>java.io</code> resta fondamentale: molte API di livello superiore ci si appoggiano, ed \u00e8 ancora molto usata.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#3511-lastrazione-di-stream","title":"35.1.1 L\u2019astrazione di stream","text":"<p>Uno <code>stream</code> rappresenta un flusso continuo di dati tra una sorgente e una destinazione.</p> <p>In <code>java.io</code>, gli stream sono unidirezionali: sono o di input o di output.</p> Stream Direzione Unit\u00e0 di dati Categoria <code>InputStream</code> Input Byte (8-bit) Stream di byte <code>OutputStream</code> Output Byte (8-bit) Stream di byte <code>Reader</code> Input Caratteri Stream di caratteri <code>Writer</code> Output Caratteri Stream di caratteri <p>Gli <code>stream</code> nascondono l\u2019origine concreta dei dati (file, rete, memoria) ed espongono un\u2019interfaccia uniforme di lettura/scrittura.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#3512-chaining-degli-stream-e-pattern-decorator","title":"35.1.2 Chaining degli stream e pattern Decorator","text":"<p>La maggior parte degli stream java.io \u00e8 progettata per essere combinata.</p> <p>Ogni wrapper aggiunge comportamento senza cambiare la sorgente dati sottostante.</p> <pre><code>InputStream in =\n    new BufferedInputStream(\n        new FileInputStream(\"data.bin\"));\n</code></pre> <p>In questo esempio: - <code>FileInputStream</code> esegue l\u2019accesso reale al file - <code>BufferedInputStream</code> aggiunge un buffer in memoria</p> <p>Note</p> <p>Questo design \u00e8 noto come Decorator Pattern.</p> <p>Permette di stratificare funzionalit\u00e0 in modo dinamico.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#3513-io-bloccante-cosa-significa","title":"35.1.3 I/O bloccante: cosa significa","text":"<p>Tutti gli stream legacy <code>java.io</code> sono bloccanti.</p> <p>Ci\u00f2 significa che un thread che esegue I/O pu\u00f2 essere sospeso dal sistema operativo.</p> <p>Per esempio, quando chiami <code>read()</code>: - se i dati sono disponibili, vengono restituiti subito - se non ci sono dati, il thread attende - se si raggiunge la fine dello stream, viene restituito -1</p> <p>Note</p> <p>Il comportamento bloccante semplifica la programmazione, ma limita la scalabilit\u00e0.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#3514-gestione-risorse-close-flush-e-perche-esistono","title":"35.1.4 Gestione risorse: <code>close()</code>, <code>flush()</code> e perch\u00e9 esistono","text":"<p>Gli stream spesso incapsulano risorse native del sistema operativo come <code>file descriptor</code> o handle di socket.</p> <p>Queste risorse sono limitate e devono essere rilasciate esplicitamente.</p> Metodo Scopo <code>flush()</code> Scrive i dati bufferizzati verso la destinazione <code>close()</code> Esegue flush e rilascia la risorsa <pre><code>try (OutputStream out = new FileOutputStream(\"file.bin\")) {\n    out.write(42);\n} // close() chiamato automaticamente\n</code></pre> <p>Note</p> <p>Non chiudere gli stream pu\u00f2 causare perdita di dati o esaurimento delle risorse.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#3515-finalize-perche-esiste-e-perche-fallisce","title":"35.1.5 <code>finalize()</code>: perch\u00e9 esiste e perch\u00e9 fallisce","text":"<p>Le prime versioni di Java tentarono di automatizzare il cleanup delle risorse usando la finalizzazione.</p> <p>Il metodo <code>finalize()</code> veniva chiamato dal garbage collector prima di recuperare la memoria.</p> <p>Tuttavia, i tempi del GC sono imprevedibili.</p> Aspetto finalize() Tempo di esecuzione Non specificato Affidabilit\u00e0 Bassa Stato attuale Deprecato <p>Note</p> <p><code>finalize()</code> non va mai usato per pulizia I/O; \u00e8 deprecato e non sicuro.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#3516-available-scopo-e-abuso","title":"35.1.6 <code>available()</code>: scopo e abuso","text":"<p><code>available()</code> stima quanti byte possono essere letti senza bloccare.</p> <p>Non indica la quantit\u00e0 totale di dati rimanenti.</p> <p>Casi d\u2019uso tipici: - evitare blocchi in UI o parsing di protocolli - dimensionare buffer temporanei</p> <pre><code>if (in.available() &gt; 0) {\n    in.read(buffer);\n}\n</code></pre> <p>Note</p> <p><code>available()</code> non deve essere usato per rilevare EOF. Solo <code>read()</code>, che ritorna -1, segnala la fine dello stream.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#3517-mark-e-reset-backtracking-controllato","title":"35.1.7 <code>mark()</code> e <code>reset()</code>: backtracking controllato","text":"<p>Alcuni input stream consentono di marcare una posizione e tornarci in seguito.</p> <pre><code>BufferedInputStream in = new BufferedInputStream(...);\nin.mark(1024);\n// read ahead\nin.reset();\n</code></pre> Stream markSupported() <code>FileInputStream</code> No <code>BufferedInputStream</code> S\u00ec <code>ByteArrayInputStream</code> S\u00ec <p></p>"},{"location":"it/module-08/io-streams-api/#3518-reader-writer-e-codifica-dei-caratteri","title":"35.1.8 Reader, Writer e codifica dei caratteri","text":"<p><code>Reader</code> e <code>Writer</code> operano su <code>caratteri</code>, non su byte.</p> <p>Questo richiede una <code>codifica dei caratteri</code> (charset).</p> <p>Se non specifichi un charset, viene usato quello di default della piattaforma.</p> <pre><code>new FileReader(\"file.txt\"); // encoding di default della piattaforma\n</code></pre> <p>Note</p> <p>Affidarsi al charset di default porta a bug di non portabilit\u00e0.</p> <p>Specifica sempre un charset esplicitamente.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#3519-file-vs-filedescriptor","title":"35.1.9 File vs FileDescriptor","text":"<p><code>File</code> rappresenta un <code>percorso</code> nel filesystem.</p> <p>Non rappresenta una risorsa aperta.</p> <p><code>FileDescriptor</code> rappresenta un handle nativo del SO verso un file o stream aperto.</p> Classe Rappresenta Possiede handle OS? <code>File</code> Percorso filesystem No <code>FileDescriptor</code> Handle file nativo OS S\u00ec <p>Note</p> <p>Pi\u00f9 stream possono condividere lo stesso FileDescriptor.</p> <p>Chiudendone uno, si chiude la risorsa sottostante per tutti.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#352-javanio-buffer-channel-e-io-non-bloccante","title":"35.2 <code>java.nio</code> \u2014 Buffer, Channel e I/O non bloccante","text":"<p>L\u2019API <code>java.nio</code> (New I/O) \u00e8 stata introdotta per risolvere i limiti di <code>java.io</code>.</p> <p>Offre un modello I/O di pi\u00f9 basso livello e pi\u00f9 esplicito, che mappa bene sui sistemi operativi moderni.</p> <p>Alla base, <code>java.nio</code> ruota attorno a tre concetti: - <code>Buffer</code> \u2014 contenitori di memoria espliciti - <code>Channel</code> \u2014 connessioni dati bidirezionali - <code>Selector</code> \u2014 multiplexing dell\u2019I/O non bloccante</p> <p></p>"},{"location":"it/module-08/io-streams-api/#3521-dagli-stream-ai-buffer-un-cambio-concettuale","title":"35.2.1 Dagli stream ai buffer: un cambio concettuale","text":"<p>Gli stream legacy nascondono la gestione della memoria al programmatore.</p> <p>Al contrario, <code>NIO</code> rende esplicita la memoria tramite i buffer.</p> Aspetto java.io java.nio Modello dati Basato su stream (push) Basato su buffer (pull dai buffer) Memoria Nascosta negli stream Esplicita via buffer Controllo Semplice, poco granulare Pi\u00f9 granulare e configurabile <p>Con NIO, l\u2019applicazione controlla quando i dati vengono letti in memoria e come vengono consumati.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#3522-buffer-scopo-e-struttura","title":"35.2.2 Buffer: scopo e struttura","text":"<p>Un <code>buffer</code> \u00e8 un contenitore tipizzato a dimensione fissa.</p> <p>Tutte le operazioni I/O NIO leggono da o scrivono su buffer.</p> <p>Il buffer pi\u00f9 comune \u00e8 <code>ByteBuffer</code>.</p> <pre><code>ByteBuffer buffer = ByteBuffer.allocate(1024);\n</code></pre> Propriet\u00e0 Significato <code>capacity</code> Dimensione totale del buffer <code>position</code> Indice corrente di lettura/scrittura <code>limit</code> Limite dei dati leggibili o scrivibili <p></p>"},{"location":"it/module-08/io-streams-api/#3523-ciclo-di-vita-del-buffer-write-flip-read","title":"35.2.3 Ciclo di vita del buffer: Write \u2192 Flip \u2192 Read","text":"<p>I <code>buffer</code> hanno un ciclo d\u2019uso rigoroso.</p> <p>Capirlo male \u00e8 una fonte comune di bug.</p> <p>Sequenza tipica: - scrivi i dati nel buffer - <code>flip()</code> per passare in modalit\u00e0 lettura - leggi i dati dal buffer - <code>clear()</code> o <code>compact()</code> per riutilizzarlo</p> <pre><code>ByteBuffer buffer = ByteBuffer.allocate(16);\n\nbuffer.put((byte) 1);\nbuffer.put((byte) 2);\n\nbuffer.flip(); // passa in modalit\u00e0 lettura\n\nwhile (buffer.hasRemaining()) {\n    byte b = buffer.get();\n}\n\nbuffer.clear(); // pronto a scrivere di nuovo\n</code></pre> <p>Note</p> <p><code>flip()</code> non cancella i dati: regola position e limit.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#3524-clear-vs-compact","title":"35.2.4 <code>clear()</code> vs <code>compact()</code>","text":"<p>Dopo la lettura, un buffer pu\u00f2 essere riutilizzato in due modi.</p> Metodo Comportamento <code>clear()</code> Scarta i dati non letti <code>compact()</code> Preserva i dati non letti <p><code>compact()</code> \u00e8 utile nei protocolli streaming dove nel buffer possono restare messaggi parziali.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#3525-heap-buffers-vs-direct-buffers","title":"35.2.5 Heap buffers vs Direct buffers","text":"<p>I buffer possono essere allocati in due regioni di memoria diverse.</p> <pre><code>ByteBuffer heap = ByteBuffer.allocate(1024);\nByteBuffer direct = ByteBuffer.allocateDirect(1024);\n</code></pre> Tipo Posizione memoria Caratteristiche <code>Heap</code> Heap JVM GC, economico da allocare <code>Direct</code> Memoria nativa Miglior throughput I/O, pi\u00f9 costoso da allocare <p>Note</p> <p>I direct buffer riducono le copie tra JVM e OS, ma vanno usati con attenzione per evitare pressione di memoria.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#3526-channel-cosa-sono","title":"35.2.6 Channel: cosa sono","text":"<p>Un <code>channel</code> rappresenta una connessione verso un\u2019entit\u00e0 I/O come file, socket o device.</p> <p>A differenza degli stream, i channel sono bidirezionali.</p> Channel Tipo Scopo <code>FileChannel</code> File I/O su file <code>SocketChannel</code> TCP Networking stream (TCP) <code>DatagramChannel</code> UDP Networking datagram (UDP) <pre><code>try (FileChannel channel =\n    FileChannel.open(Path.of(\"file.txt\"))) {\n\n    ByteBuffer buffer = ByteBuffer.allocate(128);\n    channel.read(buffer);\n}\n</code></pre> <p></p>"},{"location":"it/module-08/io-streams-api/#3527-channel-bloccanti-vs-non-bloccanti","title":"35.2.7 Channel bloccanti vs non bloccanti","text":"<p>I channel possono operare in modalit\u00e0 bloccante o non bloccante.</p> <pre><code>SocketChannel channel = SocketChannel.open();\nchannel.configureBlocking(false);\n</code></pre> <p>In modalit\u00e0 non bloccante: - <code>read()</code> pu\u00f2 ritornare subito con 0 byte - <code>write()</code> pu\u00f2 scrivere solo una parte dei dati</p> <p>Note</p> <p>L\u2019I/O non bloccante sposta complessit\u00e0 dal SO all\u2019applicazione.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#3528-scattergather-io","title":"35.2.8 Scatter/Gather I/O","text":"<p>NIO supporta lettura/scrittura da/verso pi\u00f9 buffer con una singola operazione.</p> <pre><code>ByteBuffer header = ByteBuffer.allocate(128);\nByteBuffer body = ByteBuffer.allocate(1024);\n\nByteBuffer[] buffers = { header, body };\nchannel.read(buffers);\n</code></pre> <p>Utile per protocolli strutturati (header + payload).</p> <p></p>"},{"location":"it/module-08/io-streams-api/#3529-selector-multiplexing-dellio-non-bloccante","title":"35.2.9 Selector: multiplexing dell\u2019I/O non bloccante","text":"<p>I <code>Selector</code> permettono a un singolo thread di monitorare pi\u00f9 channel.</p> <p>Sono la base dei server scalabili.</p> Componente Ruolo <code>Selector</code> Monitora pi\u00f9 channel <code>SelectionKey</code> Rappresenta registrazione e stato del channel <code>Interest set</code> Operazioni osservate (read, write, ecc.) <p></p>"},{"location":"it/module-08/io-streams-api/#35210-quando-usare-javanio","title":"35.2.10 Quando usare <code>java.nio</code>","text":"<p><code>NIO</code> \u00e8 adatto quando: - serve alta concorrenza - ti serve controllo fine sulla memoria - stai implementando protocolli o server</p> <p>Per operazioni semplici su file, spesso basta <code>java.nio.file.Files</code>.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#353-javaniofile-nio2-operazioni-su-file-e-directory-legacy-vs-modern","title":"35.3 <code>java.nio.file</code> (NIO.2) \u2014 Operazioni su file e directory (Legacy vs Modern)","text":"<p>Questa sezione si concentra sulle operazioni pratiche su file e directory.</p> <p>Confrontiamo gli approcci legacy (java.io.File + stream java.io) con quelli moderni NIO.2 (Path + Files).</p> <p>L\u2019obiettivo non \u00e8 solo conoscere i nomi dei metodi, ma capire: - cosa fa davvero ogni metodo - cosa ritorna e come segnala gli errori - quali trappole esistono (race condition, link, permessi, portabilit\u00e0) - quando un metodo di Files \u00e8 un miglioramento sicuro rispetto al vecchio approccio</p> <p></p>"},{"location":"it/module-08/io-streams-api/#3531-verifiche-di-esistenza-e-accessibilita","title":"35.3.1 Verifiche di esistenza e accessibilit\u00e0","text":"<p>Un\u2019operazione molto comune \u00e8 verificare se un file esiste e se \u00e8 accessibile (lettura, scrittura, esecuzione).</p> <p>Sia l\u2019API legacy (java.io.File) che NIO.2 (java.nio.file.Files) forniscono metodi per queste verifiche.</p> <p>\u00c8 per\u00f2 importante capire che queste verifiche sono volutamente imprecise in entrambe le API.</p> <p>Sono indizi best-effort, non garanzie affidabili.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#35311-api-legacy-file","title":"35.3.1.1 API legacy (File)","text":"<pre><code>File f = new File(\"data.txt\");\n\nboolean exists = f.exists();\nboolean canRead = f.canRead();\nboolean canWrite = f.canWrite();\nboolean canExec = f.canExecute();\n</code></pre> <p>Questi metodi ritornano boolean e non spiegano perch\u00e9 un\u2019operazione \u00e8 fallita.</p> <p>Per esempio, exists() pu\u00f2 ritornare false quando: - il file non esiste davvero - il file esiste ma l\u2019accesso \u00e8 negato - un link simbolico \u00e8 rotto - si verifica un errore I/O</p> <p>L\u2019API non consente di distinguere i casi.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#35312-api-moderna-files","title":"35.3.1.2 API moderna (Files)","text":"<pre><code>Path p = Path.of(\"data.txt\");\n\nboolean exists = Files.exists(p);\nboolean readable = Files.isReadable(p);\nboolean writable = Files.isWritable(p);\nboolean executable = Files.isExecutable(p);\n</code></pre> <p>Anche questi metodi ritornano boolean e nascondono la ragione dell'eventuale insuccesso.</p> <p>NIO.2 aggiunge un metodo esplicito per esprimere incertezza:</p> <pre><code>boolean notExists = Files.notExists(p);\n</code></pre> <p>Note</p> <p><code>exists()</code> e <code>notExists()</code> possono essere entrambi <code>false</code> quando lo stato non \u00e8 determinabile (per esempio per permessi).</p> <p>Questo non rende la verifica pi\u00f9 accurata: rende solo l\u2019incertezza esplicita.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#353121-consapevolezza-dei-link-simbolici-miglioramento-reale","title":"35.3.1.2.1 Consapevolezza dei link simbolici (miglioramento reale)","text":"<p>Un vero miglioramento di NIO.2 \u00e8 il controllo su come gestire i link simbolici:</p> <pre><code>Files.exists(p, LinkOption.NOFOLLOW_LINKS);\n</code></pre> <p>La classe File legacy non distingue in modo affidabile: - file mancante - link simbolico rotto - link verso target inaccessibile</p> <p>NIO.2 permette check link-aware e ispezione esplicita dei link.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#353122-pattern-duso-corretto-critico","title":"35.3.1.2.2 Pattern d\u2019uso corretto (critico)","text":"<p>Nessuna delle due API d\u00e0 diagnosi affidabili tramite boolean \u201cdi check\u201d.</p> <p>Il codice NIO.2 corretto non \u201ccontrolla prima\u201d.</p> <p>Invece tenta l\u2019operazione e gestisce l\u2019eccezione:</p> <pre><code>try {\n    Files.delete(p);\n} catch (NoSuchFileException e) {\n    // il file non esiste davvero\n} catch (AccessDeniedException e) {\n    // problema di permessi\n} catch (IOException e) {\n    // altro errore I/O\n}\n</code></pre> <p>Note</p> <p>Il vero vantaggio di NIO.2 \u00e8 la diagnostica tramite eccezioni durante le azioni, non check di esistenza pi\u00f9 \u201caccurati\u201d.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#353123-tabella-riassuntiva","title":"35.3.1.2.3 Tabella riassuntiva","text":"Obiettivo Legacy (File) Moderno (Files) Dettaglio chiave Verificare esistenza <code>exists()</code> <code>exists() / notExists()</code> notExists() pu\u00f2 essere false se lo stato non \u00e8 determinabile Verificare read/write <code>canRead() / canWrite()</code> <code>isReadable() / isWritable()</code> Files pu\u00f2 usare LinkOption.NOFOLLOW_LINKS quando supportato Dettagli errore Non disponibili Disponibili via eccezioni sulle azioni I check boolean non spiegano il motivo del fallimento"},{"location":"it/module-08/io-streams-api/#3532-creazione-di-file-e-directory","title":"35.3.2 Creazione di file e directory","text":"<p>La creazione \u00e8 una grande debolezza del File legacy.</p> <p>Nel legacy si usano spesso createNewFile() e mkdir/mkdirs(), che ritornano boolean e danno poche info diagnostiche.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#35321-api-legacy-file","title":"35.3.2.1 API legacy (File)","text":"<pre><code>File f = new File(\"a.txt\");\nboolean created = f.createNewFile(); // pu\u00f2 lanciare IOException\n\nFile dir = new File(\"dir\");\nboolean ok1 = dir.mkdir();\nboolean ok2 = new File(\"a/b/c\").mkdirs();\n</code></pre> <p><code>mkdir()</code> crea un solo livello; <code>mkdirs()</code> crea anche i parent.</p> <p>Entrambi ritornano false in caso di fallimento ma senza dire il perch\u00e9.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#35322-api-moderna-files","title":"35.3.2.2 API moderna (Files)","text":"<pre><code>Path file = Path.of(\"a.txt\");\nFiles.createFile(file);\n\nPath dir1 = Path.of(\"dir\");\nFiles.createDirectory(dir1);\n\nPath dirDeep = Path.of(\"a/b/c\");\nFiles.createDirectories(dirDeep);\n</code></pre> <p>Note</p> <p><code>Files.createFile</code> lancia <code>FileAlreadyExistsException</code> se il file esiste.</p> <p>Spesso \u00e8 preferibile ai check boolean perch\u00e9 \u00e8 race-safe.</p> Obiettivo Legacy (File) Moderno (Files) Dettaglio chiave Creare file <code>createNewFile()</code> <code>createFile()</code> NIO lancia FileAlreadyExistsException se esiste Creare directory <code>mkdir()</code> <code>createDirectory()</code> NIO lancia eccezioni dettagliate Creare parent <code>mkdirs()</code> <code>createDirectories()</code> Atomicit\u00e0 non garantita per directory profonde <p></p>"},{"location":"it/module-08/io-streams-api/#3533-eliminazione-di-file-e-directory","title":"35.3.3 Eliminazione di file e directory","text":"<p>La semantica di delete differisce molto tra legacy e NIO.2.</p> <p>Il legacy <code>delete()</code> ritorna boolean; NIO.2 offre metodi che lanciano eccezioni significative.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#35331-api-legacy-file","title":"35.3.3.1 API legacy (File)","text":"<pre><code>File f = new File(\"a.txt\");\nboolean deleted = f.delete();\n</code></pre> <p>Se fallisce (permessi, file mancante, directory non vuota), <code>delete()</code> spesso ritorna false senza dettagli.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#35332-api-moderna-files","title":"35.3.3.2 API moderna (Files)","text":"<pre><code>Files.delete(Path.of(\"a.txt\"));\n</code></pre> <p>Per \u201ccancella se presente\u201d, usa <code>deleteIfExists()</code>.</p> <pre><code>Files.deleteIfExists(Path.of(\"a.txt\"));\n</code></pre> Obiettivo Legacy (File) Moderno (Files) Dettaglio chiave Eliminare <code>delete()</code> <code>delete()</code> <code>Files.delete()</code> lancia eccezione con la causa del fallimento Eliminare se esiste <code>exists() + delete()</code> <code>deleteIfExists()</code> Evita race TOCTOU (check-then-act) <p></p>"},{"location":"it/module-08/io-streams-api/#3534-copia-di-file-e-directory","title":"35.3.4 Copia di file e directory","text":"<p>Nel legacy, copiare richiede tipicamente lettura/scrittura manuale via stream.</p> <p>NIO.2 fornisce operazioni di copia di alto livello con opzioni.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#35341-tecnica-legacy-stream-manuali","title":"35.3.4.1 Tecnica legacy (stream manuali)","text":"<pre><code>try (InputStream in = new FileInputStream(\"src.bin\"); OutputStream out = new FileOutputStream(\"dst.bin\")) {\n\n    byte[] buf = new byte[8192];\n    int n;\n    while ((n = in.read(buf)) != -1) {\n        out.write(buf, 0, n);\n    }\n}\n</code></pre> <p>\u00c8 verboso ed \u00e8 facile sbagliare (mancanza di buffering, chiusura, ecc.).</p> <p></p>"},{"location":"it/module-08/io-streams-api/#35342-api-moderna-filescopy","title":"35.3.4.2 API moderna (Files.copy)","text":"<pre><code>Files.copy(Path.of(\"src.bin\"), Path.of(\"dst.bin\"));\n</code></pre> <p>Il comportamento \u00e8 controllabile con opzioni.</p> <pre><code>Files.copy(\n    Path.of(\"src.bin\"),\n    Path.of(\"dst.bin\"),\n    StandardCopyOption.REPLACE_EXISTING,\n    StandardCopyOption.COPY_ATTRIBUTES\n);\n</code></pre> <p>Note</p> <p><code>Files.copy</code> lancia FileAlreadyExistsException per default.</p> <p>Usa <code>REPLACE_EXISTING</code> quando l\u2019overwrite \u00e8 intenzionale.</p> Obiettivo Approccio legacy Moderno (Files) Dettaglio chiave Copiare file Loop stream manuale <code>Files.copy(Path, Path, \u2026)</code> Opzioni: <code>REPLACE_EXISTING</code>, <code>COPY_ATTRIBUTES</code> Copiare stream InputStream/OutputStream <code>Files.copy(InputStream, Path, \u2026)</code> Utile per upload/download e piping Copiare directory Ricorsione manuale <code>walkFileTree + Files.copy</code> Nessun one-liner per copy completa di albero <p></p>"},{"location":"it/module-08/io-streams-api/#3535-spostamento-e-rinomina","title":"35.3.5 Spostamento e rinomina","text":"<p>La rinomina legacy usa spesso <code>File.renameTo()</code>, notoriamente inaffidabile e dipendente dalla piattaforma.</p> <p>NIO.2 fornisce <code>Files.move()</code> con semantica precisa e opzioni.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#35351-api-legacy","title":"35.3.5.1 API legacy","text":"<pre><code>boolean ok = new File(\"a.txt\").renameTo(new File(\"b.txt\"));\n</code></pre> <p><code>renameTo()</code> ritorna false senza spiegare, e pu\u00f2 fallire tra filesystem.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#35352-api-moderna","title":"35.3.5.2 API moderna","text":"<pre><code>Files.move(Path.of(\"a.txt\"), Path.of(\"b.txt\"));\n</code></pre> <p>Le opzioni rendono il comportamento esplicito.</p> <pre><code>Files.move(\n    Path.of(\"a.txt\"),\n    Path.of(\"b.txt\"),\n    StandardCopyOption.REPLACE_EXISTING,\n    StandardCopyOption.ATOMIC_MOVE\n);\n</code></pre> <p>Note</p> <p>ATOMIC_MOVE \u00e8 garantito solo se lo spostamento avviene nello stesso filesystem. Altrimenti viene lanciata un\u2019eccezione.</p> Obiettivo Legacy (File) Moderno (Files) Dettaglio chiave Rinomina / move <code>renameTo()</code> <code>move()</code> Exceptions + opzioni esplicite Move atomico Non supportato <code>move(\u2026, ATOMIC_MOVE)</code> Garantito solo stesso filesystem Replace existing Non esplicito <code>REPLACE_EXISTING</code> Intenzione di overwrite esplicita <p></p>"},{"location":"it/module-08/io-streams-api/#3536-lettura-e-scrittura-di-testo-e-byte-miglioramenti-di-files","title":"35.3.6 Lettura e scrittura di testo e byte (miglioramenti di Files)","text":"<p>Un grande miglioramento di NIO.2 \u00e8 la classe utility <code>Files</code>, con metodi di alto livello per lettura/scrittura comuni.</p> <p>Riduce boilerplate e migliora la correttezza.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#35361-letturascrittura-testo-legacy","title":"35.3.6.1 Lettura/scrittura testo legacy","text":"<pre><code>try (BufferedReader r = new BufferedReader(new FileReader(\"file.txt\"))) {\n    String line = r.readLine();\n}\n</code></pre> <pre><code>try (BufferedWriter w = new BufferedWriter(new FileWriter(\"file.txt\"))) {\n    w.write(\"hello\");\n}\n</code></pre> <p>Queste classi legacy usano spesso il charset di default se non si utilizza un bridge esplicito.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#35362-letturascrittura-testo-moderna","title":"35.3.6.2 Lettura/scrittura testo moderna","text":"<pre><code>List&lt;String&gt; lines = Files.readAllLines(Path.of(\"file.txt\"), StandardCharsets.UTF_8);\nFiles.write(Path.of(\"file.txt\"), lines, StandardCharsets.UTF_8);\n\nFiles.lines(Path.of(\"file.txt\")).forEach(System.out::println);\n\nString string = Files.readString(Path.of(\"file.txt\"));\nFiles.writeString(Path.of(\"file.txt\"), string);\n</code></pre>"},{"location":"it/module-08/io-streams-api/#35363-letturascrittura-binaria-moderna","title":"35.3.6.3 Lettura/scrittura binaria moderna","text":"<pre><code>byte[] data = Files.readAllBytes(Path.of(\"data.bin\"));\nFiles.write(Path.of(\"out.bin\"), data);\n</code></pre> <p>Important</p> <p><code>readAllBytes</code> e <code>readAllLines</code> caricano tutto in memoria.</p> <p>Usa <code>Files.lines()</code> (lazy) o, per file grandi, preferisci API streaming come newBufferedReader/newInputStream.</p> Task Metodo legacy Metodo NIO.2 Files Dettaglio chiave Leggere tutti i byte Loop InputStream manuale <code>readAllBytes()</code> Carica tutto in memoria Leggere tutte le righe Loop BufferedReader <code>readAllLines()</code> Carica tutto in memoria Leggere righe lazy Loop BufferedReader <code>lines()</code> Lazy, stream da chiudere Scrivere byte OutputStream <code>write(Path, byte[])</code> Conciso Scrivere righe Loop BufferedWriter <code>write(Path, Iterable, \u2026)</code> Charset specificabile Append testo FileWriter(true) <code>write(\u2026, APPEND)</code> Opzioni esplicite <p></p>"},{"location":"it/module-08/io-streams-api/#3537-newinputstreamnewoutputstream-e-newbufferedreadernewbufferedwriter","title":"35.3.7 newInputStream/newOutputStream e newBufferedReader/newBufferedWriter","text":"<p>Queste <code>factory method</code> creano stream/reader a partire da un Path.</p> <p>Sono il bridge consigliato tra streaming classico e gestione Path NIO.2.</p> <pre><code>try (InputStream in = Files.newInputStream(Path.of(\"a.bin\"))) { }\ntry (OutputStream out = Files.newOutputStream(Path.of(\"b.bin\"))) { }\n</code></pre> <pre><code>try (BufferedReader r = Files.newBufferedReader(Path.of(\"t.txt\"), StandardCharsets.UTF_8)) { }\ntry (BufferedWriter w = Files.newBufferedWriter(Path.of(\"t.txt\"), StandardCharsets.UTF_8)) { }\n</code></pre> <p></p>"},{"location":"it/module-08/io-streams-api/#3538-listing-directory-e-attraversamento-di-alberi","title":"35.3.8 Listing directory e attraversamento di alberi","text":"<p>Nel legacy, il listing directory si basa su <code>File.list()</code> e <code>File.listFiles()</code>.</p> <p>Questi metodi ritornano array e offrono poca diagnostica.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#35381-listing-legacy","title":"35.3.8.1 Listing legacy","text":"<pre><code>File dir = new File(\".\");\nFile[] children = dir.listFiles();\n</code></pre> <p>NIO.2 offre pi\u00f9 approcci a seconda del bisogno.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#35382-listing-moderno-directorystream","title":"35.3.8.2 Listing moderno (DirectoryStream)","text":"<pre><code>try (DirectoryStream&lt;Path&gt; ds = Files.newDirectoryStream(Path.of(\".\"))) {\n    for (Path p : ds) {\n        System.out.println(p);\n    }\n}\n</code></pre>"},{"location":"it/module-08/io-streams-api/#35383-walking-moderno-fileswalk","title":"35.3.8.3 Walking moderno (Files.walk)","text":"<pre><code>Files.walk(Path.of(\".\"))\n    .filter(Files::isRegularFile)\n    .forEach(System.out::println);\n</code></pre> <p>Note</p> <p><code>Files.walk</code> restituisce uno Stream che va chiuso. Usa <code>try-with-resources</code>.</p> <pre><code>try (Stream&lt;Path&gt; s = Files.walk(Path.of(\".\"))) {\n    s.forEach(System.out::println);\n}\n</code></pre> <p></p>"},{"location":"it/module-08/io-streams-api/#35384-traversal-con-filevisitor","title":"35.3.8.4 Traversal con FileVisitor","text":"<p>Per controllo completo (skip subtree, gestione errori, follow link), usa <code>walkFileTree + FileVisitor</code>.</p> <pre><code>Files.walkFileTree(Path.of(\".\"), new SimpleFileVisitor&lt;&gt;() {\n    @Override\n    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {\n        System.out.println(file);\n        return FileVisitResult.CONTINUE;\n    }\n});\n</code></pre> Obiettivo Legacy Moderno Dettaglio chiave Listing dir <code>list()</code> / <code>listFiles()</code> <code>newDirectoryStream()</code> Lazy, va chiuso Walk tree (semplice) Ricorsione manuale <code>walk()</code> (Stream) Stream va chiuso Walk tree (controllo) Ricorsione manuale <code>walkFileTree()</code> Controllo fine e gestione errori <p></p>"},{"location":"it/module-08/io-streams-api/#3539-ricerca-e-filtro","title":"35.3.9 Ricerca e filtro","text":"<p>La ricerca \u00e8 tipicamente <code>traversal + filtro</code>.</p> <p>NIO.2 offre building block: glob pattern, stream, visitor.</p> <pre><code>try (DirectoryStream&lt;Path&gt; ds =\n    Files.newDirectoryStream(Path.of(\".\"), \"*.txt\")) {\n    for (Path p : ds) {\n        System.out.println(p);\n    }\n}\n</code></pre> <pre><code>try (Stream&lt;Path&gt; s = Files.find(Path.of(\".\"), 10,\n    (p, a) -&gt; a.isRegularFile() &amp;&amp; p.toString().endsWith(\".log\"))) {\n    s.forEach(System.out::println);\n}\n</code></pre> <p></p>"},{"location":"it/module-08/io-streams-api/#35310-attributi-lettura-scrittura-e-view","title":"35.3.10 Attributi: lettura, scrittura e view","text":"<p>Il File legacy espone pochi attributi (size, lastModified).</p> <p>NIO.2 supporta metadata ricchi tramite attribute view.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#353101-attributi-legacy","title":"35.3.10.1 Attributi legacy","text":"<pre><code>long size = new File(\"a.txt\").length();\nlong lm = new File(\"a.txt\").lastModified();\n</code></pre>"},{"location":"it/module-08/io-streams-api/#353102-attributi-moderni","title":"35.3.10.2 Attributi moderni","text":"<pre><code>BasicFileAttributes a =\n    Files.readAttributes(Path.of(\"a.txt\"), BasicFileAttributes.class);\n\nlong size = a.size();\nFileTime modified = a.lastModifiedTime();\n</code></pre> <p>Accesso tramite nomi string-based:</p> <pre><code>Object v = Files.getAttribute(Path.of(\"a.txt\"), \"basic:size\");\nFiles.setAttribute(Path.of(\"a.txt\"), \"basic:lastModifiedTime\", FileTime.fromMillis(0));\n</code></pre> <p>Note</p> <p>Le attribute view dipendono dal filesystem.</p> <p>Attributi non supportati generano eccezioni.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#35311-link-simbolici-e-follow-dei-link","title":"35.3.11 Link simbolici e follow dei link","text":"<p>NIO.2 pu\u00f2 rilevare e leggere link simbolici in modo esplicito.</p> <pre><code>Path link = Path.of(\"mylink\");\nboolean isLink = Files.isSymbolicLink(link);\n\nif (isLink) {\n    Path target = Files.readSymbolicLink(link);\n}\n</code></pre> <p>Molti metodi seguono i link di default.</p> <p>Per evitarlo, passa <code>LinkOption.NOFOLLOW_LINKS</code> quando supportato.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#35312-sintesi-perche-files-e-un-miglioramento","title":"35.3.12 Sintesi: perch\u00e9 Files \u00e8 un miglioramento","text":"<p>La classe utility <code>Files</code> migliora la programmazione filesystem perch\u00e9: - riduce boilerplate (copy/move/read/write) - fornisce opzioni esplicite (overwrite, atomic move, follow links) - offre metadata pi\u00f9 ricchi (attributes/views) - supporta traversal e ricerca scalabili</p> <p>Le API legacy restano soprattutto per compatibilit\u00e0 o quando richieste da librerie legacy.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#354-serializzazione-object-stream-compatibilita-e-trappole","title":"35.4 Serializzazione \u2014 Object stream, compatibilit\u00e0 e trappole","text":"<p>La serializzazione \u00e8 il processo di convertire un grafo di oggetti in uno stream di byte per memorizzarlo o trasmetterlo, e ricostruirlo successivamente.</p> <p>In Java, la serializzazione classica \u00e8 implementata da <code>java.io.ObjectOutputStream</code> e <code>java.io.ObjectInputStream</code>.</p> <p>Questo argomento \u00e8 importante perch\u00e9 combina: - stream I/O e grafi di oggetti - versioning e backward compatibility - considerazioni di sicurezza e pattern d\u2019uso sicuri - regole del linguaggio (<code>transient</code>, static, <code>serialVersionUID</code>)</p> <p></p>"},{"location":"it/module-08/io-streams-api/#3541-cosa-fa-la-serializzazione-e-cosa-non-fa","title":"35.4.1 Cosa fa la serializzazione (e cosa non fa)","text":"<p>Quando un oggetto \u00e8 serializzato, Java scrive informazioni sufficienti a ricostruirlo: - nome della classe - serialVersionUID - valori dei campi di istanza serializzabili - riferimenti tra oggetti (identit\u00e0)</p> <p>La serializzazione non include automaticamente: - campi static (stato di classe) - campi transient (esclusi esplicitamente) - oggetti referenziati non serializzabili (a meno di gestione speciale)</p> <p></p>"},{"location":"it/module-08/io-streams-api/#3542-le-due-principali-marker-interface","title":"35.4.2 Le due principali marker interface","text":"<p>La serializzazione Java \u00e8 abilitata implementando una di queste interfacce.</p> Interfaccia Significato Livello di controllo <code>Serializable</code> Marker opt-in, meccanismo di default Medio (hook possibili) <code>Externalizable</code> Richiede implementazione manuale read/write Alto (controllo totale sul formato) <p>Note</p> <p><code>Serializable</code> non ha metodi: \u00e8 una marker interface.</p> <p><code>Externalizable</code> estende Serializable e aggiunge readExternal/writeExternal.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#3543-esempio-base-scrivere-e-leggere-un-oggetto","title":"35.4.3 Esempio base: scrivere e leggere un oggetto","text":"<p>Pattern minimo usato in pratica.</p> <pre><code>import java.io.*;\n\nclass Person implements Serializable {\n\n    private String name;\n    private int age;\n\n    Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n}\n\npublic class Demo {\n\n    public static void main(String[] args) throws Exception {\n\n        Person p = new Person(\"Alice\", 30);\n\n        try (ObjectOutputStream out =\n                 new ObjectOutputStream(new FileOutputStream(\"p.bin\"))) {\n            out.writeObject(p);\n        }\n\n        try (ObjectInputStream in =\n                 new ObjectInputStream(new FileInputStream(\"p.bin\"))) {\n            Person copy = (Person) in.readObject();\n        }\n    }\n\n}\n</code></pre> <p>Note</p> <p><code>readObject()</code> ritorna Object: serve cast. <code>readObject()</code> pu\u00f2 lanciare ClassNotFoundException.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#3544-grafi-di-oggetti-riferimenti-e-identita","title":"35.4.4 Grafi di oggetti, riferimenti e identit\u00e0","text":"<p>La serializzazione preserva l\u2019identit\u00e0 degli oggetti all\u2019interno dello stesso stream.</p> <p>Se lo stesso riferimento compare pi\u00f9 volte, Java lo scrive una sola volta e poi scrive back-reference.</p> <pre><code>Person p = new Person(\"Bob\", 40);\nObject[] arr = { p, p }; // stesso riferimento due volte\n\nout.writeObject(arr);\nObject[] restored = (Object[]) in.readObject();\n\n// restored[0] e restored[1] puntano allo stesso oggetto\n</code></pre> <p>Note</p> <p>Questo previene ricorsione infinita in grafi ciclici.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#3545-serialversionuid-la-chiave-di-versioning","title":"35.4.5 <code>serialVersionUID</code>: la chiave di versioning","text":"<p><code>serialVersionUID</code> \u00e8 un identificatore <code>long</code> usato per verificare la compatibilit\u00e0 tra stream serializzato e definizione della classe.</p> <p>Se l\u2019UID differisce, la deserializzazione tipicamente fallisce con InvalidClassException.</p> <p>Se non dichiari <code>serialVersionUID</code>, la JVM ne calcola uno dalla struttura della classe: piccole modifiche possono comprometterlo.</p> <pre><code>class Person implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private String name;\n    private int age;\n}\n</code></pre> Tipo di modifica Impatto compatibilit\u00e0 (default) Aggiungere un campo Spesso compatibile (campo nuovo con default) Rimuovere un campo Spesso compatibile (campo mancante ignorato) Cambiare tipo campo Spesso incompatibile Cambiare nome/pacchetto Incompatibile Cambiare serialVersionUID Incompatibile <p>Note</p> <p>Dichiarare un serialVersionUID stabile \u00e8 il modo standard per controllare la compatibilit\u00e0.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#3546-campi-transient-e-static","title":"35.4.6 Campi <code>transient</code> e <code>static</code>","text":"<p>I campi <code>transient</code> sono esclusi dalla serializzazione.</p> <p>Alla deserializzazione, i campi transient assumono valori di default (0, false, null) salvo ripristino manuale.</p> <p>I campi <code>static</code> appartengono alla classe, non all\u2019istanza, quindi non vengono serializzati.</p> <pre><code>class Session implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    static int counter = 0;      // non serializzato\n    transient String token;      // non serializzato\n    String user;                 // serializzato\n}\n</code></pre> <p>Note</p> <p>Se un transient serve dopo la deserializzazione, va ricalcolato o ripristinato manualmente.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#3547-campi-non-serializzabili-e-notserializableexception","title":"35.4.7 Campi non serializzabili e NotSerializableException","text":"<p>Se un oggetto contiene un campo il cui tipo non \u00e8 serializzabile, la serializzazione fallisce con NotSerializableException.</p> <pre><code>class Holder implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private Thread t; // Thread non \u00e8 serializzabile\n}\n</code></pre> <p>Soluzioni tipiche: - marcare il campo transient - sostituirlo con una rappresentazione serializzabile - usare hook di serializzazione custom</p> <p></p>"},{"location":"it/module-08/io-streams-api/#3548-costruttori-e-serializzazione","title":"35.4.8 Costruttori e serializzazione","text":"<p>Il comportamento dei costruttori in deserializzazione \u00e8 fonte frequente di confusione.</p> <p>Java ripristina lo stato principalmente dal byte stream, non eseguendo i costruttori.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#35481-regola-i-costruttori-delle-classi-serializable-non-vengono-chiamati","title":"35.4.8.1 Regola: i costruttori delle classi Serializable NON vengono chiamati","text":"<p>Durante la deserializzazione di una classe Serializable, i suoi costruttori NON vengono eseguiti.</p> <p>L\u2019istanza viene creata senza chiamare quei costruttori e i campi vengono iniettati dallo stream.</p> <p>Note</p> <p>Per questo i costruttori delle classi Serializable non devono contenere logica di inizializzazione essenziale: non verrebbe eseguita in deserializzazione.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#35482-regola-di-ereditarieta-viene-chiamata-la-prima-superclass-non-serializable","title":"35.4.8.2 Regola di ereditariet\u00e0: viene chiamata la prima superclass non-Serializable","text":"<p>Se una classe Serializable ha una superclasse non Serializable, la deserializzazione deve inizializzare quella parte.</p> <p>Quindi Java chiama il costruttore no-arg della prima superclasse non-Serializable.</p> <p>Implicazioni: - la superclasse non Serializable deve avere un no-arg accessibile - le sottoclassi Serializable saltano i costruttori, le superclassi non Serializable no</p> <p></p>"},{"location":"it/module-08/io-streams-api/#35483-tabella-quali-costruttori-vengono-eseguiti","title":"35.4.8.3 Tabella: quali costruttori vengono eseguiti","text":"Tipo di classe Costruttore chiamato in deserializzazione Classe Serializable No Sottoclasse Serializable No Prima superclasse non Serializable S\u00ec (no-arg) Classe Externalizable S\u00ec (richiesto public no-arg)"},{"location":"it/module-08/io-streams-api/#35484-esempio-quali-costruttori-vengono-chiamati","title":"35.4.8.4 Esempio: quali costruttori vengono chiamati","text":"<pre><code>import java.io.*;\n\nclass A {\n    A() {\n        System.out.println(\"A constructor\");\n    }\n}\n\nclass B extends A implements Serializable {\n    private static final long serialVersionUID = 1L;\n    B() {\n        System.out.println(\"B constructor\");\n    }\n}\n\nclass C extends B {\n    private static final long serialVersionUID = 1L;\n    C() {\n        System.out.println(\"C constructor\");\n    }\n}\n\npublic class Demo {\n    public static void main(String[] args) throws Exception {\n\n        C obj = new C();\n\n        try (ObjectOutputStream out =\n                 new ObjectOutputStream(new FileOutputStream(\"c.bin\"))) {\n            out.writeObject(obj);\n        }\n\n        try (ObjectInputStream in =\n                 new ObjectInputStream(new FileInputStream(\"c.bin\"))) {\n            Object restored = in.readObject();\n        }\n    }\n}\n</code></pre> <p>Output atteso e spiegazione Durante la costruzione normale (new C()):</p> <pre><code>A constructor\nB constructor\nC constructor\n</code></pre> <p>Durante la deserializzazione (readObject):</p> <pre><code>A constructor\n</code></pre> <p>Spiegazione: - C \u00e8 Serializable \u2192 C() non viene chiamato - B \u00e8 Serializable \u2192 B() non viene chiamato - A non \u00e8 Serializable \u2192 A() viene chiamato (no-arg) - I campi di B e C vengono ripristinati dallo stream</p> <p>Note</p> <p>Se la prima superclasse non-Serializable non ha un no-arg accessibile, la deserializzazione fallisce.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#3549-hook-di-serializzazione-custom-writeobject-e-readobject","title":"35.4.9 Hook di serializzazione custom: <code>writeObject</code> e <code>readObject</code>","text":"<p>Gli hook custom servono quando la serializzazione di default non basta (stato transient, campi derivati, cifratura, validazione, compatibilit\u00e0).</p> <p>Sono avanzati ma importanti per una deserializzazione corretta.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#35491-perche-esiste-la-serializzazione-custom","title":"35.4.9.1 Perch\u00e9 esiste la serializzazione custom","text":"<p>Di default, Java serializza automaticamente tutti i campi di istanza non static e non transient.</p> <p>\u00c8 comodo, ma non copre esigenze frequenti.</p> <p>Motivi tipici: - un campo non va salvato direttamente (dati sensibili) - un campo \u00e8 derivato/cache e va ricalcolato - serve validazione in lettura (rifiutare stato invalido) - serve logica di backward/forward compatibility - un oggetto referenziato non \u00e8 Serializable e va gestito</p> <p></p>"},{"location":"it/module-08/io-streams-api/#35492-cosa-sono-davvero-writeobject-e-readobject","title":"35.4.9.2 Cosa sono davvero <code>writeObject</code> e <code>readObject</code>","text":"<p>Per personalizzare serializzazione/deserializzazione, una classe pu\u00f2 definire due metodi privati speciali chiamati <code>writeObject</code> e <code>readObject</code>.</p> <p>Non sono override di metodi di interfacce o superclassi: non fanno parte del normale flusso del programma.</p> <p>Non li chiami mai tu.</p> <p>Il framework di serializzazione (ObjectOutputStream/ObjectInputStream) li individua tramite reflection, solo se nome e firma sono esatti, e li invoca automaticamente.</p> <p>Se non esistono (o la firma \u00e8 sbagliata), viene usata la serializzazione di default.</p> <p>Note</p> <p>Se la firma \u00e8 errata (visibilit\u00e0, parametri, return type, eccezioni), il framework non la riconosce e torna silenziosamente al default.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#35493-firme-richieste-esatte","title":"35.4.9.3 Firme richieste (esatte)","text":"<pre><code>private void writeObject(ObjectOutputStream out) throws IOException\n\nprivate void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException\n</code></pre> <p>Vincoli: - devono essere private - devono ritornare void - i tipi dei parametri devono combaciare esattamente - le eccezioni devono essere compatibili</p> <p></p>"},{"location":"it/module-08/io-streams-api/#35494-cosa-succede-in-serializzazione-step-by-step","title":"35.4.9.4 Cosa succede in serializzazione: step-by-step","text":"<p>Quando serializzi:</p> <pre><code>out.writeObject(obj);\n</code></pre> <p>Meccanismo: - verifica Serializable - cerca un private writeObject(ObjectOutputStream) - se assente \u2192 default serialization - se presente \u2192 viene chiamato il tuo writeObject</p> <p>Punto chiave: dentro writeObject, Java non scrive automaticamente i campi \u201cnormali\u201d se non lo chiedi. Per questo esiste:</p> <pre><code>out.defaultWriteObject();\n</code></pre> <p><code>defaultWriteObject()</code> significa: \u201cserializza i campi serializzabili normali col meccanismo standard\u201d.</p> <p>Poi puoi scrivere dati extra come vuoi.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#35495-pattern-tipico-e-regola-dellordine-writeread","title":"35.4.9.5 Pattern tipico e regola dell\u2019ordine write/read","text":"<p>Pattern tipico: usare default e poi estendere.</p> <p>L\u2019ordine di lettura deve coincidere con l\u2019ordine di scrittura.</p> <pre><code>private void writeObject(ObjectOutputStream out) throws IOException {\n    out.defaultWriteObject(); // scrive i campi normali\n    out.writeInt(42);         // scrive dati extra\n}\n\nprivate void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n    in.defaultReadObject();   // legge i campi normali\n    int x = in.readInt();     // legge i dati extra nello stesso ordine\n}\n</code></pre> <p>Note</p> <p>Se scrivi valori extra (int/string/etc.), devi leggerli nella stessa sequenza, altrimenti la deserializzazione fallisce o corrompe lo stato.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#35410-esempio-duso-ripristinare-un-campo-derivato-transient","title":"35.4.10 Esempio d\u2019uso: ripristinare un campo derivato transient","text":"<p>Caso tipico: ricalcolare un valore cached transient dopo deserializzazione.</p> <pre><code>class User implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private String firstName;\n    private String lastName;\n\n    private transient String fullName;\n\n    User(String firstName, String lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n        this.fullName = firstName + \" \" + lastName;\n    }\n\n    private void readObject(ObjectInputStream in)\n            throws IOException, ClassNotFoundException {\n\n        in.defaultReadObject();              // ripristina firstName e lastName\n        fullName = firstName + \" \" + lastName; // ricalcola il transient\n    }\n}\n</code></pre> <p></p>"},{"location":"it/module-08/io-streams-api/#35411-externalizable-controllo-totale-e-responsabilita-totale","title":"35.4.11 Externalizable: controllo totale (e responsabilit\u00e0 totale)","text":"<p>Externalizable richiede di definire manualmente come scrivere e leggere l\u2019oggetto.</p> <p>Richiede anche un costruttore pubblico no-arg, perch\u00e9 la deserializzazione istanzia prima l\u2019oggetto.</p> <pre><code>import java.io.*;\n\nclass Point implements Externalizable {\n    int x;\n    int y;\n\n    public Point() { } // richiesto\n\n    public Point(int x, int y) { this.x = x; this.y = y; }\n\n    @Override\n    public void writeExternal(ObjectOutput out) throws IOException {\n        out.writeInt(x);\n        out.writeInt(y);\n    }\n\n    @Override\n    public void readExternal(ObjectInput in) throws IOException {\n        x = in.readInt();\n        y = in.readInt();\n    }\n}\n</code></pre> <p>Note</p> <p>Con Externalizable controlli il formato. Se lo cambi, devi gestire tu la backward compatibility.</p> <p></p>"},{"location":"it/module-08/io-streams-api/#35412-considerazioni-di-sicurezza-su-readobject","title":"35.4.12 Considerazioni di sicurezza su <code>readObject()</code>","text":"<p>La deserializzazione di dati non fidati \u00e8 pericolosa perch\u00e9 pu\u00f2 eseguire codice indirettamente tramite: - hook readObject - logica di inizializzazione - gadget chain in librerie</p> <p>Linee guida: - non deserializzare mai byte non fidati senza un motivo forte - preferire formati sicuri (JSON, protobuf) per input esterni - se obbligato, usare object filter e validazione rigorosa</p> <p></p>"},{"location":"it/module-08/io-streams-api/#35413-trappole-comuni-e-consigli-pratici","title":"35.4.13 Trappole comuni e consigli pratici","text":"<ul> <li>Serializable \u00e8 solo marker: non richiede metodi</li> <li><code>readObject</code> ritorna Object e pu\u00f2 lanciare ClassNotFoundException</li> <li>i campi <code>static</code> non vengono mai serializzati</li> <li>i campi <code>transient</code> tornano a default salvo ripristino</li> <li>senza <code>serialVersionUID</code> la compatibilit\u00e0 pu\u00f2 rompersi \u201ca sorpresa\u201d</li> <li>Externalizable richiede public no-arg constructor</li> <li>NotSerializableException quando un campo referenziato non \u00e8 serializzabile</li> </ul>"},{"location":"it/module-08/io-streams-api/#35414-quando-usare-o-evitare-la-serializzazione-java","title":"35.4.14 Quando usare (o evitare) la serializzazione Java","text":"<p>Usa la serializzazione classica soprattutto per: - persistenza locale di breve durata con versioni controllate - caching in memoria quando entrambe le estremit\u00e0 sono fidate - sistemi legacy che gi\u00e0 la usano</p> <p>Evitala per: - protocolli di rete pubblici - storage a lungo termine con schema evolutivo - input non fidati</p>"},{"location":"it/module-08/io-streams/","title":"34. Stream I/O in Java","text":""},{"location":"it/module-08/io-streams/#indice","title":"Indice","text":"<ul> <li>34.1 Che cos\u2019\u00e8 uno Stream I/O in Java</li> <li>34.2 Stream di Byte vs Stream di Caratteri<ul> <li>34.2.1 Stream di Byte</li> <li>34.2.2 Stream di Caratteri</li> <li>34.2.3 Tabella di riepilogo</li> </ul> </li> <li>34.3 Stream di Basso Livello vs Stream di Alto Livello<ul> <li>34.3.1 Stream di Basso Livello Node-Streams</li> <li>34.3.2 Stream comuni di Basso Livello</li> <li>34.3.3 Stream di Alto Livello Filter--Processing-Streams</li> <li>34.3.4 Stream comuni di Alto Livello</li> <li>34.3.5 Regole di chaining degli stream e errori comuni<ul> <li>34.3.5.1 Regola fondamentale di chaining</li> <li>34.3.5.2 Incompatibilit\u00e0 tra stream di byte e stream di caratteri</li> <li>34.3.5.3 Chaining non valido errore-di-compilazione</li> <li>34.3.5.4 Bridging da stream di byte a stream di caratteri</li> <li>34.3.5.5 Pattern corretto di conversione</li> <li>34.3.5.6 Regole di ordinamento nelle catene di stream</li> <li>34.3.5.7 Ordine logico corretto</li> <li>34.3.5.8 Regola di gestione delle risorse</li> <li>34.3.5.9 Trappole comuni</li> </ul> </li> </ul> </li> <li>34.4 Classi base principali di javaio e metodi chiave<ul> <li>34.4.1 InputStream<ul> <li>34.4.1.1 Metodi chiave</li> <li>34.4.1.2 Esempio tipico di utilizzo</li> </ul> </li> <li>34.4.2 OutputStream<ul> <li>34.4.2.1 Metodi chiave</li> <li>34.4.2.2 Esempio tipico di utilizzo</li> </ul> </li> <li>34.4.3 Reader e Writer<ul> <li>34.4.3.1 Gestione del charset</li> </ul> </li> </ul> </li> <li>34.5 Stream bufferizzati e prestazioni<ul> <li>34.5.1 Perch\u00e9 il buffering conta</li> <li>34.5.2 Come funziona la lettura non bufferizzata</li> <li>34.5.3 Come funziona BufferedInputStream</li> <li>34.5.4 Esempio di output bufferizzato</li> <li>34.5.5 BufferedReader vs Reader</li> <li>34.5.6 Esempio di BufferedWriter</li> </ul> </li> <li>34.6 java io vs java nio e java nio file<ul> <li>34.6.1 Differenze concettuali</li> <li>34.6.2 java-nio I/O file moderno</li> </ul> </li> <li>34.7 Quando usare quale API</li> <li>34.8 Trappole comuni e suggerimenti</li> </ul> <p>Questo capitolo fornisce una spiegazione dettagliata degli <code>stream I/O in Java</code>.</p> <p>Copre gli stream classici java.io, li mette a confronto con java.nio / java.nio.file, e spiega principi di progettazione, API, casi limite e distinzioni rilevanti.</p> <p></p>"},{"location":"it/module-08/io-streams/#341-che-cose-uno-stream-io-in-java","title":"34.1 Che cos\u2019\u00e8 uno Stream I/O in Java?","text":"<p>Uno <code>stream I/O</code> rappresenta un flusso di dati tra un programma Java e una sorgente o destinazione esterna.</p> <p>I dati scorrono in modo sequenziale, come acqua in un tubo.</p> <ul> <li>Uno stream non \u00e8 una struttura dati; non memorizza dati in modo permanente</li> <li>Gli stream sono unidirezionali (input O output)</li> <li>Gli stream astraggono la sorgente sottostante (file, rete, memoria, dispositivo)</li> <li>Gli stream operano in modo bloccante, sincrono (I/O classico)</li> </ul> <p>In Java, gli stream sono organizzati attorno a due dimensioni principali:</p> <ul> <li><code>Direzione</code>: Input vs Output</li> <li><code>Tipo di dato</code>: Byte vs Carattere</li> </ul> <p></p>"},{"location":"it/module-08/io-streams/#342-stream-di-byte-vs-stream-di-caratteri","title":"34.2 Stream di Byte vs Stream di Caratteri","text":"<p>Java distingue gli stream in base all\u2019unit\u00e0 di dato che elaborano.</p> <p></p>"},{"location":"it/module-08/io-streams/#3421-stream-di-byte","title":"34.2.1 Stream di Byte","text":"<ul> <li>Lavorano con byte grezzi a 8 bit</li> <li>Usati per dati binari (immagini, audio, PDF, ZIP)</li> <li>Classi base: <code>InputStream</code> e <code>OutputStream</code></li> </ul>"},{"location":"it/module-08/io-streams/#3422-stream-di-caratteri","title":"34.2.2 Stream di Caratteri","text":"<ul> <li>Lavorano con caratteri Unicode a 16 bit</li> <li>Gestiscono automaticamente l\u2019encoding dei caratteri</li> <li>Classi base: <code>Reader</code> e <code>Writer</code></li> </ul>"},{"location":"it/module-08/io-streams/#3423-tabella-di-riepilogo","title":"34.2.3 Tabella di riepilogo","text":"Aspetto Stream di Byte Stream di Caratteri <code>Unit\u00e0 di dato</code> byte (8 bit) char (16 bit) <code>Gestione encoding</code> Nessuna S\u00ec (consapevole del charset) <code>Classi base</code> InputStream / OutputStream Reader / Writer <code>Uso tipico</code> File binari File di testo <code>Focus</code> I/O a basso livello Elaborazione testo"},{"location":"it/module-08/io-streams/#343-stream-di-basso-livello-vs-stream-di-alto-livello","title":"34.3 Stream di Basso Livello vs Stream di Alto Livello","text":"<p>Gli stream in <code>java.io</code> seguono un pattern decorator. Gli stream vengono impilati per aggiungere funzionalit\u00e0.</p> <p></p>"},{"location":"it/module-08/io-streams/#3431-stream-di-basso-livello-node-streams","title":"34.3.1 Stream di Basso Livello (Node Streams)","text":"<p>Gli stream di basso livello si collegano direttamente a una sorgente o a una destinazione di dati.</p> <ul> <li>Sanno come leggere/scrivere byte o caratteri</li> <li>NON forniscono buffering, formattazione o gestione di oggetti</li> </ul> <p></p>"},{"location":"it/module-08/io-streams/#3432-stream-comuni-di-basso-livello","title":"34.3.2 Stream comuni di Basso Livello","text":"Classe Stream Scopo <code>FileInputStream</code> Legge byte da file <code>FileOutputStream</code> Scrive byte su file <code>FileReader</code> Legge caratteri da file <code>FileWriter</code> Scrive caratteri su file <ul> <li>Esempio: stream di byte a basso livello</li> </ul> <pre><code>try (InputStream in = new FileInputStream(\"data.bin\")) {\n    int b;\n    while ((b = in.read()) != -1) {\n        System.out.println(b);\n    }\n}\n</code></pre> <p>Note</p> <p>Gli stream di basso livello sono raramente usati da soli nelle applicazioni reali a causa di prestazioni scarse e funzionalit\u00e0 limitate.</p> <p></p>"},{"location":"it/module-08/io-streams/#3433-stream-di-alto-livello-filter-processing-streams","title":"34.3.3 Stream di Alto Livello (Filter / Processing Streams)","text":"<p>Gli stream di alto livello avvolgono altri stream per aggiungere funzionalit\u00e0.</p> <ul> <li>Buffering</li> <li>Conversione del tipo di dato</li> <li>Serializzazione di oggetti</li> <li>Lettura/scrittura di primitivi</li> </ul> <p></p>"},{"location":"it/module-08/io-streams/#3434-stream-comuni-di-alto-livello","title":"34.3.4 Stream comuni di Alto Livello","text":"Classe Stream Aggiunge funzionalit\u00e0 <code>BufferedInputStream</code> Buffering <code>BufferedReader</code> Lettura basata su linee <code>DataInputStream</code> Tipi primitivi <code>ObjectInputStream</code> Serializzazione oggetti <code>PrintWriter</code> Output testo formattato <ul> <li>Esempio: chaining degli stream</li> </ul> <pre><code>try (BufferedReader reader =\n    new BufferedReader(\n        new InputStreamReader(\n            new FileInputStream(\"text.txt\")))) {\n\n    String line;\n    while ((line = reader.readLine()) != null) {\n        System.out.println(line);\n    }\n}\n</code></pre>"},{"location":"it/module-08/io-streams/#3435-regole-di-chaining-degli-stream-e-errori-comuni","title":"34.3.5 Regole di chaining degli stream e errori comuni","text":"<p>L\u2019esempio precedente illustra lo stream chaining, un concetto centrale in <code>java.io</code> basato sul pattern decorator.</p> <p>Ogni stream avvolge un altro stream, aggiungendo funzionalit\u00e0 preservando una gerarchia di tipi rigorosa.</p> <p></p>"},{"location":"it/module-08/io-streams/#34351-regola-fondamentale-di-chaining","title":"34.3.5.1 Regola fondamentale di chaining","text":"<p>Uno stream pu\u00f2 avvolgere solo un altro stream di un livello di astrazione compatibile.</p> <ul> <li>Gli stream di byte possono avvolgere solo stream di byte</li> <li>Gli stream di caratteri possono avvolgere solo stream di caratteri</li> <li>Gli stream di alto livello richiedono uno stream di basso livello sottostante</li> </ul> <p>Note</p> <p>Non puoi mescolare arbitrariamente <code>InputStream</code> con <code>Reader</code> o <code>OutputStream</code> con <code>Writer</code>.</p> <p></p>"},{"location":"it/module-08/io-streams/#34352-incompatibilita-tra-stream-di-byte-e-stream-di-caratteri","title":"34.3.5.2 Incompatibilit\u00e0 tra stream di byte e stream di caratteri","text":"<p>Un errore molto comune \u00e8 tentare di avvolgere uno stream di byte direttamente con una classe basata su caratteri (o viceversa).</p> <p></p>"},{"location":"it/module-08/io-streams/#34353-chaining-non-valido-errore-di-compilazione","title":"34.3.5.3 Chaining non valido (errore di compilazione)","text":"<pre><code>BufferedReader reader =\n    new BufferedReader(new FileInputStream(\"text.txt\"));\n</code></pre> <p>Note</p> <p>Questo fallisce perch\u00e9 <code>BufferedReader</code> si aspetta un <code>Reader</code>, non un <code>InputStream</code>.</p> <p></p>"},{"location":"it/module-08/io-streams/#34354-bridging-da-stream-di-byte-a-stream-di-caratteri","title":"34.3.5.4 Bridging da stream di byte a stream di caratteri","text":"<p>Per convertire tra stream basati su byte e stream basati su caratteri, Java fornisce classi ponte che eseguono decodifica/codifica esplicita del charset.</p> <ul> <li><code>InputStreamReader</code> converte byte \u2192 caratteri</li> <li><code>OutputStreamWriter</code> converte caratteri \u2192 byte</li> </ul> <p></p>"},{"location":"it/module-08/io-streams/#34355-pattern-corretto-di-conversione","title":"34.3.5.5 Pattern corretto di conversione","text":"<pre><code>BufferedReader reader =\n    new BufferedReader(\n        new InputStreamReader(new FileInputStream(\"text.txt\")));\n</code></pre> <p>Note</p> <p>Il ponte gestisce la decodifica dei caratteri usando un charset (predefinito o esplicito).</p> <p></p>"},{"location":"it/module-08/io-streams/#34356-regole-di-ordinamento-nelle-catene-di-stream","title":"34.3.5.6 Regole di ordinamento nelle catene di stream","text":"<p>L\u2019ordine di wrapping non \u00e8 arbitrario.</p> <ul> <li>Lo stream di basso livello deve essere il pi\u00f9 interno</li> <li>I bridge (se necessari) vengono dopo</li> <li>Gli stream bufferizzati o di elaborazione vengono per ultimi</li> </ul> <p></p>"},{"location":"it/module-08/io-streams/#34357-ordine-logico-corretto","title":"34.3.5.7 Ordine logico corretto","text":"<pre><code>FileInputStream \u2192 InputStreamReader \u2192 BufferedReader\n</code></pre>"},{"location":"it/module-08/io-streams/#34358-regola-di-gestione-delle-risorse","title":"34.3.5.8 Regola di gestione delle risorse","text":"<p>Chiudere lo stream pi\u00f9 esterno chiude automaticamente tutti gli stream avvolti.</p> <p>Note</p> <p>Per questo try-with-resources dovrebbe riferirsi solo allo stream di livello pi\u00f9 alto.</p> <p></p>"},{"location":"it/module-08/io-streams/#34359-trappole-comuni","title":"34.3.5.9 Trappole comuni","text":"<ul> <li>Tentare di bufferizzare uno stream del tipo sbagliato</li> <li>Dimenticare il bridge tra stream di byte e stream di char</li> <li>Assumere che <code>Reader</code> funzioni con dati binari</li> <li>Usare il charset predefinito involontariamente</li> <li>Chiudere manualmente gli stream interni (rischiando double-close): <code>close()</code> sul wrapper esterno \u00e8 sufficiente ed \u00e8 raccomandato</li> </ul>"},{"location":"it/module-08/io-streams/#344-classi-base-principali-di-javaio-e-metodi-chiave","title":"34.4 Classi base principali di <code>java.io</code> e metodi chiave","text":"<p>Il package <code>java.io</code> \u00e8 costruito attorno a un piccolo insieme di classi base astratte. Comprendere queste classi e i loro contratti \u00e8 essenziale, perch\u00e9 tutte le classi I/O concrete si basano su di esse.</p> <p></p>"},{"location":"it/module-08/io-streams/#3441-inputstream","title":"34.4.1 InputStream","text":"<p>Classe base astratta per input orientato ai byte. Tutti gli input stream leggono byte grezzi (valori a 8 bit) da una sorgente come un file, un socket di rete o un buffer di memoria.</p> <p></p>"},{"location":"it/module-08/io-streams/#34411-metodi-chiave","title":"34.4.1.1 Metodi chiave","text":"Metodo Descrizione int <code>read()</code> Legge un byte (0\u2013255); ritorna -1 a fine stream int <code>read(byte[])</code> Legge byte in un buffer; ritorna numero di byte letti o -1 int <code>read(byte[], int, int)</code> Legge fino a length byte in una slice del buffer int <code>available()</code> Byte leggibili senza bloccare (hint, non garanzia) void <code>close()</code> Rilascia la risorsa sottostante <p>Note</p> <p>I metodi <code>read()</code> sono bloccanti per default.</p> <p>Sospendono il thread chiamante finch\u00e9 i dati non sono disponibili, finch\u00e9 non si raggiunge end-of-stream, o finch\u00e9 non si verifica un errore I/O.</p> <p>Il metodo <code>read()</code> a singolo byte \u00e8 principalmente un primitivo di basso livello.</p> <p>In pratica, leggere un byte alla volta \u00e8 inefficiente e dovrebbe quasi sempre essere evitato a favore di letture bufferizzate.</p> <p></p>"},{"location":"it/module-08/io-streams/#34412-esempio-tipico-di-utilizzo","title":"34.4.1.2 Esempio tipico di utilizzo","text":"<pre><code>try (InputStream in = new FileInputStream(\"data.bin\")) {\n    byte[] buffer = new byte[1024];\n    int count;\n    while ((count = in.read(buffer)) != -1) {\n        // process buffer[0..count-1]\n    }\n}\n</code></pre>"},{"location":"it/module-08/io-streams/#3442-outputstream","title":"34.4.2 OutputStream","text":"<p>Classe base astratta per output orientato ai byte.</p> <p>Rappresenta una destinazione dove possono essere scritti byte grezzi.</p> <p></p>"},{"location":"it/module-08/io-streams/#34421-metodi-chiave","title":"34.4.2.1 Metodi chiave","text":"Metodo Descrizione void <code>write(int b)</code> Scrive gli 8 bit meno significativi dell\u2019intero void <code>write(byte[])</code> Scrive un intero array di byte void <code>write(byte[], int, int)</code> Scrive una slice di un array di byte void <code>flush()</code> Forza la scrittura dei dati bufferizzati void <code>close()</code> Esegue flush e rilascia la risorsa <p>Note</p> <p>Chiamare <code>close()</code> richiama implicitamente <code>flush()</code>.</p> <p>Non eseguire flush o close su un OutputStream pu\u00f2 causare perdita di dati.</p> <p></p>"},{"location":"it/module-08/io-streams/#34422-esempio-tipico-di-utilizzo","title":"34.4.2.2 Esempio tipico di utilizzo","text":"<pre><code>try (OutputStream out = new FileOutputStream(\"out.bin\")) {\n    out.write(new byte[] {1, 2, 3, 4});\n    out.flush();\n}\n</code></pre>"},{"location":"it/module-08/io-streams/#3443-reader-e-writer","title":"34.4.3 Reader e Writer","text":"<p><code>Reader</code> e <code>Writer</code> sono le controparti <code>orientate ai caratteri</code> di InputStream e OutputStream.</p> <p>Operano su caratteri Unicode a 16 bit invece di byte grezzi.</p> Classe Direzione Basata su caratteri Consapevole dell\u2019encoding <code>Reader</code> Input S\u00ec S\u00ec <code>Writer</code> Output S\u00ec S\u00ec <p>Reader e Writer implicano sempre un <code>charset</code>, esplicitamente o implicitamente.</p> <p>Questo li rende l\u2019astrazione corretta per l\u2019elaborazione di testo.</p> <p></p>"},{"location":"it/module-08/io-streams/#34431-gestione-del-charset","title":"34.4.3.1 Gestione del charset","text":"<pre><code>Reader reader = new InputStreamReader(\n    new FileInputStream(\"file.txt\"),\n    StandardCharsets.UTF_8\n);\n</code></pre> <p>Note</p> <p><code>InputStreamReader</code> e <code>OutputStreamWriter</code> sono classi ponte.</p> <p>Convertono tra <code>stream di byte</code> e <code>stream di caratteri</code> usando un <code>charset</code>.</p> <p></p>"},{"location":"it/module-08/io-streams/#345-stream-bufferizzati-e-prestazioni","title":"34.5 Stream bufferizzati e prestazioni","text":"<p>Gli <code>stream bufferizzati</code> avvolgono un altro stream e aggiungono un buffer in memoria.</p> <p>Invece di interagire con il sistema operativo a ogni read o write, i dati vengono accumulati in memoria e trasferiti in blocchi pi\u00f9 grandi.</p> <ul> <li><code>BufferedInputStream</code> / <code>BufferedOutputStream</code> per stream di byte</li> <li><code>BufferedReader</code> / <code>BufferedWriter</code> per stream di caratteri</li> </ul> <p>Note</p> <p>Gli <code>stream bufferizzati</code> sono <code>decorator</code>: non sostituiscono lo stream sottostante, lo migliorano aggiungendo comportamento di buffering.</p> <p></p>"},{"location":"it/module-08/io-streams/#3451-perche-il-buffering-conta","title":"34.5.1 Perch\u00e9 il buffering conta","text":"Aspetto Non bufferizzato Bufferizzato <code>System calls</code> Frequenti Ridotte <code>Prestazioni</code> Scarse Alte <code>Uso memoria</code> Minimo Leggermente pi\u00f9 alto <p>Le system call sono operazioni costose.</p> <p>Il buffering le minimizza raggruppando pi\u00f9 letture o scritture logiche in meno operazioni I/O fisiche.</p> <p></p>"},{"location":"it/module-08/io-streams/#3452-come-funziona-la-lettura-non-bufferizzata","title":"34.5.2 Come funziona la lettura non bufferizzata","text":"<p>In uno stream non bufferizzato, ogni chiamata a read() pu\u00f2 risultare in una system call nativa.</p> <p>Questo \u00e8 particolarmente inefficiente quando si leggono grandi quantit\u00e0 di dati.</p> <pre><code>try (InputStream in = new FileInputStream(\"data.bin\")) {\n    int b;\n    while ((b = in.read()) != -1) {\n        // ogni read() pu\u00f2 innescare una system call\n    }\n}\n</code></pre> <p>Note</p> <p>Leggere byte-per-byte senza buffering \u00e8 quasi sempre un anti-pattern di prestazioni.</p> <p></p>"},{"location":"it/module-08/io-streams/#3453-come-funziona-bufferedinputstream","title":"34.5.3 Come funziona BufferedInputStream","text":"<p><code>BufferedInputStream</code> internamente legge un grande blocco di byte in un buffer.</p> <p>Le successive chiamate <code>read()</code> sono servite direttamente dalla memoria finch\u00e9 il buffer non \u00e8 vuoto.</p> <pre><code>try (InputStream in =\n    new BufferedInputStream(new FileInputStream(\"data.bin\"))) {\n        int b;\n        while ((b = in.read()) != -1) {\n            // la maggior parte delle letture \u00e8 servita dalla memoria, non dall\u2019OS\n        }\n}\n</code></pre> <p>Note</p> <p>Il programma chiama ancora <code>read()</code> ripetutamente, ma il sistema operativo viene invocato solo quando il buffer interno deve essere riempito di nuovo.</p> <p></p>"},{"location":"it/module-08/io-streams/#3454-esempio-di-output-bufferizzato","title":"34.5.4 Esempio di output bufferizzato","text":"<p>L\u2019output bufferizzato accumula dati in memoria e li scrive in blocchi pi\u00f9 grandi.</p> <p>L\u2019operazione <code>flush()</code> forza la scrittura immediata del buffer.</p> <pre><code>try (OutputStream out =\n    new BufferedOutputStream(new FileOutputStream(\"out.bin\"))) {\n        for (int i = 0; i &lt; 1_000; i++) {\n            out.write(i);\n        }\n        out.flush(); // forza i dati bufferizzati su disco\n}\n</code></pre> <p>Note</p> <p><code>close()</code> chiama automaticamente flush().</p> <p>Chiamare <code>flush()</code> esplicitamente \u00e8 utile quando i dati devono essere visibili immediatamente.</p> <p></p>"},{"location":"it/module-08/io-streams/#3455-bufferedreader-vs-reader","title":"34.5.5 BufferedReader vs Reader","text":"<p><code>BufferedReader</code> aggiunge una <code>**lettura basata su linee**</code> efficiente sopra un Reader.</p> <p>Senza buffering, ogni carattere letto pu\u00f2 coinvolgere una system call.</p> <pre><code>try (BufferedReader reader =\n    new BufferedReader(new FileReader(\"file.txt\"))) {\n\n        String line;\n        while ((line = reader.readLine()) != null) {\n            System.out.println(line);\n        }\n}\n</code></pre> <p>Note</p> <p>Il metodo <code>readLine()</code> \u00e8 disponibile solo su <code>BufferedReader</code> (non su <code>Reader</code>), perch\u00e9 si basa sul buffering per rilevare efficientemente i confini di riga.</p> <p></p>"},{"location":"it/module-08/io-streams/#3456-esempio-di-bufferedwriter","title":"34.5.6 Esempio di BufferedWriter","text":"<pre><code>try (BufferedWriter writer =\n    new BufferedWriter(new FileWriter(\"file.txt\"))) {\n\n        writer.write(\"Hello\");\n        writer.newLine();\n        writer.write(\"World\");\n}\n</code></pre> <p><code>BufferedWriter</code> minimizza l\u2019accesso al disco e fornisce metodi di convenienza come <code>newLine()</code>.</p> <p>Note</p> <p>Avvolgi sempre gli stream di file con buffering a meno che non ci sia una forte ragione per non farlo</p> <p>Preferisci BufferedReader / BufferedWriter per testo</p> <p>Preferisci BufferedInputStream / BufferedOutputStream per dati binari</p> <p></p>"},{"location":"it/module-08/io-streams/#346-javaio-vs-javanio-e-javaniofile","title":"34.6 java.io vs java.nio (e java.nio.file)","text":"<p>Le applicazioni Java moderne favoriscono sempre pi\u00f9 le API NIO e NIO.2, ma java.io rimane fondamentale e ampiamente usato.</p> <p></p>"},{"location":"it/module-08/io-streams/#3461-differenze-concettuali","title":"34.6.1 Differenze concettuali","text":"Aspetto java.io java.nio / nio.2 <code>Modello di programmazione</code> Basato su stream Basato su buffer / channel <code>I/O bloccante</code> Bloccante per default Capace di non-bloccante <code>File API</code> File Path + Files <code>Scalabilit\u00e0</code> Limitata Alta <code>Introdotto</code> Java 1.0 Java 4 / Java 7 <p>Note</p> <p><code>java.nio</code> non sostituisce <code>java.io</code>.</p> <p>Molte classi NIO internamente si basano su stream o coesistono con essi.</p> <p></p>"},{"location":"it/module-08/io-streams/#3462-javanio-io-file-moderno","title":"34.6.2 java.nio (I/O file moderno)","text":"<p>Il package <code>java.nio.file</code> (NIO.2) fornisce una file API di alto livello, espressiva e pi\u00f9 sicura. \u00c8 l\u2019approccio preferito per operazioni su file in Java 11+.</p> <p>Esempio: leggere un file (NIO)</p> <pre><code>Path path = Path.of(\"file.txt\");\nList&lt;String&gt; lines = Files.readAllLines(path);\n</code></pre> <p>Codice java.io equivalente</p> <pre><code>try (BufferedReader reader = new BufferedReader(new FileReader(\"file.txt\"))) {\n    String line;\n    while ((line = reader.readLine()) != null) {\n        System.out.println(line);\n    }\n}\n</code></pre> <p></p>"},{"location":"it/module-08/io-streams/#347-quando-usare-quale-api","title":"34.7 Quando usare quale API","text":"Scenario API raccomandata <code>Lettura/scrittura file semplice</code> java.nio.file.Files <code>Streaming binario</code> InputStream / OutputStream <code>Elaborazione testo a caratteri</code> Reader / Writer <code>Server ad alte prestazioni</code> java.nio.channels <code>API legacy</code> java.io"},{"location":"it/module-08/io-streams/#348-trappole-comuni-e-suggerimenti","title":"34.8 Trappole comuni e suggerimenti","text":"<ul> <li>End-of-file \u00e8 indicato da -1, non da un\u2019eccezione</li> <li>Chiudere uno stream wrapper chiude automaticamente lo stream avvolto</li> <li><code>BufferedReader.readLine()</code> rimuove i separatori di linea</li> <li><code>InputStreamReader</code> coinvolge sempre un charset</li> <li>I metodi utility Files lanciano IOException checked</li> <li><code>available()</code> non deve essere usato per rilevare EOF</li> </ul> <p>Note</p> <p>La maggior parte dei bug I/O deriva da assunzioni errate su blocking, buffering o character encoding.</p>"},{"location":"it/module-08/io-user/","title":"36. Interagire con l\u2019Utente (Stream I/O Standard)","text":""},{"location":"it/module-08/io-user/#indice","title":"Indice","text":"<ul> <li>36.1 Gli Stream I/O Standard</li> <li>36.2 PrintStream Cos\u00e8 e Perch\u00e9 Esiste<ul> <li>36.2.1 Caratteristiche Chiave di PrintStream</li> <li>36.2.2 Uso Base di PrintStream</li> <li>36.2.3 Formattare l'Output con PrintStream</li> </ul> </li> <li>36.3 Leggere Input come Stream I/O<ul> <li>36.3.1 Lettura a Basso Livello da Systemin</li> <li>36.3.2 Uso di InputStreamReader e BufferedReader</li> </ul> </li> <li>36.4 La Classe Scanner Comoda ma Sottile<ul> <li>36.4.1 Problemi Comuni di Scanner</li> </ul> </li> <li>36.5 Chiusura degli Stream di Sistema</li> <li>36.6 Acquisire Input con Console<ul> <li>36.6.1 Leggere Input da Console</li> <li>36.6.2 Leggere Password in Modo Sicuro</li> </ul> </li> <li>36.7 Formattare l'Output della Console</li> <li>36.8 Confronto tra Console Scanner e BufferedReader</li> <li>36.9 Redirezione e Stream Standard</li> <li>36.10 Trappole Comuni e Best Practice</li> <li>36.11 Sintesi Finale</li> </ul> <p>I programmi Java spesso devono interagire con l\u2019utente: stampare informazioni, leggere input e formattare l\u2019output.</p> <p>Questa interazione \u00e8 implementata usando gli stream I/O standard, che sono normali stream Java connessi al sistema operativo.</p> <p>Questo capitolo spiega come Java interagisce con la console e l\u2019input/output standard, partendo dai concetti pi\u00f9 basilari e passando alle API di livello pi\u00f9 alto.</p> <p></p>"},{"location":"it/module-08/io-user/#361-gli-stream-io-standard","title":"36.1 Gli Stream I/O Standard","text":"<p>Ogni programma Java inizia con tre stream predefiniti forniti dalla JVM.</p> <p>Sono connessi all\u2019ambiente del processo (di solito un terminale o una console).</p> Stream Campo Tipo Scopo Output standard <code>System.out</code> PrintStream Output normale Errore standard <code>System.err</code> PrintStream Output di errore Input standard <code>System.in</code> InputStream Input dell\u2019utente <p>Note</p> <p>Questi stream sono creati dalla JVM, non dal programma.</p> <p>Essi esistono per l\u2019intera durata del processo.</p> <p></p>"},{"location":"it/module-08/io-user/#362-printstream-cose-e-perche-esiste","title":"36.2 <code>PrintStream</code>: Cos\u2019\u00e8 e Perch\u00e9 Esiste","text":"<p><code>PrintStream</code> \u00e8 uno stream di output orientato ai byte progettato per output leggibile dall\u2019utente.</p> <p>Avvolge un altro OutputStream e aggiunge metodi di stampa convenienti.</p> <p><code>System.out</code> e <code>System.err</code> sono entrambi istanze di <code>PrintStream</code>.</p> <p></p>"},{"location":"it/module-08/io-user/#3621-caratteristiche-chiave-di-printstream","title":"36.2.1 Caratteristiche Chiave di PrintStream","text":"<ul> <li>Stream orientato ai byte con helper per la stampa di testo</li> <li>Fornisce metodi <code>print()</code> e <code>println()</code></li> <li>Converte automaticamente i valori in testo</li> <li>Non lancia <code>IOException</code> su errori di scrittura</li> <li>Supporta opzionalmente l\u2019auto-flush su newline / <code>println()</code></li> </ul> <p>Note</p> <p>A differenza della maggior parte degli stream, PrintStream sopprime le IOExceptions.</p> <p>Gli errori devono essere verificati usando checkError().</p> <p></p>"},{"location":"it/module-08/io-user/#3622-uso-base-di-printstream","title":"36.2.2 Uso Base di PrintStream","text":"<pre><code>System.out.println(\"Hello\");\nSystem.out.print(\"Value: \");\nSystem.out.println(42);\n</code></pre> <p><code>println()</code> aggiunge automaticamente il separatore di linea specifico della piattaforma.</p> <p></p>"},{"location":"it/module-08/io-user/#3623-formattare-loutput-con-printstream","title":"36.2.3 Formattare l\u2019Output con PrintStream","text":"<p>PrintStream supporta output formattato usando <code>printf()</code> e <code>format()</code>, che sono basati sulla stessa sintassi di String.format().</p> <pre><code>System.out.printf(\"Name: %s, Age: %d%n\", \"Alice\", 30);\n</code></pre> Specificatore Significato <code>%s</code> Stringa <code>%d</code> Intero <code>%f</code> Virgola mobile <code>%n</code> Nuova linea indipendente dalla piattaforma <p>Note</p> <p><code>printf()</code> non aggiunge automaticamente una nuova linea a meno che non si specifichi <code>%n</code>.</p> <p></p>"},{"location":"it/module-08/io-user/#363-leggere-input-come-stream-io","title":"36.3 Leggere Input come Stream I/O","text":"<p>L\u2019input standard (System.in) \u00e8 un InputStream connesso all\u2019input dell\u2019utente.</p> <p>Fornisce byte grezzi e deve essere adattato per un uso pratico.</p> <p></p>"},{"location":"it/module-08/io-user/#3631-lettura-a-basso-livello-da-systemin","title":"36.3.1 Lettura a Basso Livello da System.in","text":"<p>Al livello pi\u00f9 basso, puoi leggere byte grezzi da System.in.</p> <p>Questo \u00e8 raramente conveniente per programmi interattivi.</p> <pre><code>int b = System.in.read();\n</code></pre> <p>Note</p> <p><code>System.in.read()</code> si blocca finch\u00e9 l\u2019input non \u00e8 disponibile.</p> <p></p>"},{"location":"it/module-08/io-user/#3632-uso-di-inputstreamreader-e-bufferedreader","title":"36.3.2 Uso di InputStreamReader e BufferedReader","text":"<p>Per leggere input testuale, <code>System.in</code> \u00e8 tipicamente avvolto in un Reader e bufferizzato.</p> <pre><code>BufferedReader reader =\nnew BufferedReader(new InputStreamReader(System.in));\n\nString line = reader.readLine();\n</code></pre> <p>Questo converte <code>byte \u2192 caratteri</code> e permette input basato su linee.</p> <p></p>"},{"location":"it/module-08/io-user/#364-la-classe-scanner-comoda-ma-sottile","title":"36.4 La Classe Scanner (Comoda ma Sottile)","text":"<p><code>Scanner</code> \u00e8 un\u2019utilit\u00e0 di alto livello per il parsing di input testuale.</p> <p>\u00c8 spesso usata per l\u2019interazione con la console, specialmente in piccoli programmi.</p> <pre><code>Scanner sc = new Scanner(System.in);\nint value = sc.nextInt();\nString text = sc.nextLine();\n</code></pre> <p>Note</p> <p><code>Scanner</code> esegue tokenizzazione e parsing, non semplice lettura.</p> <p>Questo la rende comoda ma pi\u00f9 lenta e talvolta sorprendente.</p> <p></p>"},{"location":"it/module-08/io-user/#3641-problemi-comuni-di-scanner","title":"36.4.1 Problemi Comuni di Scanner","text":"<ul> <li>Mischiare <code>nextInt()</code> (e altri <code>nextXxx()</code>) con <code>nextLine()</code> pu\u00f2 sembrare \u201csaltare\u201d input perch\u00e9 il newline finale del token numerico \u00e8 ancora nel buffer.</li> <li>Gli errori di parsing lanciano InputMismatchException</li> <li>Scanner \u00e8 relativamente lenta per input di grandi dimensioni</li> </ul>"},{"location":"it/module-08/io-user/#365-chiusura-degli-stream-di-sistema","title":"36.5 Chiusura degli Stream di Sistema","text":"<p>Gli <code>stream di sistema</code> sono speciali e devono essere gestiti con attenzione.</p> Stream Chiudere esplicitamente? <code>System.out</code> No <code>System.err</code> No <code>System.in</code> Di solito no <p>Chiudere <code>System.out</code> o <code>System.err</code> chiude lo stream sottostante del sistema operativo e influisce sull\u2019intera JVM: chiudere questi stream influisce sull\u2019intero processo JVM, non solo sulla classe o metodo corrente.</p> <p>Note</p> <p>In quasi tutte le applicazioni, NON dovresti chiudere <code>System.out</code> o <code>System.err</code>.</p> <p></p>"},{"location":"it/module-08/io-user/#366-acquisire-input-con-console","title":"36.6 Acquisire Input con <code>Console</code>","text":"<p>La classe <code>Console</code> fornisce un modo di livello pi\u00f9 alto e pi\u00f9 sicuro per interagire con l\u2019utente.</p> <p>\u00c8 progettata specificamente per programmi di console interattivi.</p> <pre><code>Console console = System.console();\nif (console == null) {\n    throw new IllegalStateException(\"No console available\");\n}\n</code></pre> <p>Note</p> <p><code>System.console()</code> pu\u00f2 restituire <code>null</code> quando nessuna console \u00e8 disponibile (ad es. IDE, input rediretto).</p> <p>La presenza di una console dipende dalla piattaforma sottostante e da come viene avviata la JVM.</p> <p>Se la JVM viene avviata da una riga di comando interattiva e i flussi di input/output standard non sono reindirizzati, una console \u00e8 tipicamente disponibile. In questo caso, la console \u00e8 solitamente collegata alla tastiera e al display da cui \u00e8 stato lanciato il programma.</p> <p>Se la JVM viene avviata in un contesto non interattivo \u2014 ad esempio da un IDE, un pianificatore di processi in background, un gestore di servizi, o con flussi standard reindirizzati \u2014 di solito una console non sar\u00e0 disponibile.</p> <p>Quando una console esiste, \u00e8 rappresentata da un\u2019istanza unica della classe Console, che pu\u00f2 essere ottenuta invocando il metodo <code>System.console()</code>.  Se non \u00e8 disponibile alcun dispositivo console, questo metodo restituir\u00e0 <code>null</code>.</p> <p></p>"},{"location":"it/module-08/io-user/#3661-leggere-input-da-console","title":"36.6.1 Leggere Input da Console","text":"<pre><code>String name = console.readLine(\"Name: \");\n</code></pre> <p><code>readLine()</code> stampa un prompt e legge una linea completa di input.</p> <p></p>"},{"location":"it/module-08/io-user/#3662-leggere-password-in-modo-sicuro","title":"36.6.2 Leggere Password in Modo Sicuro","text":"<p>Console permette di leggere password senza mostrare i caratteri.</p> <pre><code>char[] password = console.readPassword(\"Password: \");\n</code></pre> <p>Note</p> <p>Le password sono restituite come <code>char[]</code> cos\u00ec possono essere cancellate dalla memoria.</p> <p></p>"},{"location":"it/module-08/io-user/#367-formattare-loutput-della-console","title":"36.7 Formattare l\u2019Output della Console","text":"<p>Console supporta anche output formattato, simile a PrintStream.</p> <pre><code>console.printf(\"Welcome %s%n\", name);\n</code></pre> <p>Questo usa gli stessi specificatori di formato di <code>printf()</code>.</p> <p></p>"},{"location":"it/module-08/io-user/#368-confronto-tra-console-scanner-e-bufferedreader","title":"36.8 Confronto tra Console, Scanner e BufferedReader","text":"API Caso d\u2019uso Punti di forza Limitazioni <code>BufferedReader</code> Input testuale semplice Veloce, prevedibile, charset esplicito Parsing manuale <code>Scanner</code> Input basato su token / parsing Comoda, espressiva Pi\u00f9 lenta, comportamento dei token sottile <code>Console</code> App console interattive Password, prompt, I/O formattato Pu\u00f2 non essere disponibile (<code>null</code>)"},{"location":"it/module-08/io-user/#369-redirezione-e-stream-standard","title":"36.9 Redirezione e Stream Standard","text":"<p>Gli stream standard possono essere rediretti dal sistema operativo. Il codice Java non deve cambiare.</p> <pre><code>java App &lt; input.txt &gt; output.txt\n</code></pre> <p>Dal punto di vista del programma, <code>System.in</code> e <code>System.out</code> si comportano ancora come normali stream.</p> <p>Note</p> <p>La redirezione \u00e8 gestita dal sistema operativo o dalla shell. Il codice Java non deve cambiare per supportarla.</p> <p></p>"},{"location":"it/module-08/io-user/#3610-trappole-comuni-e-best-practice","title":"36.10 Trappole Comuni e Best Practice","text":"<ul> <li>PrintStream sopprime le IOExceptions</li> <li><code>System.console()</code> pu\u00f2 restituire null</li> <li>Non chiudere <code>System.out</code> o <code>System.err</code></li> <li>Scanner mescola parsing e lettura</li> <li>Console \u00e8 preferibile per le password</li> <li>Se usi <code>Scanner</code> su <code>System.in</code>, non chiudere lo Scanner se altre parti del programma devono ancora leggere da <code>System.in</code> (chiudere lo Scanner chiude <code>System.in</code>).</li> </ul>"},{"location":"it/module-08/io-user/#3611-sintesi-finale","title":"36.11 Sintesi Finale","text":"<ul> <li><code>System.out</code> e <code>System.err</code> sono PrintStream per l\u2019output</li> <li><code>System.in</code> \u00e8 uno stream di byte che deve essere adattato per il testo</li> <li><code>BufferedReader</code> e <code>Scanner</code> sono strategie comuni di input</li> <li><code>Console</code> fornisce input e output interattivo sicuro</li> <li>Gli stream standard si integrano naturalmente con la redirezione del sistema operativo</li> </ul>"},{"location":"it/module-09/jpms-compiling/","title":"38. Compilare, Impacchettare ed Eseguire Moduli","text":""},{"location":"it/module-09/jpms-compiling/#indice","title":"Indice","text":"<ul> <li>38.1 Il Module Path vs il Classpath</li> <li>38.2 Opzioni della Riga di Comando Relative ai Moduli<ul> <li>38.2.1 Opzioni Disponibili sia in java che in javac</li> <li>38.2.2 Opzioni Applicabili Solo a javac</li> <li>38.2.3 Opzioni Applicabili Solo a java</li> <li>38.2.4 Distinzioni Importanti</li> </ul> </li> <li>38.3 Compilare un Singolo Modulo</li> <li>38.4 Compilare Moduli Multipli Interdipendenti</li> <li>38.5 Impacchettare un Modulo in un JAR Modulare</li> <li>38.6 Eseguire un\u2019Applicazione Modulare</li> <li>38.7 Spiegazione delle Direttive del Modulo<ul> <li>38.7.1 requires</li> <li>38.7.2 requires transitive</li> <li>38.7.3 exports</li> <li>38.7.4 exports-to-qualified-exports</li> <li>38.7.5 opens</li> <li>38.7.6 opens-to-qualified-opens</li> <li>38.7.7 Tabella delle Direttive Principali</li> <li>38.7.8 Exports vs Opens \u2014 Accesso a Compile-Time vs Runtime</li> </ul> </li> <li>38.8 Moduli Named, Automatici e Unnamed<ul> <li>38.8.1 Moduli Named</li> <li>38.8.2 Moduli Automatici</li> <li>38.8.3 Modulo Unnamed</li> <li>38.8.4 Riepilogo Comparativo</li> </ul> </li> <li>38.9 Ispezionare Moduli e Dipendenze<ul> <li>38.9.1 Descrivere Moduli con java</li> <li>38.9.2 Descrivere JAR Modulari</li> <li>38.9.3 Analizzare le Dipendenze con jdeps</li> </ul> </li> <li>38.10 Creare Immagini Runtime Personalizzate con jlink</li> <li>38.11 Creare Applicazioni Self-Contained con jpackage</li> <li>38.12 Riepilogo Finale JPMS in Pratica</li> </ul> <p>Una volta che un <code>modulo</code> \u00e8 definito con un file <code>module-info.java</code>, deve essere compilato, impacchettato ed eseguito utilizzando strumenti consapevoli dei moduli.</p> <p>Questa sezione spiega come cambia la <code>toolchain Java</code> quando sono coinvolti i moduli.</p> <p></p>"},{"location":"it/module-09/jpms-compiling/#381-il-module-path-vs-il-classpath","title":"38.1 Il Module Path vs il Classpath","text":"<p><code>JPMS</code> introduce un nuovo concetto: il module path.</p> <p>Esiste accanto al tradizionale classpath, ma i due si comportano in modo molto diverso.</p> Aspetto Classpath Module path Struttura Lista piatta di JAR Moduli con identit\u00e0 Incapsulamento Nessuno Forte Verifica delle dipendenze Nessuna Rigorosa Split packages Consentiti Vietati (moduli nominati) Ordine di risoluzione Dipendente dall\u2019ordine Deterministico <p>Note</p> <ul> <li>Un JAR posizionato sul <code>module path</code> diventa un <code>modulo nominato (o automatico)</code>.</li> <li>Un JAR posizionato sul classpath \u00e8 trattato come parte del <code>modulo non nominato</code>.</li> <li>Gli split package sono consentiti sul classpath ma vietati per i moduli nominati sul module path.</li> </ul> <p></p>"},{"location":"it/module-09/jpms-compiling/#382-opzioni-della-riga-di-comando-relative-ai-moduli","title":"38.2 Opzioni della Riga di Comando Relative ai Moduli","text":"<p>Quando si lavora con il Java Module System, sia <code>java</code> che <code>javac</code> forniscono opzioni specifiche per compilare ed eseguire applicazioni modulari. </p> <p>Alcune opzioni sono condivise, mentre altre sono specifiche di uno strumento.</p> <p></p>"},{"location":"it/module-09/jpms-compiling/#3821-opzioni-disponibili-sia-in-java-che-in-javac","title":"38.2.1 Opzioni Disponibili sia in <code>java</code> che in <code>javac</code>","text":"<p>Queste opzioni possono essere utilizzate sia durante la compilazione sia durante l\u2019esecuzione:</p> <ul> <li> <p><code>--module</code> o <code>-m</code>   Utilizzata per compilare o eseguire solo il modulo specificato.</p> </li> <li> <p><code>--module-path</code> o <code>-p</code>   Specifica i percorsi nei quali <code>java</code> o <code>javac</code> cercheranno le definizioni dei moduli.</p> </li> </ul> <p></p>"},{"location":"it/module-09/jpms-compiling/#3822-opzioni-applicabili-solo-a-javac","title":"38.2.2 Opzioni Applicabili Solo a <code>javac</code>","text":"<p>Queste opzioni si applicano solo in fase di compilazione:</p> <ul> <li> <p><code>--module-source-path</code>   (nessuna forma abbreviata)   Utilizzata da <code>javac</code> per individuare le definizioni dei moduli sorgente.</p> </li> <li> <p><code>-d</code>   Specifica la directory di destinazione nella quale verranno generati i file <code>.class</code> dopo la compilazione.</p> </li> </ul> <p></p>"},{"location":"it/module-09/jpms-compiling/#3823-opzioni-applicabili-solo-a-java","title":"38.2.3 Opzioni Applicabili Solo a <code>java</code>","text":"<p>Queste opzioni si applicano solo in fase di esecuzione:</p> <ul> <li> <p><code>--list-modules</code>   (nessuna forma abbreviata)   Elenca tutti i moduli osservabili e quindi termina.</p> </li> <li> <p><code>--show-module-resolution</code>   (nessuna forma abbreviata)   Mostra i dettagli della risoluzione dei moduli durante l\u2019avvio dell\u2019applicazione.</p> </li> <li> <p><code>--describe-module</code> o <code>-d</code>   Descrive un modulo specificato e quindi termina.</p> </li> </ul> <p></p>"},{"location":"it/module-09/jpms-compiling/#3824-distinzioni-importanti","title":"38.2.4 Distinzioni Importanti","text":"<p>L\u2019opzione <code>-d</code> ha significati diversi a seconda dello strumento:</p> <ul> <li>In <code>javac</code>, <code>-d</code> definisce la directory di destinazione per i file di classe compilati.</li> <li>In <code>java</code>, <code>-d</code> \u00e8 una forma abbreviata di <code>--describe-module</code>.</li> </ul> <p>Inoltre, <code>-d</code> non deve essere confusa con <code>-D</code> (D maiuscola).</p> <ul> <li><code>-D</code> viene utilizzata durante l\u2019esecuzione di un programma Java per definire propriet\u00e0 di sistema come coppie nome-valore nella riga di comando.</li> </ul> <pre><code>java -Dconfig.file=app.properties com.example.Main\n</code></pre> <p>In questo esempio, <code>-Dconfig.file=app.properties</code> imposta una propriet\u00e0 di sistema che pu\u00f2 essere letta a runtime tramite <code>System.getProperty(\"config.file\")</code>.</p> <p></p>"},{"location":"it/module-09/jpms-compiling/#383-compilare-un-singolo-modulo","title":"38.3 Compilare un Singolo Modulo","text":"<p>Per compilare un modulo, devi specificare il percorso dei sorgenti del modulo e la directory di destinazione.</p> <pre><code>javac -d out \\\nsrc/com.example.hello/module-info.java \\\nsrc/com.example.hello/com/example/hello/Main.java\n</code></pre> <p>Un approccio pi\u00f9 scalabile utilizza <code>--module-source-path</code>.</p> <pre><code>javac --module-source-path src \\\n      -d out \\\n      $(find src -name \"*.java\")\n</code></pre> <p>Note</p> <p><code>--module-source-path</code> indica a javac dove trovare pi\u00f9 moduli contemporaneamente.</p> <p></p>"},{"location":"it/module-09/jpms-compiling/#384-compilare-moduli-multipli-interdipendenti","title":"38.4 Compilare Moduli Multipli Interdipendenti","text":"<p>Quando i moduli dipendono l\u2019uno dall\u2019altro, le loro dipendenze devono essere risolvibili in fase di compilazione.</p> <p><code>--module-path</code> mods (directory di esempio contenente moduli interdipendenti) dovrebbe contenere JAR modulari gi\u00e0 compilati o directory di moduli compilati (ognuna con il proprio module-info.class).</p> <pre><code>javac -d out \\\n--module-source-path src \\\n--module-path mods \\\n$(find src -name \"*.java\")\n</code></pre> <p>Qui: - <code>--module-source-path</code> individua gli alberi dei sorgenti dei moduli - <code>--module-path</code> fornisce moduli gi\u00e0 compilati</p> <p></p>"},{"location":"it/module-09/jpms-compiling/#385-impacchettare-un-modulo-in-un-jar-modulare","title":"38.5 Impacchettare un Modulo in un JAR Modulare","text":"<p>Dopo la compilazione, i moduli sono tipicamente impacchettati come file JAR.</p> <p>Un JAR modulare contiene un <code>module-info.class</code> alla sua root.</p> <p>Se <code>module-info.class</code> \u00e8 presente, il JAR diventa automaticamente un <code>modulo nominato</code> e il suo <code>nome</code> \u00e8 preso dal descrittore (non dal nome del file).</p> <pre><code>jar --create \\\n--file mods/com.example.hello.jar \\\n--main-class com.example.hello.Main \\\n-C out/com.example.hello .\n</code></pre> <p>Note</p> <p>Un JAR con <code>module-info.class</code> \u00e8 un <code>modulo nominato, non un modulo automatico</code>. Quando un JAR contiene un <code>module-info.class</code>, il suo nome di modulo \u00e8 preso da quel file e non \u00e8 dedotto dal nome del file.</p> <p></p>"},{"location":"it/module-09/jpms-compiling/#386-eseguire-unapplicazione-modulare","title":"38.6 Eseguire un\u2019Applicazione Modulare","text":"<p>Per eseguire un\u2019applicazione modulare, si utilizza il <code>module path</code> e si specifica il <code>nome del modulo</code>.</p> <pre><code>java --module-path mods \\\n--module com.example.hello/com.example.hello.Main\n</code></pre> <p>Puoi abbreviare usando le opzioni <code>-p</code> e <code>-m</code>.</p> <pre><code>java -p mods -m com.example.hello/com.example.hello.Main\n</code></pre> <p>Note</p> <p>Quando si usano moduli nominati, il classpath \u00e8 ignorato per la risoluzione delle dipendenze tra moduli.</p> <p></p>"},{"location":"it/module-09/jpms-compiling/#387-spiegazione-delle-direttive-del-modulo","title":"38.7 Spiegazione delle Direttive del Modulo","text":"<p>Il file <code>module-info.java</code> contiene direttive che descrivono dipendenze, visibilit\u00e0 e servizi.</p> <p>Ogni direttiva ha un significato preciso.</p> <p></p>"},{"location":"it/module-09/jpms-compiling/#3871-requires","title":"38.7.1 <code>requires</code>","text":"<p>La direttiva <code>requires</code> dichiara una dipendenza da un altro modulo.</p> <p>Senza di essa, i tipi del modulo dipendente non possono essere utilizzati.</p> <pre><code>module com.example.app {\n    requires com.example.lib;\n}\n</code></pre> <p>Effetti di requires: - La dipendenza deve essere presente a compile-time e a runtime - I package esportati del modulo richiesto diventano accessibili</p> <p></p>"},{"location":"it/module-09/jpms-compiling/#3872-requires-transitive","title":"38.7.2 <code>requires transitive</code>","text":"<p><code>requires transitive</code> espone una dipendenza ai moduli a valle.</p> <p>Propaga la leggibilit\u00e0.</p> <pre><code>module com.example.lib {\n    requires transitive com.example.util;\n    exports com.example.lib.api;\n}\n</code></pre> <p>Significato: - Qualsiasi modulo che richiede com.example.lib legge automaticamente com.example.util - I chiamanti non devono dichiarare requires com.example.util esplicitamente</p> <p>Note</p> <p>Questo \u00e8 simile alle \u201cdipendenze pubbliche\u201d in altri sistemi di moduli.</p> <p>Leggibile \u2260 esportato: un requisito transitivo non esporta automaticamente i tuoi package.</p> <p></p>"},{"location":"it/module-09/jpms-compiling/#3873-exports","title":"38.7.3 <code>exports</code>","text":"<p><code>exports</code> rende un package accessibile ad altri moduli.</p> <p>Solo i package esportati sono visibili all\u2019esterno del modulo.</p> <pre><code>module com.example.lib {\n    exports com.example.lib.api;\n}\n</code></pre> <p>I package non esportati rimangono fortemente incapsulati.</p> <p></p>"},{"location":"it/module-09/jpms-compiling/#3874-exports-to-export-qualificati","title":"38.7.4 <code>exports ... to</code> (Export Qualificati)","text":"<p>Un export qualificato limita l\u2019accesso a moduli specifici.</p> <pre><code>module com.example.lib {\n    exports com.example.internal to com.example.friend;\n}\n</code></pre> <p>Solo i moduli elencati possono accedere al package esportato.</p> <p></p>"},{"location":"it/module-09/jpms-compiling/#3875-opens","title":"38.7.5 <code>opens</code>","text":"<p><code>opens</code> consente un accesso riflessivo profondo a un package.</p> <p>\u00c8 usato principalmente da framework che utilizzano reflection.</p> <pre><code>module com.example.app {\n    opens com.example.app.model;\n}\n</code></pre> <p>Note</p> <p>opens NON rende un package accessibile a compile-time. Influenza solo la reflection a runtime.</p> <p></p>"},{"location":"it/module-09/jpms-compiling/#3876-opens-to-opens-qualificati","title":"38.7.6 <code>opens ... to</code> (Opens Qualificati)","text":"<p>Puoi limitare l\u2019accesso riflessivo a moduli specifici.</p> <pre><code>module com.example.app {\n    opens com.example.app.model to com.fasterxml.jackson.databind;\n}\n</code></pre> <p>Note</p> <p><code>opens</code> influenza la reflection; <code>exports</code> influenza la compilazione e la visibilit\u00e0 dei tipi.</p> <p></p>"},{"location":"it/module-09/jpms-compiling/#3877-tabella-delle-direttive-principali","title":"38.7.7 Tabella delle Direttive Principali","text":"Direttiva Scopo <code>requires</code> Dichiarare una dipendenza <code>requires transitive</code> Propagare una dipendenza <code>exports</code> Esporre un package <code>exports ... to</code> Esporre a moduli specifici <code>opens</code> Consentire reflection a runtime <code>opens ... to</code> Limitare l\u2019accesso riflessivo"},{"location":"it/module-09/jpms-compiling/#3878-exports-vs-opens-accesso-a-compile-time-vs-runtime","title":"38.7.8 Exports vs Opens \u2014 Accesso a Compile-Time vs Runtime","text":"Visibilit\u00e0 Compile-time? Reflection a runtime? <code>exports</code> S\u00ec No <code>opens</code> No S\u00ec <code>exports ... to</code> S\u00ec (moduli limitati) No <code>opens ... to</code> No S\u00ec (moduli limitati) <p>Important</p> <p><code>JPMS</code> aggiunge un <code>module path</code>, ma il <code>classpath</code> esiste ancora. Possono coesistere, ma i moduli nominati hanno la precedenza.</p> <p></p>"},{"location":"it/module-09/jpms-compiling/#388-moduli-named-automatici-e-unnamed","title":"38.8 Moduli Named, Automatici e Unnamed","text":"<p><code>JPMS</code> supporta differenti tipi di moduli per permettere una migrazione graduale dal classpath.</p> <p>JPMS deve interoperare con codice legacy.</p> <p>Per supportare l\u2019adozione graduale, la JVM riconosce tre differenti categorie di moduli.</p> <p></p>"},{"location":"it/module-09/jpms-compiling/#3881-moduli-named","title":"38.8.1 Moduli Named","text":"<p>Un <code>modulo named</code> possiede un <code>module-info.class</code> e una identit\u00e0 stabile.</p> <ul> <li>Incapsulamento forte</li> <li>Dipendenze esplicite</li> <li>Supporto completo JPMS</li> </ul> <p></p>"},{"location":"it/module-09/jpms-compiling/#3882-moduli-automatici","title":"38.8.2 Moduli Automatici","text":"<p>Un JAR senza <code>module-info</code> posizionato nel <code>module path</code> diventa un <code>modulo automatico</code>.</p> <p>Il suo nome \u00e8 derivato dal nome del file JAR.</p> <ul> <li>Legge tutti gli altri moduli</li> <li>Esporta tutti i package</li> <li>Nessun incapsulamento forte</li> </ul> <p>Note</p> <p>I moduli automatici esistono per facilitare la migrazione. Non sono adatti come design a lungo termine.</p> <p></p>"},{"location":"it/module-09/jpms-compiling/#3883-modulo-unnamed","title":"38.8.3 Modulo Unnamed","text":"<p>Il codice nel classpath appartiene al <code>modulo unnamed</code>.</p> <ul> <li>Legge tutti i moduli named</li> <li>Tutti i package sono aperti</li> <li>Non pu\u00f2 essere richiesto da moduli named</li> </ul> <p>Note</p> <p>Il <code>modulo unnamed</code> preserva il comportamento legacy del classpath.</p> <p></p>"},{"location":"it/module-09/jpms-compiling/#3884-riepilogo-comparativo","title":"38.8.4 Riepilogo Comparativo","text":"Tipo di modulo module-info presente? Incapsulamento Legge <code>Named</code> S\u00ec Forte Solo dichiarati <code>Automatic</code> No Debole Tutti i moduli <code>Unnamed</code> No Nessuno Tutti i moduli"},{"location":"it/module-09/jpms-compiling/#389-ispezionare-moduli-e-dipendenze","title":"38.9 Ispezionare Moduli e Dipendenze","text":""},{"location":"it/module-09/jpms-compiling/#3891-descrivere-moduli-con-java","title":"38.9.1 Descrivere Moduli con java","text":"<pre><code>java --describe-module java.sql\n</code></pre> <p>Questo mostra <code>exports</code>, <code>requires</code> e <code>services</code> di un modulo.</p> <p></p>"},{"location":"it/module-09/jpms-compiling/#3892-descrivere-jar-modulari","title":"38.9.2 Descrivere JAR Modulari","text":"<pre><code>jar --describe-module --file mylib.jar\n</code></pre>"},{"location":"it/module-09/jpms-compiling/#3893-analizzare-le-dipendenze-con-jdeps","title":"38.9.3 Analizzare le Dipendenze con <code>jdeps</code>","text":"<p><code>jdeps</code> analizza staticamente le dipendenze di classi e moduli.</p> <pre><code>jdeps myapp.jar\n</code></pre> <pre><code>jdeps --module-path mods --check my.module\n</code></pre> <p>Per rilevare l\u2019uso di API interne del JDK:</p> <pre><code>jdeps --jdk-internals myapp.jar\n</code></pre> <p></p>"},{"location":"it/module-09/jpms-compiling/#3810-creare-immagini-runtime-personalizzate-con-jlink","title":"38.10 Creare Immagini Runtime Personalizzate con <code>jlink</code>","text":"<p><code>jlink</code> costruisce un runtime Java minimale contenente solo i moduli richiesti da una applicazione.</p> <pre><code>jlink\n--module-path $JAVA_HOME/jmods:mods\n--add-modules com.example.app\n--output runtime-image\n</code></pre> <p>Benefici: - runtime pi\u00f9 piccolo - avvio pi\u00f9 rapido - nessun modulo JDK inutilizzato</p> <p></p>"},{"location":"it/module-09/jpms-compiling/#3811-creare-applicazioni-self-contained-con-jpackage","title":"38.11 Creare Applicazioni Self-Contained con <code>jpackage</code>","text":"<p><code>jpackage</code> costruisce installer specifici per piattaforma o immagini applicative.</p> <pre><code>jpackage\n--name MyApp\n--input mods\n--main-module com.example.app/com.example.Main\n</code></pre> <p><code>jpackage</code> pu\u00f2 produrre: - .exe / .msi (Windows) - .pkg / .dmg (macOS) - .deb / .rpm (Linux)</p> <p></p>"},{"location":"it/module-09/jpms-compiling/#3812-riepilogo-finale-jpms-in-pratica","title":"38.12 Riepilogo Finale JPMS in Pratica","text":"<ul> <li><code>JPMS</code> introduce <code>incapsulamento forte</code> e dipendenze affidabili</li> <li>I <code>moduli</code> sostituiscono convenzioni fragili del classpath</li> <li>I <code>servizi</code> abilitano architetture disaccoppiate</li> <li><code>Moduli automatici</code> e <code>modulo unnamed</code> supportano la migrazione</li> <li><code>jlink</code> e <code>jpackage</code> abilitano modelli moderni di deployment</li> </ul>"},{"location":"it/module-09/jpms-services/","title":"39. Servizi in JPMS (Il Modello ServiceLoader)","text":""},{"location":"it/module-09/jpms-services/#indice","title":"Indice","text":"<ul> <li>39.1 Il Problema che i Servizi Risolvono<ul> <li>39.1.1 Ruoli nel Modello dei Servizi</li> <li>39.1.2 Modulo Interfaccia del Servizio</li> <li>39.1.3 Modulo Provider del Servizio</li> <li>39.1.4 Modulo Consumer del Servizio</li> <li>39.1.5 Caricamento dei Servizi a Runtime</li> <li>39.1.6 Regole di Risoluzione dei Servizi</li> <li>39.1.7 Livello Service Locator</li> <li>39.1.8 Schema Sequenziale di Invocazione</li> <li>39.1.9 Tabella Riassuntiva dei Componenti</li> </ul> </li> </ul> <p><code>JPMS</code> include un meccanismo di servizio integrato che permette ai <code>moduli</code> di scoprire e utilizzare implementazioni a runtime senza codificare rigidamente dipendenze tra <code>provider</code> e <code>consumer</code>.</p> <p>Questo meccanismo \u00e8 basato sulla <code>ServiceLoader API</code> esistente, ma i moduli lo rendono affidabile, esplicito e sicuro.</p> <p></p>"},{"location":"it/module-09/jpms-services/#391-il-problema-che-i-servizi-risolvono","title":"39.1 Il Problema che i Servizi Risolvono","text":"<p>Talvolta un modulo necessita di utilizzare una capacit\u00e0, ma non dovrebbe dipendere da una implementazione specifica.</p> <p>Esempi tipici includono: - framework di logging - driver di database - sistemi plugin - provider di servizi selezionati a runtime</p> <p>Senza i servizi, il consumer dovrebbe dipendere direttamente da una implementazione concreta.</p> <p>Questo crea accoppiamento stretto e riduce la flessibilit\u00e0.</p> <p></p>"},{"location":"it/module-09/jpms-services/#3911-ruoli-nel-modello-dei-servizi","title":"39.1.1 Ruoli nel Modello dei Servizi","text":"<p>Il <code>modello dei servizi JPMS</code> coinvolge quattro ruoli distinti.</p> Ruolo Descrizione <code>Interfaccia del servizio</code> Definisce il contratto <code>Provider del servizio</code> Implementa il servizio <code>Consumer del servizio</code> Utilizza il servizio <code>Service loader</code> Scopre le implementazioni a runtime <p></p>"},{"location":"it/module-09/jpms-services/#3912-modulo-interfaccia-del-servizio","title":"39.1.2 Modulo Interfaccia del Servizio","text":"<p>L\u2019<code>interfaccia del servizio</code> definisce l\u2019API da cui i <code>consumer</code> dipendono.</p> <p>Deve essere esportata affinch\u00e9 altri moduli possano vederla.</p> <pre><code>package com.example.service;\n\npublic interface GreetingService {\n    String greet(String name);\n}\n</code></pre> <pre><code>module com.example.service {\n    exports com.example.service;\n}\n</code></pre> <p>Note</p> <p>Il modulo dell\u2019interfaccia del servizio non dovrebbe contenere implementazioni.</p> <p></p>"},{"location":"it/module-09/jpms-services/#3913-modulo-provider-del-servizio","title":"39.1.3 Modulo Provider del Servizio","text":"<p>Un <code>modulo provider</code> implementa l\u2019interfaccia del servizio e dichiara di fornire il servizio.</p> <pre><code>package com.example.service.impl;\n\nimport com.example.service.GreetingService;\n\npublic class EnglishGreeting implements GreetingService {\n    public String greet(String name) {\n        return \"Hello \" + name;\n    }\n}\n</code></pre> <pre><code>module com.example.provider.english {\n    requires com.example.service;\n    provides com.example.service.GreetingService with com.example.service.impl.EnglishGreeting;\n}\n</code></pre> <p>Punti chiave: - Il <code>provider</code> dipende dall\u2019<code>interfaccia del servizio</code> - La classe di implementazione non necessita di essere esportata - La direttiva <code>provides with</code> registra l\u2019implementazione</p> <p></p>"},{"location":"it/module-09/jpms-services/#3914-modulo-consumer-del-servizio","title":"39.1.4 Modulo Consumer del Servizio","text":"<p>Il <code>modulo consumer</code> dichiara di utilizzare un servizio, ma non nomina alcuna implementazione.</p> <pre><code>module com.example.consumer {\n    requires com.example.service;\n    uses com.example.service.GreetingService;\n}\n</code></pre> <p>Note</p> <p><code>uses</code> dichiara l\u2019intenzione di scoprire implementazioni a runtime.</p> <p>Un modulo che dichiara <code>uses</code> ma non ha provider corrispondenti nel module path compila normalmente, ma <code>ServiceLoader</code> restituisce un risultato vuoto a runtime.</p> <p></p>"},{"location":"it/module-09/jpms-services/#3915-caricamento-dei-servizi-a-runtime","title":"39.1.5 Caricamento dei Servizi a Runtime","text":"<p>La <code>ServiceLoader API</code> esegue la scoperta del servizio.</p> <p>Trova tutti i provider visibili al grafo dei moduli.</p> <pre><code>ServiceLoader&lt;GreetingService&gt; loader =\n    ServiceLoader.load(GreetingService.class);\n\nfor (GreetingService service : loader) {\n    System.out.println(service.greet(\"World\"));\n}\n</code></pre> <p><code>JPMS</code> garantisce che solo i provider dichiarati siano scoperti.</p> <p>La scoperta \u201caccidentale\u201d basata su classpath \u00e8 prevenuta.</p> <p></p>"},{"location":"it/module-09/jpms-services/#3916-regole-di-risoluzione-dei-servizi","title":"39.1.6 Regole di Risoluzione dei Servizi","text":"<p>Affinch\u00e9 un servizio sia individuabile da <code>ServiceLoader</code>, devono essere soddisfatte diverse condizioni:</p> Regola Significato Il modulo provider deve essere leggibile Risolto dal grafo <code>requires</code> L\u2019interfaccia del servizio deve essere esportata I consumer devono vederla Il consumer (o il Service Locator) deve dichiarare <code>uses</code> Altrimenti ServiceLoader fallisce Il provider deve dichiarare <code>provides</code> La scoperta implicita \u00e8 vietata <p></p>"},{"location":"it/module-09/jpms-services/#3917-livello-service-locator","title":"39.1.7 Livello Service Locator","text":"<p>\u00c8 possibile introdurre un livello aggiuntivo denominato <code>Service Locator</code>.</p> <p>In questa architettura:</p> <ul> <li>Il <code>consumer</code> non utilizza direttamente <code>ServiceLoader</code></li> <li>Il <code>Service Locator</code> \u00e8 l\u2019unico componente che dichiara <code>uses</code></li> <li>Il <code>consumer</code> dipende dal <code>Service Locator</code></li> </ul> <p>Struttura architetturale:</p> <pre><code>Consumer \u2192 Service Locator \u2192 ServiceLoader \u2192 Provider\n</code></pre> <p>Modulo del Service Locator:</p> <pre><code>module com.example.locator {\n    requires com.example.service;\n    uses com.example.service.GreetingService;\n}\n</code></pre> <p>Classe Service Locator:</p> <pre><code>package com.example.locator;\n\nimport java.util.ServiceLoader;\nimport com.example.service.GreetingService;\n\npublic class GreetingLocator {\n\n    public static GreetingService getService() {\n        return ServiceLoader\n                .load(GreetingService.class)\n                .findFirst()\n                .orElseThrow();\n    }\n}\n</code></pre> <p>Modulo Consumer:</p> <pre><code>module com.example.consumer {\n    requires com.example.locator;\n}\n</code></pre> <p>Il consumer non dichiara <code>uses</code> perch\u00e9 non invoca direttamente <code>ServiceLoader</code>.</p> <p></p>"},{"location":"it/module-09/jpms-services/#3918-schema-sequenziale-di-invocazione","title":"39.1.8 Schema Sequenziale di Invocazione","text":"<p>Sequenza di esecuzione:</p> <ol> <li>Il <code>Consumer</code> invoca <code>GreetingLocator.getService()</code></li> <li>Il <code>Service Locator</code> invoca <code>ServiceLoader.load(...)</code></li> <li>Il <code>ServiceLoader</code> consulta il grafo dei moduli</li> <li>Il sistema individua i moduli che dichiarano <code>provides</code></li> <li>Viene istanziata l\u2019implementazione del <code>Provider</code></li> <li>L\u2019istanza viene restituita al <code>Consumer</code></li> </ol> <p>Schema sequenziale:</p> <pre><code>Consumer\n   \u2502\n   \u2502 1. getService()\n   \u25bc\nService Locator\n   \u2502\n   \u2502 2. ServiceLoader.load()\n   \u25bc\nServiceLoader\n   \u2502\n   \u2502 3. Risoluzione provider\n   \u25bc\nProvider Implementation\n   \u2502\n   \u2502 4. Istanza restituita\n   \u25bc\nConsumer\n</code></pre> <p></p>"},{"location":"it/module-09/jpms-services/#3919-tabella-riassuntiva-dei-componenti","title":"39.1.9 Tabella Riassuntiva dei Componenti","text":"Componente Ruolo exports requires uses provides SPI Definisce contratto \u2705 \u274c \u274c \u274c Provider Implementa servizio \u274c \u2705 \u274c \u2705 Service Locator Esegue discovery (opzionale) \u2705 \u2705 \u274c Consumer Usa il servizio \u274c \u2705 \u274c \u274c"},{"location":"it/module-09/jpms/","title":"37. Java Platform Module System (JPMS)","text":""},{"location":"it/module-09/jpms/#indice","title":"Indice","text":"<ul> <li>37.1 Perch\u00e9 i moduli sono stati introdotti<ul> <li>37.1.1 Problemi con il classpath</li> <li>37.1.2 Esempio di un problema di classpath</li> </ul> </li> <li>37.2 Che cos\u2019\u00e8 un modulo<ul> <li>37.2.1 Propriet\u00e0 fondamentali dei moduli</li> <li>37.2.2 Modulo vs package vs JAR</li> </ul> </li> <li>37.3 Il descrittore module-infojava<ul> <li>37.3.1 Descrittore di modulo minimo</li> </ul> </li> <li>37.4 Struttura delle directory di un modulo</li> <li>37.5 Un primo programma modulare<ul> <li>37.5.1 Classe principale</li> <li>37.5.2 Descrittore del modulo</li> </ul> </li> <li>37.6 Spiegazione dell\u2019incapsulamento forte</li> <li>37.7 Sintesi delle idee chiave</li> </ul> <p>Il <code>Java Platform Module System</code> (JPMS) \u00e8 stato introdotto in Java 9.</p> <p>\u00c8 un meccanismo a livello di linguaggio e a livello di runtime per strutturare le applicazioni Java in unit\u00e0 fortemente incapsulate chiamate <code>moduli</code>.</p> <p>JPMS influenza come il codice viene: - organizzato - compilato - collegato - impacchettato - caricato a runtime</p> <p>Comprendere JPMS \u00e8 essenziale per il Java moderno, specialmente per grandi applicazioni, librerie, immagini di runtime e strumenti di deployment.</p> <p></p>"},{"location":"it/module-09/jpms/#371-perche-i-moduli-sono-stati-introdotti","title":"37.1 Perch\u00e9 i moduli sono stati introdotti","text":"<p>Prima di Java 9, le applicazioni Java erano costruite usando solo: - <code>packages</code> - file <code>JAR</code> - il <code>classpath</code></p> <p>Questo modello aveva limitazioni serie man mano che le applicazioni crescevano.</p> <p></p>"},{"location":"it/module-09/jpms/#3711-problemi-con-il-classpath","title":"37.1.1 Problemi con il classpath","text":"<p>Il classpath \u00e8 una lista piatta di JAR in cui: - tutte le classi pubbliche sono accessibili a tutti - non esiste una dichiarazione affidabile delle dipendenze - le versioni in conflitto sono comuni - l\u2019incapsulamento \u00e8 debole o inesistente - classi duplicate si sovrascrivono silenziosamente in base all\u2019ordine del classpath</p> <p>Questo ha portato a problemi ben noti come: - \u201cJAR hell\u201d - bug di ordinamento del classpath - uso accidentale di API interne - errori di runtime che non venivano rilevati in fase di compilazione</p> <p></p>"},{"location":"it/module-09/jpms/#3712-esempio-di-un-problema-di-classpath","title":"37.1.2 Esempio di un problema di classpath","text":"<p>Supponiamo che due librerie dipendano da versioni diverse dello stesso JAR di terze parti.</p> <p>Solo una versione pu\u00f2 essere messa sul classpath.</p> <p>Quale viene scelta dipende solamente dall\u2019ordine del classpath, non dalla appropriatezza effettiva.</p> <p>Note</p> <p>Questo problema non pu\u00f2 essere risolto in modo affidabile con il solo strumento del classpath.</p> <p></p>"},{"location":"it/module-09/jpms/#372-che-cose-un-modulo","title":"37.2 Che cos\u2019\u00e8 un modulo?","text":"<p>Un <code>modulo</code> \u00e8 un\u2019unit\u00e0 di codice nominata e auto-descrittiva.</p> <p>In sintesi, un modulo \u00e8 una collezione di uno o pi\u00f9 package correlati, insieme a un file descrittore del modulo che ne definisce esplicitamente le sue dipendenze e le funzionalit\u00e0 che rende disponibili.  </p> <p>Un modulo offre quindi a chi lo utilizza un complesso ben definito e controllato di funzionalit\u00e0.</p> <p>Ogni modulo nominato ha un nome unico che lo identifica al compilatore e al sistema dei moduli.</p> <p>Dichiara esplicitamente: - da cosa dipende - cosa espone agli altri moduli - cosa mantiene nascosto</p> <p>Un modulo \u00e8 pi\u00f9 forte di un package e pi\u00f9 strutturato di un JAR.</p> <p></p>"},{"location":"it/module-09/jpms/#3721-proprieta-fondamentali-dei-moduli","title":"37.2.1 Propriet\u00e0 fondamentali dei moduli","text":"Propriet\u00e0 Descrizione Incapsulamento forte I package sono nascosti di default Dipendenze esplicite Le dipendenze devono essere dichiarate Configurazione affidabile Dipendenze mancanti causano errori precoci Identit\u00e0 nominata Ogni modulo ha un nome unico"},{"location":"it/module-09/jpms/#3722-modulo-vs-package-vs-jar","title":"37.2.2 Modulo vs package vs JAR","text":"Concetto Scopo Incapsulamento Package Raggruppamento di namespace Debole (public ancora visibile) JAR Impacchettamento / deployment Nessuno (tutte le classi visibili quando sul classpath) Modulo Incapsulamento + unit\u00e0 di dipendenza Forte (package non esportati nascosti)"},{"location":"it/module-09/jpms/#373-il-descrittore-module-infojava","title":"37.3 Il descrittore <code>module-info.java</code>","text":"<p>Ogni <code>modulo nominato</code> \u00e8 definito da un file descrittore del modulo chiamato:</p> <pre><code>module-info.java\n</code></pre> <p>Questo file descrive il modulo al compilatore e al runtime.</p> <p></p>"},{"location":"it/module-09/jpms/#3731-descrittore-di-modulo-minimo","title":"37.3.1 Descrittore di modulo minimo","text":"<p>Un descrittore di modulo minimo dichiara solo il nome del modulo. Il nome del file deve essere esattamente <code>module-info.java</code>, e deve trovarsi nella root dell\u2019albero dei sorgenti del modulo.</p> <pre><code>module com.example.hello {\n}\n</code></pre> <p>Note</p> <p>Un modulo senza direttive non esporta nulla e non dipende da nulla.</p> <p></p>"},{"location":"it/module-09/jpms/#374-struttura-delle-directory-di-un-modulo","title":"37.4 Struttura delle directory di un modulo","text":"<p>Un progetto modulare segue un layout standard di directory.</p> <p>Il descrittore del modulo si trova alla root dell\u2019albero dei sorgenti del modulo.</p> <pre><code>src/\n\u2514\u2500 com.example.hello/\n    \u251c\u2500 module-info.java\n    \u2514\u2500 com/\n        \u2514\u2500 example/\n            \u2514\u2500 hello/\n                \u2514\u2500 Main.java\n</code></pre> <p>Punti chiave: - Il nome della directory corrisponde al nome del modulo - <code>module-info.java</code> \u00e8 in cima alla root dei sorgenti del modulo - i package seguono le regole standard di naming Java</p> <p>Note</p> <p>Nei progetti IDE e build-tool, la struttura dei file pu\u00f2 differire (ad es. Maven usa <code>src/main/java</code>). Ci\u00f2 che resta sempre vero: <code>module-info.java</code> sta nella root dell\u2019albero dei sorgenti del modulo e i percorsi dei package seguono il naming standard Java.</p> <p></p>"},{"location":"it/module-09/jpms/#375-un-primo-programma-modulare","title":"37.5 Un primo programma modulare","text":"<p>Creiamo un\u2019applicazione modulare minima.</p> <p></p>"},{"location":"it/module-09/jpms/#3751-classe-principale","title":"37.5.1 Classe principale","text":"<pre><code>package com.example.hello;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, modular world!\");\n    }\n}\n</code></pre>"},{"location":"it/module-09/jpms/#3752-descrittore-del-modulo","title":"37.5.2 Descrittore del modulo","text":"<pre><code>module com.example.hello {\n    exports com.example.hello;\n}\n</code></pre> <p>La <code>direttiva exports</code> rende il package accessibile ad altri moduli.</p> <p>Senza di essa, il package \u00e8 incapsulato e inaccessibile.</p> <p></p>"},{"location":"it/module-09/jpms/#376-spiegazione-dellincapsulamento-forte","title":"37.6 Spiegazione dell\u2019incapsulamento forte","text":"<p>In <code>JPMS</code>, i package NON sono accessibili di default.</p> <p>Anche le classi public sono nascoste a meno che non siano esportate esplicitamente.</p> <p>Nei moduli, <code>public</code> significa \u201cpublic verso altri moduli solo se il package contenitore \u00e8 esportato.\u201d</p> Situazione Accessibile da un altro modulo? Classe public in package non esportato No Classe public in package esportato S\u00ec Membro protected in package esportato S\u00ec, ma solo via ereditariet\u00e0 (non accesso generale) Classe/membro package-private (qualsiasi package) No Membro private No <p>Note</p> <p>Questa \u00e8 una differenza fondamentale rispetto al modello basato sul classpath.</p> <p></p>"},{"location":"it/module-09/jpms/#377-sintesi-delle-idee-chiave","title":"37.7 Sintesi delle idee chiave","text":"<ul> <li><code>JPMS</code> introduce i moduli come unit\u00e0 forti di incapsulamento</li> <li>Le dipendenze sono esplicite e verificate</li> <li><code>module-info.java</code> \u00e8 il descrittore centrale</li> <li>I package sono nascosti a meno che non siano esportati</li> <li>La visibilit\u00e0 basata su classpath non si applica pi\u00f9 nei moduli</li> <li>La visibilit\u00e0 public non \u00e8 pi\u00f9 sufficiente: le export del modulo controllano l\u2019accessibilit\u00e0</li> </ul>"}]}